[
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp4_body. Let $Q_$ be a function from elements $_x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_489$.",
    "output": "postulate void_rect_CProp4_body : (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_489)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_I. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.O$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate bigop_I : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus n matita_arithmetics_nat.O) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_and_r. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.And$ applied to $A$ and $C$ and $matita_basics_logic.And$ applied to $B$ and $C$.",
    "output": "postulate iff_and_r : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.And A C) (matita_basics_logic.And B C))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_Type2_body. For all functions $Q_$ from elements $_x_70$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $x_70$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_70$.",
    "output": "postulate False_rect_Type2_body : (Q_ : (_x_70 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type2) -> (x_70 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ x_70)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "postulate Sum_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) -> (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type0 (Q_ x_551)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp5. For all functions $Q_$ from elements $_x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_490$.",
    "output": "postulate void_rect_CProp5 : (Q_ : (_x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_490)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_spec_inv_ind. For all elements $x1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $x1$ and $x2$ and $x3$, for all functions $P$ from elements $_z1769$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $x1$ and elements $_x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1770$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$, for all functions $_H2$ from functions $_x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1770$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x3$.",
    "output": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 m)) -> cic.Term cic.prop (P m)) -> (_H2 : (_x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P x3)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15491. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $x1106$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1106$ and $matita_arithmetics_nat.minus$ applied to $x1106$ and $n$.",
    "output": "postulate let_clause_15491 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x1106 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1106 (matita_arithmetics_nat.minus x1106 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_0. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $matita_arithmetics_nat.S$ applied to $i$ and $f$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate bigop_0 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (matita_arithmetics_nat.S i))) (f matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1692. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x358$ and $x359$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x358$ and $matita_arithmetics_nat.times$ applied to $x358$ and $x359$ and $matita_arithmetics_nat.times$ applied to $x358$ and $matita_arithmetics_nat.S$ applied to $x359$.",
    "output": "postulate let_clause_1692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_S. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate not_eq_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Square_double. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "postulate square_double : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1531. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1531 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_previous_prime1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_max_forall_false. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_basics_bool.true$ and $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_nat.O$.",
    "output": "postulate exists_max_forall_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.max n f)) matita_basics_bool.true)) (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "postulate And_rect_CProp4 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_146)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1548$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1549$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_ind. Let $_n$ and $_m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_1192$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $x_1193$, for all elements $x_1192$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1192$.",
    "output": "postulate divides_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sqrt_bound. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate sqrt_bound : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit. $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate unit : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mem_filter. Let $S$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $a$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $a$ and $l$.",
    "output": "postulate mem_filter : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem S a (matita_basics_lists_list.filter S f l))) -> cic.Term cic.prop (matita_basics_lists_list.mem S a l)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_g : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate option : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_674$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_674$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_674$.",
    "output": "postulate Sig_rect_Type1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type1 (Q_ x_674)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1236$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1237$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_body. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "postulate decidable_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.divides n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_minus_S_pred. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate eq_minus_S_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_nth. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $matita_basics_lists_list.nth_opt$ applied to $A$ and $n$ and $l$ and $matita_basics_types.Some$ applied to $A$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate All_nth : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a))) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_times. Let $n$ and $m$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "postulate divides_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_to_minus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.",
    "output": "postulate le_plus_to_minus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fold_sum. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $I$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $J$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.append$ applied to $A$ and $I$ and $J$.",
    "output": "postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Checker_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate checker_body : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_to_eq2. Let $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $r$ and $r1$.",
    "output": "postulate div_mod_spec_to_eq2 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (__1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r r1)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Andb_true_l. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$.",
    "output": "postulate andb_true_l : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_or. Let $P$ and $Q$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $Q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.Or$ applied to $P$ and $Q$.",
    "output": "postulate decidable_or : (P : cic.Univ cic.prop) -> (Q : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> (__1 : cic.Term cic.prop (matita_basics_logic.decidable Q)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Or P Q))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_True. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_I$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.I$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (case_I : cic.Term return_sort (return_type matita_basics_logic.I)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp1. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "postulate log_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)) (matita_arithmetics_nat.times m (matita_arithmetics_nat.S (matita_arithmetics_log.log p n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rule. If $Sort$, then if $Sort$, then $Sort$.",
    "output": "postulate rule : Sort -> Sort -> Sort"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_ACop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "postulate Prod_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_708)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type4_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_conj$ from elements $x_124$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_123$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_124$ and $x_123$, for all elements $x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_122$.",
    "output": "postulate And_rect_Type4_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4) -> (_H_conj : (x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> (x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type4 (Q_ x_122)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive_times_plus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.plus$ applied to $b$ and $c$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $a$ and $matita_arithmetics_nat.times$ applied to $c$ and $a$.",
    "output": "postulate distributive_times_plus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.plus b c) a) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times b a) (matita_arithmetics_nat.times c a)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_notb. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_basics_bool.bool$ and $matita_basics_bool.bool$ and $matita_basics_bool.notb$.",
    "output": "postulate injective_notb : cic.Term cic.prop (matita_basics_relations.injective matita_basics_bool.bool matita_basics_bool.bool matita_basics_bool.notb)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub0_to_false. For all functions $h$ and $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $I$ and $matita_arithmetics_nat.O$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $A$ and $J$ and $I$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $J$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_bigops.filter$ applied to $A$ and $J$ and $i$ and $matita_basics_bool.false$.",
    "output": "postulate sub0_to_false : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A J I)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_bigops.upto A J))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_bigops.filter A J i) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.",
    "output": "postulate ACop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Proj1. Let $A$ and $B$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $A$.",
    "output": "postulate proj1 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type5_body. Let $Q_$ be a function from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "postulate unit_rect_Type5_body : (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) -> (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) -> (x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type5 (Q_ x_499)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_ind. For all functions $Q_$ from elements $_x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_495$.",
    "output": "postulate unit_ind : (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_495)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp2_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_850$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.eqb$ applied to $n$ and $m$.",
    "output": "postulate eqb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_exp1. Let $p$ and $n$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.",
    "output": "postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_div_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate eq_div_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n m) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_ex. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Notb_notb. Let $b$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.notb$ applied to $matita_basics_bool.notb$ applied to $b$ and $b$.",
    "output": "postulate notb_notb : (b : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.notb (matita_basics_bool.notb b)) b)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mem_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate mem_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S_times_2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_S_times_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_l. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b2$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b1$.",
    "output": "postulate lstar_ind_l : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b1)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_Sn. For all elements $b$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_exp.exp$ applied to $b$ and $n$.",
    "output": "postulate exp_Sn : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp b (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times b (matita_arithmetics_exp.exp b n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "postulate le_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_sqrt.sqrt n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_to_eq_O. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate exp_to_eq_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_div. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$.",
    "output": "postulate monotonic_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_div_and_mod.div m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Start_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15311. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $d$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $p$.",
    "output": "postulate let_clause_15311 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lhd_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate lhd_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_963$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_963$.",
    "output": "postulate Dop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_963)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Tri_transitive. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.tri_relation$ applied to $A$ and $B$ and $C$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate tri_transitive : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1716$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1717$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate pi1 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_not_bertrand_to_bertrand. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "postulate not_not_bertrand_to_bertrand : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n))) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_comp_r. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ and $R1$ and $R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $R1$ and $R2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R$ and $R2$.",
    "output": "postulate sub_comp_r : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_581$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_582$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_582$, for all functions $_H_inr$ from elements $x_583$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_583$, for all elements $x_581$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_581$.",
    "output": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_955$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_955$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_955$.",
    "output": "postulate Dop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type0 (Q_ x_955)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Hd. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_d$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate hd : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_d : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_546$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_inl$ from elements $x_547$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_547$, for all functions $_H_inr$ from elements $x_548$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_548$, for all elements $x_546$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_546$.",
    "output": "postulate Sum_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1) -> (_H_inl : (x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))) -> (_H_inr : (x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))) -> (x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type1 (Q_ x_546)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_O_l. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_lt_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate divides_to_lt_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp1. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_112$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_113$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_113$, for all elements $x_112$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_112$.",
    "output": "postulate Not_rect_CProp1 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_113 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))) -> (x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_112)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cons_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.",
    "output": "postulate cons_injective_r : (A : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "SameF_p_le. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_p$ applied to $m$ and $p$ and $A$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sameF_p$ applied to $n$ and $p$ and $A$ and $f$ and $g$.",
    "output": "postulate sameF_p_le : (A : cic.Univ univs.Type0) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p m p A f g)) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_p n p A f g)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Breakup_pair. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $C$ to elements of $cic.Univ$ of $cic.prop$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $P$ applied to $matita_basics_types.fst$ applied to $A$ and $B$ and $x$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $x$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $_0$ to $C$ and the function that maps $a$ and $b$ to $P$ applied to $a$ and $b$ and $x$.",
    "output": "postulate breakup_pair : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (R : (__ : cic.Term univs.Type0 C) -> cic.Univ cic.prop) -> (P : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (__ : cic.Term cic.prop (R (P (matita_basics_types.fst A B x) (matita_basics_types.snd A B x)))) -> cic.Term cic.prop (R (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\\ a : cic.Term univs.Type0 A -> \\ b : cic.Term univs.Type0 B -> P a b) x))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp1. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_771$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_773$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_772$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_775$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_772$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_773$ and $x_772$, for all elements $x_771$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_771$.",
    "output": "postulate list_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_773 : cic.Term univs.Type0 _A) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_775 : cic.Term cic.prop (Q_ x_772)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_773 x_772))) -> (x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_771)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_ind_body. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_80$, for all elements $x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_79$.",
    "output": "postulate Not_ind_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_80 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> (x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_79)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "postulate lt_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_gcd_nm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $m$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $n$.",
    "output": "postulate divides_gcd_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nth_opt_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "postulate nth_opt_body : (A : cic.Univ univs.Type0) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type0. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_conj$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_144$ and $x_143$, for all elements $x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_142$.",
    "output": "postulate And_rect_Type0 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type0) -> (_H_conj : (x_144 : cic.Term cic.prop _A) -> (x_143 : cic.Term cic.prop _B) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) -> (x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type0 (Q_ x_142)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_plus_to_le. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "postulate eq_plus_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate primes_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_exp.exp$ applied to $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_exp_to_le : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1009. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $Hfn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $n$ and $matita_basics_bool.false$, for all elements $Hmax$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$, for all elements $Hmax0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $matita_arithmetics_nat.O$, for all functions $auto$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate let_clause_1009 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (Hfn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false)) -> (Hmax : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n)) -> (Hmax0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) n)) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i m) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) matita_arithmetics_nat.O))) -> (auto : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type3_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_div_mod_spec_intro$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_823$ and $x_822$, for all elements $x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_821$.",
    "output": "postulate div_mod_spec_rect_Type3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3) -> (_H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> (x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type3 (Q_ x_821)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Compose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_x$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $C$.",
    "output": "postulate compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_x : cic.Term univs.Type0 A) -> cic.Term univs.Type0 C"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_range. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (case_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate commutative : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $__$ and $b2$ and $__1$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $__1$ and $__2$ and $z$.",
    "output": "postulate match_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (case_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_557$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_557$, for all functions $_H_inr$ from elements $x_558$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_558$, for all elements $x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_556$.",
    "output": "postulate Sum_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_556)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fst_body. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate fst_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1164$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1165$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1164 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1165 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_exp1. Let $p$ and $n$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$.",
    "output": "postulate p_ord_to_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_primr. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1063. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $permf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lein$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $lejn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all elements $lebn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $n$, for all elements $fb$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all functions $__$ from elements $i0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i0$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $i0$ and $n$, for all elements $injf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $j$.",
    "output": "postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (__ : (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)) -> (injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) j)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type2. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.",
    "output": "postulate range_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_947$.",
    "output": "postulate Dop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15601. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15601 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp4. Let $Q_$ be a function from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.",
    "output": "postulate bool_rect_CProp4 : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_lt. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "postulate decidable_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type3. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_921$.",
    "output": "postulate range_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type3 (Q_ x_921)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_566$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_567$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_567$, for all functions $_H_inr$ from elements $x_568$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_568$, for all elements $x_566$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_566$.",
    "output": "postulate Sum_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_566 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_567 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_567))) -> (_H_inr : (x_568 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_568))) -> (x_566 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_566)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_4$ and $x_5$.",
    "output": "postulate eq_rect_Type4 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_4 : cic.Term univs.Type2 A) -> (_x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Univ univs.Type4) -> (_H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_4 : cic.Term univs.Type2 A) -> (x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Term univs.Type4 (Q_ x_4 x_5)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type5_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "postulate Sum_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_646$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_646$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_646$.",
    "output": "postulate DPair_rect_Type2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type2) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type2 (Q_ x_646)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_eq_nat. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate decidable_eq_nat : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_mod. Let $p$ and $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "postulate divides_mod : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_div_and_mod.mod m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_ind_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_720$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_717$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_718$ and $x_717$, for all elements $x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_716$.",
    "output": "postulate list_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_718 : cic.Term univs.Type0 _A) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_720 : cic.Term cic.prop (Q_ x_717)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> (x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_716)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Foldr_body. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate foldr_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$ applied to $i$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and the function that maps $__1$ to $P$ applied to $i$.",
    "output": "postulate decidable_forall : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (P i))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (\\ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> P i))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "postulate nat_rect_CProp3_body : (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_401)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate mod_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod matita_arithmetics_nat.O n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate div_mod_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_gcd_times. Let $m$ and $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $p$.",
    "output": "postulate le_gcd_times : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "postulate map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list B)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_exp1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "postulate le_Psi_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S n)))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1062. Let $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $ltrb$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $b$, for all elements $spec$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $b$ and $r$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, for all elements $ltr1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r1$ and $b$, for all elements $spec1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q1$ and $b$ and $r1$, for all elements $leqq1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $q$ and $q1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $r1$ and $matita_arithmetics_nat.times$ applied to $b$ and $q1$.",
    "output": "postulate let_clause_1062 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le q q1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r1 (matita_arithmetics_nat.times b q1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type2. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_698$.",
    "output": "postulate Prod_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_to_injn. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "postulate injective_to_injn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1585. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate let_clause_1585 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nth_primeS. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_minimization.min$ applied to $matita_arithmetics_primes.let_upper_bound1$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_primes.let_previous_prime1$ applied to $n$ and $matita_arithmetics_primes.primeb$.",
    "output": "postulate nth_primeS : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)) (matita_arithmetics_minimization.min (matita_arithmetics_primes.let_upper_bound1 n) (matita_arithmetics_nat.S (matita_arithmetics_primes.let_previous_prime1 n)) matita_arithmetics_primes.primeb))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1320$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_740$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $x_737$ and elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_738$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_738$ and $x_737$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate list_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1320 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type2) -> (_H1 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_738 : cic.Term univs.Type0 x1) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_740 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_737)) -> cic.Term univs.Type2 (P x_737)) -> (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Associative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.associative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate associative_plus : cic.Term cic.prop (matita_basics_relations.associative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_939$.",
    "output": "postulate range_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_939)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type1. Let $Q_$ be a function from elements $_x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type1$. Then for all elements $_H_true$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_341$.",
    "output": "postulate bool_rect_Type1 : (Q_ : (_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1) -> (_H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false)) -> (x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ x_341)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_I. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.O$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate bigop_I : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus n matita_arithmetics_nat.O) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "TimesAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_S_fact. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate not_divides_S_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type1_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "postulate div_mod_spec_rect_Type1_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) -> (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type1 (Q_ x_829)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_SO_smallest_factor. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.",
    "output": "postulate le_SO_smallest_factor : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_void. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $return_sort$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1002$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1003$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_552$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_552$, for all functions $_H2$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1003$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_553$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_553$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate Sum_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1002 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (x_552 : cic.Term univs.Type0 x1) -> (_z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_552))) -> cic.Term univs.Type0 (P (matita_basics_types.inl x1 x2 x_552))) -> (_H2 : (x_553 : cic.Term univs.Type0 x2) -> (_z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_553))) -> cic.Term univs.Type0 (P (matita_basics_types.inr x1 x2 x_553))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_aop. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$.",
    "output": "postulate let_aop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z707$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z708$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_412$ from elements $_z708$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_410$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_410$ and elements $_z708$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate nat_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z707 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_410)) -> cic.Term cic.prop (P x_410)) -> (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_410))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_410))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate div_aux_body : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_or_r. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $A$ and $C$ and $matita_basics_logic.Or$ applied to $B$ and $C$.",
    "output": "postulate iff_or_r : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or A C) (matita_basics_logic.Or B C))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rev_append_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate rev_append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sigma_const. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate sigma_const : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_range. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (case_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) -> (divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1))) -> (eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ex. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.",
    "output": "postulate range_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_937)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fst_p_ord_times. Let $p$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_types.fst$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_basics_types.fst$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.fst$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$.",
    "output": "postulate fst_p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p)) (matita_arithmetics_nat.plus (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord a p)) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord b p))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_Type4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1044$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z1045$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_591$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1045$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_591$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_591$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_913$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_913$.",
    "output": "postulate ACop_rect_CProp0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_913)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_all. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate primes_all : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate bijn : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_ex. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_Type3. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z918$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z919$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z918 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type3) -> (_H1 : (_z919 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type3 (P matita_basics_types.it)) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type0. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.",
    "output": "postulate Prod_rect_Type0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type0 (Q_ x_702)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing_to_le. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_arithmetics_nat.le$ applied to $m$ and $f$ applied to $i$.",
    "output": "postulate increasing_to_le : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.le m (f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example12. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example12 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_899$.",
    "output": "postulate ACop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type1 (Q_ x_899)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.",
    "output": "postulate aop : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_n_times_nm. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $n$.",
    "output": "postulate gcd_n_times_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_nat.times n m)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type4. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_692$.",
    "output": "postulate Prod_rect_Type4 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type4 (Q_ x_692)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_length_to_mem. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__2$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $n$ and $l$.",
    "output": "postulate eq_length_to_mem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) (matita_arithmetics_nat.S n))) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__2 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.le x n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1380$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1381$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1380 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1381 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_S_fact. Let $n$ and $i$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate not_divides_S_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Comm. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, for all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $b$ and $a$.",
    "output": "postulate comm : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) a b) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) b a))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15692. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_pi. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_div_and_mod.mod$ applied to $f$ applied to $i$ and $p$ and $p$.",
    "output": "postulate congruent_pi : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_div_and_mod.mod (f i) p)) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_fact_2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "postulate exp_fact_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Start_lprim. For all elements $n$ and $m$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $m$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $acc$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $a$.",
    "output": "postulate start_lprim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.lprim n m (matita_basics_lists_list.cons matita_arithmetics_nat.nat a acc))) (matita_basics_types.Some matita_arithmetics_nat.nat a))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_plus_minus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $z$ and $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.plus$ applied to $x$ and $y$.",
    "output": "postulate minus_plus_minus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le y z)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.plus x y))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_781$.",
    "output": "postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_781)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nil_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate nil_cons : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a l) (matita_basics_lists_list.nil A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pair_destruct_1. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $c$.",
    "output": "postulate pair_destruct_1 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> (c : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp1_body. Let $Q_$ be a function from elements $_x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_62$.",
    "output": "postulate True_rect_CProp1_body : (Q_ : (_x_62 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_62 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_62)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_805$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_805$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_805$.",
    "output": "postulate Aop_rect_CProp0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_805 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_805 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_805)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp2. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_626$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_627$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_627$, for all elements $x_626$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_626$.",
    "output": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate split : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list A) (matita_basics_lists_list.list A))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.",
    "output": "postulate commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le. Let $b$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_exp.exp$ applied to $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_exp_to_le : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_Sn_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "postulate not_le_Sn_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z131$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z132$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_Type4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z131 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H1 : (_z132 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type4 (P matita_basics_logic.I)) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp0_body. For all functions $Q_$ from elements $_x_64$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_64$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_64$.",
    "output": "postulate True_rect_CProp0_body : (Q_ : (_x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_64)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_ind. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_522$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_522$, for all functions $_H_inr$ from elements $x_523$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_523$, for all elements $x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_521$.",
    "output": "postulate Sum_ind : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_S. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.",
    "output": "postulate mod_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type3. For all functions $Q_$ from elements $_x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_O$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_380$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, for all elements $x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_377$.",
    "output": "postulate nat_rect_Type3 : (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type3 (Q_ x_377)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_ind. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1104$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1105$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Type. If $Nat$, then $Sort$.",
    "output": "postulate type : Nat -> Sort"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1012. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.let_m2$ applied to $f$ and $n$ and $i$ and $b$ and $matita_basics_bool.false$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.let_m2$ applied to $f$ and $n$ and $i$ and $b$ and $matita_arithmetics_nat.plus$ applied to $i$ and $b$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $fb$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $b$ and $matita_basics_bool.true$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $b$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.false$ and $matita_basics_bool.true$.",
    "output": "postulate let_clause_1012 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) (\\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m2 f n i b) (matita_arithmetics_nat.plus i b)))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prim. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate prim : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Comm_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, for all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $b$ and $a$.",
    "output": "postulate comm_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) a b) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) b a))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp1_body. For all functions $Q_$ from elements $_x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_493$.",
    "output": "postulate void_rect_CProp1_body : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_Type2. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $P$ from elements $_z671$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_384$ from elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $x_382$ and elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate nat_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z671 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H1 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type2 (P matita_arithmetics_nat.O)) -> (_H2 : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_382)) -> cic.Term univs.Type2 (P x_382)) -> (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "EqProp. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all elements $_x$ and $__$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate eqProp : (A : cic.Univ cic.prop) -> (_x : cic.Term cic.prop A) -> (__ : cic.Term cic.prop A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_priml1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_priml1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Discr_minus_x_xy. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.O$.",
    "output": "postulate discr_minus_x_xy : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x (matita_arithmetics_nat.minus x y))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_plus_plus_l. For all elements $x$ and $y$ and $h$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $h$ and $matita_arithmetics_nat.plus$ applied to $y$ and $h$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$.",
    "output": "postulate minus_plus_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le. Let $_n$ and $__$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_prim_prim_pred. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate eq_prim_prim_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_mod_aux_m_m. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.mod_aux$ applied to $p$ and $n$ and $m$ and $m$.",
    "output": "postulate le_mod_aux_m_m : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Or. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Or : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_7$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_8$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_7$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_7$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_8$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_7$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_7$ and $x_8$.",
    "output": "postulate eq_rect_Type5_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_7 : cic.Term univs.Type2 A) -> (_x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7)) -> cic.Univ univs.Type5) -> (_H_refl : cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_7 : cic.Term univs.Type2 A) -> (x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7)) -> cic.Term univs.Type5 (Q_ x_7 x_8)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_522$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_522$, for all functions $_H_inr$ from elements $x_523$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_523$, for all elements $x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_521$.",
    "output": "postulate Sum_ind : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ and $K$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h2$ and $k2$ and $A$ and $J$ and $K$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "postulate transitive_sub : (h1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (K : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (__ : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h1 k1 A I J)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h2 k2 A J K)) -> cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> h2 (h1 x)) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k1 (k2 x)) A I K)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_DPair. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $f$ applied to $dpi1$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $f$.",
    "output": "postulate mk_DPair : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (f dpi1)) -> cic.Term univs.Type0 (matita_basics_types.DPair A f)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_152$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_151$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_152$ and $x_151$, for all elements $x_150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_150$.",
    "output": "postulate And_rect_CProp5_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_152 : cic.Term cic.prop _A) -> (x_151 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) -> (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_150)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_n_to_le. Let $h$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $n$, for all functions $__2$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $m$ and $m$, for all elements $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $j$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $h$ applied to $j$.",
    "output": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.",
    "output": "postulate list_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.",
    "output": "postulate ACop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_ind_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_943$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_943$.",
    "output": "postulate Dop_ind_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_943)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_plus. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $q$.",
    "output": "postulate divides_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.plus p q))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_or_l. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $C$ and $A$ and $matita_basics_logic.Or$ applied to $C$ and $B$.",
    "output": "postulate iff_or_l : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type4_body. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_nmk$ from functions $x_83$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_83$, for all elements $x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_82$.",
    "output": "postulate Not_rect_Type4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4) -> (_H_nmk : (x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) -> (x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type4 (Q_ x_82)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_x_times_x. For all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.",
    "output": "postulate le_x_times_x : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "postulate range_rect_Type0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type0 (Q_ x_927)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_CProp0. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z966$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z967$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z966 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z967 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rcomp. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R1$ and $_R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a1$ and $_a2$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Rcomp : (A : cic.Univ univs.Type0) -> (_R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a1 : cic.Term univs.Type0 A) -> (_a2 : cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "postulate div_mod_spec_rect_CProp3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_ind_plus. For all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $n$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $n$.",
    "output": "postulate nat_ind_plus : (R : cic.Term univs.Type0 (matita_basics_relations.predicate matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (R matita_arithmetics_nat.O)) -> (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (R n)) -> cic.Term cic.prop (R (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_n_O. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate exp_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp n matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sigma_p_dividesb. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate sigma_p_dividesb : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop m (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fst. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate fst : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_exp_times. Let $n$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "postulate exp_exp_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type0. Let $Q_$ be a function from elements $_x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_488$.",
    "output": "postulate void_rect_Type0 : (Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type0) -> (x_488 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type0 (Q_ x_488)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Found_min_spec. Let $n$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$.",
    "output": "postulate found_min_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1890$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $m$ and elements $_x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ and elements $_x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1891$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x4$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$, for all functions $_H2$ from functions $_x_1081$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1891$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x4$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x4$.",
    "output": "postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 m)) -> cic.Term cic.prop (P m)) -> (_H2 : (_x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P x4)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_minl. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$.",
    "output": "postulate le_minl : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le i n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15622. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_elim_left. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $S$, for all functions $__1$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $S$ and elements $tl$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $tl$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.append$ applied to $S$ and $tl$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$.",
    "output": "postulate list_elim_left : (S : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (P (matita_basics_lists_list.nil S))) -> (__1 : (a : cic.Term univs.Type0 S) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__1 : cic.Term cic.prop (P tl)) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (P l)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bc. For all elements $_n$ and $_k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate bc : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10331. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_965$.",
    "output": "postulate Dop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_965)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp4_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_557$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_557$, for all functions $_H_inr$ from elements $x_558$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_558$, for all elements $x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_556$.",
    "output": "postulate Sum_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_556)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z293$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_101$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z294$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_101$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_101$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_rect_CProp4 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z293 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_101 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z294 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_101))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_101))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Or. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Or : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Allr_fwd_cons. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $l$.",
    "output": "postulate Allr_fwd_cons : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.cons A a l))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R0. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all elements $_t$ of $cic.Term$ of $univs.Type0$ and $T$, $cic.Term$ holds for $univs.Type0$ and $T$.",
    "output": "postulate R0 : (T : cic.Univ univs.Type0) -> (_t : cic.Term univs.Type0 T) -> cic.Term univs.Type0 T"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_B_exp. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_B_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact_pi_p3. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate fact_pi_p3 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_found_min_spec. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.",
    "output": "postulate not_found_min_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp5. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_104$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_104$, for all elements $x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_103$.",
    "output": "postulate Not_rect_CProp5 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Some. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "postulate Some : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_plus_plus_l. Let $x$ and $y$ and $h$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $h$ and $matita_arithmetics_nat.plus$ applied to $y$ and $h$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$.",
    "output": "postulate minus_plus_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "None. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate mod_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_plus_comm_23. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $z$ and $y$.",
    "output": "postulate plus_plus_comm_23 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_638$.",
    "output": "postulate DPair_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_div. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $n$ and $m$.",
    "output": "postulate divides_to_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_to_minus. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.",
    "output": "postulate le_plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "K1. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $p$ and $matita_arithmetics_nat.O$.",
    "output": "postulate k1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1362$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1363$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_780$ from elements $_z1363$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_777$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_777$ and elements $_z1363$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_778$ and $x_777$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_778$ and $x_777$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate list_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1362 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_778 : cic.Term univs.Type0 x1) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_780 : (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_777)) -> cic.Term cic.prop (P x_777)) -> (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_778 x_777))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_778 x_777))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1608$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1609$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1608 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1609 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "K. For all elements $_n$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate k : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_le. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate decidable_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.le n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_CProp2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1746$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1747$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1746 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1747 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_B1_theta. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.B1$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_B1_theta : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B1 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) -> (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_times_n. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "postulate lt_times_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.times n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_plus_l. Let $x$ and $y$ and $z$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$.",
    "output": "postulate le_inv_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_prod. For all elements $k1$ and $k2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $x$ to $p1$ applied to $x$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $x$ and $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $x$ and $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.times$ applied to $k1$ and $k2$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $p1$ applied to $matita_arithmetics_div_and_mod.div$ applied to $i$ and $k2$ and $p2$ applied to $matita_arithmetics_div_and_mod.div$ applied to $i$ and $k2$ and $matita_arithmetics_div_and_mod.mod$ applied to $i$ and $k2$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $matita_arithmetics_div_and_mod.div$ applied to $i$ and $k2$ and $matita_arithmetics_div_and_mod.mod$ applied to $i$ and $k2$.",
    "output": "postulate bigop_prod : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k1 (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 x) B nil (matita_arithmetics_bigops.op B nil op) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 x i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.times k1 k2) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (p1 (matita_arithmetics_div_and_mod.div i k2)) (p2 (matita_arithmetics_div_and_mod.div i k2) (matita_arithmetics_div_and_mod.mod i k2))) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (matita_arithmetics_div_and_mod.div i k2) (matita_arithmetics_div_and_mod.mod i k2))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reverse_single. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "postulate reverse_single : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1704. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1704 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_lt_times_r. For all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $t$ to $matita_arithmetics_nat.times$ applied to $c$ and $t$.",
    "output": "postulate monotonic_lt_times_r : (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ t : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times c t))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type4_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_813$.",
    "output": "postulate div_mod_spec_rect_Type4_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4) -> (_H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) -> (x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type4 (Q_ x_813)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp0. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.",
    "output": "postulate void_rect_CProp0 : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inv. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate inv : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Position_of_aux_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_found$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_acc$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.",
    "output": "postulate position_of_aux_body : (A : cic.Univ univs.Type0) -> (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_Type0_body. For all functions $Q_$ from elements $_x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_72$.",
    "output": "postulate False_rect_Type0_body : (Q_ : (_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0) -> (x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ x_72)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp3_body. For all functions $Q_$ from elements $_x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_353$.",
    "output": "postulate bool_rect_CProp3_body : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z689$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_396$ from elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_394$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_394$ and elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate nat_inv_rect_CProp4 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z689 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_394)) -> cic.Term cic.prop (P x_394)) -> (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_394))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_394))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive_times_plus_r. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.plus$ applied to $b$ and $c$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $a$ and $matita_arithmetics_nat.times$ applied to $c$ and $a$.",
    "output": "postulate distributive_times_plus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.plus b c) a) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times b a) (matita_arithmetics_nat.times c a)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Proj2. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $B$.",
    "output": "postulate proj2 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop B"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_transpose. For all elements $i$ and $j$ and $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $k$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $k$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $matita_arithmetics_permutation.transpose$ applied to $k$ and $j$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $n$.",
    "output": "postulate eq_transpose : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i))) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k))) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $lt1p$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $m$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1p : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type3. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.",
    "output": "postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_CProp3. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1477$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp3 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1476 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1477 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp1. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_853$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_855$ and $x_854$, for all elements $x_853$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_853$.",
    "output": "postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B1. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type4_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_640$.",
    "output": "postulate DPair_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type4 (Q_ x_640)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "LePsi_r2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate lePsi_r2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Snd_eq. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $b$.",
    "output": "postulate snd_eq : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_le_0. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.O$.",
    "output": "postulate plus_le_0 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_times_n_to_lt_r. Let $n$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "postulate lt_times_n_to_lt_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type4. For all functions $Q_$ from elements $_x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_true$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_329$.",
    "output": "postulate bool_rect_Type4 : (Q_ : (_x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) -> (_H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false)) -> (x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ x_329)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_797$.",
    "output": "postulate Aop_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_797)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.",
    "output": "postulate cr_pair1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.O matita_arithmetics_nat.O) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_sum. Let $k1$ and $k2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.plus$ applied to $k1$ and $k2$ and the function that maps $i$ to $matita_basics_bool.match_bool$ applied to $univs.Type0$ and the function that maps $__$ to $matita_basics_bool.bool$ and $p1$ applied to $matita_arithmetics_nat.minus$ applied to $i$ and $k2$ and $p2$ applied to $i$ and $matita_arithmetics_nat.leb$ applied to $k2$ and $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $matita_basics_bool.match_bool$ applied to $univs.Type0$ and the function that maps $__$ to $B$ and $f$ applied to $matita_arithmetics_nat.minus$ applied to $i$ and $k2$ and $g$ applied to $i$ and $matita_arithmetics_nat.leb$ applied to $k2$ and $i$.",
    "output": "postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.match_bool univs.Type0 (\\ __ : cic.Term univs.Type0 matita_basics_bool.bool -> matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.match_bool univs.Type0 (\\ __ : cic.Term univs.Type0 matita_basics_bool.bool -> B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_arithmetics_nat.leb k2 i))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.",
    "output": "postulate DPair_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_652)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_740$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_738$ and $x_737$, for all elements $x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_736$.",
    "output": "postulate list_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) -> (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type2 (Q_ x_736)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "M. If $Nat$, then if $Nat$, then $Nat$.",
    "output": "postulate m : Nat -> Nat -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iter. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate iter : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Make_list. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate make_list : (A : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_706$.",
    "output": "postulate Prod_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_706)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp1_body. For all functions $Q_$ from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.",
    "output": "postulate nat_rect_CProp1_body : (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_409)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type5_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "postulate Prod_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type5 (Q_ x_694)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sigma_p. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and $matita_arithmetics_nat.lt$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ and $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $g2$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "postulate lt_sigma_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> (__2 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (matita_arithmetics_nat.lt (g1 i) (g2 i))) (matita_basics_logic.And (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) (matita_arithmetics_nat.lt matita_arithmetics_nat.O (g2 i))))))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_primr. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_exp_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_max_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $n$.",
    "output": "postulate lt_max_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_680$.",
    "output": "postulate Sig_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_680)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transpose_i_j_j_i. For all elements $i$ and $j$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $j$ and $i$ and $n$.",
    "output": "postulate transpose_i_j_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose j i n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "SameF_upto. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__1$ to $A$.",
    "output": "postulate sameF_upto : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type5. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "postulate unit_rect_Type5 : (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) -> (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) -> (x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type5 (Q_ x_499)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_mod_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate divides_mod_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Irreflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate irreflexive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_ab_lt. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$ and $matita_arithmetics_nat.lt$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$.",
    "output": "postulate congruent_ab_lt : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length_tail. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_arithmetics_nat.pred$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "postulate length_tail : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_arithmetics_nat.pred (matita_basics_lists_list.length A l)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn_fg. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to the function that maps $p$ to $f$ applied to $g$ applied to $p$ and $n$.",
    "output": "postulate bijn_fg : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (g p)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_n_mod_n. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $p$.",
    "output": "postulate congruent_n_mod_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n p) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_877$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_877$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_877$.",
    "output": "postulate Aop_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_877)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_degenerate. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $p$ and $n$.",
    "output": "postulate p_ord_degenerate : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat p n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp2. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_572$, for all functions $_H_inr$ from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_573$, for all elements $x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_571$.",
    "output": "postulate Sum_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))) -> (_H_inr : (x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))) -> (x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_571)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_37$ and $x_38$.",
    "output": "postulate eq_rect_CProp0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_37 : cic.Term univs.Type2 A) -> (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Term cic.prop (Q_ x_37 x_38)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_f2. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $univs.Type2$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type2$ and $B$ to elements of $cic.Term$ of $univs.Type2$ and $C$, for all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $y1$ and $y2$ of $cic.Term$ of $univs.Type2$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x1$ and $x2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $B$ and $y1$ and $y2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $C$ and $f$ applied to $x1$ and $y1$ and $f$ applied to $x2$ and $y2$.",
    "output": "postulate eq_f2 : (A : cic.Univ univs.Type2) -> (B : cic.Univ univs.Type2) -> (C : cic.Univ univs.Type2) -> (f : (__ : cic.Term univs.Type2 A) -> (__1 : cic.Term univs.Type2 B) -> cic.Term univs.Type2 C) -> (x1 : cic.Term univs.Type2 A) -> (x2 : cic.Term univs.Type2 A) -> (y1 : cic.Term univs.Type2 B) -> (y2 : cic.Term univs.Type2 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2)) -> cic.Term cic.prop (matita_basics_logic.eq C (f x1 y1) (f x2 y2))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mdef. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_binomial.bc$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "postulate Mdef : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.M m) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp2. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z371$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_160$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_159$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z372$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_160$ and $x_159$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_160$ and $x_159$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_gcd_times_1. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate eq_gcd_times_1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_d_gcd. Let $m$ and $n$ and $d$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$.",
    "output": "postulate divides_d_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15623. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15623 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10471. Let $n1$ and $n2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f1$ and $f2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, for all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__$ to $matita_arithmetics_nat.nat$ and the function that maps $k$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$, for all functions $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$, for all elements $_clearme2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, for all functions $same$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, for all elements $i$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.O$ and the function that maps $i0$ to $p1$ applied to $i0$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f1$ applied to $i0$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i0$ to $f$ applied to $i0$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f2$ applied to $i0$, for all functions $p20$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n1$, for all elements $sub1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $matita_arithmetics_nat.S$ applied to $m$ and $p20$, for all elements $sub2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $matita_arithmetics_nat.S$ applied to $m$ and $p20$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$, for all elements $x2571$ and $x2572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2571$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2572$ and $matita_arithmetics_div_and_mod.div$ applied to $x2571$ and $x2572$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2571$ and $x2572$.",
    "output": "postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\\ k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1))))) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1)))) -> (_clearme2 : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2)))) -> (same : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 m f))) -> (__2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 m f) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop matita_arithmetics_nat.O (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f1 i0)) (matita_arithmetics_bigops.bigop m (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f2 i0)))) -> (p20 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1)) -> (sub1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20))) -> (sub2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1))) -> (x2571 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2572 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2571 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2572 (matita_arithmetics_div_and_mod.div x2571 x2572)) (matita_arithmetics_div_and_mod.mod x2571 x2572)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_max_to_pi_p_primeb. Let $q$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $m$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $i$ and $matita_arithmetics_primes.dividesb$ applied to $i$ and $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $q$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_primes.dividesb$ applied to $p$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$.",
    "output": "postulate lt_max_to_pi_p_primeb : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max (matita_arithmetics_nat.S m) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i m))) q)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop q (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p m)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1128$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1129$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.",
    "output": "postulate Prod_rect_Type3 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type3 (Q_ x_696)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate exp : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_to_le. Let $a$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $n$ and $matita_arithmetics_nat.plus$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_plus_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a n) (matita_arithmetics_nat.plus a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_793$.",
    "output": "postulate Aop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp4. Let $Q_$ be a function from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "postulate False_rect_CProp4 : (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_73)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ex2_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "postulate ex2_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) -> (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term cic.prop (Q_ x_274)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transpose_i_j_i. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $i$ and $j$.",
    "output": "postulate transpose_i_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j i) j)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leb_true_to_le. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate leb_true_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Type0. $cic.Sort$.",
    "output": "postulate Type0 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_transpose_r. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $f$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $m$.",
    "output": "postulate permut_transpose_r : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (matita_arithmetics_permutation.transpose i j n)) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le1. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_exp_to_le1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp0_body. For all functions $Q_$ from elements $_x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_519$.",
    "output": "postulate unit_rect_CProp0_body : (Q_ : (_x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_519)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_False. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_False : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_674$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_674$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_674$.",
    "output": "postulate Sig_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type1 (Q_ x_674)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate minus_S_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_Type0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z617$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_z618$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z618$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_Type0 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z617 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H1 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type0 (P matita_basics_bool.true)) -> (_H2 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type0 (P matita_basics_bool.false)) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate times_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times n matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bertrand. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate bertrand : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_to_bijn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$.",
    "output": "postulate permut_to_bijn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp1. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "postulate False_rect_CProp1 : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_CProp2. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z635$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_CProp2 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z635 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1626$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1627$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1626 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1627 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "postulate decidable_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Null. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.",
    "output": "postulate null : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type2_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_740$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_738$ and $x_737$, for all elements $x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_736$.",
    "output": "postulate list_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) -> (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type2 (Q_ x_736)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_le_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "postulate monotonic_le_times_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_n_to_eq_n. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $n$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $n$ and $n$.",
    "output": "postulate permut_n_to_eq_n : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp5. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_25$ and $x_26$.",
    "output": "postulate eq_rect_CProp5 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.",
    "output": "postulate inl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Tech_log. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $x$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $x$ and $n$.",
    "output": "postulate tech_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_exp.exp p x) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_true_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate eqb_true_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_l_aux. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b2$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b1$.",
    "output": "postulate lstar_ind_l_aux : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b2)) -> cic.Term cic.prop (P l b1)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $len$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lep$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $p$, for all elements $ltp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $Hc$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $p$ and $matita_basics_bool.true$, for all elements $H2n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) -> (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) matita_basics_bool.true)) -> (H2n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn_transpose. For all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$.",
    "output": "postulate bijn_transpose : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate commutative_plus : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_append. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l1$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l2$.",
    "output": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_discr. Let $a1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $a2$ and $a$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $x0$ applied to $b$ and $c$ and $x0$ applied to $x0$ applied to $a$ and $b$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z51$ to $P$ and $y$ and $x$.",
    "output": "postulate Aop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> cic.univ univs.Type2) (\\ t0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ t1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) -> \\ t2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) -> \\ t3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) -> matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> cic.univ univs.Type2) (\\ u0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ u1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a2 a) a)) -> \\ u2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a a2) a)) -> \\ u3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a (u0 b c)) (u0 (u0 a b) c))) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) (\\ e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (\\ e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (\\ _e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) -> P))))) (\\ _z51 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0)) -> (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1)) -> (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2)) -> (_e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_iter. Let $g$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $a$ and $b$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $g$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $b$.",
    "output": "postulate monotonic_iter : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "postulate Aop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type4_body. For all functions $Q_$ from elements $_x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_it$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_497$.",
    "output": "postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1559. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.",
    "output": "postulate let_clause_1559 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.",
    "output": "postulate eq_rect_CProp3_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate f_ind : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. For all elements $n$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_S_fact. Let $n$ and $i$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate mod_S_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)) i) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "postulate not_le_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iso. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate iso : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B2. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $g$.",
    "output": "postulate min_f_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound3. Let $n$ and $m$ and $x$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound3 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_all. Let $_l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate primes_all : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "postulate eq_rect_Type0 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "postulate div_mod_spec_rect_CProp3 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_Type4. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z912$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z913$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_Type4 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z912 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H1 : (_z913 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type4 (P matita_basics_types.it)) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1650$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1651$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate range_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1650 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type2) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1651 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_fg. Let $f$ and $g$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $m$ to $f$ applied to $g$ applied to $m$ and $n$.",
    "output": "postulate permut_fg : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (g m)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mem_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l1$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l2$.",
    "output": "postulate mem_append : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.mem A a l1) (matita_basics_lists_list.mem A a l2))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Aop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_SO_to_le_B_exp. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate lt_SO_to_le_B_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.",
    "output": "postulate eq_rect_CProp3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $i$.",
    "output": "postulate eq_fact_pi_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_Psi. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$.",
    "output": "postulate monotonic_Psi : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le matita_arithmetics_chebyshev_chebyshev_psi.Psi)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_true. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $a$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$.",
    "output": "postulate filter_true : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.filter A p (matita_basics_lists_list.cons A a l)) (matita_basics_lists_list.cons A a (matita_basics_lists_list.filter A p l)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "postulate not_eq_n_Sn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1572 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1532. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1532 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length_tail1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "postulate length_tail1 : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z384$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1595. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $primepn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $primepm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $lt1gcd$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$.",
    "output": "postulate let_clause_1595 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m)))) -> (H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_false. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.",
    "output": "postulate bigop_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.false) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1559. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.",
    "output": "postulate let_clause_1559 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp4. Let $Q_$ be a function from elements $_x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_489$.",
    "output": "postulate void_rect_CProp4 : (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_489)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_times_to_le. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_times_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_164$ and $x_163$, for all elements $x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_162$.",
    "output": "postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp1. Let $Q_$ be a function from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.",
    "output": "postulate nat_rect_CProp1 : (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_409)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_905$.",
    "output": "postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1206$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1207$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Sig_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_ind_aux. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate f_ind_aux : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_n_r. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $m$ and $n$.",
    "output": "postulate le_plus_n_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "postulate fact_pi_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1573$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1621$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z365$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z366$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_156 : cic.Term cic.prop x1) -> (x_155 : cic.Term cic.prop x2) -> (_z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "postulate theta_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Psi_2. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate Psi_2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_1_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate exp_1_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_lt_plus_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $m$ to $matita_arithmetics_nat.plus$ applied to $n$ and $m$.",
    "output": "postulate monotonic_lt_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_true_to_eq. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate eqb_true_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_SO_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate divides_SO_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_899$.",
    "output": "postulate ACop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type1 (Q_ x_899)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_ab_lt. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$ and $matita_arithmetics_nat.lt$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$.",
    "output": "postulate congruent_ab_lt : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))"
  }
]