[
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_False. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $return_sort$. Låt $z$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$. Då håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "postulate match_False : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort) -> (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_inv_rect_Type0. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$. Soit $P$ une fonction des éléments $_z1332$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_H1$ des éléments $_z1333$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.nil$ appliqué à $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_basics_lists_list.nil$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_748$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $x_747$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ et des fonctions $_x_750$ des éléments $_z1333$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $x_747$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $x_747$ et des éléments $_z1333$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_748$ et $x_747$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_748$ et $x_747$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $Hterm$.",
    "output": "list_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1332 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type0) -> _H1 : (_z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type0 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_748 : cic.Term univs.Type0 x1 -> x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_750 : (_z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_747) -> cic.Term univs.Type0 (P x_747)) -> _z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_748 x_747)) -> cic.Term univs.Type0 (P (matita_basics_lists_list.cons x1 x_748 x_747))) -> cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type1_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_606$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H_None$ be an element of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$. Let $_H_Some$ be a function from elements $x_607$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_607$. Then for all elements $x_606$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_606$.",
    "output": "option_rect_Type1_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type1) -> _H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_607 : cic.Term univs.Type0 _A -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type1 (Q_ x_606) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_CProp2. Låt $x1$ och $x2$ och $x3$ och $x4$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1482$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_851$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x4$ och $x2$ och element $x_850$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x3$ och $x2$ och $x4$ och element $_z1483$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $Hterm$ och $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_851$ och $x_850$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_851$ och $x_850$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom div_mod_spec_inv_rect_CProp2 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1482 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop), forall _H1 : ((x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1483 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_851 x_850))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_851 x_850))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_I. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $op$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $B$ et $nil$. Alors pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $n$ et $matita_arithmetics_nat.O$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $p$ appliqué à $i0$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $matita_arithmetics_nat.O$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.",
    "output": "postulate bigop_I : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus n matita_arithmetics_nat.O) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R2. Låt $T0$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $a0$ vara ett element av $cic.Term$ av $univs.Type0$ och $T0$. Låt $T1$ vara en funktion från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ till element av $cic.Univ$ av $univs.Type0$. Låt $a1$ vara ett element av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$. Då för alla funktioner $T2$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $_a2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$, för alla element $b0$ av $cic.Term$ av $univs.Type0$ och $T0$, för alla element $e0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $b0$, för alla element $b1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $b0$ och $e0$, för alla element $e1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $b0$ och $e0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $b0$ och $e0$ och $b1$, håller $cic.Term$ för $univs.Type0$ och $T2$ applicerat på $b0$ och $e0$ och $b1$ och $e1$.",
    "output": "Axiom R2 : forall T0 : cic.Univ univs.Type0, forall a0 : cic.Term univs.Type0 T0, forall T1 : ((x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0), forall a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0)), forall T2 : ((x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0), forall _a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1)), forall b0 : cic.Term univs.Type0 T0, forall e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0), forall b1 : cic.Term univs.Type0 (T1 b0 e0), forall e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 b0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 b0 e0) b1), cic.Term univs.Type0 (T2 b0 e0 b1 e1) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rintersection. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soient $_R1$ et $_R2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$. Alors pour tous les éléments $_a$ et $_b$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Univ$ tient pour $cic.prop$.",
    "output": "postulate Rintersection : (A : cic.Univ univs.Type0) -> (_R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "O. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom O : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1068. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $permf$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lein$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$. Let $lejn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all elements $lebn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $n$, for all elements $fb$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all functions $__$ from elements $i0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i0$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $i0$ and $n$, for all elements $injf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$.",
    "output": "postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (__ : (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)) -> (injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_DPair. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $return_sort$. Soit $case_mk_DPair$ une fonction des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$. Soit $z$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$. Alors $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "match_DPair : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ return_sort) -> case_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term return_sort (return_type (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type1_body. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_138$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H_conj$ från element $x_140$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_139$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_140$ och $x_139$, för alla element $x_138$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_138$.",
    "output": "postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1553. Soient $n$ et $n0$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $a$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n0$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n0$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n0$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n0$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$, pour tous les éléments $Hn$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n0$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n0$ et $matita_arithmetics_nat.plus$ appliqué à $a$ et $matita_arithmetics_nat.S$ appliqué à $a$.",
    "output": "Axiom let_clause_1553 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))), forall Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.plus a (matita_arithmetics_nat.S a))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_times. Låt $p$ och $a$ och $b$ och $qa$ och $ra$ och $qb$ och $rb$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $a$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $b$, för alla element $__3$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord$ applicerat på $a$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $qa$ och $ra$, för alla element $__4$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord$ applicerat på $b$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $qb$ och $rb$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $b$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $qa$ och $qb$ och $matita_arithmetics_nat.times$ applicerat på $ra$ och $rb$.",
    "output": "Axiom p_ord_times : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall qa : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall ra : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall qb : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall rb : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra)), forall __4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.plus qa qb) (matita_arithmetics_nat.times ra rb))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type2_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $_x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $Q_$ une fonction des éléments $x_13$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_14$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_13$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_refl$ un élément de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$. Soit $x_13$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $x_14$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_13$. Alors $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_13$ et $x_14$.",
    "output": "axiom eq_rect_Type2_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_13 : cic.Term univs.Type2 A) -> (_x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) -> cic.Univ univs.Type2) (_H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x))) (x_13 : cic.Term univs.Type2 A) (x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) : cic.Term univs.Type2 (Q_ x_13 x_14)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_RC. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.bi_relation$ applicerat på $A$ och $B$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_relations.bi_relation$ applicerat på $A$ och $B$.",
    "output": "bi_RC : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp3. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_879$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Alors pour tous les éléments $x_879$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_879$.",
    "output": "postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_879)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_869$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$. Then for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_869$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_869$.",
    "output": "Aop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type2 (Q_ x_869) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_le_times_to_lt_S_to_div. Låt $a$ och $c$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $b$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.times$ applicerat på $b$ och $c$ och $a$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $a$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $matita_arithmetics_nat.S$ applicerat på $c$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_div_and_mod.div$ applicerat på $a$ och $b$ och $c$.",
    "output": "postulate lt_to_le_times_to_lt_S_to_div : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.times b (matita_arithmetics_nat.S c)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) c)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_le. Soit $_n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $return_sort$ un élément de $cic.Sort$. Alors pour toutes les fonctions $return_type$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_n$ et $__$ à des éléments de $cic.Univ$ de $return_sort$, pour tous les éléments $case_le_n$ de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $_n$ et $matita_arithmetics_nat.le_n$ appliqué à $_n$, pour toutes les fonctions $case_le_S$ des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_n$ et $m$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $matita_arithmetics_nat.le_S$ appliqué à $_n$ et $m$ et $__$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_n$ et $__$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $__$ et $z$.",
    "output": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_not_exists. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara en funktion från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $b$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $matita_arithmetics_nat.plus$ applicerat på $n$ och $b$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.false$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.min$ applicerat på $n$ och $b$ och $f$ och $matita_arithmetics_nat.plus$ applicerat på $n$ och $b$.",
    "output": "axiom min_not_exists (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp5. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_959$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_Dop$ vara en funktion från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$. Låt $x_959$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_959$.",
    "output": "postulate Dop_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10471. Låt $n1$ och $n2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p1$ och $p2$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $op$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $B$ och $nil$. Låt $f1$ och $f2$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.iso$ applicerat på $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$. Låt $h$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme0$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $__$ som $matita_arithmetics_nat.nat$ och funktionen som avbildar $k$ som $matita_basics_logic.And$ applicerat på $matita_basics_logic.And$ applicerat på $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.true$ och funktionen som avbildar $__1$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $h$ och $k$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $k$ och $h$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$. Låt $k$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_basics_logic.And$ applicerat på $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.true$ och funktionen som avbildar $__1$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $h$ och $k$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $k$ och $h$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$. Låt $_clearme2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.true$ och funktionen som avbildar $__1$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $h$ och $k$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$. Låt $same$ vara en funktion från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n1$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$. Låt $i$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Hind$ vara en funktion från funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.O$ och $n1$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $h$ och $k$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $matita_arithmetics_nat.O$ och $p1$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $m$ och $f$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $k$ och $h$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $m$ och $f$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $matita_arithmetics_nat.O$ och $p1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.O$ och funktionen som avbildar $i0$ som $p1$ applicerat på $i0$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i0$ som $f1$ applicerat på $i0$ och $matita_arithmetics_bigops.bigop$ applicerat på $m$ och funktionen som avbildar $i0$ som $f$ applicerat på $i0$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i0$ som $f2$ applicerat på $i0$. Låt $p20$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.O$ och $n1$. Låt $sub1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $h$ och $k$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $matita_arithmetics_nat.O$ och $p1$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $matita_arithmetics_nat.S$ applicerat på $m$ och $p20$. Då för alla element $sub2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $k$ och $h$ och $B$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f2$ och $matita_arithmetics_nat.S$ applicerat på $m$ och $p20$ och $matita_arithmetics_bigops.mk_range$ applicerat på $B$ och $f1$ och $matita_arithmetics_nat.O$ och $p1$, för alla element $x2571$ och $x2572$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2571$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x2572$ och $matita_arithmetics_div_and_mod.div$ applicerat på $x2571$ och $x2572$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $x2571$ och $x2572$.",
    "output": "postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\\ k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1))))) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1)))) -> (_clearme2 : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2)))) -> (same : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 m f))) -> (__2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 m f) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop matita_arithmetics_nat.O (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f1 i0)) (matita_arithmetics_bigops.bigop m (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f2 i0)))) -> (p20 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1)) -> (sub1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20))) -> (sub2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1))) -> (x2571 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2572 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2571 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2572 (matita_arithmetics_div_and_mod.div x2571 x2572)) (matita_arithmetics_div_and_mod.mod x2571 x2572)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_div_div_div_times. Let $n$ and $m$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_div_and_mod.div$ applied to $q$ and $n$ and $m$ and $matita_arithmetics_div_and_mod.div$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "Axiom eq_div_div_div_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q n) m) (matita_arithmetics_div_and_mod.div q (matita_arithmetics_nat.times n m))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1422$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1423$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_lists_list.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1422 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1423 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_discr. Låt $a1$ och $a2$ vara element av $cic.Univ$ av $univs.Type0$. Låt $x$ och $y$ vara element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $a1$ och $a2$. Låt $_e$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $a1$ och $a2$ och $x$ och $y$. Då håller $cic.Term$ för $univs.Type2$ och $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $u0$ och $u1$ som $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $cic.prod$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $matita_basics_logic.R0$ applicerat på $a1$ och $t0$ och $u0$ och funktionen som avbildar $e0$ som $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och funktionen som avbildar $x0$ och $p0$ som $a2$ applicerat på $u0$ och $e0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $t0$ och funktionen som avbildar $x0$ och $p0$ som $a2$ och $t1$ och $u0$ och $e0$ och $u1$ och funktionen som avbildar $_e1$ som $P$ och funktionen som avbildar $_z45$ som $P$ och $y$ och $x$.",
    "output": "postulate Prod_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1) -> P))) (\\ _z45 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F3_ind_aux. Låt $A1$ och $A2$ och $A3$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A2$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $A3$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $P$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation3$ applicerat på $A1$ och $A2$ och $A3$, för alla funktioner $__$ från element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $__$ från element $a1$ av $cic.Term$ av $univs.Type0$ och $A1$ och element $a2$ av $cic.Term$ av $univs.Type0$ och $A2$ och element $a3$ av $cic.Term$ av $univs.Type0$ och $A3$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $f$ applicerat på $a1$ och $a2$ och $a3$ och $n$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a1$ och $a2$ och $a3$ och element $a1$ av $cic.Term$ av $univs.Type0$ och $A1$ och element $a2$ av $cic.Term$ av $univs.Type0$ och $A2$ och element $a3$ av $cic.Term$ av $univs.Type0$ och $A3$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a1$ och $a2$ och $a3$ och $n$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a1$ och $a2$ och $a3$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $a1$ av $cic.Term$ av $univs.Type0$ och $A1$, för alla element $a2$ av $cic.Term$ av $univs.Type0$ och $A2$, för alla element $a3$ av $cic.Term$ av $univs.Type0$ och $A3$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a1$ och $a2$ och $a3$ och $n$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $a1$ och $a2$ och $a3$.",
    "output": "f3_ind_aux : A1 : cic.Univ univs.Type0 -> A2 : cic.Univ univs.Type0 -> A3 : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A1 -> __1 : cic.Term univs.Type0 A2 -> __2 : cic.Term univs.Type0 A3 -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.relation3 A1 A2 A3) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3)) -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3)) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type3_body. Let $Q_$ be a function from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_true$ be an element of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$. Let $_H_false$ be an element of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$. Let $x_335$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.",
    "output": "bool_rect_Type3_body : Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false) -> x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3 (Q_ x_335) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15625. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $pnm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $d$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme0$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $H$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $m$ et $d$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $c$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15625 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B2_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.B2$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_psi_bounds.bool_to_nat$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.",
    "output": "axiom B2_def (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.B2 n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k n p))) (matita_arithmetics_chebyshev_bertrand.k n p)))))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_diff. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $op$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $B$ et $nil$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Soient $i$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $n$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p$ appliqué à $i$ et $matita_basics_bool.true$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $x$ à $p$ appliqué à $x$ et $B$ et $nil$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $x$ à $f$ appliqué à $x$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $B$ et $nil$ et $op$ et $f$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $x$ à $matita_basics_bool.andb$ appliqué à $matita_basics_bool.notb$ appliqué à $matita_arithmetics_nat.eqb$ appliqué à $i$ et $x$ et $p$ appliqué à $x$ et $B$ et $nil$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $x$ à $f$ appliqué à $x$.",
    "output": "postulate bigop_diff : (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p x) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x)) (matita_arithmetics_bigops.aop__o__op B nil op (f i) (matita_arithmetics_bigops.bigop n (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.eqb i x)) (p x)) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x))))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $len$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $p$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $lep$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_sqrt.sqrt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $p$. Låt $ltp$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $Hc$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.leb$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_chebyshev_bertrand.k$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $p$ och $matita_basics_bool.true$. Låt $H2n$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_exp.exp$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Då för alla element $x2515$ och $x2516$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2515$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x2516$ och $matita_arithmetics_div_and_mod.div$ applicerat på $x2515$ och $x2516$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $x2515$ och $x2516$.",
    "output": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p) -> ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) matita_basics_bool.true) -> H2n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_relation. Soient $__$ et $__1$ des éléments de $cic.Univ$ de $univs.Type0$. Alors $cic.Univ$ tient pour $univs.Type0$.",
    "output": "Axiom bi_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.",
    "output": "postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_transpose. Låt $i$ och $j$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $j$ och $n$.",
    "output": "Axiom permut_transpose : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le j n), cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.transpose i j) n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "It. $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.unit$.",
    "output": "axiom it : cic.Term univs.Type0 matita_basics_types.unit"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_Type0. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $P$ be a function from elements $_z617$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_H1$ from elements $_z618$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z618$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_Type0 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z617 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H1 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type0 (P matita_basics_bool.true)) -> (_H2 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type0 (P matita_basics_bool.false)) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus_m_m. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $m$.",
    "output": "plus_minus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m)) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_ind_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_915$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_range$ une fonction des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$. Alors pour tous les éléments $x_915$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_915$.",
    "output": "range_ind_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_915) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_transitive. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.bi_relation$ appliqué à $A$ et $B$, $cic.Univ$ tient pour $cic.prop$.",
    "output": "postulate bi_transitive : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_n_n. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $n$.",
    "output": "postulate divides_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides n n)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fold_true. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $a$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $op$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p$ appliqué à $a$ et $matita_basics_bool.true$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $op$ et $nil$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_basics_lists_list.cons$ appliqué à $A$ et $a$ et $l$ et $op$ appliqué à $f$ appliqué à $a$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $op$ et $nil$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $l$.",
    "output": "Axiom fold_true : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall p : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool), forall op : ((__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B), forall nil : cic.Term univs.Type0 B, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (fun i => p i) (fun i => f i) (matita_basics_lists_list.cons A a l)) (op (f a) (matita_basics_lists_list.fold A B op nil (fun i => p i) (fun i => f i) l))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type0_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_955$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_955$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_955$.",
    "output": "axiom Dop_rect_Type0_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type0 (Q_ x_955)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_939$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_939$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_939$.",
    "output": "range_rect_CProp0 : _A : cic.Univ univs.Type0 -> Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_939) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_r_aux. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$, pour tous les éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $P$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation2$ appliqué à $matita_arithmetics_nat.nat$ et $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.O$ et $b1$, pour toutes les fonctions $__1$ des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b$ et $b2$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $l$ et $b$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b2$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $b$ et $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b$ et $b2$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $b$ et $b1$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $l$ et $b2$.",
    "output": "axiom lstar_ind_r_aux (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 : cic.Term univs.Type0 B) (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b b2 : cic.Term univs.Type0 B) (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1)) : cic.Term cic.prop (P l b2)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10471. Let $n1$ and $n2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p1$ and $p2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $op$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$. Then for all functions $f1$ and $f2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, for all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__$ to $matita_arithmetics_nat.nat$ and the function that maps $k$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$, for all functions $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$, for all elements $_clearme2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, for all functions $same$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, for all elements $i$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.O$ and the function that maps $i0$ to $p1$ applied to $i0$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f1$ applied to $i0$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i0$ to $f$ applied to $i0$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f2$ applied to $i0$, for all functions $p20$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n1$, for all elements $sub1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $matita_arithmetics_nat.S$ applied to $m$ and $p20$, for all elements $sub2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $matita_arithmetics_nat.S$ applied to $m$ and $p20$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$, for all elements $x2571$ and $x2572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2571$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2572$ and $matita_arithmetics_div_and_mod.div$ applied to $x2571$ and $x2572$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2571$ and $x2572$.",
    "output": "Axiom let_clause_10471 : forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall p2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil), forall f1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall f2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall _clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2)), forall h : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall _clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __ => matita_arithmetics_nat.nat)) (fun k => matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (fun __ => cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (fun __1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1)))), forall k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall _clearme1 : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (fun __ => cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (fun __1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1))), forall _clearme2 : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (fun __ => cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (fun __1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))), forall same : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 m f))) -> (__2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 m f) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop matita_arithmetics_nat.O (fun i0 => p1 i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (fun i0 => f1 i0)) (matita_arithmetics_bigops.bigop m (fun i0 => f i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (fun i0 => f2 i0)))), forall p20 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1), forall sub1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20)), forall sub2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1)), forall x2571 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2572 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2571 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2572 (matita_arithmetics_div_and_mod.div x2571 x2572)) (matita_arithmetics_div_and_mod.mod x2571 x2572))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type3. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_921$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type3$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$. Då för alla element $x_921$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_921$.",
    "output": "Axiom range_rect_Type3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type3 (Q_ x_921) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1536$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1537$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom Aop_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Proj1. För alla element $A$ och $B$ av $cic.Univ$ av $cic.prop$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $A$ och $B$, håller $cic.Term$ för $cic.prop$ och $A$.",
    "output": "Axiom proj1 : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.And A B), cic.Term cic.prop A ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp2. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_inl$ be a function from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_572$. Let $_H_inr$ be a function from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_573$. Let $x_571$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_571$.",
    "output": "axiom Sum_rect_CProp2 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))) (_H_inr : (x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))) (x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_571)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reverse_single. Let $S$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "reverse_single : S : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 S -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inv. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $A$, för alla element $_a$ och $_b$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Univ$ för $cic.prop$.",
    "output": "axiom inv (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) (_a _b : cic.Term univs.Type0 A) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_plus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$.",
    "output": "axiom le_inv_plus_l (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp4. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_652$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_DPair$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$, pour tous les éléments $x_652$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_652$.",
    "output": "Axiom DPair_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_652) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1398$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1399$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_lists_list.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.",
    "output": "postulate Aop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1398 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1399 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Let $x_879$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "axiom Aop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_879)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_lt. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $e$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $A$. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på funktionen som avbildar $x$ som $x$ och funktionen som avbildar $x$ som $x$ och $A$ och $matita_arithmetics_bigops.mk_range$ applicerat på $A$ och $e$ och $n$ och $p$ och $matita_arithmetics_bigops.mk_range$ applicerat på $A$ och $e$ och $m$ och $p$.",
    "output": "Axiom sub_lt : forall A : cic.Univ univs.Type0, forall e : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (fun x => x) (fun x => x) A (matita_arithmetics_bigops.mk_range A e n p) (matita_arithmetics_bigops.mk_range A e m p)) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1722$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $x2$ et $x2$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $x1$ et $x2$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ et des éléments $_z1723$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_Dop$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ et $_null$ et $_distr$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ et $_null$ et $_distr$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.",
    "output": "axiom Dop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp2. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.times$ applicerat på $m$ och $matita_arithmetics_log.log$ applicerat på $p$ och $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_exp.exp$ applicerat på $n$ och $m$.",
    "output": "log_exp2 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times m (matita_arithmetics_log.log p n)) (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_1_max_prime. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $i$ and $matita_arithmetics_primes.dividesb$ applied to $i$ and $n$.",
    "output": "Axiom lt_1_max_prime : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (fun i => matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Conf3. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$. Then for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Conf3 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.relation2 A B) -> __1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp5. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_inl$ be a function from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$. Let $_H_inr$ be a function from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$. Let $x_561$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "postulate Sum_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_conj$ be a function from elements $x_168$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_168$ and $x_167$. Then for all elements $x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_166$.",
    "output": "And_rect_CProp0_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_168 : cic.Term cic.prop _A -> x_167 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) -> x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_166) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type0_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_702$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_702$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_702$.",
    "output": "Axiom Prod_rect_Type0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type0 (Q_ x_702) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1047. Let $k$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $op$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $lenk$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$. Let $j$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $leup$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $j$, for all functions $Hind$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $j$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $j$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$, for all functions $Hfalse$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $j$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$, for all elements $x2571$ and $x2572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2571$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2572$ and $matita_arithmetics_div_and_mod.div$ applied to $x2571$ and $x2572$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2571$ and $x2572$.",
    "output": "postulate let_clause_1047 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (lenk : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (leup : cic.Term cic.prop (matita_arithmetics_nat.le n j)) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i j)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop j (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))) -> (Hfalse : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.S j))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> (x2571 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2572 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2571 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2572 (matita_arithmetics_div_and_mod.div x2571 x2572)) (matita_arithmetics_div_and_mod.mod x2571 x2572)))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $f$, $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "Axiom dpi1 : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall _xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f), cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1617. Let $p$ and $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$. Let $gcd1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$. Let $c$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $nm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$. Let $b$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$. Let $H$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$. Then for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $a$ and $matita_arithmetics_nat.times$ applied to $m$ and $b$.",
    "output": "axiom let_clause_1617 (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m))) (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp3_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_682$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Sig$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$, för alla element $x_682$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_682$.",
    "output": "Sig_rect_CProp3_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_682 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_682 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_682) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_case. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $x$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.mem$ applied to $A$ and $x$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$ and $matita_basics_lists_list.mem$ applied to $A$ and $x$ and $matita_basics_lists_list.filter$ applied to $A$ and the function that maps $x0$ to $matita_basics_bool.notb$ applied to $p$ applied to $x0$ and $l$.",
    "output": "Axiom filter_case : forall A : cic.Univ univs.Type0, forall p : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool), forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall x : cic.Term univs.Type0 A, forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A x l), cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.mem A x (matita_basics_lists_list.filter A p l)) (matita_basics_lists_list.mem A x (matita_basics_lists_list.filter A (fun x0 => matita_basics_bool.notb (p x0)) l))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_div_to_times. Soient $n$ et $m$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $q$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $q$ et $m$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $q$ et $m$.",
    "output": "Axiom lt_div_to_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m), cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times q m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void. $cic.Univ$ holds for $univs.Type0$.",
    "output": "void : cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1047. Soient $k$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $op$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Soit $lenk$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $k$. Soit $j$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $leup$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $j$. Soit $Hind$ une fonction des fonctions $__$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $j$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p$ appliqué à $i$ et $matita_basics_bool.false$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $j$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$. Soit $Hfalse$ une fonction des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.S$ appliqué à $j$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p$ appliqué à $i$ et $matita_basics_bool.false$. Soient $x2571$ et $x2572$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2571$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2572$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2571$ et $x2572$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2571$ et $x2572$.",
    "output": "axiom let_clause_1047 (k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (lenk : cic.Term cic.prop (matita_arithmetics_nat.le n k)) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (leup : cic.Term cic.prop (matita_arithmetics_nat.le n j)) (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i j)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ i => p i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop j (λ i => p i) B nil op (λ i => f i)))) (Hfalse : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.S j))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) (x2571 x2572 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2571 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2572 (matita_arithmetics_div_and_mod.div x2571 x2572)) (matita_arithmetics_div_and_mod.mod x2571 x2572)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_883$.",
    "output": "Axiom Aop_rect_CProp1_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_883) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1561. Pour tous les éléments $p$ et $m$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $gcd1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $nm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $p$ et $c$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $b$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$, pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$, pour tous les éléments $H0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $p$ et $a$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $b$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_1561 (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m))) (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop. Soit $x0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x1$ un élément de $cic.Term$ de $univs.Type0$ et de $x0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x3$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $matita_arithmetics_bigops.ACop$ appliqué à $x0$ et $x1$ et $x2$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_bigops.Aop$ appliqué à $x0$ et $x1$.",
    "output": "dpi1__o__aop : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1) -> cic.Univ univs.Type0) -> x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp4_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $_x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $x_22$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_23$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_22$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_refl$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$, pour tous les éléments $x_22$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $x_23$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_22$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_22$ et $x_23$.",
    "output": "eq_rect_CProp4_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_22 : cic.Term univs.Type2 A -> _x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_22 : cic.Term univs.Type2 A -> x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Term cic.prop (Q_ x_22 x_23) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp4_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_range$ be a function from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$. Let $x_929$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_929$.",
    "output": "axiom range_rect_CProp4_body (_A : cic.Univ univs.Type0) (Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_929)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_inv_ind. Låt $x1$ och $x2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $x3$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $x4$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1890$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_1080$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x2$ och $m$ och element $_x_1079$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$ och element $_x_1078$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x3$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $_x_1077$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x2$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $m$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x3$ applicerat på $i$ och $matita_basics_bool.false$ och element $_z1891$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x4$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $m$, för alla funktioner $_H2$ från funktioner $_x_1081$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x2$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x3$ applicerat på $i$ och $matita_basics_bool.false$ och element $_z1891$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x4$ och $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $x4$.",
    "output": "Axiom min_spec_inv_ind : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4), forall P : ((_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 m)) -> cic.Term cic.prop (P m)), forall _H2 : ((_x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus x1 x2))), cic.Term cic.prop (P x4) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sigma_p_dividesb1. Let $m$ and $n$ and $p$ and $k$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $n$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $k$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom sigma_p_dividesb1 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall k : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n)), forall __3 : cic.Term cic.prop (matita_arithmetics_nat.le m k), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop k (fun i => matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H_refl$ be an element of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$. Let $x_16$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $x_17$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$. Then $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.",
    "output": "postulate eq_rect_Type1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) -> (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_16 : cic.Term univs.Type2 A) -> (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Term univs.Type1 (Q_ x_16 x_17)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_797$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Alors pour tous les éléments $x_797$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_797$.",
    "output": "Axiom Aop_rect_CProp5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_797) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_exists. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soient $t$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $t$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $m$ et $matita_basics_bool.true$, pour tous les éléments $k$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $m$, pour toutes les fonctions $__3$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $i$ et des éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $i$ et $matita_basics_bool.false$, pour tous les éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $t$ et $matita_arithmetics_nat.plus$ appliqué à $k$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_minimization.min$ appliqué à $k$ et $b$ et $f$ et $m$.",
    "output": "axiom min_exists (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (t m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m t)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) (k b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le b m)) (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp0. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_776$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_nil$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $_H_cons$ des éléments $x_778$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_777$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_780$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_777$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_778$ et $x_777$, pour tous les éléments $x_776$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_776$.",
    "output": "postulate list_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) -> (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_776)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1722$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $x2$ et $x2$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $x1$ et $x2$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ et des éléments $_z1723$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_Dop$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ et $_null$ et $_distr$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ et $_null$ et $_distr$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.",
    "output": "postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_rem_eq. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_basics_types.snd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$.",
    "output": "axiom ord_rem_eq (n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord_rem n p) (matita_basics_types.snd matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord n p)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp2. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_626$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_None$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_627$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_627$, för alla element $x_626$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_626$.",
    "output": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R4. Låt $T0$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $a0$ av $cic.Term$ av $univs.Type0$ och $T0$, för alla funktioner $T1$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ till element av $cic.Univ$ av $univs.Type0$, för alla element $a1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$, för alla funktioner $T2$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $a2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$, för alla funktioner $T3$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $p1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ och element $x2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $matita_basics_logic.R2$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $x0$ och $p0$ och $x1$ och $p1$ och $x2$ till element av $cic.Univ$ av $univs.Type0$, för alla element $a3$ av $cic.Term$ av $univs.Type0$ och $T3$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$, för alla funktioner $T4$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $p1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ och element $x2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och element $p2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $matita_basics_logic.R2$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och element $x3$ av $cic.Term$ av $univs.Type0$ och $T3$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $p2$ och element $_p3$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T3$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $p2$ och $matita_basics_logic.R3$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $T3$ och $a3$ och $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $p2$ och $x3$ till element av $cic.Univ$ av $univs.Type0$, för alla element $_a4$ av $cic.Term$ av $univs.Type0$ och $T4$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $a3$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T3$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $a3$, för alla element $b0$ av $cic.Term$ av $univs.Type0$ och $T0$, för alla element $e0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $b0$, för alla element $b1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $b0$ och $e0$, för alla element $e1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $b0$ och $e0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $b0$ och $e0$ och $b1$, för alla element $b2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $b0$ och $e0$ och $b1$ och $e1$, för alla element $e2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $matita_basics_logic.R2$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $b0$ och $e0$ och $b1$ och $e1$ och $b2$, för alla element $b3$ av $cic.Term$ av $univs.Type0$ och $T3$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$, för alla element $e3$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T3$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$ och $matita_basics_logic.R3$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $T3$ och $a3$ och $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$ och $b3$, håller $cic.Term$ för $univs.Type0$ och $T4$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$ och $b3$ och $e3$.",
    "output": "postulate R4 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) -> (T3 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> cic.Univ univs.Type0) -> (a3 : cic.Term univs.Type0 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2))) -> (T4 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> (x3 : cic.Term univs.Type0 (T3 x0 p0 x1 p1 x2 p2)) -> (_p3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T3 x0 p0 x1 p1 x2 p2)) (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 x0 p0 x1 p1 x2 p2) x3)) -> cic.Univ univs.Type0) -> (_a4 : cic.Term univs.Type0 (T4 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2) a3 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2))) a3))) -> (b0 : cic.Term univs.Type0 T0) -> (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0)) -> (b1 : cic.Term univs.Type0 (T1 b0 e0)) -> (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 b0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 b0 e0) b1)) -> (b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1)) -> (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2)) -> (b3 : cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2)) -> (e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T3 b0 e0 b1 e1 b2 e2)) (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 b0 e0 b1 e1 b2 e2) b3)) -> cic.Term univs.Type0 (T4 b0 e0 b1 e1 b2 e2 b3 e3)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_rect_Type3. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z984$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type3$. Låt $_H1$ vara en funktion från element $x_537$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z985$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_537$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_537$. Då för alla funktioner $_H2$ från element $x_538$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z985$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_538$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_538$, håller $cic.Term$ för $univs.Type3$ och $P$ applicerat på $Hterm$.",
    "output": "postulate Sum_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z984 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_537 : cic.Term univs.Type0 x1) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_537))) -> cic.Term univs.Type3 (P (matita_basics_types.inl x1 x2 x_537))) -> (_H2 : (x_538 : cic.Term univs.Type0 x2) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_799$.",
    "output": "axiom Aop_rect_CProp3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_799)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_4_to_fact. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_factorial.fact$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_factorial.fact$ applicerat på $n$ och $matita_arithmetics_factorial.fact$ applicerat på $n$.",
    "output": "lt_4_to_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_mod_to_divides. För alla element $p$ och $m$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $m$ och $n$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $m$.",
    "output": "axiom divides_mod_to_divides (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_div_and_mod.mod m n))) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) : cic.Term cic.prop (matita_arithmetics_primes.divides p m)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type0_body. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_142$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_conj$ des éléments $x_144$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_143$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_144$ et $x_143$, pour tous les éléments $x_142$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_142$.",
    "output": "postulate And_rect_Type0_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type0) -> (_H_conj : (x_144 : cic.Term cic.prop _A) -> (x_143 : cic.Term cic.prop _B) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) -> (x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type0 (Q_ x_142)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Let $x_783$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$. Then $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "Aop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type4 (Q_ x_783) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1128$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$. Alors pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1129$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.",
    "output": "Axiom DPair_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_CProp1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1752$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $x1$ och $x2$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ och element $_z1753$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Dop$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ och $_null$ och $_distr$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ och $_null$ och $_distr$. Då håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Dop_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1752 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1753 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_discr. För alla element $a1$ och $a2$ av $cic.Univ$ av $univs.Type0$, för alla element $x$ och $y$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $a1$ och $a2$, för alla element $_e$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $a1$ och $a2$ och $x$ och $y$, håller $cic.Term$ för $univs.Type2$ och $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $u0$ och $u1$ som $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $cic.prod$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $matita_basics_logic.R0$ applicerat på $a1$ och $t0$ och $u0$ och funktionen som avbildar $e0$ som $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och funktionen som avbildar $x0$ och $p0$ som $a2$ applicerat på $u0$ och $e0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $t0$ och funktionen som avbildar $x0$ och $p0$ som $a2$ och $t1$ och $u0$ och $e0$ och $u1$ och funktionen som avbildar $_e1$ som $P$ och funktionen som avbildar $_z45$ som $P$ och $y$ och $x$.",
    "output": "axiom Prod_discr (a1 a2 : cic.Univ univs.Type0) (x y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((λ x0 => λ p0 => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (λ x0 => λ p0 => a2) t1 u0 e0) u1) (λ _e1 => P))) (λ _z45 => P))) y) x)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Discr_plus_xy_minus_xz. För alla element $x$ och $z$ och $y$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $x$ och $y$ och $matita_arithmetics_nat.minus$ applicerat på $x$ och $z$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $y$ och $matita_arithmetics_nat.O$.",
    "output": "postulate discr_plus_xy_minus_xz : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x y) (matita_arithmetics_nat.minus x z))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "M. For all elements $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom M (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_add. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $l1$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $x$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $l2$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $matita_basics_lists_list.cons$ appliqué à $A$ et $x$ et $l2$.",
    "output": "axiom Exists_add (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (x : cic.Term univs.Type0 A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2)))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_divides_true. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.list_divides$ appliqué à $l$ et $n$ et $matita_basics_bool.true$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $p$ à $matita_basics_logic.And$ appliqué à $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $p$ et $l$ et $matita_arithmetics_primes.divides$ appliqué à $p$ et $n$.",
    "output": "list_divides_true : l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) (matita_arithmetics_primes.divides p n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_eq. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split$ applied to $A$ and $l$ and $n$ and $matita_basics_types.snd$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split$ applied to $A$ and $l$ and $n$.",
    "output": "split_eq : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1575. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $d$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme0$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $H$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $x1029$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1029$ och $matita_arithmetics_nat.times$ applicerat på $x1029$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $c$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $d$.",
    "output": "postulate let_clause_1575 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_nat.times x1029 (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_max_to_false. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$.",
    "output": "lt_max_to_false : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Relation. Låt $__$ vara ett element av $cic.Univ$ av $univs.Type0$. Då håller $cic.Univ$ för $univs.Type0$.",
    "output": "Axiom relation : forall __ : cic.Univ univs.Type0, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp3. Pour toutes les fonctions $Q_$ des éléments $_x_491$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_491$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_491$.",
    "output": "postulate void_rect_CProp3 : (Q_ : (_x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_491)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Prod. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $_fst$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då för alla element $_snd$ av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$.",
    "output": "mk_Prod : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _fst : cic.Term univs.Type0 A -> _snd : cic.Term univs.Type0 B -> cic.Term univs.Type0 (matita_basics_types.Prod A B) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_pi_p_M1. Soient $m$ et $i$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_bigops.bigop$ appliqué à $i$ et la fonction qui envoie $p$ à $matita_basics_bool.andb$ appliqué à $matita_arithmetics_nat.leb$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $p$ et $matita_arithmetics_primes.primeb$ appliqué à $p$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $p$ à $p$ et $matita_arithmetics_binomial.M$ appliqué à $m$.",
    "output": "postulate divides_pi_p_M1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Even_or_odd. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $a$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$.",
    "output": "axiom even_or_odd (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ a => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type0. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_97$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H_nmk$ vara en funktion från funktioner $x_98$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_98$. Låt $x_97$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$. Då håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_97$.",
    "output": "Not_rect_Type0 : _A : cic.Univ cic.prop -> Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type0) -> _H_nmk : (x_98 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type0 (Q_ x_97) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_discr. Soit $a1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $a2$ un élément de $cic.Term$ de $univs.Type0$ et de $a1$. Alors pour tous les éléments $x$ et $y$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $a1$ et $a2$, pour tous les éléments $_e$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.ACop$ appliqué à $a1$ et $a2$ et $x$ et $y$, $cic.Term$ tient pour $univs.Type2$ et $matita_arithmetics_bigops.match_ACop$ appliqué à $a1$ et $a2$ et $cic.succ$ appliqué à $univs.Type2$ et la fonction qui envoie $__$ à $cic.univ$ appliqué à $univs.Type2$ et la fonction qui envoie $t0$ et $t1$ à $matita_arithmetics_bigops.match_ACop$ appliqué à $a1$ et $a2$ et $cic.succ$ appliqué à $univs.Type2$ et la fonction qui envoie $__$ à $cic.univ$ appliqué à $univs.Type2$ et la fonction qui envoie $u0$ et $u1$ à $cic.prod$ appliqué à $cic.succ$ appliqué à $univs.Type1$ et $univs.Type1$ et $cic.univ$ appliqué à $univs.Type1$ et la fonction qui envoie $P$ à $cic.prod$ appliqué à $univs.Type1$ et $univs.Type1$ et $cic.prod$ appliqué à $cic.prop$ et $univs.Type1$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.Aop$ appliqué à $a1$ et $a2$ et $matita_basics_logic.R0$ appliqué à $matita_arithmetics_bigops.Aop$ appliqué à $a1$ et $a2$ et $t0$ et $u0$ et la fonction qui envoie $e0$ à $cic.prod$ appliqué à $cic.prop$ et $univs.Type1$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et la fonction qui envoie $x0$ et $p0$ à $cic.prod$ appliqué à $univs.Type0$ et $cic.prop$ et $a1$ et la fonction qui envoie $a$ à $cic.prod$ appliqué à $univs.Type0$ et $cic.prop$ et $a1$ et la fonction qui envoie $b$ à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $a1$ et $matita_arithmetics_bigops.op$ appliqué à $a1$ et $a2$ et $x0$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $a1$ et $a2$ et $x0$ et $b$ et $a$ appliqué à $u0$ et $e0$ et $matita_basics_logic.R1$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.Aop$ appliqué à $a1$ et $a2$ et $t0$ et la fonction qui envoie $x_19$ et $_x_20$ à $cic.lift$ appliqué à $cic.prop$ et $univs.Type0$ et la fonction qui envoie $x0$ et $p0$ à $cic.prod$ appliqué à $univs.Type0$ et $cic.prop$ et $a1$ et la fonction qui envoie $a$ à $cic.prod$ appliqué à $univs.Type0$ et $cic.prop$ et $a1$ et la fonction qui envoie $b$ à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $a1$ et $matita_arithmetics_bigops.op$ appliqué à $a1$ et $a2$ et $x0$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $a1$ et $a2$ et $x0$ et $b$ et $a$ appliqué à $x_19$ et $_x_20$ et $t1$ et $u0$ et $e0$ et $u1$ et la fonction qui envoie $_e1$ à $P$ et la fonction qui envoie $_z57$ à $P$ et $y$ et $x$.",
    "output": "axiom ACop_discr (a1 : cic.Univ univs.Type0) (a2 : cic.Term univs.Type0 a1) (x y : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) x y)) : cic.Term univs.Type2 (matita_arithmetics_bigops.match_ACop a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_arithmetics_bigops.match_ACop a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.Aop a1 a2) t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((λ x0 => λ p0 => cic.prod univs.Type0 cic.prop a1 (λ a => cic.prod univs.Type0 cic.prop a1 (λ b => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_arithmetics_bigops.op a1 a2 x0 a b) (matita_arithmetics_bigops.op a1 a2 x0 b a)))) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop a1 a2)) t0 (λ x_19 => λ _x_20 => cic.lift cic.prop univs.Type0 ((λ x0 => λ p0 => cic.prod univs.Type0 cic.prop a1 (λ a => cic.prod univs.Type0 cic.prop a1 (λ b => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_arithmetics_bigops.op a1 a2 x0 a b) (matita_arithmetics_bigops.op a1 a2 x0 b a)))) x_19 _x_20)) t1 u0 e0) u1) (λ _e1 => P))) (λ _z57 => P))) y) x)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Same_bigop. Låt $k$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p1$ och $p2$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $op$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $f$ och $g$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sameF_upto$ applicerat på $k$ och $matita_basics_bool.bool$ och $p1$ och $p2$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sameF_p$ applicerat på $k$ och $p1$ och $B$ och $f$ och $g$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $g$ applicerat på $i$.",
    "output": "axiom same_bigop (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto k matita_basics_bool.bool p1 p2)) (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p k p1 B f g)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k (λ i => p1 i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p2 i) B nil op (λ i => g i)))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1686. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Hind$ des éléments $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $p$ et $m$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $p$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$, pour tous les éléments $Hm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$, pour tous les éléments $Hlt$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$, pour tous les éléments $Ha$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $a$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.pred$ appliqué à $m$ et $matita_arithmetics_nat.plus$ appliqué à $a$ et $a$.",
    "output": "postulate let_clause_1686 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))) -> (Hm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> (Hlt : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> (Ha : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.pred m) (matita_arithmetics_nat.plus a a))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_found_min_spec. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.",
    "output": "Axiom not_found_min_spec : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)), cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type2_r. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $a$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Då för alla funktioner $P$ från element $x$ av $cic.Term$ av $univs.Type2$ och $A$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $x$ och $a$ till element av $cic.Univ$ av $univs.Type2$, för alla element $__$ av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $a$ och $matita_basics_logic.refl$ applicerat på $A$ och $a$, för alla element $x$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $p$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $x$ och $a$, håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $x$ och $p$.",
    "output": "eq_rect_Type2_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term univs.Type2 (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "le_2_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter. Let $T$ be an element of $cic.Univ$ of $univs.Type0$. Let $_p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.",
    "output": "postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.",
    "output": "postulate Sig_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1617. Låt $p$ och $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $p$. Då för alla element $gcd1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $nm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $p$ och $c$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $b$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$, för alla element $H0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $p$ och $a$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $b$.",
    "output": "let_clause_1617 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) -> H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp3. Soit $Q_$ une fonction des éléments $_x_513$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_it$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_513$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_513$.",
    "output": "Axiom unit_rect_CProp3 : forall Q_ : ((_x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_513 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_513) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Extract_pair. Låt $A$ och $B$ och $C$ och $D$ vara element av $cic.Univ$ av $univs.Type0$. Låt $u$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$. Låt $Q$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $C$ och $D$. Låt $x$ vara ett element av $cic.Term$ av $univs.Type0$ och $C$. Då för alla element $y$ av $cic.Term$ av $univs.Type0$ och $D$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $C$ och $D$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $__$ som $matita_basics_types.Prod$ applicerat på $C$ och $D$ och funktionen som avbildar $a$ och $b$ som $Q$ applicerat på $a$ och $b$ och $u$ och $matita_basics_types.mk_Prod$ applicerat på $C$ och $D$ och $x$ och $y$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och funktionen som avbildar $a$ som $matita_basics_logic.ex$ applicerat på $B$ och funktionen som avbildar $b$ som $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $a$ och $b$ och $u$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $C$ och $D$ och $Q$ applicerat på $a$ och $b$ och $matita_basics_types.mk_Prod$ applicerat på $C$ och $D$ och $x$ och $y$.",
    "output": "postulate extract_pair : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (D : cic.Univ univs.Type0) -> (u : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (Q : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> (x : cic.Term univs.Type0 C) -> (y : cic.Term univs.Type0 D) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> matita_basics_types.Prod C D) (\\ a : cic.Term univs.Type0 A -> \\ b : cic.Term univs.Type0 B -> Q a b) u) (matita_basics_types.mk_Prod C D x y))) -> cic.Term cic.prop (matita_basics_logic.ex A (\\ a : cic.Term univs.Type0 A -> matita_basics_logic.ex B (\\ b : cic.Term univs.Type0 B -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y)))))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_to_le_theta_exp_theta. Soit $m$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$.",
    "output": "axiom lt_O_to_le_theta_exp_theta (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_eq. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soient $_x$ et $__$ des éléments de $cic.Term$ de $univs.Type2$ et de $A$. Soit $return_sort$ un élément de $cic.Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $__$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $__$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $__$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "Axiom filter_eq : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall __ : cic.Term univs.Type2 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.eq A _x __), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Hint_declaration_CProp0. Låt $A$ vara ett element av $cic.Univ$ av $cic.prop$. Då för alla element $_a$ och $_b$ av $cic.Term$ av $cic.prop$ och $A$, håller $cic.Univ$ för $univs.Type0$.",
    "output": "postulate hint_declaration_CProp0 : (A : cic.Univ cic.prop) -> (_a : cic.Term cic.prop A) -> (_b : cic.Term cic.prop A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15622. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Then for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_15622 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_ex2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_P$ and $_Q$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$. Let $return$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$. Then for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1134$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H1$ vara en funktion från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $x2$ applicerat på $dpi1$ och element $_z1135$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$. Då håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.",
    "output": "axiom DPair_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_ind_aux. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.predicate$ applicerat på $A$. Låt $__$ vara en funktion från element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $__$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $f$ applicerat på $a$ och $n$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a$ och element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $n$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $a$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $n$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $a$.",
    "output": "axiom f_ind_aux (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (a : cic.Term univs.Type0 A) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) : cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Null_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $xxx$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $nil$. Alors pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.prod$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $nil$ et $nil$.",
    "output": "Axiom null_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $x1$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x4$ and $x5$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from elements $_z2089$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_z2088$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2087$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2092$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ and elements $_z2091$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b$ and elements $_z2090$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$, for all functions $_H2$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_x_1236$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_x_1235$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $x1$ and $x2$ and $l$ and $b$ and $b2$ and functions $_x_1238$ from elements $_z2092$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $l$ and elements $_z2091$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b$ and elements $_z2090$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ and $b2$ and elements $_z2092$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and elements $_z2091$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b1$ and elements $_z2090$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x3$ and $x4$ and $x5$.",
    "output": "Axiom lstar_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1), forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 x1, forall x5 : cic.Term univs.Type0 x1, forall _Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar x1 x2 x3 x4 x5), forall P : ((_z2089 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_z2088 : cic.Term univs.Type0 x1) -> (_z2087 : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall _H1 : ((b : cic.Term univs.Type0 x1) -> (_z2092 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> (_z2091 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2090 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b)) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)), forall _H2 : ((b1 : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (_x_1236 : cic.Term cic.prop (x2 b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 x1) -> (_x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar x1 x2 l b b2)) -> (_x_1238 : (_z2092 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 l)) -> (_z2091 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2090 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b2)) -> cic.Term cic.prop (P l b b2)) -> (_z2092 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (_z2091 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b1)) -> (_z2090 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b2)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)), cic.Term cic.prop (P x3 x4 x5) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1188$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1189$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "axiom Sig_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type2) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1392$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1393$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_lists_list.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.",
    "output": "axiom Aop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) (P : (_z1392 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1393 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pair_elim2. Låt $A$ och $B$ och $C$ och $C'$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $T$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$, för alla funktioner $T'$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C'$, för alla element $p$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $C$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $C'$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $lft$ av $cic.Term$ av $univs.Type0$ och $A$ och element $rgt$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ och $T$ applicerat på $lft$ och $rgt$ och $T'$ applicerat på $lft$ och $rgt$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $p$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $_0$ som $C$ och funktionen som avbildar $lft$ och $rgt$ som $T$ applicerat på $lft$ och $rgt$ och $p$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $_0$ som $C'$ och funktionen som avbildar $lft$ och $rgt$ som $T'$ applicerat på $lft$ och $rgt$ och $p$.",
    "output": "Axiom pair_elim2 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall C : cic.Univ univs.Type0, forall C' : cic.Univ univs.Type0, forall T : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C), forall T' : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C'), forall p : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall P : ((__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop), forall __ : ((lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt) (T' lft rgt))), cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (fun _0 => C) (fun lft => fun rgt => T lft rgt) p) (matita_basics_types.match_Prod A B univs.Type0 (fun _0 => C') (fun lft => fun rgt => T' lft rgt) p)) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type4. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_945$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_mk_Dop$ une fonction des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$. Alors pour tous les éléments $x_945$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_945$.",
    "output": "Dop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type4 (Q_ x_945) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_to_gcd_aux. Let $p$ and $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "Axiom not_divides_to_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_f3. Let $A$ and $B$ and $C$ and $D$ be elements of $cic.Univ$ of $univs.Type2$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type2$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type2$ and $C$ to elements of $cic.Term$ of $univs.Type2$ and $D$. Then for all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $y1$ and $y2$ of $cic.Term$ of $univs.Type2$ and $B$, for all elements $z1$ and $z2$ of $cic.Term$ of $univs.Type2$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x1$ and $x2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $B$ and $y1$ and $y2$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $C$ and $z1$ and $z2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $D$ and $f$ applied to $x1$ and $y1$ and $z1$ and $f$ applied to $x2$ and $y2$ and $z2$.",
    "output": "Axiom eq_f3 : forall A : cic.Univ univs.Type2, forall B : cic.Univ univs.Type2, forall C : cic.Univ univs.Type2, forall D : cic.Univ univs.Type2, forall f : ((__ : cic.Term univs.Type2 A) -> (__1 : cic.Term univs.Type2 B) -> (__2 : cic.Term univs.Type2 C) -> cic.Term univs.Type2 D), forall x1 : cic.Term univs.Type2 A, forall x2 : cic.Term univs.Type2 A, forall y1 : cic.Term univs.Type2 B, forall y2 : cic.Term univs.Type2 B, forall z1 : cic.Term univs.Type2 C, forall z2 : cic.Term univs.Type2 C, forall __ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2), forall __1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2), forall __2 : cic.Term cic.prop (matita_basics_logic.eq C z1 z2), cic.Term cic.prop (matita_basics_logic.eq D (f x1 y1 z1) (f x2 y2 z2)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type0. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $cic.prop$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z353$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H1$ vara en funktion från element $x_144$ av $cic.Term$ av $cic.prop$ och $x1$ och element $x_143$ av $cic.Term$ av $cic.prop$ och $x2$ och element $_z354$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_144$ och $x_143$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_144$ och $x_143$. Då håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.",
    "output": "And_inv_rect_Type0 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ univs.Type0) -> _H1 : (x_144 : cic.Term cic.prop x1 -> x_143 : cic.Term cic.prop x2 -> _z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143)) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp5. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_841$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_843$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_842$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_843$ och $x_842$, för alla element $x_841$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_841$.",
    "output": "div_mod_spec_rect_CProp5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) -> x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_841) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_map. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.Exists$ applicerat på $A$ och $P$ och $l$, för alla funktioner $__1$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a$ till element av $cic.Term$ av $cic.prop$ och $Q$ applicerat på $f$ applicerat på $a$, håller $cic.Term$ för $cic.prop$ och $matita_basics_lists_list.Exists$ applicerat på $B$ och $Q$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $f$ och $l$.",
    "output": "axiom Exists_map (A B : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ cic.prop) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l)) (__1 : (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (P a)) -> cic.Term cic.prop (Q (f a))) : cic.Term cic.prop (matita_basics_lists_list.Exists B Q (matita_basics_lists_list.map A B f l))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_706$.",
    "output": "Prod_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_706) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type1. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_674$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type1$. Låt $_H_mk_Sig$ vara en funktion från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$. Låt $x_674$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$. Då håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_674$.",
    "output": "postulate Sig_rect_Type1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type1 (Q_ x_674)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_DPair. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_DPair : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_dx. Pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $b1$ et $b$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b$, pour tous les éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b$ et $b2$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$ et $b2$.",
    "output": "Axiom lstar_dx : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b1 : cic.Term univs.Type0 B, forall b : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b), forall b2 : cic.Term univs.Type0 B, forall __1 : cic.Term cic.prop (R b b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp3_body. Låt $Q_$ vara en funktion från element $_x_401$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_O$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.O$. Då för alla funktioner $_H_S$ från element $x_402$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_404$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_402$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_402$, för alla element $x_401$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_401$.",
    "output": "postulate nat_rect_CProp3_body : (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_401)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_Sfalse. Soit $k$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $p$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $B$, pour toutes les fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p$ appliqué à $k$ et $matita_basics_bool.false$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.S$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.",
    "output": "postulate bigop_Sfalse : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_exp. Soient $n$ et $m$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $p$ et $n$ et $matita_arithmetics_exp.exp$ appliqué à $p$ et $m$.",
    "output": "postulate lt_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1_body. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_925$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type1$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$. Då för alla element $x_925$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_925$.",
    "output": "Axiom range_rect_Type1_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type1 (Q_ x_925) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type2. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$. Då för alla element $x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_923$.",
    "output": "range_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type2) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type2 (Q_ x_923) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type4_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_mk_ACop$ une fonction des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$. Alors pour tous les éléments $x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_891$.",
    "output": "axiom ACop_rect_Type4_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type4 (Q_ x_891)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $n$.",
    "output": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type4. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type2$, pour tous les éléments $_x$ de $cic.Term$ de $univs.Type2$ et de $A$, pour toutes les fonctions $Q_$ des éléments $x_4$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_5$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_4$ à des éléments de $cic.Univ$ de $univs.Type4$, pour tous les éléments $_H_refl$ de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$, pour tous les éléments $x_4$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $x_5$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_4$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_4$ et $x_5$.",
    "output": "postulate eq_rect_Type4 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_4 : cic.Term univs.Type2 A) -> (_x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Univ univs.Type4) -> (_H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_4 : cic.Term univs.Type2 A) -> (x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Term univs.Type4 (Q_ x_4 x_5)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_upper_bound1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_min_true. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $n$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $i$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_basics_bool.true$.",
    "output": "axiom f_min_true (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.min n b f)) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reflexive. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom reflexive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reverse_reverse. Låt $S$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $S$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $S$ och $matita_basics_lists_list.reverse$ applicerat på $S$ och $matita_basics_lists_list.reverse$ applicerat på $S$ och $l$ och $l$.",
    "output": "postulate reverse_reverse : (S : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.reverse S l)) l)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reverse_append. Soit $S$ un élément de $cic.Univ$ de $univs.Type0$. Soient $l1$ et $l2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $S$ et $matita_basics_lists_list.reverse$ appliqué à $S$ et $matita_basics_lists_list.append$ appliqué à $S$ et $l1$ et $l2$ et $matita_basics_lists_list.append$ appliqué à $S$ et $matita_basics_lists_list.reverse$ appliqué à $S$ et $l2$ et $matita_basics_lists_list.reverse$ appliqué à $S$ et $l1$.",
    "output": "reverse_append : S : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.append S l1 l2)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l2) (matita_basics_lists_list.reverse S l1))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub0_to_false. Soient $h$ et $k$ des fonctions des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $I$ et $J$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.upto$ appliqué à $A$ et $I$ et $matita_arithmetics_nat.O$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_bigops.sub_hk$ appliqué à $h$ et $k$ et $A$ et $J$ et $I$, pour tous les éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_bigops.upto$ appliqué à $A$ et $J$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_bigops.filter$ appliqué à $A$ et $J$ et $i$ et $matita_basics_bool.false$.",
    "output": "Axiom sub0_to_false : forall h : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, forall I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O), forall __1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A J I), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_bigops.upto A J)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_bigops.filter A J i) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_append_r. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $l1$ et $l2$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $l2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$.",
    "output": "postulate Exists_append_r : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l2)) -> cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10333. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Alors pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.",
    "output": "postulate let_clause_10333 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) -> (case_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_0. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Då för alla element $op$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $B$ och $nil$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och funktionen som avbildar $i$ som $matita_basics_bool.true$ och $B$ och $nil$ och $matita_arithmetics_bigops.op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.op$ applicerat på $B$ och $nil$ och $op$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $matita_basics_bool.true$ och $B$ och $nil$ och $matita_arithmetics_bigops.op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $matita_arithmetics_nat.S$ applicerat på $i$ och $f$ applicerat på $matita_arithmetics_nat.O$.",
    "output": "Axiom bigop_0 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun i => matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f i)) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop n (fun i => matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f (matita_arithmetics_nat.S i))) (f matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_to_eq_O. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_exp.exp$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.O$.",
    "output": "axiom exp_to_eq_O (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_S_fact. Låt $n$ och $i$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $i$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_factorial.fact$ applicerat på $n$ och $i$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.",
    "output": "postulate mod_S_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)) i) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1074$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1075$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1075$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_615$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_615$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate option_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1074 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_615 : cic.Term univs.Type0 x1) -> (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_1_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.",
    "output": "Axiom exp_1_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_lstar_r. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$. Soit $return_sort$ un élément de $cic.Sort$. Alors pour toutes les fonctions $return_type$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar_r$ appliqué à $B$ et $_R$ et $__$ et $__1$ et $__2$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $case_lstar_r_O$ des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_arithmetics_nat.O$ et $b$ et $b$ et $matita_arithmetics_lstar.lstar_r_O$ appliqué à $B$ et $_R$ et $b$, pour toutes les fonctions $case_lstar_r_S$ des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar_r$ appliqué à $B$ et $_R$ et $l$ et $b1$ et $b$ et des éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $_R$ appliqué à $b$ et $b2$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$ et $b2$ et $matita_arithmetics_lstar.lstar_r_S$ appliqué à $B$ et $_R$ et $l$ et $b1$ et $b$ et $__$ et $b2$ et $__1$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__1$ et $__2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar_r$ appliqué à $B$ et $_R$ et $__$ et $__1$ et $__2$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $__$ et $__1$ et $__2$ et $z$.",
    "output": "postulate match_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (case_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_to_gcd_aux. Soient $p$ et $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $matita_arithmetics_nat.S$ appliqué à $p$ et $m$ et $n$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $p$ et $n$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $m$ et $n$.",
    "output": "axiom not_divides_to_gcd_aux (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_rect_CProp2. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1020$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H1$ des éléments $x_572$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1021$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_572$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_572$, pour toutes les fonctions $_H2$ des éléments $x_573$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1021$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_573$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_573$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "Sum_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_572 : cic.Term univs.Type0 x1 -> _z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572)) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))) -> _H2 : (x_573 : cic.Term univs.Type0 x2 -> _z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573)) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Let $x_803$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "Aop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_803) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_ind_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Q_$ vara en funktion från element $_x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_div_mod_spec_intro$ från element $x_811$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_810$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_811$ och $x_810$, för alla element $x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_809$.",
    "output": "Axiom div_mod_spec_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))), forall x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_809) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fst_p_ord_times. Soient $p$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $a$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_types.fst$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $b$ et $p$ et $matita_arithmetics_nat.plus$ appliqué à $matita_basics_types.fst$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $a$ et $p$ et $matita_basics_types.fst$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $b$ et $p$.",
    "output": "fst_p_ord_times : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p)) (matita_arithmetics_nat.plus (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord a p)) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord b p)))) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_div_O. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.O$.",
    "output": "postulate lt_to_div_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n m) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_ind. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $x_417$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_418$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_n$ och $x_417$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_le_n$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_n$ och $matita_arithmetics_nat.le_n$ applicerat på $_n$, för alla funktioner $_H_le_S$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $x_419$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_n$ och $m$ och element $_x_421$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $m$ och $x_419$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $m$ och $matita_arithmetics_nat.le_S$ applicerat på $_n$ och $m$ och $x_419$, för alla element $x_417$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $x_418$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_n$ och $x_417$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_417$ och $x_418$.",
    "output": "Axiom le_ind : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop), forall _H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n)), forall _H_le_S : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))), forall x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417), cic.Term cic.prop (Q_ x_417 x_418) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1621$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "ACop_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_863$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Alors pour tous les éléments $x_863$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_863$.",
    "output": "axiom Aop_rect_Type4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type4 (Q_ x_863)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp2. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_881$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_881$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_881$.",
    "output": "postulate Aop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_881)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Same_bigop. Låt $k$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p1$ och $p2$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $op$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $f$ och $g$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sameF_upto$ applicerat på $k$ och $matita_basics_bool.bool$ och $p1$ och $p2$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sameF_p$ applicerat på $k$ och $p1$ och $B$ och $f$ och $g$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $g$ applicerat på $i$.",
    "output": "axiom same_bigop (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto k matita_basics_bool.bool p1 p2)) (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p k p1 B f g)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k (λ i => p1 i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p2 i) B nil op (λ i => g i)))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_void. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $return_sort$. Soit $return$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$. Alors pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "Axiom filter_void : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 matita_basics_types.void, cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_S_dx. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $R$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$. Då för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $B$ och funktionen som avbildar $b$ som $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b$ och funktionen som avbildar $b$ som $R$ applicerat på $b$ och $b2$.",
    "output": "Axiom lstar_inv_S_dx : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2), cic.Term cic.prop (matita_basics_logic.ex2 B (fun b => matita_arithmetics_lstar.lstar B R l b1 b) (fun b => R b b2)) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp2. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_658$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_DPair$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$, pour tous les éléments $x_658$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_658$.",
    "output": "DPair_rect_CProp2 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_658) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type4. Soient $_n$ et $_m$ et $_q$ et $_r$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $Q_$ une fonction des éléments $_x_813$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_815$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_814$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_815$ et $x_814$. Alors pour tous les éléments $x_813$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_813$.",
    "output": "axiom div_mod_spec_rect_Type4 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4) (_H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) (x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term univs.Type4 (Q_ x_813)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_ab_lt. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$ and $matita_arithmetics_nat.lt$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$.",
    "output": "Axiom congruent_ab_lt : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun x => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_780$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_777$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_778$ and $x_777$, for all elements $x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_776$.",
    "output": "list_rect_CProp0 : _A : cic.Univ univs.Type0 -> Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_778 : cic.Term univs.Type0 _A -> x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_780 : cic.Term cic.prop (Q_ x_777) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) -> x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_776) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sigma_p. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $p1$ och $p2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla funktioner $g1$ och $g2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $__$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p2$ applicerat på $i$ och $matita_basics_bool.true$, för alla funktioner $__1$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $g1$ applicerat på $i$ och $g2$ applicerat på $i$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.true$ och $matita_arithmetics_nat.lt$ applicerat på $g1$ applicerat på $i$ och $g2$ applicerat på $i$ och $matita_basics_logic.And$ applicerat på $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p1$ applicerat på $i$ och $matita_basics_bool.false$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p2$ applicerat på $i$ och $matita_basics_bool.true$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $g2$ applicerat på $i$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$.",
    "output": "axiom lt_sigma_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) (__2 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (matita_arithmetics_nat.lt (g1 i) (g2 i))) (matita_basics_logic.And (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) (matita_arithmetics_nat.lt matita_arithmetics_nat.O (g2 i))))))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_bigops.bigop n (λ i => p1 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => g1 i)) (matita_arithmetics_bigops.bigop n (λ i => p2 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => g2 i)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15692. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Let $posm$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Let $pnm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Let $c$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_15692 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type1_body. Soient $_n$ et $_m$ et $_q$ et $_r$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $Q_$ une fonction des éléments $_x_829$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_831$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_830$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_831$ et $x_830$. Soit $x_829$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$. Alors $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_829$.",
    "output": "postulate div_mod_spec_rect_Type1_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) -> (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type1 (Q_ x_829)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp1. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $cic.prop$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z377$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_164$ av $cic.Term$ av $cic.prop$ och $x1$ och element $x_163$ av $cic.Term$ av $cic.prop$ och $x2$ och element $_z378$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_164$ och $x_163$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_164$ och $x_163$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "And_inv_rect_CProp1 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_164 : cic.Term cic.prop x1 -> x_163 : cic.Term cic.prop x2 -> _z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lop_Strue. Soient $m$ et $i$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $acc$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.list_divides$ appliqué à $acc$ et $i$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_bertrand256.lprim$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $i$ et $acc$ et $matita_arithmetics_chebyshev_bertrand256.lprim$ appliqué à $m$ et $matita_arithmetics_nat.S$ appliqué à $i$ et $acc$.",
    "output": "axiom lop_Strue (m i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S m) i acc) (matita_arithmetics_chebyshev_bertrand256.lprim m (matita_arithmetics_nat.S i) acc))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.",
    "output": "axiom let_clause_1033 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below. Soit $_l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$. Soit $_n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Univ$ tient pour $cic.prop$.",
    "output": "axiom primes_below (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_refl$ be an element of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$. Then for all elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_37$ and $x_38$.",
    "output": "postulate eq_rect_CProp0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_37 : cic.Term univs.Type2 A) -> (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Term cic.prop (Q_ x_37 x_38)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp4_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_556$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_inl$ des éléments $x_557$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_557$, pour toutes les fonctions $_H_inr$ des éléments $x_558$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_558$, pour tous les éléments $x_556$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_556$.",
    "output": "Sum_rect_CProp4_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_557 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> _H_inr : (x_558 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_556) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Comm. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $xxx$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$. Then for all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $b$ and $a$.",
    "output": "Axiom comm : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) a b) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) b a)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "Axiom le_n_Sn : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_m1. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ och $_x_365$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.",
    "output": "Axiom let_m1 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_ind. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_118$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_conj$ des éléments $x_120$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_119$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_120$ et $x_119$, pour tous les éléments $x_118$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_118$.",
    "output": "Axiom And_ind : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))), forall x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_118) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive_times_plus. $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.distributive$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ et $matita_arithmetics_nat.plus$.",
    "output": "distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_found_max_spec. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $n$ and $f$ and $matita_arithmetics_nat.O$.",
    "output": "not_found_max_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_not_exists. Pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $n$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $__$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $i$ et $matita_basics_bool.false$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$.",
    "output": "Axiom min_not_exists : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$. Then for all functions $P$ from elements $_z1734$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1735$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Dop_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Square_double. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $n$.",
    "output": "square_double : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type3. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$. Then for all functions $_H_conj$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_132$ and $x_131$, for all elements $x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_130$.",
    "output": "And_rect_Type3 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type3) -> _H_conj : (x_132 : cic.Term cic.prop _A -> x_131 : cic.Term cic.prop _B -> cic.Term univs.Type3 (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) -> x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type3 (Q_ x_130) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Extract_pair. Let $A$ and $B$ and $C$ and $D$ be elements of $cic.Univ$ of $univs.Type0$. Let $u$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$. Let $Q$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $C$ and $D$. Then for all elements $x$ of $cic.Term$ of $univs.Type0$ and $C$, for all elements $y$ of $cic.Term$ of $univs.Type0$ and $D$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $__$ to $matita_basics_types.Prod$ applied to $C$ and $D$ and the function that maps $a$ and $b$ to $Q$ applied to $a$ and $b$ and $u$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $B$ and the function that maps $b$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $u$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $Q$ applied to $a$ and $b$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$.",
    "output": "extract_pair : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> D : cic.Univ univs.Type0 -> u : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> Q : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> x : cic.Term univs.Type0 C -> y : cic.Term univs.Type0 D -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B) => matita_basics_types.Prod C D) (a : cic.Term univs.Type0 A => b : cic.Term univs.Type0 B => Q a b) u) (matita_basics_types.mk_Prod C D x y)) -> cic.Term cic.prop (matita_basics_logic.ex A (a : cic.Term univs.Type0 A => matita_basics_logic.ex B (b : cic.Term univs.Type0 B => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp1. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_range$ be a function from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$. Then for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.",
    "output": "postulate range_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_937)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_commute. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p11$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $p12$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $p21$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $p22$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $op$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $B$ och $nil$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $__2$ vara en funktion från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $j$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $j$ och $m$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_basics_bool.andb$ applicerat på $p11$ applicerat på $i$ och $p12$ applicerat på $i$ och $j$ och $matita_basics_bool.andb$ applicerat på $p21$ applicerat på $j$ och $p22$ applicerat på $i$ och $j$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p11$ applicerat på $i$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $matita_arithmetics_bigops.bigop$ applicerat på $m$ och funktionen som avbildar $j$ som $p12$ applicerat på $i$ och $j$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $j$ som $f$ applicerat på $i$ och $j$ och $matita_arithmetics_bigops.bigop$ applicerat på $m$ och funktionen som avbildar $j$ som $p21$ applicerat på $j$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $j$ som $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p22$ applicerat på $i$ och $j$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $j$.",
    "output": "bigop_commute : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p11 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p12 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p21 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p22 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt j m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb (p11 i) (p12 i j)) (matita_basics_bool.andb (p21 j) (p22 i j)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p11 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop m (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => p12 i j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i j))) (matita_arithmetics_bigops.bigop m (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => p21 j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p22 i j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i j)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type3_body. Let $Q_$ be a function from elements $_x_501$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_it$ be an element of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.it$. Then for all elements $x_501$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_501$.",
    "output": "postulate unit_rect_Type3_body : (Q_ : (_x_501 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type3) -> (_H_it : cic.Term univs.Type3 (Q_ matita_basics_types.it)) -> (x_501 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type3 (Q_ x_501)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_eq. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_x$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $__$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $__$ à des éléments de $cic.Univ$ de $return_sort$, pour tous les éléments $case_refl$ de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $__$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $__$ et $z$.",
    "output": "postulate match_eq : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) -> (case_refl : cic.Term return_sort (return_type _x (matita_basics_logic.refl A _x))) -> (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_spec_ind. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $Q_$ be a function from elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_found_max_spec$ be a function from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$. Let $_H_not_found_max_spec$ be a function from functions $x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$. Then for all elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_971$ and $x_972$.",
    "output": "postulate max_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop) -> (_H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f x_976))) -> (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Term cic.prop (Q_ x_971 x_972)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Op. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $nil$, pour tous les éléments $_x_807$ et $_x_808$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "op : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> _x_807 : cic.Term univs.Type0 A -> _x_808 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp2. Soit $Q_$ une fonction des éléments $_x_60$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_I$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.I$. Soit $x_60$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_60$.",
    "output": "postulate True_rect_CProp2 : (Q_ : (_x_60 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_60 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_60)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "SameF_upto_le. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $f$ and $g$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$. Then for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $m$ and $A$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $n$ and $A$ and $f$ and $g$.",
    "output": "axiom sameF_upto_le (A : cic.Univ univs.Type0) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto m A f g)) : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto n A f g)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_times_div_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $n$.",
    "output": "le_times_div_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Aop. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $nil$ et $a$ et $a$, pour toutes les fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $nil$ et $a$, pour toutes les fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_lists_list.Aop$ appliqué à $A$ et $nil$.",
    "output": "Axiom mk_Aop : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall op : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A), forall _nill : ((a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)), forall _nilr : ((a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)), forall _assoc : ((a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))), cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Invert_permut. Soit $__$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $__1$ des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.",
    "output": "Axiom invert_permut : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_sigma. Soient $n$ et $a$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $p$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $a$ et $matita_arithmetics_exp.exp$ appliqué à $a$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.plus$ et la fonction qui envoie $i$ à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "Axiom exp_sigma : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp2_body. Let $Q_$ be a function from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.",
    "output": "postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Some. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.option$ applicerat på $A$.",
    "output": "Some : A : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 A -> cic.Term univs.Type0 (matita_basics_types.option A) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_plus. Låt $n$ och $p$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $p$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $matita_arithmetics_nat.plus$ applicerat på $p$ och $q$.",
    "output": "Axiom divides_plus : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.divides n p), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q), cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.plus p q)) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Alors pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.",
    "output": "axiom let_clause_1033 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_eq. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split$ applied to $A$ and $l$ and $n$ and $matita_basics_types.snd$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split$ applied to $A$ and $l$ and $n$.",
    "output": "Axiom split_eq : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_CProp1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1224$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $x2$ applicerat på $pi1$ och element $_z1225$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom Sig_inv_rect_CProp1 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type4_body. Låt $Q_$ vara en funktion från element $_x_497$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $univs.Type4$. Låt $_H_it$ vara ett element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_types.it$. Låt $x_497$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$. Då håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_497$.",
    "output": "axiom unit_rect_Type4_body (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) (x_497 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type4 (Q_ x_497)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_bertrand_to_le1. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_chebyshev_bertrand.not_bertrand$ appliqué à $n$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_sqrt.sqrt$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "Axiom not_bertrand_to_le1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_606$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_None$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_607$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_607$, for all elements $x_606$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_606$.",
    "output": "option_rect_Type1 : _A : cic.Univ univs.Type0 -> Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type1) -> _H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_607 : cic.Term univs.Type0 _A -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type1 (Q_ x_606) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_S_dx. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $B$ and the function that maps $b$ to $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and the function that maps $b$ to $R$ applied to $b$ and $b2$.",
    "output": "Axiom lstar_inv_S_dx : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2), cic.Term cic.prop (matita_basics_logic.ex2 B (fun b => matita_arithmetics_lstar.lstar B R l b1 b) (fun b => R b b2)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1_body. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_925$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$, för alla element $x_925$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_925$.",
    "output": "range_rect_Type1_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type1) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type1 (Q_ x_925) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp3. För alla element $x1$ och $x2$ av $cic.Univ$ av $cic.prop$, för alla element $Hterm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z365$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_156$ av $cic.Term$ av $cic.prop$ och $x1$ och element $x_155$ av $cic.Term$ av $cic.prop$ och $x2$ och element $_z366$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_156$ och $x_155$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_156$ och $x_155$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "axiom And_inv_rect_CProp3 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_156 : cic.Term cic.prop x1) -> (x_155 : cic.Term cic.prop x2) -> (_z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R4. Let $T0$ be an element of $cic.Univ$ of $univs.Type0$. Let $a0$ be an element of $cic.Term$ of $univs.Type0$ and $T0$. Let $T1$ be a function from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ to elements of $cic.Univ$ of $univs.Type0$. Let $a1$ be an element of $cic.Term$ of $univs.Type0$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$. Then for all functions $T2$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$, for all functions $T3$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $p1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ and elements $x2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $x0$ and $p0$ and $x1$ and $p1$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T2$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $matita_basics_logic.R2$ applied to $T0$ and $a0$ and $T1$ and $a1$ and $T2$ and $a2$ and $x0$ and $p0$ and $x1$ and $p1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a3$ of $cic.Term$ of $univs.Type0$ and $T3$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $a2$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $a2$, for all functions $T4$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $p1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ and elements $x2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $x0$ and $p0$ and $x1$ and $p1$ and elements $p2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T2$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $matita_basics_logic.R2$ applied to $T0$ and $a0$ and $T1$ and $a1$ and $T2$ and $a2$ and $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and elements $x3$ of $cic.Term$ of $univs.Type0$ and $T3$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ and elements $_p3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T3$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ and $matita_basics_logic.R3$ applied to $T0$ and $a0$ and $T1$ and $a1$ and $T2$ and $a2$ and $T3$ and $a3$ and $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ and $x3$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_a4$ of $cic.Term$ of $univs.Type0$ and $T4$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $a2$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $a2$ and $a3$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T3$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $a2$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $a2$ and $a3$, for all elements $b0$ of $cic.Term$ of $univs.Type0$ and $T0$, for all elements $e0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $b0$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $b0$ and $e0$, for all elements $e1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $b0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $b0$ and $e0$ and $b1$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $b0$ and $e0$ and $b1$ and $e1$, for all elements $e2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T2$ applied to $b0$ and $e0$ and $b1$ and $e1$ and $matita_basics_logic.R2$ applied to $T0$ and $a0$ and $T1$ and $a1$ and $T2$ and $a2$ and $b0$ and $e0$ and $b1$ and $e1$ and $b2$, for all elements $b3$ of $cic.Term$ of $univs.Type0$ and $T3$ applied to $b0$ and $e0$ and $b1$ and $e1$ and $b2$ and $e2$, for all elements $e3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T3$ applied to $b0$ and $e0$ and $b1$ and $e1$ and $b2$ and $e2$ and $matita_basics_logic.R3$ applied to $T0$ and $a0$ and $T1$ and $a1$ and $T2$ and $a2$ and $T3$ and $a3$ and $b0$ and $e0$ and $b1$ and $e1$ and $b2$ and $e2$ and $b3$, $cic.Term$ holds for $univs.Type0$ and $T4$ applied to $b0$ and $e0$ and $b1$ and $e1$ and $b2$ and $e2$ and $b3$ and $e3$.",
    "output": "axiom R4 (T0 : cic.Univ univs.Type0) (a0 : cic.Term univs.Type0 T0) (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) (T3 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> cic.Univ univs.Type0) (a3 : cic.Term univs.Type0 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2))) (T4 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> (x3 : cic.Term univs.Type0 (T3 x0 p0 x1 p1 x2 p2)) -> (_p3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T3 x0 p0 x1 p1 x2 p2)) (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 x0 p0 x1 p1 x2 p2) x3)) -> cic.Univ univs.Type0) (_a4 : cic.Term univs.Type0 (T4 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2) a3 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2))) a3))) (b0 : cic.Term univs.Type0 T0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0)) (b1 : cic.Term univs.Type0 (T1 b0 e0)) (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 b0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 b0 e0) b1)) (b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1)) (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2)) (b3 : cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2)) (e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T3 b0 e0 b1 e1 b2 e2)) (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 b0 e0 b1 e1 b2 e2) b3)) : cic.Term univs.Type0 (T4 b0 e0 b1 e1 b2 e2 b3 e3)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp4. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "And_rect_CProp4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_148 : cic.Term cic.prop _A -> x_147 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_146) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_min_r. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $n$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_minimization.min$ applicerat på $n$ och $b$ och $f$ och $matita_arithmetics_nat.plus$ applicerat på $n$ och $b$.",
    "output": "le_min_r : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length_filter_eqb. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.filter$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.eqb$ applied to $m$ and $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom length_filter_eqb (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat (matita_basics_lists_list.filter matita_arithmetics_nat.nat (matita_arithmetics_nat.eqb m) l)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16003. För alla element $m$ och $n$ och $a$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $pnm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $m$ och $d$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $c$.",
    "output": "let_clause_16003 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $p1$ et $p2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour toutes les fonctions $g1$ et $g2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $n1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Hind$ des fonctions $__$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $n1$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p1$ appliqué à $i$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p2$ appliqué à $i$ et $matita_basics_bool.true$ et des fonctions $__1$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $n1$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p1$ appliqué à $i$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $g1$ appliqué à $i$ et $g2$ appliqué à $i$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_bigops.bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$, pour toutes les fonctions $H1$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.S$ appliqué à $n1$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p1$ appliqué à $i$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p2$ appliqué à $i$ et $matita_basics_bool.true$, pour toutes les fonctions $H2$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.S$ appliqué à $n1$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p1$ appliqué à $i$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $g1$ appliqué à $i$ et $g2$ appliqué à $i$, pour tous les éléments $Hp2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p2$ appliqué à $n1$ et $matita_basics_bool.true$, pour tous les éléments $Hp1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p1$ appliqué à $n1$ et $matita_basics_bool.true$, pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.",
    "output": "Axiom let_clause_1033 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall p2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall g2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (fun i => p1 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => g1 i)) (matita_arithmetics_bigops.bigop n1 (fun i => p2 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => g2 i)))), forall H1 : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.S n1))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)), forall H2 : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.S n1))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))), forall Hp2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 n1) matita_basics_bool.true), forall Hp1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 n1) matita_basics_bool.true), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type2. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z341$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z342$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_136$ and $x_135$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_136$ and $x_135$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_Type2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z341 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (x_136 : cic.Term cic.prop x1) -> (x_135 : cic.Term cic.prop x2) -> (_z342 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_136 x_135))) -> cic.Term univs.Type2 (P (matita_basics_logic.conj x1 x2 x_136 x_135))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type5. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_594$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type5$, för alla element $_H_None$ av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_595$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_595$, för alla element $x_594$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_594$.",
    "output": "postulate option_rect_Type5 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type5) -> (_H_None : cic.Term univs.Type5 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_595 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.Some _A x_595))) -> (x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type5 (Q_ x_594)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_pred. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $matita_arithmetics_nat.pred$.",
    "output": "postulate monotonic_pred : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le matita_arithmetics_nat.pred)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_mid. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $l1$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $x$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $l2$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $matita_basics_lists_list.cons$ appliqué à $A$ et $x$ et $l2$.",
    "output": "Axiom Exists_mid : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall x : cic.Term univs.Type0 A, forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (P x), cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1572. Soient $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $H$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.O$. Soit $auto$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.O$. Alors pour tous les éléments $auto'$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_1572 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O), forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O), forall auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10331. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lt4n$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $le4m$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$. Let $Hind$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lea$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$. Let $Hinda$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$. Then for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m)) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a)) -> (Hinda : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S a)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type2. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_541$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_inl$ des éléments $x_542$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_542$, pour toutes les fonctions $_H_inr$ des éléments $x_543$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_543$, pour tous les éléments $x_541$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_541$.",
    "output": "postulate Sum_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2) -> (_H_inl : (x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> (_H_inr : (x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> (x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type2 (Q_ x_541)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter. Soit $T$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_p$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $T$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $_l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $T$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_lists_list.list$ appliqué à $T$.",
    "output": "Axiom filter : forall T : cic.Univ univs.Type0, forall _p : ((__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list T), cic.Term univs.Type0 (matita_basics_lists_list.list T) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.",
    "output": "sum_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_smallest_factor_n. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $matita_arithmetics_primes.smallest_factor$ applicerat på $n$.",
    "output": "prime_smallest_factor_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.smallest_factor n)) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Foldr. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Alors pour tous les éléments $_b$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $_l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, $cic.Term$ tient pour $univs.Type0$ et $B$.",
    "output": "postulate foldr : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_660$.",
    "output": "postulate DPair_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_660)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_times_n_to_lt_r. Låt $n$ och $p$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $q$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $q$.",
    "output": "axiom lt_times_n_to_lt_r (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injn_Sn_n. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "Axiom injn_Sn_n : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n)), cic.Term cic.prop (matita_arithmetics_permutation.injn f n) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $n$ och $m$ och $matita_arithmetics_nat.plus$ applicerat på $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $m$.",
    "output": "Axiom log_exp : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_pi2. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $P$ och $P'$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x$ till element av $cic.Term$ av $cic.prop$ och $P'$ applicerat på $x$, för alla element $x$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och funktionen som avbildar $x$ som $P$ applicerat på $x$, håller $cic.Term$ för $cic.prop$ och $P'$ applicerat på $matita_basics_types.pi1$ applicerat på $A$ och funktionen som avbildar $x0$ som $P$ applicerat på $x0$ och $x$.",
    "output": "sub_pi2 : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> P' : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> __ : (x : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (P x) -> cic.Term cic.prop (P' x)) -> x : cic.Term univs.Type0 (matita_basics_types.Sig A (x : cic.Term univs.Type0 A => P x)) -> cic.Term cic.prop (P' (matita_basics_types.pi1 A (x0 : cic.Term univs.Type0 A => P x0) x)) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_CProp1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1158$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1159$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "postulate DPair_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1158 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1159 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_mid. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $x$ and $l2$.",
    "output": "Axiom Exists_mid : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall x : cic.Term univs.Type0 A, forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (P x), cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lprim_invariant. Pour tous les éléments $n$ et $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $acc$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $i$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_chebyshev_bertrand256.primes_below$ appliqué à $acc$ et $i$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_chebyshev_bertrand256.primes_below$ appliqué à $matita_arithmetics_chebyshev_bertrand256.lprim$ appliqué à $n$ et $i$ et $acc$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $i$.",
    "output": "Axiom lprim_invariant : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "postulate range_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type0 (Q_ x_927)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp2. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_881$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_881$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_881$.",
    "output": "axiom Aop_rect_CProp2 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_881)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp4. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_957$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_957$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_957$.",
    "output": "Axiom Dop_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_957) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type1. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_674$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type1$. Låt $_H_mk_Sig$ vara en funktion från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$. Då för alla element $x_674$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_674$.",
    "output": "axiom Sig_rect_Type1 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term univs.Type1 (Q_ x_674)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Even_or_odd. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $a$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $a$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $a$.",
    "output": "even_or_odd : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type1. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_791$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_791$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_791$.",
    "output": "postulate Aop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_discr. Let $a1$ be an element of $cic.Univ$ of $univs.Type0$. Let $a2$ be an element of $cic.Term$ of $univs.Type0$ and $a1$. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $a1$ and $a2$. Let $_e$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $a1$ and $a2$ and $x$ and $y$. Then $cic.Term$ holds for $univs.Type2$ and $matita_arithmetics_bigops.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_arithmetics_bigops.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $a2$ and $a$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $x0$ applied to $b$ and $c$ and $x0$ applied to $x0$ applied to $a$ and $b$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z55$ to $P$ and $y$ and $x$.",
    "output": "postulate Aop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> cic.univ univs.Type2) (\\ t0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ t1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) -> \\ t2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) -> \\ t3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) -> matita_arithmetics_bigops.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> cic.univ univs.Type2) (\\ u0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ u1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a2 a) a)) -> \\ u2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a a2) a)) -> \\ u3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a (u0 b c)) (u0 (u0 a b) c))) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) (\\ e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (\\ e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (\\ _e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) -> P))))) (\\ _z55 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0)) -> (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1)) -> (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2)) -> (_e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp2. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_658$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_DPair$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$, för alla element $x_658$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_658$.",
    "output": "axiom DPair_rect_CProp2 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_658)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15622. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $pnm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $d$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $m$ et $d$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $c$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "let_clause_15622 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_pi. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $m$.",
    "output": "axiom exp_pi (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_exp.exp (f i) m)) (matita_arithmetics_exp.exp (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => f i)) m))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp2_body. För alla funktioner $Q_$ från element $_x_356$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_356$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_356$.",
    "output": "Axiom bool_rect_CProp2_body : forall Q_ : ((_x_356 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_356 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_356) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $nil$, pour tous les éléments $_x_969$ et $_x_970$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "prod_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> _x_969 : cic.Term univs.Type0 A -> _x_970 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1716$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1717$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "axiom Dop_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type2. Soit $Q_$ une fonction des éléments $_x_503$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_H_it$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_503$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_503$.",
    "output": "unit_rect_Type2 : Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it) -> x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type2 (Q_ x_503) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_to_andb_true. Låt $b1$ och $b2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $b1$ och $matita_basics_bool.true$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $b2$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_basics_bool.andb$ applicerat på $b1$ och $b2$ och $matita_basics_bool.true$.",
    "output": "postulate true_to_andb_true : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_S_sigma_p. För alla element $a$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $a$ och $n$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och funktionen som avbildar $k$ som $matita_basics_bool.true$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $k$ som $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_binomial.bc$ applicerat på $n$ och $k$ och $matita_arithmetics_exp.exp$ applicerat på $a$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $k$.",
    "output": "postulate exp_S_sigma_p : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S a) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k)))))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_to_eq_O. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_exp.exp$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.O$.",
    "output": "exp_to_eq_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_max_spec. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$. Then for all functions $case_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $__$ and $__1$ and $__2$, for all functions $case_not_found_max_spec$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.not_found_max_spec$ applied to $_n$ and $_f$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "match_max_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __) -> cic.Univ return_sort) -> case_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))) -> case_not_found_max_spec : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f __))) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __) -> cic.Term return_sort (return_type __ z) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rewrite_r. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Alors pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $univs.Type2$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type2$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $x$, pour tous les éléments $y$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $y$ et $x$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $y$.",
    "output": "postulate rewrite_r : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (P : (__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P x)) -> (y : cic.Term univs.Type2 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq A y x)) -> cic.Term univs.Type2 (P y)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_CProp1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1224$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1225$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "Axiom Sig_inv_rect_CProp1 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Is_nil. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Then $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom is_nil (A : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H_mk_range$ be a function from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$. Let $x_925$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$. Then $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_925$.",
    "output": "Axiom range_rect_Type1_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type1 (Q_ x_925) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1553. Let $n$ and $n0$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$. Then for all elements $Hn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $a$.",
    "output": "let_clause_1553 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.plus a (matita_arithmetics_nat.S a))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_R$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Univ$ för $cic.prop$.",
    "output": "monotonic : A : cic.Univ univs.Type0 -> _R : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi1_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_xxx$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $f$. Alors $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "pi1_body : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f) -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "SameF_p_le. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Alors pour toutes les fonctions $f$ et $g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_bigops.sameF_p$ appliqué à $m$ et $p$ et $A$ et $f$ et $g$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_bigops.sameF_p$ appliqué à $n$ et $p$ et $A$ et $f$ et $g$.",
    "output": "sameF_p_le : A : cic.Univ univs.Type0 -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> __1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p m p A f g) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_p n p A f g) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1549. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Then for all elements $eqm0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $x1106$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1106$ and $matita_arithmetics_nat.minus$ applied to $x1106$ and $m$.",
    "output": "axiom let_clause_1549 (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (eqm0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) (x1106 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1106 (matita_arithmetics_nat.minus x1106 m))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1068. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $permf$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $f$ och $n$. Låt $i$ och $j$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $lein$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$. Låt $lejn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$. Då för alla element $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $a$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $i$, för alla element $lean$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $a$ och $n$, för alla element $fa$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $i$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $b$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $b$ och $j$, för alla element $lebn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $b$ och $n$, för alla element $fb$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $b$ och $j$, för alla funktioner $__$ från element $i0$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i0$ och $n$ till element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.injn$ applicerat på $f$ och $n$, för alla element $auto$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $a$ och $b$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $i$.",
    "output": "postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (__ : (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)) -> (injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type4_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_590$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type4$, pour tous les éléments $_H_None$ de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_591$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_591$, pour tous les éléments $x_590$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_590$.",
    "output": "option_rect_Type4_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type4) -> _H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_591 : cic.Term univs.Type0 _A -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> x_590 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type4 (Q_ x_590) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_div_S_div. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $m$ och $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $m$.",
    "output": "lt_div_S_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.div n m)) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type0_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_702$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_H_mk_Prod$ une fonction des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$. Alors pour tous les éléments $x_702$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_702$.",
    "output": "Prod_rect_Type0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type0) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type0 (Q_ x_702) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_prod. Låt $k1$ och $k2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p1$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $p2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $op$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $B$ och $nil$. Då för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $k1$ och funktionen som avbildar $x$ som $p1$ applicerat på $x$ och $B$ och $nil$ och $matita_arithmetics_bigops.op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $x$ som $matita_arithmetics_bigops.bigop$ applicerat på $k2$ och funktionen som avbildar $i$ som $p2$ applicerat på $x$ och $i$ och $B$ och $nil$ och $matita_arithmetics_bigops.op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $x$ och $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.times$ applicerat på $k1$ och $k2$ och funktionen som avbildar $i$ som $matita_basics_bool.andb$ applicerat på $p1$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $i$ och $k2$ och $p2$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $i$ och $k2$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $i$ och $k2$ och $B$ och $nil$ och $matita_arithmetics_bigops.op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $i$ och $k2$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $i$ och $k2$.",
    "output": "axiom bigop_prod (k1 k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k1 (λ x => p1 x) B nil (matita_arithmetics_bigops.op B nil op) (λ x => matita_arithmetics_bigops.bigop k2 (λ i => p2 x i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f x i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.times k1 k2) (λ i => matita_basics_bool.andb (p1 (matita_arithmetics_div_and_mod.div i k2)) (p2 (matita_arithmetics_div_and_mod.div i k2) (matita_arithmetics_div_and_mod.mod i k2))) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f (matita_arithmetics_div_and_mod.div i k2) (matita_arithmetics_div_and_mod.mod i k2))))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp1_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_162$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_conj$ vara en funktion från element $x_164$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_163$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_164$ och $x_163$. Låt $x_162$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_162$.",
    "output": "And_rect_CProp1_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_164 : cic.Term cic.prop _A -> x_163 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_162) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R4. Låt $T0$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $a0$ av $cic.Term$ av $univs.Type0$ och $T0$, för alla funktioner $T1$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ till element av $cic.Univ$ av $univs.Type0$, för alla element $a1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$, för alla funktioner $T2$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $a2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$, för alla funktioner $T3$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $p1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ och element $x2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $matita_basics_logic.R2$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $x0$ och $p0$ och $x1$ och $p1$ och $x2$ till element av $cic.Univ$ av $univs.Type0$, för alla element $a3$ av $cic.Term$ av $univs.Type0$ och $T3$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$, för alla funktioner $T4$ från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $p1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ och element $x2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och element $p2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $matita_basics_logic.R2$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och element $x3$ av $cic.Term$ av $univs.Type0$ och $T3$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $p2$ och element $_p3$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T3$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $p2$ och $matita_basics_logic.R3$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $T3$ och $a3$ och $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $p2$ och $x3$ till element av $cic.Univ$ av $univs.Type0$, för alla element $_a4$ av $cic.Term$ av $univs.Type0$ och $T4$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $a3$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T3$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $a2$ och $a3$, för alla element $b0$ av $cic.Term$ av $univs.Type0$ och $T0$, för alla element $e0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $b0$, för alla element $b1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $b0$ och $e0$, för alla element $e1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $b0$ och $e0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $b0$ och $e0$ och $b1$, för alla element $b2$ av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $b0$ och $e0$ och $b1$ och $e1$, för alla element $e2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T2$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $matita_basics_logic.R2$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $b0$ och $e0$ och $b1$ och $e1$ och $b2$, för alla element $b3$ av $cic.Term$ av $univs.Type0$ och $T3$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$, för alla element $e3$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T3$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$ och $matita_basics_logic.R3$ applicerat på $T0$ och $a0$ och $T1$ och $a1$ och $T2$ och $a2$ och $T3$ och $a3$ och $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$ och $b3$, håller $cic.Term$ för $univs.Type0$ och $T4$ applicerat på $b0$ och $e0$ och $b1$ och $e1$ och $b2$ och $e2$ och $b3$ och $e3$.",
    "output": "Axiom R4 : forall T0 : cic.Univ univs.Type0, forall a0 : cic.Term univs.Type0 T0, forall T1 : ((x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0), forall a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0)), forall T2 : ((x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0), forall a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1)), forall T3 : ((x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> cic.Univ univs.Type0), forall a3 : cic.Term univs.Type0 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2)), forall T4 : ((x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> (x3 : cic.Term univs.Type0 (T3 x0 p0 x1 p1 x2 p2)) -> (_p3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T3 x0 p0 x1 p1 x2 p2)) (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 x0 p0 x1 p1 x2 p2) x3)) -> cic.Univ univs.Type0), forall _a4 : cic.Term univs.Type0 (T4 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2) a3 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2))) a3)), forall b0 : cic.Term univs.Type0 T0, forall e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0), forall b1 : cic.Term univs.Type0 (T1 b0 e0), forall e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 b0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 b0 e0) b1), forall b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1), forall e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2), forall b3 : cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2), forall e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T3 b0 e0 b1 e1 b2 e2)) (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 b0 e0 b1 e1 b2 e2) b3), cic.Term univs.Type0 (T4 b0 e0 b1 e1 b2 e2 b3 e3) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type4_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$. Let $_H_mk_DPair$ be a function from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$. Let $x_640$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$. Then $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_640$.",
    "output": "postulate DPair_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type4 (Q_ x_640)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp0. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_634$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_None$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_635$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_635$, pour tous les éléments $x_634$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_634$.",
    "output": "postulate option_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_634 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_635 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_635))) -> (x_634 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_634)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type4. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1110$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type4$. Alors pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1111$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.",
    "output": "postulate DPair_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Invert_permut_f. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ and $m$.",
    "output": "postulate invert_permut_f : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.invert_permut n f (f m)) m)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_log_O. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_log.log$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.O$.",
    "output": "postulate lt_to_log_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_Type3. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1248$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H1$ be a function from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1249$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$. Then $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1248 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1249 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Coerc_pair_sigma. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $p$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.snd$ applicerat på $A$ och $B$ och $p$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $matita_basics_types.Sig$ applicerat på $B$ och funktionen som avbildar $x$ som $P$ applicerat på $x$.",
    "output": "postulate coerc_pair_sigma : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (P (matita_basics_types.snd A B p))) -> cic.Term univs.Type0 (matita_basics_types.Prod A (matita_basics_types.Sig B (\\ x : cic.Term univs.Type0 B -> P x)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type0. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$. Let $_H_mk_range$ be a function from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$. Then for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "Axiom range_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type0 (Q_ x_927) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Op_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $nil$, pour tous les éléments $_x_807$ et $_x_808$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "Axiom op_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall _xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall _x_807 : cic.Term univs.Type0 A, forall _x_808 : cic.Term univs.Type0 A, cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp4_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "eq_rect_CProp4_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_22 : cic.Term univs.Type2 A -> _x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_22 : cic.Term univs.Type2 A -> x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Term cic.prop (Q_ x_22 x_23) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp4_body. Låt $Q_$ vara en funktion från element $_x_73$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x_73$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_73$.",
    "output": "Axiom False_rect_CProp4_body : forall Q_ : ((_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_73 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_73) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type5. För alla funktioner $Q_$ från element $_x_44$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type5$, för alla element $_H_I$ av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_44$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_44$.",
    "output": "postulate True_rect_Type5 : (Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type5) -> (_H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I)) -> (x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type5 (Q_ x_44)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_unit. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $return_sort$. Låt $case_it$ vara ett element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_types.it$. Låt $z$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$. Då håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "postulate match_unit : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort) -> (case_it : cic.Term return_sort (return_type matita_basics_types.it)) -> (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_transpose. Låt $i$ och $j$ och $k$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $j$ och $i$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $i$ och $k$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $j$ och $k$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $j$ och $n$ och $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $k$ och $matita_arithmetics_permutation.transpose$ applicerat på $k$ och $j$ och $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $k$ och $n$.",
    "output": "Axiom eq_transpose : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall k : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i)), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k)), forall __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n)))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inj_mk_Sig. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $x$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $P$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $A$ et $P$ et $x$ et $matita_basics_types.mk_Sig$ appliqué à $A$ et $P$ et $matita_basics_types.pi1$ appliqué à $A$ et $P$ et $x$ et $matita_basics_types.pi2$ appliqué à $A$ et $P$ et $x$.",
    "output": "Axiom inj_mk_Sig : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall x : cic.Term univs.Type0 (matita_basics_types.Sig A P), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig A P)) x (matita_basics_types.mk_Sig A P (matita_basics_types.pi1 A P x) (matita_basics_types.pi2 A P x))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp4_body. Soit $Q_$ une fonction des éléments $_x_347$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_true$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.true$. Alors pour tous les éléments $_H_false$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_347$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_347$.",
    "output": "axiom bool_rect_CProp4_body (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_347)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type0_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_901$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_901$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_901$.",
    "output": "ACop_rect_Type0_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type0) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type0 (Q_ x_901) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_rect_CProp0. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1032$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $x_582$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1033$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_582$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_582$. Låt $_H2$ vara en funktion från element $x_583$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1033$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_583$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_583$. Då håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom Sum_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1032 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_582 : cic.Term univs.Type0 x1) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_582))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_582))), forall _H2 : ((x_583 : cic.Term univs.Type0 x2) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_583))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_883$.",
    "output": "Aop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_883) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_mop. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Alors pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $B$ et $nil$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $a$ et $_x_969$ et $_x_970$ de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $univs.Type0$ et $B$.",
    "output": "axiom let_mop (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (a _x_969 _x_970 : cic.Term univs.Type0 B) : cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_n_fact_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "axiom lt_n_fact_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_times_mod. Soient $n$ et $m$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $p$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $p$ et $p$.",
    "output": "postulate mod_times_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1075. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $bijf$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$. Let $fS$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$. Let $i$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lein$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$. Then for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $Hc$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $a$.",
    "output": "let_clause_1075 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> bijf : cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n)) -> fS : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n)) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lein : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> lean : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n)) -> fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i) -> Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.S n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i a) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_BPsi1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "axiom le_Psi_BPsi1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type0. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_955$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_955$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_955$.",
    "output": "axiom Dop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type0 (Q_ x_955)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Refute_none_by_refl. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $E$ to $matita_basics_logic.match_False$ applied to $univs.Type0$ and the function that maps $_0$ to $B$ and $H$ applied to $E$ and the function that maps $v$ and $_0$ to $P$ applied to $v$ and $x$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$.",
    "output": "postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\\ y : cic.Term univs.Type0 (matita_basics_types.option A) -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B)) (\\ E : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> matita_basics_logic.match_False univs.Type0 (\\ _0 : cic.Term cic.prop matita_basics_logic.False -> B) (H E)) (\\ v : cic.Term univs.Type0 A -> \\ _0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v)) -> P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp3. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_622$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_None$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_623$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_623$, för alla element $x_622$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_622$.",
    "output": "option_rect_CProp3 : _A : cic.Univ univs.Type0 -> Q_ : (_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_623 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))) -> x_622 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_622) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp0. Låt $Q_$ vara en funktion från element $_x_64$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_I$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_64$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_64$.",
    "output": "axiom True_rect_CProp0 (Q_ : (_x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_64 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_64)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_pi. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $p$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $matita_arithmetics_exp.exp$ appliqué à $f$ appliqué à $i$ et $m$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $m$.",
    "output": "Axiom exp_pi : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp (f i) m)) (matita_arithmetics_exp.exp (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => f i)) m)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_CProp1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1158$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $x2$ applicerat på $dpi1$ och element $_z1159$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "postulate DPair_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1158 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1159 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_Type4. Pour tous les éléments $x1$ et $x2$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1242$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H1$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1243$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$, $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.",
    "output": "Prod_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type4) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_17041. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_17041 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lt1n$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Let $x2515$ and $x2516$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1034. Soient $n$ et $m$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soient $x2515$ et $x2516$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$.",
    "output": "let_clause_1034 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_CProp1. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$. Låt $P$ vara en funktion från element $_z960$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $_z961$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.unit$ och $Hterm$ och $matita_basics_types.it$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.it$. Då håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom unit_inv_rect_CProp1 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.plus$ applied to $n2$ and $m2$.",
    "output": "axiom le_plus (n1 n2 m1 m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_aop. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$.",
    "output": "axiom let_aop (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (a : cic.Term univs.Type0 B) : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1644$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1645$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "Axiom range_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term univs.Type3 (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_CProp2. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1680$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ et des éléments $_z1681$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.range$ appliqué à $x1$ et $Hterm$ et $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "Axiom range_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1680 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1681 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_option. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_None$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $case_Some$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.Some$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_option : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) -> (case_None : cic.Term return_sort (return_type (matita_basics_types.None _A))) -> (case_Some : (__ : cic.Term univs.Type0 _A) -> cic.Term return_sort (return_type (matita_basics_types.Some _A __))) -> (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_ind. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_716$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_nil$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$. Soit $_H_cons$ une fonction des éléments $x_718$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_717$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_720$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_717$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_718$ et $x_717$. Alors pour tous les éléments $x_716$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_716$.",
    "output": "list_ind : _A : cic.Univ univs.Type0 -> Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_718 : cic.Term univs.Type0 _A -> x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_720 : cic.Term cic.prop (Q_ x_717) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_716) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reflexive. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$. Then $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom reflexive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_forall_lt. För alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.true$ och $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och funktionen som avbildar $__$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.false$.",
    "output": "axiom exists_forall_lt (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (λ i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (λ __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.",
    "output": "axiom log_exp (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp4. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Prod$ be a function from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$. Then for all elements $x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_704$.",
    "output": "axiom Prod_rect_CProp4 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_704)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_Type4. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1242$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type4$. Då för alla funktioner $_H1$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1243$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom Prod_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_gcd_SO_to_not_divides. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$.",
    "output": "eq_gcd_SO_to_not_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_exp. Let $p$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $m$ and $p$ and $m$.",
    "output": "Axiom ord_exp : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_exp.exp p m) p) m) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iter. Soit $H$ un élément de $cic.Univ$ de $univs.Type0$. Soit $__$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $H$ à des éléments de $cic.Term$ de $univs.Type0$ et de $H$. Soit $__1$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $H$, $cic.Term$ tient pour $univs.Type0$ et $H$.",
    "output": "axiom iter (H : cic.Univ univs.Type0) (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term univs.Type0 H) : cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fold_filter. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $_a$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $op$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $p$ applied to $i$ and the function that maps $i$ to $f$ applied to $i$ and $l$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$.",
    "output": "fold_filter : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _a : cic.Term univs.Type0 A -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> nil : cic.Term univs.Type0 B -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => p i) (i : cic.Term univs.Type0 A => f i) l) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) (matita_basics_lists_list.filter A p l))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type3_body. Soit $_A$ un élément de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_88$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type3$. Soit $_H_nmk$ une fonction des fonctions $x_89$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_89$. Soit $x_88$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$. Alors $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_88$.",
    "output": "Axiom Not_rect_Type3_body : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3), forall _H_nmk : ((x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))), forall x_88 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type3 (Q_ x_88) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod. Låt $s1$ och $s2$ vara element av $Sort$. Låt $a$ vara ett element av $Univ$ av $s1$. Låt $b$ vara en funktion från element av $Term$ av $s1$ och $a$ till element av $Univ$ av $s2$. Då håller $Univ$ för $rule$ applicerat på $s1$ och $s2$.",
    "output": "axiom prod (s1 s2 : Sort) (a : Univ s1) (b : Term s1 a -> Univ s2) : Univ (rule s1 s2)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp1. För alla element $p$ och $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_exp.exp$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_log.log$ applicerat på $p$ och $n$.",
    "output": "log_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)) (matita_arithmetics_nat.times m (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_CProp1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1752$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $x1$ och $x2$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ och element $_z1753$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Dop$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ och $_null$ och $_distr$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ och $_null$ och $_distr$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Dop_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1752 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1753 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1572. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Let $H$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$. Then for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_1572 (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Invert_permut_f. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.injn$ applicerat på $f$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_permutation.invert_permut$ applicerat på $n$ och $f$ och $f$ applicerat på $m$ och $m$.",
    "output": "postulate invert_permut_f : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.invert_permut n f (f m)) m)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_trans. Soient $A$ et $B$ et $C$ des éléments de $cic.Univ$ de $cic.prop$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.iff$ appliqué à $A$ et $B$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.iff$ appliqué à $B$ et $C$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.iff$ appliqué à $A$ et $C$.",
    "output": "axiom iff_trans (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) : cic.Term cic.prop (matita_basics_logic.iff A C)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_ind. For all functions $Q_$ from elements $_x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_326$.",
    "output": "axiom bool_ind (Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_326 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_326)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1034. Let $n$ and $m$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$.",
    "output": "Axiom let_clause_1034 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1075. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $bijf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $fS$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lein$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $Hc$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $a$.",
    "output": "axiom let_clause_1075 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (bijf : cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))) (fS : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) (lean : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n))) (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.S n))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i a)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp4. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1602$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $b$ et $a$ et des éléments $_z1603$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "Axiom ACop_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1602 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1603 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type3. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_10$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_11$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_10$ till element av $cic.Univ$ av $univs.Type3$. Låt $_H_refl$ vara ett element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Då för alla element $x_10$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_11$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_10$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_10$ och $x_11$.",
    "output": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_False. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "postulate filter_False : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__op. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Let $x1$ be an element of $cic.Term$ of $univs.Type0$ and $x0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Let $x3$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$. Then for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp0. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1428$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ et des éléments $_z1429$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_lists_list.mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "Axiom Aop_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2), forall P : ((_z1428 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1429 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $ltn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $H$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $H1$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $m$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $x2515$ och $x2516$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2515$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x2516$ och $matita_arithmetics_div_and_mod.div$ applicerat på $x2515$ och $x2516$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $x2515$ och $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> (H : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> (H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_CProp2. Pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, pour toutes les fonctions $P$ des éléments $_z954$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z955$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "postulate unit_inv_rect_CProp2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z954 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z955 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Or. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$. Let $return$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$. Let $z$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$. Then $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_Or : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.Or _A _B), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_inv_append. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $l1$ and $l2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l1$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l2$.",
    "output": "postulate All_inv_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_lists_list.All A P l1) (matita_basics_lists_list.All A P l2))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_905$.",
    "output": "ACop_rect_CProp5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_905) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_CProp0. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1098$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1099$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_635$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1099$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_635$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_635$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "option_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1098 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ cic.prop) -> _H1 : (_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> _H2 : (x_635 : cic.Term univs.Type0 x1 -> _z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_635)) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_635))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Null_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $xxx$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $nil$. Låt $a$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.prod$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $nil$ och $nil$.",
    "output": "postulate null_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "To_max. Låt $i$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $i$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $i$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.max$ applicerat på $n$ och $m$ och $i$.",
    "output": "Axiom to_max : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m i), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp2. Soit $Q_$ une fonction des éléments $_x_515$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_it$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.it$. Alors pour tous les éléments $x_515$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_515$.",
    "output": "axiom unit_rect_CProp2 (Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_515 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_515)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lop_Sfalse. Soient $m$ et $i$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $acc$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.list_divides$ appliqué à $acc$ et $i$ et $matita_basics_bool.false$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_bertrand256.lprim$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $i$ et $acc$ et $matita_arithmetics_chebyshev_bertrand256.lprim$ appliqué à $m$ et $matita_arithmetics_nat.S$ appliqué à $i$ et $matita_basics_lists_list.append$ appliqué à $matita_arithmetics_nat.nat$ et $acc$ et $matita_basics_lists_list.cons$ appliqué à $matita_arithmetics_nat.nat$ et $i$ et $matita_basics_lists_list.nil$ appliqué à $matita_arithmetics_nat.nat$.",
    "output": "Axiom lop_Sfalse : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S m) i acc) (matita_arithmetics_chebyshev_bertrand256.lprim m (matita_arithmetics_nat.S i) (matita_basics_lists_list.append matita_arithmetics_nat.nat acc (matita_basics_lists_list.cons matita_arithmetics_nat.nat i (matita_basics_lists_list.nil matita_arithmetics_nat.nat))))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_n_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $n$ et $n$.",
    "output": "axiom gcd_n_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n n) n)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type0. Soit $Q_$ une fonction des éléments $_x_507$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_H_it$ un élément de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.it$. Soit $x_507$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$. Alors $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_507$.",
    "output": "Axiom unit_rect_Type0 : forall Q_ : ((_x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0), forall _H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it), forall x_507 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term univs.Type0 (Q_ x_507) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1110$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H1$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $x2$ applicerat på $dpi1$ och element $_z1111$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.",
    "output": "postulate DPair_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__op. Låt $x0$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x1$ vara ett element av $cic.Term$ av $univs.Type0$ och $x0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$. Låt $x3$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $matita_basics_lists_list.Aop$ applicerat på $x0$ och $x1$ och $x2$. Låt $_x_807$ och $_x_808$ vara element av $cic.Term$ av $univs.Type0$ och $x0$. Då håller $cic.Term$ för $univs.Type0$ och $x0$.",
    "output": "dpi1__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1) -> cic.Univ univs.Type0) -> x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2) -> _x_807 : cic.Term univs.Type0 x0 -> _x_808 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15625. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Då för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $m$ och $d$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $c$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.",
    "output": "let_clause_15625 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15691. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $pnm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $d$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $n$ et $c$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $d$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_15691 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type5. Soit $Q_$ une fonction des éléments $_x_499$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type5$. Soit $_H_it$ un élément de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.it$. Alors pour tous les éléments $x_499$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_499$.",
    "output": "unit_rect_Type5 : Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type5) -> _H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it) -> x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type5 (Q_ x_499) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp5. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_103$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_nmk$ vara en funktion från funktioner $x_104$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_104$. Då för alla element $x_103$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_103$.",
    "output": "axiom Not_rect_CProp5 (_A : cic.Univ cic.prop) (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term cic.prop (Q_ x_103)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_mod. Låt $p$ och $a$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $p$ och $a$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på funktionen som avbildar $n$ som $matita_arithmetics_div_and_mod.mod$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $n$ och $p$ och $matita_arithmetics_nat.pred$ applicerat på $p$.",
    "output": "axiom permut_mod (p a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a))) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp4_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_795$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_795$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_795$.",
    "output": "Axiom Aop_rect_CProp4_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_795) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inj_mk_Sig. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $P$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sig$ applicerat på $A$ och $P$ och $x$ och $matita_basics_types.mk_Sig$ applicerat på $A$ och $P$ och $matita_basics_types.pi1$ applicerat på $A$ och $P$ och $x$ och $matita_basics_types.pi2$ applicerat på $A$ och $P$ och $x$.",
    "output": "inj_mk_Sig : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> x : cic.Term univs.Type0 (matita_basics_types.Sig A P) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig A P)) x (matita_basics_types.mk_Sig A P (matita_basics_types.pi1 A P x) (matita_basics_types.pi2 A P x))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_sigma_l. Let $n$ and $a$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $a$ and $f$ applied to $i$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "axiom exp_sigma_l (n a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_exp.exp a (f i))) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => f i))))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15311. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$. Soient $d$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $eqm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $p$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $p$.",
    "output": "Axiom let_clause_15311 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p))) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15491. Pour tous les éléments $m$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $eqn0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $x1106$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x1106$ et $matita_arithmetics_nat.minus$ appliqué à $x1106$ et $n$.",
    "output": "postulate let_clause_15491 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x1106 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1106 (matita_arithmetics_nat.minus x1106 n))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp1. För alla funktioner $Q_$ från element $_x_359$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_359$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_359$.",
    "output": "axiom bool_rect_CProp1 (Q_ : (_x_359 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_359 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_359)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp3. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $_x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $Q_$ une fonction des éléments $x_28$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_29$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_28$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_refl$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$, pour tous les éléments $x_28$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $x_29$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_28$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_28$ et $x_29$.",
    "output": "postulate eq_rect_CProp3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Not. Pour tous les éléments $_A$ de $cic.Univ$ de $cic.prop$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "Axiom filter_Not : forall _A : cic.Univ cic.prop, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_comp_l. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $R$ och $R1$ och $R2$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_relations.subR$ applicerat på $A$ och $R1$ och $R2$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.subR$ applicerat på $A$ och $matita_basics_relations.Rcomp$ applicerat på $A$ och $R1$ och $R$ och $matita_basics_relations.Rcomp$ applicerat på $A$ och $R2$ och $R$.",
    "output": "sub_comp_l : A : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 R) (matita_basics_relations.Rcomp A R2 R)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pad_bigop1. För alla element $k$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $p$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $k$, för alla funktioner $__1$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $i$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $k$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p$ applicerat på $i$ och $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.",
    "output": "axiom pad_bigop1 (k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ i => p i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil op (λ i => f i)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_plus_m_m. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $m$ and $m$.",
    "output": "minus_plus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n m) m)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type2_body. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_91$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$. Låt $_H_nmk$ vara en funktion från funktioner $x_92$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_92$. Låt $x_91$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$. Då håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_91$.",
    "output": "axiom Not_rect_Type2_body (_A : cic.Univ cic.prop) (Q_ : (_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type2) (_H_nmk : (x_92 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))) (x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type2 (Q_ x_91)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, håller $cic.Univ$ för $cic.prop$.",
    "output": "postulate Exists_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_max_true. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $matita_arithmetics_minimization.max$ applicerat på $n$ och $f$ och $matita_basics_bool.true$.",
    "output": "postulate f_max_true : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.max n f)) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1068. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $permf$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lein$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$. Let $lejn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all elements $lebn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $n$, for all elements $fb$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all functions $__$ from elements $i0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i0$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $i0$ and $n$, for all elements $injf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$.",
    "output": "Axiom let_clause_1068 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lein : cic.Term cic.prop (matita_arithmetics_nat.le i n), forall lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)), forall lean : cic.Term cic.prop (matita_arithmetics_nat.le a n), forall fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i), forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)), forall lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n), forall fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j), forall __ : ((i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)), forall injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n), forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_ord_rem. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Then for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord_rem$ applied to $m$ and $n$ and $m$.",
    "output": "Axiom lt_ord_rem : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord_rem m n) m) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp0. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_913$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_ACop$ une fonction des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$. Soit $x_913$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_913$.",
    "output": "postulate ACop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_913)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "Axiom dpi1 : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall _xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f), cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F3_ind. Soient $A1$ et $A2$ et $A3$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $A3$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $P$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation3$ appliqué à $A1$ et $A2$ et $A3$. Soit $__$ une fonction des éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $__$ des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $a3$ de $cic.Term$ de $univs.Type0$ et de $A3$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $f$ appliqué à $a1$ et $a2$ et $a3$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et $a3$ et des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $a3$ de $cic.Term$ de $univs.Type0$ et de $A3$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a1$ et $a2$ et $a3$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et $a3$. Alors pour tous les éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$, pour tous les éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$, pour tous les éléments $a3$ de $cic.Term$ de $univs.Type0$ et de $A3$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $a1$ et $a2$ et $a3$.",
    "output": "axiom f3_ind (A1 A2 A3 : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> (__2 : cic.Term univs.Type0 A3) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : cic.Term univs.Type0 (matita_basics_relations.relation3 A1 A2 A3)) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)) (a1 : cic.Term univs.Type0 A1) (a2 : cic.Term univs.Type0 A2) (a3 : cic.Term univs.Type0 A3) : cic.Term cic.prop (P a1 a2 a3)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_list. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$. Låt $case_nil$ vara ett element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$. Låt $case_cons$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $__$ och $__1$. Låt $z$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$. Då håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "postulate match_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (case_nil : cic.Term return_sort (return_type (matita_basics_lists_list.nil _A))) -> (case_cons : (__ : cic.Term univs.Type0 _A) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type (matita_basics_lists_list.cons _A __ __1))) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_Strue. Låt $k$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $op$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$. Då för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p$ applicerat på $k$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.S$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $op$ applicerat på $f$ applicerat på $k$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.",
    "output": "axiom bigop_Strue (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (λ i => p i) B nil op (λ i => f i)) (op (f k) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil op (λ i => f i))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_r_aux. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $b1$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "lstar_ind_r_aux : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> __2 : cic.Term cic.prop (R b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1) -> cic.Term cic.prop (P l b2) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type5_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.",
    "output": "Axiom div_mod_spec_rect_Type5_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5), forall _H_div_mod_spec_intro : ((x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))), forall x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type5 (Q_ x_817) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $_xxx$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.",
    "output": "postulate aop_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_945$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_945$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_945$.",
    "output": "postulate Dop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type4 (Q_ x_945)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1078. Let $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$. Let $ltrb$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $b$. Let $spec$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $b$ and $r$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$. Let $ltr1b$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r1$ and $b$. Let $spec1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q1$ and $b$ and $r1$. Then for all elements $leqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $q1$, for all elements $ltqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $q1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $r$ and $matita_arithmetics_nat.times$ applied to $b$ and $q$.",
    "output": "postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q)))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_eq. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $l$ et $matita_basics_lists_list.append$ appliqué à $A$ et $matita_basics_types.fst$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.split$ appliqué à $A$ et $l$ et $n$ et $matita_basics_types.snd$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.split$ appliqué à $A$ et $l$ et $n$.",
    "output": "Axiom split_eq : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1545. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $n$. Let $q1$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q1$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$. Let $q2$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q2$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_1545 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n) -> q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1)) -> _clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m) -> q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unique_filter. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$.",
    "output": "axiom unique_filter (S : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_lists_list.unique S l)) : cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_m2. Pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $n$ et $i$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.",
    "output": "Axiom let_m2 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp3. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_nil$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $_H_cons$ des éléments $x_763$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_762$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_765$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_762$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_763$ et $x_762$, pour tous les éléments $x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_761$.",
    "output": "postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive2. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Alors pour toutes les fonctions $_g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Univ$ tient pour $cic.prop$.",
    "output": "axiom distributive2 (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (_g : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_And. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "axiom filter_And (_A _B : cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $len$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $p$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $lep$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_sqrt.sqrt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $p$, för alla element $ltp$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $Hc$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.leb$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_chebyshev_bertrand.k$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $p$ och $matita_basics_bool.true$, för alla element $H2n$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_exp.exp$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $x2515$ och $x2516$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2515$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x2516$ och $matita_arithmetics_div_and_mod.div$ applicerat på $x2515$ och $x2516$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $x2515$ och $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) -> (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) matita_basics_bool.true)) -> (H2n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_O_S. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $n$.",
    "output": "Axiom not_eq_O_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.S n))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_SO_smallest_factor. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_primes.smallest_factor$ appliqué à $n$.",
    "output": "axiom lt_SO_smallest_factor (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_CProp1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1092$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1093$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_631$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1093$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_631$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_631$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "axiom option_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) (P : (_z1092 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) (_H1 : (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) (_H2 : (x_631 : cic.Term univs.Type0 x1) -> (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_631))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_631))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_RC_reflexive. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.bi_relation$ appliqué à $A$ et $B$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.bi_reflexive$ appliqué à $A$ et $B$ et $matita_basics_relations.bi_RC$ appliqué à $A$ et $B$ et $R$.",
    "output": "postulate bi_RC_reflexive : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) -> cic.Term cic.prop (matita_basics_relations.bi_reflexive A B (matita_basics_relations.bi_RC A B R))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp1. För alla element $n$ och $m$ och $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $a$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $n$ och $a$ och $matita_arithmetics_exp.exp$ applicerat på $m$ och $a$.",
    "output": "le_exp1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n a) (matita_arithmetics_exp.exp m a)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp3. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_28$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_29$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_28$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_refl$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Låt $x_28$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $x_29$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_28$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_28$ och $x_29$.",
    "output": "axiom eq_rect_CProp3 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_28 : cic.Term univs.Type2 A) (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) : cic.Term cic.prop (Q_ x_28 x_29)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive2. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $_g$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then $cic.Univ$ holds for $cic.prop$.",
    "output": "distributive2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _g : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_ind. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $cic.prop$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z323$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_120$ av $cic.Term$ av $cic.prop$ och $x1$ och element $x_119$ av $cic.Term$ av $cic.prop$ och $x2$ och element $_z324$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_120$ och $x_119$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_120$ och $x_119$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "And_inv_ind : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z323 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_120 : cic.Term cic.prop x1 -> x_119 : cic.Term cic.prop x2 -> _z324 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_120 x_119)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_120 x_119))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_rem_eq. För alla element $n$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.ord_rem$ applicerat på $n$ och $p$ och $matita_basics_types.snd$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord$ applicerat på $n$ och $p$.",
    "output": "postulate ord_rem_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord_rem n p) (matita_basics_types.snd matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord n p)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_diff. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $op$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $B$ och $nil$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $i$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p$ applicerat på $i$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $x$ som $p$ applicerat på $x$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $x$ som $f$ applicerat på $x$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $x$ som $matita_basics_bool.andb$ applicerat på $matita_basics_bool.notb$ applicerat på $matita_arithmetics_nat.eqb$ applicerat på $i$ och $x$ och $p$ applicerat på $x$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $x$ som $f$ applicerat på $x$.",
    "output": "axiom bigop_diff (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (i n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ x => p x) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ x => f x)) (matita_arithmetics_bigops.aop__o__op B nil op (f i) (matita_arithmetics_bigops.bigop n (λ x => matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.eqb i x)) (p x)) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ x => f x))))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_fact. Soient $n$ et $i$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $i$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $i$ et $matita_arithmetics_factorial.fact$ appliqué à $n$.",
    "output": "Axiom divides_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le i n), cic.Term cic.prop (matita_arithmetics_primes.divides i (matita_arithmetics_factorial.fact n)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Binomial_law. Let $a$ and $b$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $k$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $k$ to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.bc$ applied to $n$ and $k$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $n$ and $k$ and $matita_arithmetics_exp.exp$ applied to $b$ and $k$.",
    "output": "Axiom binomial_law : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.plus a b) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun k => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun k => matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k))) (matita_arithmetics_exp.exp b k)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Q_$ vara en funktion från element $_x_845$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_div_mod_spec_intro$ vara en funktion från element $x_847$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_846$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_847$ och $x_846$. Låt $x_845$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_845$.",
    "output": "postulate div_mod_spec_rect_CProp3 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_times. Låt $n$ och $m$ och $n1$ och $m1$ och $p$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $p$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_congruence.congruent$ applicerat på $n$ och $n1$ och $p$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_congruence.congruent$ applicerat på $m$ och $m1$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_congruence.congruent$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $n1$ och $m1$ och $p$.",
    "output": "congruent_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n n1 p) -> __2 : cic.Term cic.prop (matita_arithmetics_congruence.congruent m m1 p) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times n1 m1) p) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_Type0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1596$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H1$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1597$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom ACop_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1596 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type0), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1597 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_787$.",
    "output": "Aop_rect_Type3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type3) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type3 (Q_ x_787) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z635$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom bool_inv_rect_CProp2 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z635 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H1 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) (_H2 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_ind_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_664$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_664$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_664$.",
    "output": "Sig_ind_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_664) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_mid. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $l1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $x$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $l2$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x$, håller $cic.Term$ för $cic.prop$ och $matita_basics_lists_list.Exists$ applicerat på $A$ och $P$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $matita_basics_lists_list.cons$ applicerat på $A$ och $x$ och $l2$.",
    "output": "axiom Exists_mid (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (x : cic.Term univs.Type0 A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (P x)) : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2)))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi1. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $f$, $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "pi1 : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f) -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_n_mod_times. Låt $n$ och $m$ och $p$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_congruence.congruent$ applicerat på $n$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $p$ och $p$.",
    "output": "Axiom congruent_n_mod_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp2. För alla element $x1$ och $x2$ av $cic.Univ$ av $cic.prop$, för alla element $Hterm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z371$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_160$ av $cic.Term$ av $cic.prop$ och $x1$ och element $x_159$ av $cic.Term$ av $cic.prop$ och $x2$ och element $_z372$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_160$ och $x_159$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_160$ och $x_159$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "axiom And_inv_rect_CProp2 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_body. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$. Soit $Q_$ une fonction des éléments $x_1233$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1232$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $x_1231$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $_x_1234$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $_R$ et $x_1233$ et $x_1232$ et $x_1231$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_lstar_O$ des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$ et $b$ et $b$ et $matita_arithmetics_lstar.lstar_O$ appliqué à $B$ et $_R$ et $b$, pour toutes les fonctions $_H_lstar_S$ des éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $x_1236$ de $cic.Term$ de $cic.prop$ et de $_R$ appliqué à $b1$ et $b$ et des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $x_1235$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $_R$ et $l$ et $b$ et $b2$ et des éléments $_x_1238$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $l$ et $b$ et $b2$ et $x_1235$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$ et $b2$ et $matita_arithmetics_lstar.lstar_S$ appliqué à $B$ et $_R$ et $b1$ et $b$ et $x_1236$ et $l$ et $b2$ et $x_1235$, pour tous les éléments $x_1233$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $x_1232$ et $x_1231$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $x_1234$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $_R$ et $x_1233$ et $x_1232$ et $x_1231$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_1233$ et $x_1232$ et $x_1231$ et $x_1234$.",
    "output": "Axiom lstar_ind_body : forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall Q_ : ((x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231)) -> cic.Univ cic.prop), forall _H_lstar_O : ((b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))), forall _H_lstar_S : ((b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1236 : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> (_x_1238 : cic.Term cic.prop (Q_ l b b2 x_1235)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b x_1236 l b2 x_1235))), forall x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_1232 : cic.Term univs.Type0 B, forall x_1231 : cic.Term univs.Type0 B, forall x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231), cic.Term cic.prop (Q_ x_1233 x_1232 x_1231 x_1234) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $cic.prop$. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$. Let $P$ be a function from elements $_z311$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$. Let $_H1$ be a function from functions $x_113$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z312$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_113$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_113$. Then $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Not_inv_rect_CProp1 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) (_H1 : (x_113 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z312 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_113))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1698$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1699$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Dop_inv_ind (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_le_minus_l. För alla element $p$ och $q$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $q$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $q$ och $n$ och $matita_arithmetics_nat.minus$ applicerat på $p$ och $n$.",
    "output": "Axiom monotonic_le_minus_l : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le q p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp1_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_660$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_DPair$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$, för alla element $x_660$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_660$.",
    "output": "Axiom DPair_rect_CProp1_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_660) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_exp_pred_SO. För alla element $p$ och $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $p$ och $a$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_congruence.congruent$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $a$ och $matita_arithmetics_nat.pred$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$.",
    "output": "congruent_exp_pred_SO : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_exp.exp a (matita_arithmetics_nat.pred p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_to_decidable_eq. Pour tous les éléments $b1$ et $b2$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.decidable$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $b1$ et $b2$.",
    "output": "Axiom bool_to_decidable_eq : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length_map. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $B$ et $matita_basics_lists_list.map$ appliqué à $A$ et $B$ et $f$ et $l$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$.",
    "output": "Axiom length_map : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_S_S_to_not_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "Axiom not_le_S_S_to_not_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom Dop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_0. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $matita_arithmetics_nat.S$ applied to $i$ and $f$ applied to $matita_arithmetics_nat.O$.",
    "output": "bigop_0 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f (matita_arithmetics_nat.S i))) (f matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Univ. Let $s$ be an element of $Sort$. Then $Univ$ holds for $succ$ applied to $s$.",
    "output": "axiom univ (s : Sort) : Univ (succ s)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type2. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1122$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1123$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $Hterm$.",
    "output": "Axiom DPair_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1122 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1123 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_ind. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_586$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_None$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Alors pour toutes les fonctions $_H_Some$ des éléments $x_587$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_587$, pour tous les éléments $x_586$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_586$.",
    "output": "Axiom option_ind : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))), forall x_586 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_586) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type3. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_nmk$ be a function from functions $x_89$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_89$. Then for all elements $x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_88$.",
    "output": "Not_rect_Type3 : _A : cic.Univ cic.prop -> Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type3) -> _H_nmk : (x_89 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) -> x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type3 (Q_ x_88) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_congruent. Låt $n$ och $m$ och $p$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $n$. Låt $__2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_congruence.congruent$ applicerat på $n$ och $m$ och $p$.",
    "output": "postulate divides_to_congruent : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m))) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_body. För alla element $__$ och $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.",
    "output": "times_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_mem_nat. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.decidable$ appliqué à $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $n$ et $l$.",
    "output": "postulate decidable_mem_nat : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_n_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_nat.eqb$ appliqué à $n$ et $n$ et $matita_basics_bool.true$.",
    "output": "axiom eqb_n_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n n) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_Type0. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $P$ be a function from elements $_z683$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$. Let $_H1$ be a function from elements $_z684$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_nat.O$. Let $_H2$ be a function from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_392$ from elements $_z684$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $x_390$ and elements $_z684$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_390$. Then $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "nat_inv_rect_Type0 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) -> _H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390) -> cic.Term univs.Type0 (P x_390)) -> _z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390)) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leq_sqrt_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_sqrt.sqrt$ appliqué à $n$ et $matita_arithmetics_sqrt.sqrt$ appliqué à $n$ et $n$.",
    "output": "postulate leq_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_inv_lstar. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $R$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$.",
    "output": "postulate lstar_r_inv_lstar : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_CProp3. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$. Låt $P$ vara en funktion från element $_z167$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H1$ från element $_z168$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.True$ och $Hterm$ och $matita_basics_logic.I$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.I$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "True_inv_rect_CProp3 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z167 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fst. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $A$ et $B$, $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "postulate fst : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_ind_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Q_$ vara en funktion från element $_x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_div_mod_spec_intro$ vara en funktion från element $x_811$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_810$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_811$ och $x_810$. Då för alla element $x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_809$.",
    "output": "div_mod_spec_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_809) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp5. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_931$.",
    "output": "axiom range_rect_CProp5 (_A : cic.Univ univs.Type0) (Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_931)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_I_gen. Soient $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Alors pour tous les éléments $op$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $B$ et $nil$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $a$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $b$ et $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $p$ appliqué à $i0$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $a$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $a$ et $matita_arithmetics_bigops.bigop$ appliqué à $b$ et la fonction qui envoie $i$ à $matita_basics_bool.andb$ appliqué à $matita_arithmetics_nat.leb$ appliqué à $a$ et $i$ et $p$ appliqué à $i$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.",
    "output": "axiom bigop_I_gen (a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (λ i => (λ i0 => p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (λ i => matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f i)))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $len$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $p$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $lep$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_sqrt.sqrt$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $p$, pour tous les éléments $ltp$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $Hc$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_nat.leb$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_chebyshev_bertrand.k$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $p$ et $matita_basics_bool.true$, pour tous les éléments $H2n$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) -> (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) matita_basics_bool.true)) -> (H2n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Flatten_to_mem. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $l1$ et $l2$ et $a$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour toutes les fonctions $__1$ des éléments $x$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$ et $x$ et $l$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $A$ et $x$ et $n$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $A$ et $a$ et $n$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.flatten$ appliqué à $A$ et $l$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $matita_basics_lists_list.append$ appliqué à $A$ et $a$ et $l2$, pour tous les éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $q$ à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l1$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $q$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.mem$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$ et $a$ et $l$.",
    "output": "Axiom flatten_to_mem : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A)), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall a : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : ((x : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) x l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A x) n)), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A a) n), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.flatten A l) (matita_basics_lists_list.append A l1 (matita_basics_lists_list.append A a l2))), forall __4 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun q => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_arithmetics_nat.times n q))), cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) a l) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$. Then for all functions $P$ from elements $_z1224$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1225$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Sig_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_l_aux. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $R$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $P$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation2$ appliqué à $matita_arithmetics_nat.nat$ et $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.O$ et $b2$, pour toutes les fonctions $__1$ des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b1$ et $b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b$ et $b2$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $l$ et $b$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $b1$ et $b$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $b$ et $b2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $l$ et $b1$.",
    "output": "lstar_ind_l_aux : B : cic.Univ univs.Type0 -> R : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> b2 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b2) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (R b1 b) -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b2) -> cic.Term cic.prop (P l b1) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_939$.",
    "output": "range_rect_CProp0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_939) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_S. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, for all elements $l0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $l0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $B$ and the function that maps $b$ to $R$ applied to $b1$ and $b$ and the function that maps $b$ to $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l0$ and $b$ and $b2$.",
    "output": "lstar_inv_S : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> l0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S matita_arithmetics_nat.O)) l) -> cic.Term cic.prop (matita_basics_logic.ex2 B (b : cic.Term univs.Type0 B => R b1 b) (b : cic.Term univs.Type0 B => matita_arithmetics_lstar.lstar B R l0 b b2)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_37$ and $x_38$.",
    "output": "axiom eq_rect_CProp0_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_37 : cic.Term univs.Type2 A) (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) : cic.Term cic.prop (Q_ x_37 x_38)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_a. Soient $a$ et $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n$ et $matita_arithmetics_nat.plus$ appliqué à $a$ et $m$.",
    "output": "axiom le_plus_a (a n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus a m))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp3_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_907$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$. Då för alla element $x_907$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_907$.",
    "output": "axiom ACop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_907)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_priml. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_priml : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Or_ind. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H_or_introl$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_introl$ applied to $_A$ and $_B$ and $x_171$, for all functions $_H_or_intror$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_intror$ applied to $_A$ and $_B$ and $x_172$, for all elements $x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_170$.",
    "output": "Axiom Or_ind : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop), forall _H_or_introl : ((x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))), forall _H_or_intror : ((x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))), forall x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B), cic.Term cic.prop (Q_ x_170) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R3. Soit $T0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $a0$ un élément de $cic.Term$ de $univs.Type0$ et de $T0$. Soit $T1$ une fonction des éléments $x0$ de $cic.Term$ de $univs.Type0$ et de $T0$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $x0$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $a1$ un élément de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$. Soit $T2$ une fonction des éléments $x0$ de $cic.Term$ de $univs.Type0$ et de $T0$ et des éléments $p0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $x0$ et des éléments $x1$ de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $x0$ et $p0$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $x0$ et $p0$ et $matita_basics_logic.R1$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $T1$ et $a1$ et $x0$ et $p0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $a2$ un élément de $cic.Term$ de $univs.Type0$ et de $T2$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$. Soit $T3$ une fonction des éléments $x0$ de $cic.Term$ de $univs.Type0$ et de $T0$ et des éléments $p0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $x0$ et des éléments $x1$ de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $x0$ et $p0$ et des éléments $p1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $x0$ et $p0$ et $matita_basics_logic.R1$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $T1$ et $a1$ et $x0$ et $p0$ et $x1$ et des éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $T2$ appliqué à $x0$ et $p0$ et $x1$ et $p1$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T2$ appliqué à $x0$ et $p0$ et $x1$ et $p1$ et $matita_basics_logic.R2$ appliqué à $T0$ et $a0$ et $T1$ et $a1$ et $T2$ et $a2$ et $x0$ et $p0$ et $x1$ et $p1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_a3$ de $cic.Term$ de $univs.Type0$ et de $T3$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $a2$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T2$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $a2$, pour tous les éléments $b0$ de $cic.Term$ de $univs.Type0$ et de $T0$, pour tous les éléments $e0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $b0$, pour tous les éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $b0$ et $e0$, pour tous les éléments $e1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $b0$ et $e0$ et $matita_basics_logic.R1$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $T1$ et $a1$ et $b0$ et $e0$ et $b1$, pour tous les éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $T2$ appliqué à $b0$ et $e0$ et $b1$ et $e1$, pour tous les éléments $e2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T2$ appliqué à $b0$ et $e0$ et $b1$ et $e1$ et $matita_basics_logic.R2$ appliqué à $T0$ et $a0$ et $T1$ et $a1$ et $T2$ et $a2$ et $b0$ et $e0$ et $b1$ et $e1$ et $b2$, $cic.Term$ tient pour $univs.Type0$ et $T3$ appliqué à $b0$ et $e0$ et $b1$ et $e1$ et $b2$ et $e2$.",
    "output": "Axiom R3 : forall T0 : cic.Univ univs.Type0, forall a0 : cic.Term univs.Type0 T0, forall T1 : ((x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0), forall a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0)), forall T2 : ((x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0), forall a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1)), forall T3 : ((x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> cic.Univ univs.Type0), forall _a3 : cic.Term univs.Type0 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2)), forall b0 : cic.Term univs.Type0 T0, forall e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0), forall b1 : cic.Term univs.Type0 (T1 b0 e0), forall e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 b0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 b0 e0) b1), forall b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1), forall e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2), cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp2. Soit $Q_$ une fonction des éléments $_x_76$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $x_76$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_76$.",
    "output": "False_rect_CProp2 : Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_76 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_76) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_fact_to_le. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$.",
    "output": "Axiom divides_fact_to_le : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)), cic.Term cic.prop (matita_arithmetics_nat.le p n) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_to_bijn. Låt $f$ och $g$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara en funktion från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $i$ och $g$ applicerat på $i$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $f$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $g$ och $n$.",
    "output": "postulate eq_to_bijn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f i) (g i))) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_below. Let $_l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate all_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp1_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $Q_$ des éléments $_x_686$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_686$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_686$.",
    "output": "Sig_rect_CProp1_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_686) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_ind_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $Q_$ des éléments $_x_118$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_conj$ des éléments $x_120$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_119$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_120$ et $x_119$, pour tous les éléments $x_118$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_118$.",
    "output": "Axiom And_ind_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))), forall x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_118) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_pi. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $g1$ och $g2$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara en funktion från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p$ applicerat på $i$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $g1$ applicerat på $i$ och $g2$ applicerat på $i$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$.",
    "output": "postulate le_pi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$. Then for all functions $P$ from elements $_z1704$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1705$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "Dop_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1704 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ univs.Type4) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1705 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_plus. För alla element $n$ och $p$ och $q$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $matita_arithmetics_nat.plus$ applicerat på $p$ och $q$.",
    "output": "axiom divides_plus (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q)) : cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.plus p q))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_r_aux. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $b1$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $P$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$. Let $__1$ be a function from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$. Let $l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $b$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "Axiom lstar_ind_r_aux : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B), forall __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1), forall __1 : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1), cic.Term cic.prop (P l b2) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp5_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $_x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $Q_$ une fonction des éléments $x_25$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_26$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_25$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_refl$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$. Soit $x_25$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $x_26$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_25$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_25$ et $x_26$.",
    "output": "Axiom eq_rect_CProp5_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_25 : cic.Term univs.Type2 A, forall x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25), cic.Term cic.prop (Q_ x_25 x_26) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type2_body. Soient $_n$ et $_m$ et $_q$ et $_r$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $Q_$ une fonction des éléments $_x_825$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $univs.Type2$. Alors pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_827$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_826$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_827$ et $x_826$, pour tous les éléments $x_825$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_825$.",
    "output": "div_mod_spec_rect_Type2_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type2) -> _H_div_mod_spec_intro : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_827 x_826))) -> x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type2 (Q_ x_825) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_ind. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1236$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1237$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom Prod_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type3. Pour toutes les fonctions $Q_$ des éléments $_x_46$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $univs.Type3$, pour tous les éléments $_H_I$ de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_logic.I$, pour tous les éléments $x_46$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_46$.",
    "output": "Axiom True_rect_Type3 : forall Q_ : ((_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3), forall _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I), forall x_46 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type3 (Q_ x_46) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_div_le. Soient $a$ et $b$ et $c$ et $d$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $d$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $a$ et $b$ et $matita_arithmetics_div_and_mod.div$ appliqué à $c$ et $d$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $c$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $d$.",
    "output": "postulate times_div_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div c d)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b d)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_ind_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_861$.",
    "output": "Axiom Aop_ind_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_861) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type4. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_917$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_mk_range$ une fonction des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$. Soit $x_917$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$. Alors $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_917$.",
    "output": "Axiom range_rect_Type4 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type4 (Q_ x_917) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp4. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_refl$ be an element of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$. Let $x_22$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Then for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "eq_rect_CProp4 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_22 : cic.Term univs.Type2 A -> _x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_22 : cic.Term univs.Type2 A -> x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Term cic.prop (Q_ x_22 x_23) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp3. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_907$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$. Då för alla element $x_907$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_907$.",
    "output": "axiom ACop_rect_CProp3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_907)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Aop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $op$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$. Let $_nill$ be a function from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $nil$ and $a$ and $a$. Let $_nilr$ be a function from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $nil$ and $a$. Then for all functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.",
    "output": "mk_Aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_lstar. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_R$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$. Då för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $B$ och element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_lstar_O$ från element $b$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_nat.O$ och $b$ och $b$ och $matita_arithmetics_lstar.lstar_O$ applicerat på $B$ och $_R$ och $b$, för alla funktioner $case_lstar_S$ från element $b1$ av $cic.Term$ av $univs.Type0$ och $B$ och element $b$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__$ av $cic.Term$ av $cic.prop$ och $_R$ applicerat på $b1$ och $b$ och element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $b2$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $l$ och $b$ och $b2$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$ och $b2$ och $matita_arithmetics_lstar.lstar_S$ applicerat på $B$ och $_R$ och $b1$ och $b$ och $__$ och $l$ och $b2$ och $__1$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__1$ och $__2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $__$ och $__1$ och $__2$ och $z$.",
    "output": "Axiom match_lstar : forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort), forall case_lstar_O : ((b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))), forall case_lstar_S : ((b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 B, forall __2 : cic.Term univs.Type0 B, forall z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2), cic.Term return_sort (return_type __ __1 __2 z) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp5_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_959$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_959$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_959$.",
    "output": "Dop_rect_CProp5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_959) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type1. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_700$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_mk_Prod$ une fonction des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$. Soit $x_700$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$. Alors $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_700$.",
    "output": "axiom Prod_rect_Type1 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type1) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type1 (Q_ x_700)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_divides. $cic.Term$ håller för $cic.prop$ och $matita_basics_relations.transitive$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_primes.divides$.",
    "output": "axiom transitive_divides : cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat matita_arithmetics_primes.divides)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_le_times_r. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.monotonic$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.le$ et la fonction qui envoie $m$ à $matita_arithmetics_nat.times$ appliqué à $n$ et $m$.",
    "output": "axiom monotonic_le_times_r (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (λ m => matita_arithmetics_nat.times n m))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_inv_lstar. Pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $b1$ et $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar_r$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b2$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b2$.",
    "output": "lstar_r_inv_lstar : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_transpose. Pour tous les éléments $i$ et $j$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $j$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à $matita_arithmetics_permutation.transpose$ appliqué à $i$ et $j$ et $n$.",
    "output": "axiom permut_transpose (i j n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.transpose i j) n)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R3. Soit $T0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $a0$ un élément de $cic.Term$ de $univs.Type0$ et de $T0$. Soit $T1$ une fonction des éléments $x0$ de $cic.Term$ de $univs.Type0$ et de $T0$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $x0$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $a1$ un élément de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$. Soit $T2$ une fonction des éléments $x0$ de $cic.Term$ de $univs.Type0$ et de $T0$ et des éléments $p0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $x0$ et des éléments $x1$ de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $x0$ et $p0$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $x0$ et $p0$ et $matita_basics_logic.R1$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $T1$ et $a1$ et $x0$ et $p0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $a2$ un élément de $cic.Term$ de $univs.Type0$ et de $T2$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$. Soit $T3$ une fonction des éléments $x0$ de $cic.Term$ de $univs.Type0$ et de $T0$ et des éléments $p0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $x0$ et des éléments $x1$ de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $x0$ et $p0$ et des éléments $p1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $x0$ et $p0$ et $matita_basics_logic.R1$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $T1$ et $a1$ et $x0$ et $p0$ et $x1$ et des éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $T2$ appliqué à $x0$ et $p0$ et $x1$ et $p1$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T2$ appliqué à $x0$ et $p0$ et $x1$ et $p1$ et $matita_basics_logic.R2$ appliqué à $T0$ et $a0$ et $T1$ et $a1$ et $T2$ et $a2$ et $x0$ et $p0$ et $x1$ et $p1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_a3$ un élément de $cic.Term$ de $univs.Type0$ et de $T3$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $a2$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T2$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $a0$ et $matita_basics_logic.refl$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $a1$ et $a2$. Soit $b0$ un élément de $cic.Term$ de $univs.Type0$ et de $T0$. Alors pour tous les éléments $e0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $b0$, pour tous les éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $T1$ appliqué à $b0$ et $e0$, pour tous les éléments $e1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T1$ appliqué à $b0$ et $e0$ et $matita_basics_logic.R1$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T0$ et $a0$ et $T1$ et $a1$ et $b0$ et $e0$ et $b1$, pour tous les éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $T2$ appliqué à $b0$ et $e0$ et $b1$ et $e1$, pour tous les éléments $e2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $T2$ appliqué à $b0$ et $e0$ et $b1$ et $e1$ et $matita_basics_logic.R2$ appliqué à $T0$ et $a0$ et $T1$ et $a1$ et $T2$ et $a2$ et $b0$ et $e0$ et $b1$ et $e1$ et $b2$, $cic.Term$ tient pour $univs.Type0$ et $T3$ appliqué à $b0$ et $e0$ et $b1$ et $e1$ et $b2$ et $e2$.",
    "output": "axiom R3 (T0 : cic.Univ univs.Type0) (a0 : cic.Term univs.Type0 T0) (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) (T3 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> (x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2)) -> cic.Univ univs.Type0) (_a3 : cic.Term univs.Type0 (T3 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) a2))) (b0 : cic.Term univs.Type0 T0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0)) (b1 : cic.Term univs.Type0 (T1 b0 e0)) (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 b0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 b0 e0) b1)) (b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1)) (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1)) (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2)) : cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp0_body. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_634$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_None$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_635$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_635$, för alla element $x_634$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_634$.",
    "output": "option_rect_CProp0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_634 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_635 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_635))) -> x_634 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_634) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_nth. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $l$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $A$ et $matita_basics_lists_list.nth_opt$ appliqué à $A$ et $n$ et $l$ et $matita_basics_types.Some$ appliqué à $A$ et $a$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $a$.",
    "output": "Axiom All_nth : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.All A P l), forall a : cic.Term univs.Type0 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a)), cic.Term cic.prop (P a) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_discr. Låt $a1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $a2$ vara ett element av $cic.Term$ av $univs.Type0$ och $a1$. Låt $x$ och $y$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $a1$ och $a2$. Låt $_e$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Dop$ applicerat på $a1$ och $a2$ och $x$ och $y$. Då håller $cic.Term$ för $univs.Type2$ och $matita_arithmetics_bigops.match_Dop$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ och $t2$ och $t3$ som $matita_arithmetics_bigops.match_Dop$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $u0$ och $u1$ och $u2$ och $u3$ som $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $cic.prod$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $a1$ och $a2$ och $matita_basics_logic.R0$ applicerat på $matita_arithmetics_bigops.ACop$ applicerat på $a1$ och $a2$ och $t0$ och $u0$ och funktionen som avbildar $e0$ som $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och funktionen som avbildar $x0$ och $p0$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__1$ som $a1$ applicerat på $u0$ och $e0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $a1$ och $a2$ och $t0$ och funktionen som avbildar $x0$ och $p0$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__1$ som $a1$ och $t1$ och $u0$ och $e0$ och $u1$ och funktionen som avbildar $e1$ som $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och funktionen som avbildar $x0$ och $p0$ och $x1$ och $p1$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $a$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $x1$ applicerat på $a$ och $a2$ och $a2$ applicerat på $u0$ och $e0$ och $u1$ och $e1$ och $matita_basics_logic.R2$ applicerat på $matita_arithmetics_bigops.ACop$ applicerat på $a1$ och $a2$ och $t0$ och funktionen som avbildar $x0$ och $p0$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__1$ som $a1$ och $t1$ och funktionen som avbildar $x0$ och $p0$ och $x1$ och $__$ som $cic.lift$ applicerat på $cic.prop$ och $univs.Type0$ och funktionen som avbildar $x01$ och $p01$ och $x11$ och $p1$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $a$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $x11$ applicerat på $a$ och $a2$ och $a2$ applicerat på $x0$ och $p0$ och $x1$ och $__$ och $t2$ och $u0$ och $e0$ och $u1$ och $e1$ och $u2$ och funktionen som avbildar $e2$ som $cic.prod$ applicerat på $cic.prop$ och $univs.Type1$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och funktionen som avbildar $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $p2$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $a$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $b$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $c$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $x1$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $a1$ och $a2$ och $x0$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $a1$ och $a2$ och $x0$ och $x1$ applicerat på $a$ och $b$ och $x1$ applicerat på $a$ och $c$ applicerat på $u0$ och $e0$ och $u1$ och $e1$ och $u2$ och $e2$ och $matita_basics_logic.R3$ applicerat på $matita_arithmetics_bigops.ACop$ applicerat på $a1$ och $a2$ och $t0$ och funktionen som avbildar $x0$ och $p0$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__$ som $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $a1$ och funktionen som avbildar $__1$ som $a1$ och $t1$ och funktionen som avbildar $x0$ och $p0$ och $x1$ och $__$ som $cic.lift$ applicerat på $cic.prop$ och $univs.Type0$ och funktionen som avbildar $x01$ och $p01$ och $x11$ och $p1$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $a$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $x11$ applicerat på $a$ och $a2$ och $a2$ applicerat på $x0$ och $p0$ och $x1$ och $__$ och $t2$ och funktionen som avbildar $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $__$ som $cic.lift$ applicerat på $cic.prop$ och $univs.Type0$ och funktionen som avbildar $x01$ och $p01$ och $x11$ och $p11$ och $x21$ och $p2$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $a$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $b$ som $cic.prod$ applicerat på $univs.Type0$ och $cic.prop$ och $a1$ och funktionen som avbildar $c$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $a1$ och $x11$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $a1$ och $a2$ och $x01$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $a1$ och $a2$ och $x01$ och $x11$ applicerat på $a$ och $b$ och $x11$ applicerat på $a$ och $c$ applicerat på $x0$ och $p0$ och $x1$ och $p1$ och $x2$ och $__$ och $t3$ och $u0$ och $e0$ och $u1$ och $e1$ och $u2$ och $e2$ och $u3$ och funktionen som avbildar $_e3$ som $P$ och funktionen som avbildar $_z61$ som $P$ och $y$ och $x$.",
    "output": "Dop_discr : a1 : cic.Univ univs.Type0 -> a2 : cic.Term univs.Type0 a1 -> x : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> y : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop a1 a2)) x y) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => t1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => t2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t1 a a2) a2)) => t3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t1 a (matita_arithmetics_bigops.aop__o__op a1 a2 t0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 t0 (t1 a b) (t1 a c)))) => matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => u1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => u2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u1 a a2) a2)) => u3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u1 a (matita_arithmetics_bigops.aop__o__op a1 a2 u0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 u0 (u1 a b) (u1 a c)))) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 u0 e0) u1) (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 u0 e0) u1) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) u0 e0 u1 e1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) u0 e0 u1 e1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => x10 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a (matita_arithmetics_bigops.aop__o__op a1 a2 x0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x0 (x1 a b) (x1 a c)))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x12 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2))) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a (matita_arithmetics_bigops.aop__o__op a1 a2 x01 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => x10 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a (matita_arithmetics_bigops.aop__o__op a1 a2 x0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x0 (x1 a b) (x1 a c)))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x12 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2))) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a (matita_arithmetics_bigops.aop__o__op a1 a2 x01 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) => P))))) (_z61 : (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0) -> e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 u0 e0) u1) -> e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) u0 e0 u1 e1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) -> _e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => x10 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a (matita_arithmetics_bigops.aop__o__op a1 a2 x0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x0 (x1 a b) (x1 a c)))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x12 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2))) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a (matita_arithmetics_bigops.aop__o__op a1 a2 x01 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_append. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $l1$ och $l2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.All$ applicerat på $A$ och $P$ och $l1$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.All$ applicerat på $A$ och $P$ och $l2$, håller $cic.Term$ för $cic.prop$ och $matita_basics_lists_list.All$ applicerat på $A$ och $P$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $l2$.",
    "output": "Axiom All_append : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.All A P l1), forall __1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2), cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $A$, för alla element $_x_941$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.",
    "output": "filter_body : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_941 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pair_elim2. Låt $A$ och $B$ och $C$ och $C'$ vara element av $cic.Univ$ av $univs.Type0$. Låt $T$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$. Låt $T'$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C'$. Låt $p$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$. Då för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $C$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $C'$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $lft$ av $cic.Term$ av $univs.Type0$ och $A$ och element $rgt$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ och $T$ applicerat på $lft$ och $rgt$ och $T'$ applicerat på $lft$ och $rgt$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $p$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $_0$ som $C$ och funktionen som avbildar $lft$ och $rgt$ som $T$ applicerat på $lft$ och $rgt$ och $p$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $_0$ som $C'$ och funktionen som avbildar $lft$ och $rgt$ som $T'$ applicerat på $lft$ och $rgt$ och $p$.",
    "output": "Axiom pair_elim2 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall C : cic.Univ univs.Type0, forall C' : cic.Univ univs.Type0, forall T : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C), forall T' : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C'), forall p : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall P : ((__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop), forall __ : ((lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt) (T' lft rgt))), cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (fun _0 => C) (fun lft => fun rgt => T lft rgt) p) (matita_basics_types.match_Prod A B univs.Type0 (fun _0 => C') (fun lft => fun rgt => T' lft rgt) p)) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_exists. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soient $t$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $t$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $m$ et $matita_basics_bool.true$. Soient $k$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $m$, pour toutes les fonctions $__3$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $i$ et des éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $i$ et $matita_basics_bool.false$, pour tous les éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $t$ et $matita_arithmetics_nat.plus$ appliqué à $k$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_minimization.min$ appliqué à $k$ et $b$ et $f$ et $m$.",
    "output": "Axiom min_exists : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall t : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt m t), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true), forall k : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le b m), forall __3 : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)), forall __4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16003. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $d$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme0$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $H$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $m$ och $d$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $c$.",
    "output": "let_clause_16003 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_div_S_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.",
    "output": "axiom lt_div_S_div (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.div n m))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sym_not_eq. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $x$ et $y$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $y$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $A$ et $y$ et $x$.",
    "output": "axiom sym_not_eq (A : cic.Univ univs.Type2) (x y : cic.Term univs.Type2 A) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq A x y))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq A y x))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type4. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då för alla funktioner $Q_$ från element $_x_945$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_945$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_945$.",
    "output": "Axiom Dop_rect_Type4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term univs.Type4 (Q_ x_945) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp1. Let $Q_$ be a function from elements $_x_359$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_359$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_359$.",
    "output": "Axiom bool_rect_CProp1 : forall Q_ : ((_x_359 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_359 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_359) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_ex2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (case_ex2_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_lstar. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $_R$ et $__$ et $__1$ et $__2$ à des éléments de $cic.Univ$ de $return_sort$. Soit $case_lstar_O$ une fonction des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_arithmetics_nat.O$ et $b$ et $b$ et $matita_arithmetics_lstar.lstar_O$ appliqué à $B$ et $_R$ et $b$. Soit $case_lstar_S$ une fonction des éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_R$ appliqué à $b1$ et $b$ et des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $_R$ et $l$ et $b$ et $b2$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$ et $b2$ et $matita_arithmetics_lstar.lstar_S$ appliqué à $B$ et $_R$ et $b1$ et $b$ et $__$ et $l$ et $b2$ et $__1$. Alors pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__1$ et $__2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $_R$ et $__$ et $__1$ et $__2$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $__$ et $__1$ et $__2$ et $z$.",
    "output": "axiom match_lstar (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) (case_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) (case_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 __2 : cic.Term univs.Type0 B) (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) : cic.Term return_sort (return_type __ __1 __2 z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_Type3. Låt $Q_$ vara en funktion från element $_x_69$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $univs.Type3$. Då för alla element $x_69$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_69$.",
    "output": "False_rect_Type3 : Q_ : (_x_69 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type3) -> x_69 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type3 (Q_ x_69) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_min. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soient $n$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $i$ à $matita_basics_logic.And$ appliqué à $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.le$ appliqué à $b$ et $i$ et $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $i$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$.",
    "output": "postulate lt_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type5_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_7$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_8$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_7$ till element av $cic.Univ$ av $univs.Type5$. Låt $_H_refl$ vara ett element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Låt $x_7$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Då för alla element $x_8$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_7$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_7$ och $x_8$.",
    "output": "eq_rect_Type5_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_7 : cic.Term univs.Type2 A -> _x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) -> cic.Univ univs.Type5) -> _H_refl : cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x)) -> x_7 : cic.Term univs.Type2 A -> x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) -> cic.Term univs.Type5 (Q_ x_7 x_8) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_S_mod. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à $matita_arithmetics_congruence.S_mod$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et $n$.",
    "output": "axiom permut_S_mod (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_S_S_to_lt. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$.",
    "output": "lt_S_S_to_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lhd_nil. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.lhd$ appliqué à $A$ et $matita_basics_lists_list.nil$ appliqué à $A$ et $n$ et $matita_basics_lists_list.nil$ appliqué à $A$.",
    "output": "lhd_nil : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.lhd A (matita_basics_lists_list.nil A) n) (matita_basics_lists_list.nil A)) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type5. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_668$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_668$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_668$.",
    "output": "Axiom Sig_rect_Type5 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type5), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type5 (Q_ x_668) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp5_body. För alla element $_A$ och $_B$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_706$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $x_706$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_706$.",
    "output": "Axiom Prod_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_706) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative2. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Alors $cic.Univ$ tient pour $cic.prop$.",
    "output": "Axiom commutative2 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_DPair$ be a function from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$. Let $x_656$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "axiom DPair_rect_CProp3 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_ACop$ be a function from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Then for all elements $x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_909$.",
    "output": "postulate ACop_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_909)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_911$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_ACop$ be a function from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_911$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_911$.",
    "output": "Axiom ACop_rect_CProp1 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_911) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mem_filter_true. Låt $S$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $S$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $a$ vara ett element av $cic.Term$ av $univs.Type0$ och $S$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $S$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.mem$ applicerat på $S$ och $a$ och $matita_basics_lists_list.filter$ applicerat på $S$ och $f$ och $l$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $a$ och $matita_basics_bool.true$.",
    "output": "postulate mem_filter_true : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem S a (matita_basics_lists_list.filter S f l))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f a) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pair_elim2. Låt $A$ och $B$ och $C$ och $C'$ vara element av $cic.Univ$ av $univs.Type0$. Låt $T$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$. Då för alla funktioner $T'$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C'$, för alla element $p$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $C$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $C'$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $lft$ av $cic.Term$ av $univs.Type0$ och $A$ och element $rgt$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ och $T$ applicerat på $lft$ och $rgt$ och $T'$ applicerat på $lft$ och $rgt$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $p$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $_0$ som $C$ och funktionen som avbildar $lft$ och $rgt$ som $T$ applicerat på $lft$ och $rgt$ och $p$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $_0$ som $C'$ och funktionen som avbildar $lft$ och $rgt$ som $T'$ applicerat på $lft$ och $rgt$ och $p$.",
    "output": "postulate pair_elim2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (C' : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (T' : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C') -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt) (T' lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T lft rgt) p) (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C') (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T' lft rgt) p))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp4_body. Let $Q_$ be a function from elements $_x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_O$ be an element of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$. Let $_H_S$ be a function from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_396$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_394$. Let $x_393$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_393$.",
    "output": "nat_rect_CProp4_body : Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_396 : cic.Term cic.prop (Q_ x_394) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) -> x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_393) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1575. För alla element $m$ och $n$ och $a$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $pnm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $x1029$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1029$ och $matita_arithmetics_nat.times$ applicerat på $x1029$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $c$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $d$.",
    "output": "postulate let_clause_1575 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_nat.times x1029 (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d))))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_Type1. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$. Soit $P$ une fonction des éléments $_z930$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type1$. Alors pour toutes les fonctions $_H1$ des éléments $_z931$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.",
    "output": "unit_inv_rect_Type1 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type1) -> _H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_ex2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_P$ and $_Q$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp2_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_710$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Prod$ une fonction des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$. Soit $x_710$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_710$.",
    "output": "postulate Prod_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_710 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_710 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_710)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1542$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1543$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "axiom Aop_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "S. Assume that $Nat$. Then $Nat$.",
    "output": "axiom s (x : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Or_inv_ind. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$. Let $_H1$ be a function from elements $x_171$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$. Let $_H2$ be a function from elements $x_172$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$. Then $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Or_inv_ind : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2), forall P : ((_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_171 : cic.Term cic.prop x1) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_introl x1 x2 x_171))) -> cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))), forall _H2 : ((x_172 : cic.Term cic.prop x2) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då för alla funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $nil$ och $a$ och $a$, för alla funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $nil$ och $a$, för alla funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $nil$.",
    "output": "axiom mk_Aop (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Compose. För alla element $A$ och $B$ och $C$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$, för alla funktioner $_g$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $_x$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $univs.Type0$ och $C$.",
    "output": "compose : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> _g : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _x : cic.Term univs.Type0 A -> cic.Term univs.Type0 C ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_Type0. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$. Soit $P$ une fonction des éléments $_z1068$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_H1$ des éléments $_z1069$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_611$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1069$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_611$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_611$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $Hterm$.",
    "output": "axiom option_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) : cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_883$.",
    "output": "Axiom Aop_rect_CProp1_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_883) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type2. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_602$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$. Let $_H_None$ be an element of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$. Then for all functions $_H_Some$ from elements $x_603$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_603$, for all elements $x_602$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_602$.",
    "output": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing_to_injective. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$.",
    "output": "postulate increasing_to_injective : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_symmetric. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $_R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.bi_relation$ appliqué à $A$ et $B$. Alors $cic.Univ$ tient pour $cic.prop$.",
    "output": "Axiom bi_symmetric : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_1_fact. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_factorial.fact$ applicerat på $n$.",
    "output": "postulate le_1_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_inv_lstar. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $R$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $b1$ och $b2$ vara element av $cic.Term$ av $univs.Type0$ och $B$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$.",
    "output": "postulate lstar_r_inv_lstar : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp4. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1602$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1603$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom ACop_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1602 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1603 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp4_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_678$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Sig$ une fonction des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$. Soit $x_678$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_678$.",
    "output": "postulate Sig_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_678)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_ind. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $cic.prop$. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z323$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $x_120$ de $cic.Term$ de $cic.prop$ et de $x1$ et des éléments $x_119$ de $cic.Term$ de $cic.prop$ et de $x2$ et des éléments $_z324$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.And$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_120$ et $x_119$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_120$ et $x_119$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "axiom And_inv_ind (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z323 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_120 : cic.Term cic.prop x1) -> (x_119 : cic.Term cic.prop x2) -> (_z324 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_120 x_119))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_120 x_119))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.",
    "output": "postulate Sum_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type1_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_648$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_mk_DPair$ une fonction des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$. Soit $x_648$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$. Alors $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_648$.",
    "output": "DPair_rect_Type1_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type1) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type1 (Q_ x_648) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_trans. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $C$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $C$.",
    "output": "postulate iff_trans : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) -> cic.Term cic.prop (matita_basics_logic.iff A C)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type3. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Då för alla funktioner $Q_$ från element $x_10$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_11$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_10$ till element av $cic.Univ$ av $univs.Type3$, för alla element $_H_refl$ av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$, för alla element $x_10$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_11$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_10$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_10$ och $x_11$.",
    "output": "Axiom eq_rect_Type3 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3), forall _H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)), forall x_10 : cic.Term univs.Type2 A, forall x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10), cic.Term univs.Type3 (Q_ x_10 x_11) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_787$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type3$. Då för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_787$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_787$.",
    "output": "postulate Aop_rect_Type3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_ind. Let $_n$ and $_b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $Q_$ be a function from elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_found_min_spec$ be a function from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$. Let $_H_not_found_min_spec$ be a function from functions $x_1081$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and $matita_arithmetics_minimization.not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$. Then for all elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1075$ and $x_1076$.",
    "output": "Axiom min_spec_ind : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop), forall _H_found_min_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077))), forall _H_not_found_min_spec : ((x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus _n _b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus _n _b) (matita_arithmetics_minimization.not_found_min_spec _n _b _f x_1081))), forall x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075), cic.Term cic.prop (Q_ x_1075 x_1076) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_ind. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_690$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Prod$ be a function from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$. Then for all elements $x_690$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_690$.",
    "output": "axiom Prod_ind (_A _B : cic.Univ univs.Type0) (Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_690)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Notb. För alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.",
    "output": "Axiom notb : forall __ : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $return_sort$. Alors pour toutes les fonctions $case_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_arithmetics_bigops.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "match_Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ return_sort) -> case_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound. Let $__$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_upper_bound : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_exp.exp$ applied to $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "axiom le_exp_to_le (b n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m))) : cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1595. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $primepn$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $primepm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $lt1gcd$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $m$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_primes.smallest_factor$ applicerat på $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $m$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $n$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$.",
    "output": "let_clause_1595 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) -> H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m)) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_pi. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $p$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $matita_arithmetics_exp.exp$ appliqué à $f$ appliqué à $i$ et $m$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $m$.",
    "output": "postulate exp_pi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp (f i) m)) (matita_arithmetics_exp.exp (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) m))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_CProp2. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors pour toutes les fonctions $P$ des éléments $_z173$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z174$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "True_inv_rect_CProp2 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z173 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_lt_times_l. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $c$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.monotonic$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.lt$ et la fonction qui envoie $t$ à $matita_arithmetics_nat.times$ appliqué à $t$ et $c$.",
    "output": "Axiom monotonic_lt_times_l : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times t c)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_divides_times. Låt $p$ och $q$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $p$ och $q$. Låt $__2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $n$. Låt $__3$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $q$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_nat.times$ applicerat på $p$ och $q$ och $n$.",
    "output": "axiom divides_to_divides_times (p q n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p q))) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides q n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times p q) n)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type2_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_736$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_nil$ un élément de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$. Alors pour toutes les fonctions $_H_cons$ des éléments $x_738$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_737$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_740$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $x_737$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_738$ et $x_737$, pour tous les éléments $x_736$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_736$.",
    "output": "list_rect_Type2_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type2) -> _H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_738 : cic.Term univs.Type0 _A -> x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_740 : cic.Term univs.Type2 (Q_ x_737) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type2 (Q_ x_736) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1532. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $divnm$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$. Then for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_1532 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp5. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_905$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_905$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_905$.",
    "output": "Axiom ACop_rect_CProp5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_905) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_true. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Alors pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $p$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $p$ appliqué à $a$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.filter$ appliqué à $A$ et $p$ et $matita_basics_lists_list.cons$ appliqué à $A$ et $a$ et $l$ et $matita_basics_lists_list.cons$ appliqué à $A$ et $a$ et $matita_basics_lists_list.filter$ appliqué à $A$ et $p$ et $l$.",
    "output": "Axiom filter_true : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall a : cic.Term univs.Type0 A, forall p : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.filter A p (matita_basics_lists_list.cons A a l)) (matita_basics_lists_list.cons A a (matita_basics_lists_list.filter A p l))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_Type3. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z599$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> (_H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_668$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$. Then for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_668$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_668$.",
    "output": "Axiom Sig_rect_Type5_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type5), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type5 (Q_ x_668) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_Type0. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$. Låt $P$ vara en funktion från element $_z155$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H1$ vara en funktion från element $_z156$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.True$ och $Hterm$ och $matita_basics_logic.I$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_logic.I$. Då håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.",
    "output": "postulate True_inv_rect_Type0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z155 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) -> (_H1 : (_z156 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type0 (P matita_basics_logic.I)) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1575. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $d$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme0$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Då för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $x1029$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1029$ och $matita_arithmetics_nat.times$ applicerat på $x1029$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $c$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $d$.",
    "output": "let_clause_1575 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_nat.times x1029 (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1512$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$. Then for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1513$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "axiom Aop_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1512 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type3) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1513 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1068. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $permf$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $n$. Soient $i$ et $j$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $lein$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$. Soit $lejn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $j$ et $n$. Soit $a$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.le$ appliqué à $a$ et $n$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a$ et $i$. Soit $lean$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $a$ et $n$. Soit $fa$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a$ et $i$. Soit $b$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme0$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.le$ appliqué à $b$ et $n$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $b$ et $j$. Soit $lebn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $n$. Soit $fb$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $b$ et $j$. Soit $__$ une fonction des éléments $i0$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i0$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $f$ appliqué à $i0$ et $n$. Soit $injf$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.injn$ appliqué à $f$ et $n$. Alors pour tous les éléments $auto$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $a$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a$ et $i$.",
    "output": "axiom let_clause_1068 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) (i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) (__ : (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)) (injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_inv_ind. Låt $x1$ och $x2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $x3$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $x4$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_Hterm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från element $_z1890$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_1080$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x2$ och $m$ och element $_x_1079$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$ och element $_x_1078$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x3$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $_x_1077$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x2$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $m$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x3$ applicerat på $i$ och $matita_basics_bool.false$ och element $_z1891$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x4$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $m$, för alla funktioner $_H2$ från funktioner $_x_1081$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x2$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x3$ applicerat på $i$ och $matita_basics_bool.false$ och element $_z1891$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x4$ och $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x1$ och $x2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $x4$.",
    "output": "axiom min_spec_inv_ind (x1 x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 m)) -> cic.Term cic.prop (P m)) (_H2 : (_x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus x1 x2))) : cic.Term cic.prop (P x4)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type2. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $x1$, för alla funktioner $P$ från element $_z1650$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H1$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ och element $_z1651$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.range$ applicerat på $x1$ och $Hterm$ och $matita_arithmetics_bigops.mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$, håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $Hterm$.",
    "output": "axiom range_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1650 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type2) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1651 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type2_body. Soit $Q_$ une fonction des éléments $_x_338$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_true$ un élément de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_bool.true$. Soit $_H_false$ un élément de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_bool.false$. Alors pour tous les éléments $x_338$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_338$.",
    "output": "postulate bool_rect_Type2_body : (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) -> (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ x_338)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1617. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $a$ and $matita_arithmetics_nat.times$ applied to $m$ and $b$.",
    "output": "Axiom let_clause_1617 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))), forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)), forall H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type3. Soit $Q_$ une fonction des éléments $_x_46$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $univs.Type3$. Soit $_H_I$ un élément de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_logic.I$. Soit $x_46$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_46$.",
    "output": "axiom True_rect_Type3 (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) (x_46 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type3 (Q_ x_46)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp3_body. För alla funktioner $Q_$ från element $_x_513$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_it$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_513$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_513$.",
    "output": "Axiom unit_rect_CProp3_body : forall Q_ : ((_x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_513 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_513) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_680$.",
    "output": "postulate Sig_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_680)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_lstar_r. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $_R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$. Let $case_lstar_r_O$ be a function from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$. Let $case_lstar_r_S$ be a function from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $__$ and $b2$ and $__1$. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $__1$ and $__2$ and $z$.",
    "output": "postulate match_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (case_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi2_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $f$, $cic.Term$ tient pour $univs.Type0$ et $f$ appliqué à $matita_basics_types.dpi1$ appliqué à $A$ et $f$ et $xxx$.",
    "output": "Axiom dpi2_body : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f), cic.Term univs.Type0 (f (matita_basics_types.dpi1 A f xxx)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dividesb_div_true. Let $d$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $d$ and $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $n$ and $matita_basics_bool.true$.",
    "output": "postulate dividesb_div_true : (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb d n) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb (matita_arithmetics_div_and_mod.div n d) n) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1569. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $d$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme0$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $H$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $c$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $d$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_1569 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_prim4l. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.",
    "output": "le_exp_prim4l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_871$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Let $x_871$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$. Then $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_871$.",
    "output": "Aop_rect_Type1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type1 (Q_ x_871) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type4. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1704$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H1$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $x2$ et $x2$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $x1$ et $x2$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ et des éléments $_z1705$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_Dop$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ et $_null$ et $_distr$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $x1$ et $x2$ et $sum$ et $prod$ et $_null$ et $_distr$, $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.",
    "output": "Dop_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1704 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ univs.Type4) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1705 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_ind_r. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $a$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $P$ be a function from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $cic.prop$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$. Let $x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Then for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x$ and $p$.",
    "output": "eq_ind_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term cic.prop (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_897$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_897$.",
    "output": "axiom ACop_rect_Type2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type2 (Q_ x_897)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fold. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $_op$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $_b$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $_p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate fold : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "le_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1170$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1171$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Sig_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1170 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1171 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_f2. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $univs.Type2$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type2$ and $B$ to elements of $cic.Term$ of $univs.Type2$ and $C$. Then for all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $y1$ and $y2$ of $cic.Term$ of $univs.Type2$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x1$ and $x2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $B$ and $y1$ and $y2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $C$ and $f$ applied to $x1$ and $y1$ and $f$ applied to $x2$ and $y2$.",
    "output": "Axiom eq_f2 : forall A : cic.Univ univs.Type2, forall B : cic.Univ univs.Type2, forall C : cic.Univ univs.Type2, forall f : ((__ : cic.Term univs.Type2 A) -> (__1 : cic.Term univs.Type2 B) -> cic.Term univs.Type2 C), forall x1 : cic.Term univs.Type2 A, forall x2 : cic.Term univs.Type2 A, forall y1 : cic.Term univs.Type2 B, forall y2 : cic.Term univs.Type2 B, forall __ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2), forall __1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2), cic.Term cic.prop (matita_basics_logic.eq C (f x1 y1) (f x2 y2)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp1. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_771$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_nil$ be an element of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$. Let $_H_cons$ be a function from elements $x_773$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_772$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_775$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_772$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_773$ and $x_772$. Let $x_771$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_771$.",
    "output": "Axiom list_rect_CProp1 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_773 : cic.Term univs.Type0 _A) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_775 : cic.Term cic.prop (Q_ x_772)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_773 x_772))), forall x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_771) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distr_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $xxx$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$. Then for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "postulate distr_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Smallest_factor_to_min. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $matita_arithmetics_minimization.min$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $m$ to $matita_arithmetics_nat.eqb$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate smallest_factor_to_min : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_CProp3. För alla element $Hterm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, för alla funktioner $P$ från element $_z167$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z168$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.True$ och $Hterm$ och $matita_basics_logic.I$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.I$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "axiom True_inv_rect_CProp3 (Hterm : cic.Term cic.prop matita_basics_logic.True) (P : (_z167 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$. Then for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "axiom Aop_rect_Type1 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Sum. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "postulate filter_Sum : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type0. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_610$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H_None$ vara ett element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$. Då för alla funktioner $_H_Some$ från element $x_611$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_611$, för alla element $x_610$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_610$.",
    "output": "axiom option_rect_Type0 (_A : cic.Univ univs.Type0) (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type0 (Q_ x_610)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop__o__op. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Let $x1$ be an element of $cic.Term$ of $univs.Type0$ and $x0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "postulate dpi1__o__aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp4_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då för alla funktioner $Q_$ från element $_x_795$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_795$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_795$.",
    "output": "postulate Aop_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_795)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom Sig (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_797$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_797$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_797$.",
    "output": "postulate Aop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_797)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type0_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_702$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_H_mk_Prod$ une fonction des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$. Alors pour tous les éléments $x_702$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_702$.",
    "output": "axiom Prod_rect_Type0_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type0 (Q_ x_702)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_943$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_Dop$ vara en funktion från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$. Låt $x_943$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_943$.",
    "output": "axiom Dop_ind_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_943)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp4_body. Let $Q_$ be a function from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.",
    "output": "Axiom bool_rect_CProp4_body : forall Q_ : ((_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_347 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_347) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1206$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1207$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Sig_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ cic.prop) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leq_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "axiom leq_sqrt_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_rev_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_basics_lists_list.list$ applied to $H$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate split_rev_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type4_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_526$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_inl$ från element $x_527$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_527$, för alla funktioner $_H_inr$ från element $x_528$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_528$, för alla element $x_526$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_526$.",
    "output": "postulate Sum_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type4) -> (_H_inl : (x_527 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inl _A _B x_527))) -> (_H_inr : (x_528 : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inr _A _B x_528))) -> (x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type4 (Q_ x_526)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_S_S_to_not_le. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_nat.le$ applicerat på $n$ och $m$.",
    "output": "not_le_S_S_to_not_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type0_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_833$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_div_mod_spec_intro$ from elements $x_835$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_834$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_835$ and $x_834$, for all elements $x_833$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_833$.",
    "output": "axiom div_mod_spec_rect_Type0_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_833 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type0) (_H_div_mod_spec_intro : (x_835 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_834 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_835 x_834))) (x_833 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term univs.Type0 (Q_ x_833)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leb_false_to_not_le. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_nat.leb$ appliqué à $n$ et $m$ et $matita_basics_bool.false$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $matita_arithmetics_nat.le$ appliqué à $n$ et $m$.",
    "output": "axiom leb_false_to_not_le (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fmin_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.let_m$ applied to $f$ and $n$ and $b$ and $matita_basics_bool.false$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.let_m$ applied to $f$ and $n$ and $b$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.",
    "output": "axiom fmin_false (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n b : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) (λ __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m f n b) (matita_arithmetics_nat.plus n b)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Found_max_spec. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $m$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $m$ och $matita_basics_bool.true$, för alla funktioner $__2$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $i$ och element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $n$ och $f$ och $m$.",
    "output": "postulate found_max_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f m)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1617. Soient $p$ et $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$. Soit $gcd1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $nm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $p$ et $c$. Soit $a$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme0$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $b$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$. Alors pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$, pour tous les éléments $H0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $p$ et $a$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $b$.",
    "output": "axiom let_clause_1617 (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m))) (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injn_Sn_n. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "postulate injn_Sn_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_ab. För alla element $m$ och $n$ och $a$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $x$ som $matita_basics_logic.And$ applicerat på $matita_arithmetics_congruence.congruent$ applicerat på $x$ och $a$ och $m$ och $matita_arithmetics_congruence.congruent$ applicerat på $x$ och $b$ och $n$.",
    "output": "Axiom congruent_ab : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun x => matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n))) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp1. Soit $_A$ un élément de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_112$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_nmk$ une fonction des fonctions $x_113$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_113$. Soit $x_112$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_112$.",
    "output": "Not_rect_CProp1 : _A : cic.Univ cic.prop -> Q_ : (_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_113 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))) -> x_112 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_112) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec. Let $_n$ and $_b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom min_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Smallest_factor_to_min. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $matita_arithmetics_minimization.min$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $m$ to $matita_arithmetics_nat.eqb$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate smallest_factor_to_min : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_True. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $return_sort$. Soit $return$ une fonction des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$. Alors pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "axiom filter_True (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop matita_basics_logic.True) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_op. Let $k$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $op$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$. Let $f$ and $g$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $g$ applied to $i$.",
    "output": "axiom bigop_op (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.aop__o__op B nil op (matita_arithmetics_bigops.bigop k (λ i => p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ i => g i))) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ i => matita_arithmetics_bigops.aop__o__op B nil op (f i) (g i))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1560. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $divnm$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$. Let $H$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$. Let $d$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $auto$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_1560 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_ind. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $P$ vara en funktion från element $_z587$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H1$ från element $_z588$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$, för alla funktioner $_H2$ från element $_z588$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom bool_inv_ind : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z587 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H1 : ((_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)), forall _H2 : ((_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$. Let $_H_mk_Sig$ be a function from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$. Let $x_666$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$. Then $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.",
    "output": "Sig_rect_Type4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type4) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type4 (Q_ x_666) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lift. Let $s1$ and $s2$ be elements of $Sort$. Then for all elements $a$ of $Univ$ of $s1$, $Univ$ holds for $max$ applied to $s1$ and $s2$.",
    "output": "axiom lift (s1 s2 : Sort) (a : Univ s1) : Univ (max s1 s2)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Append_body. För alla element $H$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ och $__1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$.",
    "output": "postulate append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$. Then for all functions $P$ from elements $_z1098$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_635$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_635$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_635$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom option_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) (P : (_z1098 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) (_H1 : (_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) (_H2 : (x_635 : cic.Term univs.Type0 x1) -> (_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_635))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_635))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp3. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_nil$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $_H_cons$ des éléments $x_763$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_762$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_765$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_762$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_763$ et $x_762$, pour tous les éléments $x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_761$.",
    "output": "postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type3_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.",
    "output": "postulate list_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) -> (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) -> (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type3 (Q_ x_731)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_l. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $R$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $P$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation2$ applicerat på $matita_arithmetics_nat.nat$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$ och $b2$, för alla funktioner $__1$ från element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $b1$ av $cic.Term$ av $univs.Type0$ och $B$ och element $b$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $cic.prop$ och $R$ applicerat på $b1$ och $b$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b$ och $b2$ och element $__3$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $l$ och $b$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $b1$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $l$ och $b1$.",
    "output": "lstar_ind_l : B : cic.Univ univs.Type0 -> R : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> b2 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b2) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (R b1 b) -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> cic.Term cic.prop (P l b1) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_smallest_factor_to_not_divides. Låt $n$ och $i$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $i$. Låt $__2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $matita_arithmetics_primes.smallest_factor$ applicerat på $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $i$ och $n$.",
    "output": "Axiom lt_smallest_factor_to_not_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n)), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n)) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_smallest_factor_to_not_divides. Soient $n$ et $i$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $i$. Soit $__2$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_primes.smallest_factor$ appliqué à $n$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $i$ et $n$.",
    "output": "Axiom lt_smallest_factor_to_not_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n)), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp4. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_903$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_903$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_903$.",
    "output": "postulate ACop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_903)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_ind. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_118$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_conj$ från element $x_120$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_119$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_120$ och $x_119$, för alla element $x_118$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_118$.",
    "output": "Axiom And_ind : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))), forall x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_118) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_l_aux. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $R$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Univ$ av $cic.prop$. Låt $b2$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Låt $P$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation2$ applicerat på $matita_arithmetics_nat.nat$ och $B$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$ och $b2$. Låt $__1$ vara en funktion från element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $b1$ av $cic.Term$ av $univs.Type0$ och $B$ och element $b$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $cic.prop$ och $R$ applicerat på $b1$ och $b$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b$ och $b2$ och element $__3$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $l$ och $b$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $b1$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $B$. Då för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b$, för alla element $__3$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $b$ och $b2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $l$ och $b1$.",
    "output": "postulate lstar_ind_l_aux : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b2)) -> cic.Term cic.prop (P l b1)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_exists. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.ex$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$ et la fonction qui envoie $l1$ à $matita_basics_logic.ex$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$ et la fonction qui envoie $l2$ à $matita_basics_logic.And$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $l$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l1$ et $n$.",
    "output": "Axiom split_exists : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (fun l1 => matita_basics_logic.ex (matita_basics_lists_list.list A) (fun l2 => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A l1 l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_times. Låt $n$ och $m$ och $p$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $m$ och $q$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $p$ och $q$.",
    "output": "postulate divides_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10131. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ och $m$ och $n0$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $eqm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.max$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n0$ och $f$ och $m$. Låt $fm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $m$ och $matita_basics_bool.false$. Låt $i$ och $j$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $ltj$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $j$ och $matita_arithmetics_nat.S$ applicerat på $n0$, för alla element $x7$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x7$ och $matita_arithmetics_nat.plus$ applicerat på $m$ och $x7$.",
    "output": "let_clause_10131 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m) -> fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0)) -> x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_exists. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $t$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $t$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $m$ och $matita_basics_bool.true$, för alla element $k$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $b$ och $m$, för alla funktioner $__3$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $b$ och $i$ och element $__4$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $m$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.false$, för alla element $__4$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $t$ och $matita_arithmetics_nat.plus$ applicerat på $k$ och $b$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.min$ applicerat på $k$ och $b$ och $f$ och $m$.",
    "output": "min_exists : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> t : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m t) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> __4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_dividesb_true. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $n$ och $m$ och $matita_basics_bool.true$.",
    "output": "divides_to_dividesb_true : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_ind. För alla element $x1$ och $x2$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1236$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1237$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type2_r. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $a$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $P$ une fonction des éléments $x$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $__$ un élément de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $a$ et $matita_basics_logic.refl$ appliqué à $A$ et $a$. Soit $x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $p$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$. Alors $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $x$ et $p$.",
    "output": "eq_rect_Type2_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term univs.Type2 (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_104$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_104$, for all elements $x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_103$.",
    "output": "postulate Not_rect_CProp5_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp4_body. Soit $Q_$ une fonction des éléments $_x_347$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_true$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.true$. Alors pour tous les éléments $_H_false$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_347$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_347$.",
    "output": "postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F3_ind_aux. Soient $A1$ et $A2$ et $A3$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $A3$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $P$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation3$ appliqué à $A1$ et $A2$ et $A3$. Alors pour toutes les fonctions $__$ des éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $__$ des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $a3$ de $cic.Term$ de $univs.Type0$ et de $A3$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $f$ appliqué à $a1$ et $a2$ et $a3$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et $a3$ et des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $a3$ de $cic.Term$ de $univs.Type0$ et de $A3$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a1$ et $a2$ et $a3$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et $a3$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$, pour tous les éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$, pour tous les éléments $a3$ de $cic.Term$ de $univs.Type0$ et de $A3$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a1$ et $a2$ et $a3$ et $n$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $a1$ et $a2$ et $a3$.",
    "output": "postulate f3_ind_aux : (A1 : cic.Univ univs.Type0) -> (A2 : cic.Univ univs.Type0) -> (A3 : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> (__2 : cic.Term univs.Type0 A3) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation3 A1 A2 A3)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type3_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Q_$ vara en funktion från element $_x_821$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type3$. Låt $_H_div_mod_spec_intro$ vara en funktion från element $x_823$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_822$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_823$ och $x_822$. Låt $x_821$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$. Då håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_821$.",
    "output": "axiom div_mod_spec_rect_Type3_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3) (_H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) (x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term univs.Type3 (Q_ x_821)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$ to elements of $cic.Univ$ of $univs.Type4$. Then for all elements $_H_refl$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_4$ and $x_5$.",
    "output": "eq_rect_Type4 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_4 : cic.Term univs.Type2 A -> _x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) -> cic.Univ univs.Type4) -> _H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x)) -> x_4 : cic.Term univs.Type2 A -> x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) -> cic.Term univs.Type4 (Q_ x_4 x_5) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp2. Soit $Q_$ une fonction des éléments $_x_492$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $x_492$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_492$.",
    "output": "Axiom void_rect_CProp2 : forall Q_ : ((_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_492 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_492) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp0. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H1$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z384$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "And_inv_rect_CProp0 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_168 : cic.Term cic.prop x1 -> x_167 : cic.Term cic.prop x2 -> _z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15623. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Let $posm$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Then for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_15623 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$. Då för alla funktioner $case_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "Axiom match_Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort), forall case_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type1_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_741$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$. Alors pour tous les éléments $_H_nil$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $_H_cons$ des éléments $x_743$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_742$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_745$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $x_742$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_743$ et $x_742$, pour tous les éléments $x_741$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_741$.",
    "output": "Axiom list_rect_Type1_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type1), forall _H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_743 : cic.Term univs.Type0 _A) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_745 : cic.Term univs.Type1 (Q_ x_742)) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))), forall x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type1 (Q_ x_741) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta_pred. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.",
    "output": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate div_aux_body : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta_pred. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.",
    "output": "Axiom theta_pred : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "S_pred. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $n$ et $n$.",
    "output": "S_pred : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_nat.pred n)) n) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_ind. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_943$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_943$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_943$.",
    "output": "postulate Dop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_943)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1562. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $pnm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $d$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $n$ et $c$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $d$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_1562 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_ind_body. Soit $_A$ un élément de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_79$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_nmk$ des fonctions $x_80$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_80$, pour tous les éléments $x_79$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_79$.",
    "output": "Axiom Not_ind_body : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_80 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))), forall x_79 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_79) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_commute. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p11$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p12$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p21$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p22$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $j$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $p11$ applied to $i$ and $p12$ applied to $i$ and $j$ and $matita_basics_bool.andb$ applied to $p21$ applied to $j$ and $p22$ applied to $i$ and $j$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p11$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $j$ to $p12$ applied to $i$ and $j$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $f$ applied to $i$ and $j$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $j$ to $p21$ applied to $j$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p22$ applied to $i$ and $j$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $j$.",
    "output": "bigop_commute : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p11 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p12 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p21 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p22 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt j m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb (p11 i) (p12 i j)) (matita_basics_bool.andb (p21 j) (p22 i j)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p11 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop m (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => p12 i j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i j))) (matita_arithmetics_bigops.bigop m (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => p21 j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p22 i j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i j)))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_div_mod. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $n$ et $m$ et $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $m$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $m$.",
    "output": "axiom div_mod_spec_div_mod (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m (matita_arithmetics_div_and_mod.div n m) (matita_arithmetics_div_and_mod.mod n m))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_Type1. Låt $x1$ och $x2$ och $x3$ och $x4$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1458$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från element $x_831$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x4$ och $x2$ och element $x_830$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x3$ och $x2$ och $x4$ och element $_z1459$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $Hterm$ och $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_831$ och $x_830$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_831$ och $x_830$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom div_mod_spec_inv_rect_Type1 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1), forall _H1 : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_CProp4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1140$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $x2$ applicerat på $dpi1$ och element $_z1141$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "DPair_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1140 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ cic.prop) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1141 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_rect_Type3. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z984$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$. Then for all functions $_H1$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$, for all functions $_H2$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "axiom Sum_inv_rect_Type3 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z984 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type3) (_H1 : (x_537 : cic.Term univs.Type0 x1) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_537))) -> cic.Term univs.Type3 (P (matita_basics_types.inl x1 x2 x_537))) (_H2 : (x_538 : cic.Term univs.Type0 x2) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P (matita_basics_types.inr x1 x2 x_538))) : cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_ind. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $P$ be a function from elements $_z587$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Let $_H1$ be a function from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$. Let $_H2$ be a function from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$. Then $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom bool_inv_ind (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z587 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H1 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) (_H2 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type2. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_869$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Soit $x_869$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$. Alors $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_869$.",
    "output": "postulate Aop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_869)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp2. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.times$ applicerat på $m$ och $matita_arithmetics_log.log$ applicerat på $p$ och $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_exp.exp$ applicerat på $n$ och $m$.",
    "output": "axiom log_exp2 (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times m (matita_arithmetics_log.log p n)) (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type2_body. Låt $Q_$ vara en funktion från element $_x_338$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $univs.Type2$. Då för alla element $_H_true$ av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_338$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_338$.",
    "output": "Axiom bool_rect_Type2_body : forall Q_ : ((_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2), forall _H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false), forall x_338 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type2 (Q_ x_338) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type0. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_610$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_H_None$ un élément de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Soit $_H_Some$ une fonction des éléments $x_611$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_611$. Alors pour tous les éléments $x_610$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_610$.",
    "output": "Axiom option_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0), forall _H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))), forall x_610 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type0 (Q_ x_610) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_discr. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Let $_e$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $x$ and $y$. Then $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_unit$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_types.match_unit$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z31$ to $P$ and $y$ and $x$.",
    "output": "Axiom unit_discr : forall x : cic.Term univs.Type0 matita_basics_types.unit, forall y : cic.Term univs.Type0 matita_basics_types.unit, forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) x y), cic.Term univs.Type2 (matita_basics_types.match_unit (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (matita_basics_types.match_unit (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 P (fun _z31 => P))) y) x) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_ind. Soit $Q_$ une fonction des éléments $_x_66$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $x_66$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_66$.",
    "output": "Axiom False_ind : forall Q_ : ((_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_66 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_66) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type2. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_inl$ from elements $x_542$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_542$, for all functions $_H_inr$ from elements $x_543$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_543$, for all elements $x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_541$.",
    "output": "Axiom Sum_rect_Type2 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2), forall _H_inl : ((x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))), forall _H_inr : ((x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))), forall x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type2 (Q_ x_541) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_921$.",
    "output": "postulate range_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type3 (Q_ x_921)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp0. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_662$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_DPair$ une fonction des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$. Alors pour tous les éléments $x_662$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_662$.",
    "output": "axiom DPair_rect_CProp0 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_662)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F3_ind_aux. Låt $A1$ och $A2$ och $A3$ vara element av $cic.Univ$ av $univs.Type0$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A2$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $A3$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation3$ applicerat på $A1$ och $A2$ och $A3$. Låt $__$ vara en funktion från element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $__$ från element $a1$ av $cic.Term$ av $univs.Type0$ och $A1$ och element $a2$ av $cic.Term$ av $univs.Type0$ och $A2$ och element $a3$ av $cic.Term$ av $univs.Type0$ och $A3$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $f$ applicerat på $a1$ och $a2$ och $a3$ och $n$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a1$ och $a2$ och $a3$ och element $a1$ av $cic.Term$ av $univs.Type0$ och $A1$ och element $a2$ av $cic.Term$ av $univs.Type0$ och $A2$ och element $a3$ av $cic.Term$ av $univs.Type0$ och $A3$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a1$ och $a2$ och $a3$ och $n$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a1$ och $a2$ och $a3$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $a1$ vara ett element av $cic.Term$ av $univs.Type0$ och $A1$. Låt $a2$ vara ett element av $cic.Term$ av $univs.Type0$ och $A2$. Då för alla element $a3$ av $cic.Term$ av $univs.Type0$ och $A3$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a1$ och $a2$ och $a3$ och $n$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $a1$ och $a2$ och $a3$.",
    "output": "Axiom f3_ind_aux : forall A1 : cic.Univ univs.Type0, forall A2 : cic.Univ univs.Type0, forall A3 : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> (__2 : cic.Term univs.Type0 A3) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall P : cic.Term univs.Type0 (matita_basics_relations.relation3 A1 A2 A3), forall __ : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a1 : cic.Term univs.Type0 A1, forall a2 : cic.Term univs.Type0 A2, forall a3 : cic.Term univs.Type0 A3, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n), cic.Term cic.prop (P a1 a2 a3) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_not_eq. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate lt_to_not_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type1_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_138$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_conj$ une fonction des éléments $x_140$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_139$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_140$ et $x_139$. Alors pour tous les éléments $x_138$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_138$.",
    "output": "Axiom And_rect_Type1_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1), forall _H_conj : ((x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))), forall x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type1 (Q_ x_138) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1422$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ et des éléments $_z1423$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_lists_list.mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "Axiom Aop_inv_rect_CProp1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2), forall P : ((_z1422 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1423 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp1. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $_x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $Q_$ une fonction des éléments $x_34$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_35$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_34$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_refl$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$. Alors pour tous les éléments $x_34$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $x_35$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_34$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_34$ et $x_35$.",
    "output": "axiom eq_rect_CProp1 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_34 : cic.Term univs.Type2 A) -> (_x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_34 : cic.Term univs.Type2 A) (x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) : cic.Term cic.prop (Q_ x_34 x_35)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_CProp4. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1206$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1207$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "postulate Sig_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_prim_prim_pred. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_chebyshev_psi.prim$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_psi.prim$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.",
    "output": "Axiom eq_prim_prim_pred : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Univ$ för $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp3. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_961$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_961$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_961$.",
    "output": "postulate Dop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp0. Låt $Q_$ vara en funktion från element $_x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_78$.",
    "output": "postulate False_rect_CProp0 : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15591. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $eqn0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $n$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $q$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $eqm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.O$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $n$.",
    "output": "axiom let_clause_15591 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp0. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_714$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $x_714$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_714$.",
    "output": "axiom Prod_rect_CProp0 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_714)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type0_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_610$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_H_None$ un élément de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Soit $_H_Some$ une fonction des éléments $x_611$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_611$. Alors pour tous les éléments $x_610$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_610$.",
    "output": "option_rect_Type0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type0) -> _H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_611 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) -> x_610 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type0 (Q_ x_610) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_div. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Då för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_log.log$ applicerat på $p$ och $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $m$.",
    "output": "postulate log_div : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_nat.minus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ltl_nil. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.ltl$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$ and $n$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "ltl_nil : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.ltl A (matita_basics_lists_list.nil A) n) (matita_basics_lists_list.nil A)) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1068. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $permf$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $n$. Soient $i$ et $j$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $lein$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$. Soit $lejn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $j$ et $n$. Soit $a$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.le$ appliqué à $a$ et $n$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a$ et $i$, pour tous les éléments $lean$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $a$ et $n$, pour tous les éléments $fa$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a$ et $i$, pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.le$ appliqué à $b$ et $n$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $b$ et $j$, pour tous les éléments $lebn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $n$, pour tous les éléments $fb$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $b$ et $j$, pour toutes les fonctions $__$ des éléments $i0$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i0$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $f$ appliqué à $i0$ et $n$, pour tous les éléments $injf$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.injn$ appliqué à $f$ et $n$, pour tous les éléments $auto$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $a$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a$ et $i$.",
    "output": "let_clause_1068 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lein : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> lean : cic.Term cic.prop (matita_arithmetics_nat.le a n) -> fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n) -> fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j) -> __ : (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)) -> injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n) -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "pi_1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Comm. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, for all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.aop$ applied to $A$ and $nil$ and $xxx$ and $b$ and $a$.",
    "output": "Axiom comm : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) a b) (matita_arithmetics_bigops.op A nil (matita_arithmetics_bigops.aop A nil xxx) b a)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16004. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $pnm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $m$ och $d$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $c$.",
    "output": "axiom let_clause_16004 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_to_minus. Låt $n$ och $m$ och $p$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.plus$ applicerat på $m$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $p$.",
    "output": "postulate plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp1. Pour tous les éléments $x1$ et $x2$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1290$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1291$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "Prod_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ cic.prop) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_spec_ind_body. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $Q_$ vara en funktion från element $x_971$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_972$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $x_971$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_found_max_spec$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $x_975$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $_n$ och element $x_974$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $x_973$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $_n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $i$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $m$ och $matita_arithmetics_minimization.found_max_spec$ applicerat på $_n$ och $_f$ och $m$ och $x_975$ och $x_974$ och $x_973$, för alla funktioner $_H_not_found_max_spec$ från funktioner $x_976$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $_n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $i$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_minimization.not_found_max_spec$ applicerat på $_n$ och $_f$ och $x_976$, för alla element $x_971$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $x_972$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $x_971$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_971$ och $x_972$.",
    "output": "Axiom max_spec_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop), forall _H_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))), forall _H_not_found_max_spec : ((x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f x_976))), forall x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971), cic.Term cic.prop (Q_ x_971 x_972) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_RC. För alla element $A$ och $B$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.bi_relation$ applicerat på $A$ och $B$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_relations.bi_relation$ applicerat på $A$ och $B$.",
    "output": "bi_RC : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_not. Soient $A$ et $B$ des éléments de $cic.Univ$ de $cic.prop$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.iff$ appliqué à $A$ et $B$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.iff$ appliqué à $matita_basics_logic.Not$ appliqué à $A$ et $matita_basics_logic.Not$ appliqué à $B$.",
    "output": "axiom iff_not (A B : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Not A) (matita_basics_logic.Not B))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__op. Soit $x0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x1$ un élément de $cic.Term$ de $univs.Type0$ et de $x0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x3$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $matita_basics_lists_list.Aop$ appliqué à $x0$ et $x1$ et $x2$, pour tous les éléments $_x_807$ et $_x_808$ de $cic.Term$ de $univs.Type0$ et de $x0$, $cic.Term$ tient pour $univs.Type0$ et $x0$.",
    "output": "Axiom dpi1__o__op : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1)) -> cic.Univ univs.Type0), forall x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2), forall _x_807 : cic.Term univs.Type0 x0, forall _x_808 : cic.Term univs.Type0 x0, cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp0. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_885$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_885$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_885$.",
    "output": "Axiom Aop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_885) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_f. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type2$. Då för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type2$ och $A$ till element av $cic.Term$ av $univs.Type2$ och $B$, för alla element $x$ och $y$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $x$ och $y$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $B$ och $f$ applicerat på $x$ och $f$ applicerat på $y$.",
    "output": "postulate eq_f : (A : cic.Univ univs.Type2) -> (B : cic.Univ univs.Type2) -> (f : (__ : cic.Term univs.Type2 A) -> cic.Term univs.Type2 B) -> (x : cic.Term univs.Type2 A) -> (y : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term cic.prop (matita_basics_logic.eq B (f x) (f y))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length. För alla element $H$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.",
    "output": "postulate length : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_n_elim. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $P$ une fonction des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $__1$ une fonction des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $n$.",
    "output": "lt_O_n_elim : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> __1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_pi. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $m$.",
    "output": "axiom exp_pi (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_exp.exp (f i) m)) (matita_arithmetics_exp.exp (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => f i)) m))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Notb_notb. Pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_basics_bool.notb$ appliqué à $matita_basics_bool.notb$ appliqué à $b$ et $b$.",
    "output": "postulate notb_notb : (b : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.notb (matita_basics_bool.notb b)) b)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1585. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $m$ och $n$. Då för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $auto$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $m$, för alla element $auto'$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $d$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $n$.",
    "output": "Axiom let_clause_1585 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m), forall auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ltl_nil. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.ltl$ appliqué à $A$ et $matita_basics_lists_list.nil$ appliqué à $A$ et $n$ et $matita_basics_lists_list.nil$ appliqué à $A$.",
    "output": "postulate ltl_nil : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.ltl A (matita_basics_lists_list.nil A) n) (matita_basics_lists_list.nil A))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type4. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1638$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H1$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ et des éléments $_z1639$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.range$ appliqué à $x1$ et $Hterm$ et $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$, $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.",
    "output": "axiom range_inv_rect_Type4 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1638 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type4) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1639 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type0_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_142$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_H_conj$ une fonction des éléments $x_144$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_143$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_144$ et $x_143$. Soit $x_142$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$. Alors $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_142$.",
    "output": "And_rect_Type0_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type0) -> _H_conj : (x_144 : cic.Term cic.prop _A -> x_143 : cic.Term cic.prop _B -> cic.Term univs.Type0 (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) -> x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type0 (Q_ x_142) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$ to elements of $cic.Univ$ of $univs.Type2$. Let $_H_refl$ be an element of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$. Let $x_13$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $x_14$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$. Then $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_13$ and $x_14$.",
    "output": "Axiom eq_rect_Type2 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_13 : cic.Term univs.Type2 A) -> (_x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) -> cic.Univ univs.Type2), forall _H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x)), forall x_13 : cic.Term univs.Type2 A, forall x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13), cic.Term univs.Type2 (Q_ x_13 x_14) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type2. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1122$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H1$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $x2$ applicerat på $dpi1$ och element $_z1123$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$, håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom DPair_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1122 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1123 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1596$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1597$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1596 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1597 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type0_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_901$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_901$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_901$.",
    "output": "axiom ACop_rect_Type0_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nth_prime_body. Soit $__$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.",
    "output": "nth_prime_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp3. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_622$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_None$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_623$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_623$, för alla element $x_622$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_622$.",
    "output": "postulate option_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_623 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))) -> (x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_622)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n3. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $n$ och $matita_arithmetics_nat.pred$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.",
    "output": "Axiom le_prim_n3 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_Type4. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Let $P$ be a function from elements $_z912$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type4$. Let $_H1$ be a function from elements $_z913$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.it$. Then $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_Type4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z912 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type4) -> _H1 : (_z913 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term univs.Type4 (P matita_basics_types.it)) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le. Soient $b$ et $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $b$ et $n$ et $matita_arithmetics_exp.exp$ appliqué à $b$ et $m$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n$ et $m$.",
    "output": "le_exp_to_le : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type1_body. Soit $Q_$ une fonction des éléments $_x_385$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_O$ un élément de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$. Alors pour toutes les fonctions $_H_S$ des éléments $x_386$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_388$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $x_386$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_386$, pour tous les éléments $x_385$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_385$.",
    "output": "postulate nat_rect_Type1_body : (Q_ : (_x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type1) -> (_H_O : cic.Term univs.Type1 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_388 : cic.Term univs.Type1 (Q_ x_386)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_nat.S x_386))) -> (x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type1 (Q_ x_385)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort), forall case_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_void. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $return_sort$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_void : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ return_sort) -> z : cic.Term univs.Type0 matita_basics_types.void -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_1_fact. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_factorial.fact$ appliqué à $n$.",
    "output": "le_1_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_factorial.fact n)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type1. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_546$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type1$. Då för alla funktioner $_H_inl$ från element $x_547$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_547$, för alla funktioner $_H_inr$ från element $x_548$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_548$, för alla element $x_546$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_546$.",
    "output": "postulate Sum_rect_Type1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1) -> (_H_inl : (x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))) -> (_H_inr : (x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))) -> (x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type1 (Q_ x_546)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_DPair. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $return_sort$. Låt $return$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$. Då för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "Axiom filter_DPair : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n$ et $n$.",
    "output": "axiom le_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le n n)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type1_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_899$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_899$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_899$.",
    "output": "axiom ACop_rect_Type1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type1 (Q_ x_899)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type1. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_741$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$, pour tous les éléments $_H_nil$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $_H_cons$ des éléments $x_743$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_742$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_745$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $x_742$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_743$ et $x_742$, pour tous les éléments $x_741$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_741$.",
    "output": "list_rect_Type1 : _A : cic.Univ univs.Type0 -> Q_ : (_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type1) -> _H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_743 : cic.Term univs.Type0 _A -> x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_745 : cic.Term univs.Type1 (Q_ x_742) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))) -> x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type1 (Q_ x_741) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_rem_eq. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_basics_types.snd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$.",
    "output": "axiom ord_rem_eq (n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord_rem n p) (matita_basics_types.snd matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord n p)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_CProp3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $cic.prop$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1212$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H1$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $x2$ applicerat på $pi1$ och element $_z1213$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "axiom Sig_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp0. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1428$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ et des éléments $_z1429$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_lists_list.mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "axiom Aop_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) (P : (_z1428 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1429 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus_m_m. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $m$.",
    "output": "plus_minus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unique_body. För alla element $H$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, håller $cic.Univ$ för $cic.prop$.",
    "output": "postulate unique_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_not_divides_fact. Let $p$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "prime_to_not_divides_fact : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R2. Låt $T0$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $a0$ vara ett element av $cic.Term$ av $univs.Type0$ och $T0$. Låt $T1$ vara en funktion från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ till element av $cic.Univ$ av $univs.Type0$. Låt $a1$ vara ett element av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$. Låt $T2$ vara en funktion från element $x0$ av $cic.Term$ av $univs.Type0$ och $T0$ och element $p0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $x0$ och element $x1$ av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $x0$ och $p0$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $x0$ och $p0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $x0$ och $p0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$. Låt $_a2$ vara ett element av $cic.Term$ av $univs.Type0$ och $T2$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $a0$ och $matita_basics_logic.refl$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $a1$. Låt $b0$ vara ett element av $cic.Term$ av $univs.Type0$ och $T0$. Låt $e0$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $b0$. Låt $b1$ vara ett element av $cic.Term$ av $univs.Type0$ och $T1$ applicerat på $b0$ och $e0$. Då för alla element $e1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T1$ applicerat på $b0$ och $e0$ och $matita_basics_logic.R1$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $T0$ och $a0$ och $T1$ och $a1$ och $b0$ och $e0$ och $b1$, håller $cic.Term$ för $univs.Type0$ och $T2$ applicerat på $b0$ och $e0$ och $b1$ och $e1$.",
    "output": "R2 : T0 : cic.Univ univs.Type0 -> a0 : cic.Term univs.Type0 T0 -> T1 : (x0 : cic.Term univs.Type0 T0 -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0) -> cic.Univ univs.Type0) -> a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0)) -> T2 : (x0 : cic.Term univs.Type0 T0 -> p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0) -> x1 : cic.Term univs.Type0 (T1 x0 p0) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1) -> cic.Univ univs.Type0) -> _a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1)) -> b0 : cic.Term univs.Type0 T0 -> e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0) -> b1 : cic.Term univs.Type0 (T1 b0 e0) -> e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 b0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 b0 e0) b1) -> cic.Term univs.Type0 (T2 b0 e0 b1 e1) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "match_Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ return_sort) -> case_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type4_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_917$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type4$. Alors pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_917$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_917$.",
    "output": "axiom range_rect_Type4_body (_A : cic.Univ univs.Type0) (Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type4 (Q_ x_917)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_add. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $l1$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Then for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $x$ and $l2$.",
    "output": "postulate Exists_add : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (x : cic.Term univs.Type0 A) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nil_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "axiom nil_to_nil (A : cic.Univ univs.Type0) (l1 l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type2_body. Let $Q_$ be a function from elements $_x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$. Let $_H_O$ be an element of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.O$. Then for all functions $_H_S$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_384$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, for all elements $x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_381$.",
    "output": "axiom nat_rect_Type2_body (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type2 (Q_ x_381)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp2_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_31$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_32$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_31$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_refl$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Då för alla element $x_31$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_32$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_31$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_31$ och $x_32$.",
    "output": "postulate eq_rect_CProp2_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_31 : cic.Term univs.Type2 A) -> (x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Term cic.prop (Q_ x_31 x_32)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_pi_p_M1. Soient $m$ et $i$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_bigops.bigop$ appliqué à $i$ et la fonction qui envoie $p$ à $matita_basics_bool.andb$ appliqué à $matita_arithmetics_nat.leb$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $p$ et $matita_arithmetics_primes.primeb$ appliqué à $p$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $p$ à $p$ et $matita_arithmetics_binomial.M$ appliqué à $m$.",
    "output": "divides_pi_p_M1 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => p)) (matita_arithmetics_binomial.M m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_l. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b2$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b1$.",
    "output": "postulate lstar_ind_l : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b1)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3. Soient $_n$ et $_m$ et $_q$ et $_r$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $Q_$ une fonction des éléments $_x_845$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_847$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_846$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_847$ et $x_846$. Alors pour tous les éléments $x_845$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_845$.",
    "output": "axiom div_mod_spec_rect_CProp3 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H_refl$ be an element of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$. Let $x_16$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Then for all elements $x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.",
    "output": "postulate eq_rect_Type1_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) -> (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_16 : cic.Term univs.Type2 A) -> (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Term univs.Type1 (Q_ x_16 x_17)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_not_eq. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $m$.",
    "output": "postulate lt_to_not_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp3. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_799$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_799$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_799$.",
    "output": "Aop_rect_CProp3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_799) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_ind_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $Q_$ be a function from elements $_x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_div_mod_spec_intro$ be a function from elements $x_811$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_810$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$. Then for all elements $x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_809$.",
    "output": "Axiom div_mod_spec_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))), forall x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_809) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_iso. Let $n1$ and $n2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p1$ and $p2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $op$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$. Let $f1$ and $f2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f2$ applied to $i$.",
    "output": "bigop_iso : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil) -> f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> __ : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p1 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f1 i)) (matita_arithmetics_bigops.bigop n2 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p2 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f2 i))) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type4. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $_x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $Q_$ une fonction des éléments $x_4$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_5$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_4$ à des éléments de $cic.Univ$ de $univs.Type4$. Alors pour tous les éléments $_H_refl$ de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$, pour tous les éléments $x_4$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $x_5$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_4$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_4$ et $x_5$.",
    "output": "axiom eq_rect_Type4 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_4 : cic.Term univs.Type2 A) -> (_x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Univ univs.Type4) (_H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x))) (x_4 : cic.Term univs.Type2 A) (x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) : cic.Term univs.Type4 (Q_ x_4 x_5)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_d_times_gcd. Let $m$ and $n$ and $d$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $m$. Then for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$.",
    "output": "postulate divides_d_times_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd n m)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_ind. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_R$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$. Låt $Q_$ vara en funktion från element $x_1337$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $x_1336$ av $cic.Term$ av $univs.Type0$ och $B$ och element $x_1335$ av $cic.Term$ av $univs.Type0$ och $B$ och element $_x_1338$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $_R$ och $x_1337$ och $x_1336$ och $x_1335$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_lstar_r_O$ vara en funktion från element $b$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.O$ och $b$ och $b$ och $matita_arithmetics_lstar.lstar_r_O$ applicerat på $B$ och $_R$ och $b$. Låt $_H_lstar_r_S$ vara en funktion från element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $b1$ av $cic.Term$ av $univs.Type0$ och $B$ och element $b$ av $cic.Term$ av $univs.Type0$ och $B$ och element $x_1340$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $cic.Term$ av $univs.Type0$ och $B$ och element $x_1339$ av $cic.Term$ av $cic.prop$ och $_R$ applicerat på $b$ och $b2$ och element $_x_1342$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $l$ och $b1$ och $b$ och $x_1340$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$ och $b2$ och $matita_arithmetics_lstar.lstar_r_S$ applicerat på $B$ och $_R$ och $l$ och $b1$ och $b$ och $x_1340$ och $b2$ och $x_1339$. Låt $x_1337$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $x_1336$ och $x_1335$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $x_1338$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $_R$ och $x_1337$ och $x_1336$ och $x_1335$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_1337$ och $x_1336$ och $x_1335$ och $x_1338$.",
    "output": "axiom lstar_r_ind (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop) (_H_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) (_H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))) (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_1336 x_1335 : cic.Term univs.Type0 B) (x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) : cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp1_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_965$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_Dop$ vara en funktion från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$. Låt $x_965$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_965$.",
    "output": "Axiom Dop_rect_CProp1_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_965) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ex2_intro. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $P$ and $Q$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $x$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $Q$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $P$ and $Q$.",
    "output": "postulate ex2_intro : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P x)) -> (__1 : cic.Term cic.prop (Q x)) -> cic.Term cic.prop (matita_basics_logic.ex2 A P Q)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_939$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$, för alla element $x_939$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_939$.",
    "output": "postulate range_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_939)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1078. Soient $a$ et $b$ et $q$ et $r$ et $q1$ et $r1$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $a$ et $b$ et $q$ et $r$. Soit $ltrb$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $r$ et $b$. Soit $spec$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $a$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $q$ et $b$ et $r$. Soit $_clearme0$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $a$ et $b$ et $q1$ et $r1$. Alors pour tous les éléments $ltr1b$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $r1$ et $b$, pour tous les éléments $spec1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $a$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $q1$ et $b$ et $r1$, pour tous les éléments $leqq1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $q$ et $q1$, pour tous les éléments $ltqq1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $q$ et $q1$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $a$ et $matita_arithmetics_nat.plus$ appliqué à $r$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $q$.",
    "output": "Axiom let_clause_1078 : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r), forall ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b), forall spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r)), forall _clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1), forall ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b), forall spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1)), forall leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1), forall ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp4_body. Låt $Q_$ vara en funktion från element $_x_347$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_347$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_347$.",
    "output": "axiom bool_rect_CProp4_body (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_347)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_inv_rect_CProp1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$. Soit $P$ une fonction des éléments $_z1356$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.nil$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.nil$ appliqué à $x1$. Soit $_H2$ une fonction des éléments $x_773$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $x_772$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ et des fonctions $_x_775$ des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $x_772$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x_772$ et des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_773$ et $x_772$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_773$ et $x_772$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "axiom list_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1374$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$. Let $_H1$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1375$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Then $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1374 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ univs.Type4) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1375 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type4 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "Prod_rect_CProp3 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_708) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_discr. Let $a1$ be an element of $cic.Univ$ of $univs.Type0$. Let $a2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $univs.Type0$. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $a1$ and $a2$. Then for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_DPair$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_DPair$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z41$ to $P$ and $y$ and $x$.",
    "output": "Axiom DPair_discr : forall a1 : cic.Univ univs.Type0, forall a2 : ((__ : cic.Term univs.Type0 a1) -> cic.Univ univs.Type0), forall x : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((fun x0 => fun p0 => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (fun x0 => fun p0 => a2 x0) t1 u0 e0) u1) (fun _e1 => P))) (fun _z41 => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_n_mod_n. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $p$.",
    "output": "Axiom congruent_n_mod_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n p) p) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp2. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1614$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $b$ et $a$ et des éléments $_z1615$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "ACop_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1614 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1615 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_ind. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Let $P$ be a function from elements $_z906$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H1$ from elements $_z907$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom unit_inv_ind (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z906 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H1 : (_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_n_O. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $matita_arithmetics_nat.O$.",
    "output": "axiom divides_n_O (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_primes.divides n matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type1. Let $Q_$ be a function from elements $_x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H_O$ be an element of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.O$. Then for all functions $_H_S$ from elements $x_386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_388$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_386$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_386$, for all elements $x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_385$.",
    "output": "Axiom nat_rect_Type1 : forall Q_ : ((_x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type1), forall _H_O : cic.Term univs.Type1 (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_388 : cic.Term univs.Type1 (Q_ x_386)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_nat.S x_386))), forall x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type1 (Q_ x_385) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp3_body. Soit $Q_$ une fonction des éléments $_x_75$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $x_75$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_75$.",
    "output": "axiom False_rect_CProp3_body (Q_ : (_x_75 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_75 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_75)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_939$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_939$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_939$.",
    "output": "axiom range_rect_CProp0 (_A : cic.Univ univs.Type0) (Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_939)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_ind_plus. Soit $R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.predicate$ appliqué à $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $matita_arithmetics_nat.O$. Alors pour toutes les fonctions $__1$ des éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $R$ appliqué à $n$.",
    "output": "postulate nat_ind_plus : (R : cic.Term univs.Type0 (matita_basics_relations.predicate matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (R matita_arithmetics_nat.O)) -> (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (R n)) -> cic.Term cic.prop (R (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_895$.",
    "output": "ACop_rect_Type3_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type3) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type3 (Q_ x_895) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_plus_l. Soient $x$ et $y$ et $z$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $x$ et $y$ et $z$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.le$ appliqué à $x$ et $matita_arithmetics_nat.minus$ appliqué à $z$ et $y$ et $matita_arithmetics_nat.le$ appliqué à $y$ et $z$.",
    "output": "axiom le_inv_plus_l (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_BPsi1. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_chebyshev_factorization.B$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $n$.",
    "output": "axiom le_Psi_BPsi1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1569. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Let $posm$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Let $pnm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Let $c$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Let $d$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Let $H$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_1569 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_sigma_pi_SO_n. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $matita_basics_bool.true$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $i$ som $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.",
    "output": "Axiom eq_sigma_pi_SO_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp1. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_853$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_855$ and $x_854$, for all elements $x_853$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_853$.",
    "output": "div_mod_spec_rect_CProp1 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_853) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound5. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_upper_bound5 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1617. Let $p$ and $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$. Let $gcd1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Then for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $a$ and $matita_arithmetics_nat.times$ applied to $m$ and $b$.",
    "output": "Axiom let_clause_1617 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))), forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)), forall H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp0. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_913$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$. Då för alla element $x_913$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_913$.",
    "output": "Axiom ACop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_913) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_787$.",
    "output": "Aop_rect_Type3_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type3) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type3 (Q_ x_787) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_le_to_lt. För alla element $n$ och $m$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $p$.",
    "output": "Axiom lt_to_le_to_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m p), cic.Term cic.prop (matita_arithmetics_nat.lt n p) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_O_to_not_divides. Let $p$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$. Then for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "Axiom ord_O_to_not_divides : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_sigma. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p1$ and $p2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $g1$ and $g2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "axiom le_sigma (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (λ i => p1 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => g1 i)) (matita_arithmetics_bigops.bigop n (λ i => p2 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => g2 i)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_S. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $R$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$. Låt $b1$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $B$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $R$ applicerat på $b1$ och $b$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $b2$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$ och $b2$.",
    "output": "axiom lstar_S (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 b : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (R b1 b)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b2 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_ACop$ be a function from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_907$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_907$.",
    "output": "ACop_rect_CProp3_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_907) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15625. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Alors pour tous les éléments $pnm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $d$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $m$ et $d$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $c$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15625 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Sig. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$. Let $case_mk_Sig$ be a function from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$. Then for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (case_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term return_sort (return_type (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Psi_3. $cic.Term$ håller för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.",
    "output": "Axiom Psi_3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp4. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_100$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_nmk$ vara en funktion från funktioner $x_101$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_101$. Då för alla element $x_100$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_100$.",
    "output": "postulate Not_rect_CProp4 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp0. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_688$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_688$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_688$.",
    "output": "Sig_rect_CProp0 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_688) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Dop. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $nil$, för alla funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $nil$ och $nil$, för alla funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $nil$.",
    "output": "postulate mk_Dop : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a nil) nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A nil sum b c)) (matita_arithmetics_bigops.aop__o__op A nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_Type2. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $P$ vara en funktion från element $_z605$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $univs.Type2$. Låt $_H1$ vara en funktion från element $_z606$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.true$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_basics_bool.true$. Låt $_H2$ vara en funktion från element $_z606$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.false$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_basics_bool.false$. Då håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $Hterm$.",
    "output": "axiom bool_inv_rect_Type2 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z605 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) (_H1 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type2 (P matita_basics_bool.true)) (_H2 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type2 (P matita_basics_bool.false)) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Hint_declaration_CProp1. Let $A$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $_a$ and $_b$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom hint_declaration_CProp1 (A : cic.Univ cic.prop) (_a _b : cic.Term cic.prop A) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp3. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_708$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Prod$ une fonction des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$. Soit $x_708$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_708$.",
    "output": "Axiom Prod_rect_CProp3 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_708) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp3. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_799$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Soit $x_799$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_799$.",
    "output": "Axiom Aop_rect_CProp3 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_799) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_n_to_le. Låt $h$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $k$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $h$ och $n$. Låt $__2$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $k$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $h$ applicerat på $m$ och $m$. Låt $j$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__3$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $j$. Låt $__4$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $h$ applicerat på $j$.",
    "output": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Op. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $_xxx$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $nil$, för alla element $_x_807$ och $_x_808$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $univs.Type0$ och $A$.",
    "output": "Axiom op : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall _xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall _x_807 : cic.Term univs.Type0 A, forall _x_808 : cic.Term univs.Type0 A, cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$. Then for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.",
    "output": "DPair_rect_Type3 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type3) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type3 (Q_ x_644) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1013. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ och $m$ och $i$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Hind$ vara en funktion från element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.max$ applicerat på $i$ och $f$ och $m$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $m$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.O$. Låt $fi$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.true$. Låt $eqm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $i$ och $m$. Då för alla element $fm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $m$ och $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_basics_bool.false$ och $matita_basics_bool.true$.",
    "output": "axiom let_clause_1013 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max i f) m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) (fi : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i m)) (fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp3. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_622$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_None$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Soit $_H_Some$ une fonction des éléments $x_623$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_623$. Alors pour tous les éléments $x_622$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_622$.",
    "output": "option_rect_CProp3 : _A : cic.Univ univs.Type0 -> Q_ : (_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_623 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))) -> x_622 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_622) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lhd. Pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $H$, pour tous les éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_lists_list.list$ appliqué à $H$.",
    "output": "postulate lhd : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Proj2. För alla element $A$ och $B$ av $cic.Univ$ av $cic.prop$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $A$ och $B$, håller $cic.Term$ för $cic.prop$ och $B$.",
    "output": "postulate proj2 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop B"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Dop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_Dop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type2. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_923$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_mk_range$ une fonction des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$. Soit $x_923$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$. Alors $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_923$.",
    "output": "Axiom range_rect_Type2 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type2 (Q_ x_923) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Compose. Låt $A$ och $B$ och $C$ vara element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$. Då för alla funktioner $_g$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $_x$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $univs.Type0$ och $C$.",
    "output": "postulate compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_x : cic.Term univs.Type0 A) -> cic.Term univs.Type0 C"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1620$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1621$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "axiom ACop_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type3. Let $Q_$ be a function from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_true$ be an element of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$. Let $_H_false$ be an element of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$. Let $x_335$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.",
    "output": "bool_rect_Type3 : Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false) -> x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3 (Q_ x_335) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1080$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1081$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_623$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1081$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_623$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_623$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "option_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1080 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ cic.prop) -> _H1 : (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> _H2 : (x_623 : cic.Term univs.Type0 x1 -> _z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_623)) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_to_le_min. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $n$ and $m$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.",
    "output": "true_to_le_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type0. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1134$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1135$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $Hterm$.",
    "output": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1416$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1417$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1416 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1417 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp2. Låt $Q_$ vara en funktion från element $_x_492$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x_492$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_492$.",
    "output": "Axiom void_rect_CProp2 : forall Q_ : ((_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_492 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_492) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type1_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_953$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_mk_Dop$ une fonction des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$. Alors pour tous les éléments $x_953$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_953$.",
    "output": "Dop_rect_Type1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type1 (Q_ x_953) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_eq. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split$ applied to $A$ and $l$ and $n$ and $matita_basics_types.snd$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split$ applied to $A$ and $l$ and $n$.",
    "output": "postulate split_eq : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter. Let $T$ be an element of $cic.Univ$ of $univs.Type0$. Let $_p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $_l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.",
    "output": "axiom filter (T : cic.Univ univs.Type0) (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) : cic.Term univs.Type0 (matita_basics_lists_list.list T)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$. Let $P$ be a function from elements $_z1092$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$. Let $_H1$ be a function from elements $_z1093$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$. Let $_H2$ be a function from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1093$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_631$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_631$. Then $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate option_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1092 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_631 : cic.Term univs.Type0 x1) -> (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_631))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_631))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_ind_body. Pour tous les éléments $_n$ et $_m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Q_$ des éléments $_x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_quotient$ des éléments $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1193$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_m$ et $matita_arithmetics_nat.times$ appliqué à $_n$ et $q$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_primes.quotient$ appliqué à $_n$ et $_m$ et $q$ et $x_1193$, pour tous les éléments $x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_1192$.",
    "output": "axiom divides_ind_body (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term cic.prop (Q_ x_1192)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_list. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $return_sort$. Soit $case_nil$ un élément de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$. Soit $case_cons$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $__$ et $__1$. Soit $z$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$. Alors $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "postulate match_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (case_nil : cic.Term return_sort (return_type (matita_basics_lists_list.nil _A))) -> (case_cons : (__ : cic.Term univs.Type0 _A) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type (matita_basics_lists_list.cons _A __ __1))) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_mk_ACop$ be a function from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Then for all elements $x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_895$.",
    "output": "axiom ACop_rect_Type3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type3) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type3 (Q_ x_895)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Checker_spec. Let $tl$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $l$ and $matita_basics_bool.true$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$ and $l$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $tl$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $tl$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$.",
    "output": "axiom checker_spec (tl : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker l) matita_basics_bool.true)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) l (matita_basics_lists_list.cons matita_arithmetics_nat.nat a tl))) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p tl)) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$. Låt $case_mk_Aop$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Då för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "axiom match_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type2_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_602$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_None$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_603$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_603$, for all elements $x_602$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_602$.",
    "output": "Axiom option_rect_Type2_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2), forall _H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))), forall x_602 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type2 (Q_ x_602) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp2. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_909$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_909$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_909$.",
    "output": "Axiom ACop_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_909) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_max_n. Pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_minimization.max$ appliqué à $n$ et $f$ et $n$.",
    "output": "axiom le_max_n (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type4_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_917$.",
    "output": "range_rect_Type4_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type4) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type4 (Q_ x_917) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Compare_append. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $l1$ och $l2$ och $l3$ och $l4$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $l2$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l3$ och $l4$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_basics_lists_list.list$ applicerat på $A$ och funktionen som avbildar $l$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l1$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l3$ och $l$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l4$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l$ och $l2$ och $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l3$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $l$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l2$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l$ och $l4$.",
    "output": "compare_append : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.append A l3 l4)) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A l3 l)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l4 (matita_basics_lists_list.append A l l2))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 (matita_basics_lists_list.append A l1 l)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A l l4))))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type0. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_901$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$. Då för alla element $x_901$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_901$.",
    "output": "axiom ACop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_mp. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ and $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ to elements of $cic.Term$ of $cic.prop$ and $Q$ applied to $a$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $Q$ and $l$.",
    "output": "postulate All_mp : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P a)) -> cic.Term cic.prop (Q a)) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> cic.Term cic.prop (matita_basics_lists_list.All A Q l)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type1_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$. Alors pour tous les éléments $_H_None$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_607$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_607$, pour tous les éléments $x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_606$.",
    "output": "axiom option_rect_Type1_body (_A : cic.Univ univs.Type0) (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type1 (Q_ x_606)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Invert_permut. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__2$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.",
    "output": "axiom invert_permut (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max. Assume that $Sort$. Then if $Sort$, then $Sort$.",
    "output": "Axiom max : Sort -> Sort -> Sort ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_leb_true. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.true$.",
    "output": "le_to_leb_true : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Not. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_nmk$ från funktioner $__$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $__$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "axiom match_Not (_A : cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) (z : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_DPair. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $return_sort$ un élément de $cic.Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $case_mk_DPair$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "postulate match_DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) -> (case_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term return_sort (return_type (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp3. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_761$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_nil$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_763$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_762$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_765$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_762$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_763$ och $x_762$, för alla element $x_761$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_761$.",
    "output": "postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "StreicherK. Låt $T$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $t$ vara ett element av $cic.Term$ av $univs.Type2$ och $T$. Då för alla funktioner $P$ från element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $T$ och $t$ och $t$ till element av $cic.Univ$ av $univs.Type2$, för alla element $__$ av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_basics_logic.refl$ applicerat på $T$ och $t$, för alla element $p$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $T$ och $t$ och $t$, håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $p$.",
    "output": "postulate streicherK : (T : cic.Univ univs.Type2) -> (t : cic.Term univs.Type2 T) -> (P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t))) -> (p : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Term univs.Type2 (P p)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_n_mod_times. Låt $n$ och $m$ och $p$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $p$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_congruence.congruent$ applicerat på $n$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $p$ och $p$.",
    "output": "postulate congruent_n_mod_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_CProp1. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$. Alors pour toutes les fonctions $P$ des éléments $_z960$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z961$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "unit_inv_rect_CProp1 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1553. Let $n$ and $n0$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$. Let $Hn$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $a$.",
    "output": "postulate let_clause_1553 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.plus a (matita_arithmetics_nat.S a)))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type2. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_897$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_897$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_897$.",
    "output": "ACop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type2) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type2 (Q_ x_897) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bc_n_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_binomial.bc$ appliqué à $n$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "postulate bc_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Sig. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $pi1$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $_pi2$ vara ett element av $cic.Term$ av $cic.prop$ och $f$ applicerat på $pi1$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $f$.",
    "output": "mk_Sig : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (f pi1) -> cic.Term univs.Type0 (matita_basics_types.Sig A f) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_smallest_factor_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_primes.smallest_factor$ appliqué à $n$ et $n$.",
    "output": "postulate le_smallest_factor_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_primes.smallest_factor n) n)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_861$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Då för alla element $x_861$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_861$.",
    "output": "Axiom Aop_ind_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_861) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp2_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_881$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Soit $x_881$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_881$.",
    "output": "axiom Aop_rect_CProp2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_881)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_n_n. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $n$ och $matita_arithmetics_nat.O$.",
    "output": "Axiom mod_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_previous_prime4 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type3_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_895$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_895$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_895$.",
    "output": "ACop_rect_Type3_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type3) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type3 (Q_ x_895) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B_SSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom B_SSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_max_f_max_g. Låt $f$ och $g$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $__$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $i$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $g$ applicerat på $i$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_minimization.max$ applicerat på $n$ och $f$ och $matita_arithmetics_minimization.max$ applicerat på $n$ och $g$.",
    "output": "le_max_f_max_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp4_body. Pour toutes les fonctions $Q_$ des éléments $_x_509$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_it$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_509$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_509$.",
    "output": "unit_rect_CProp4_body : Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H_it : cic.Term cic.prop (Q_ matita_basics_types.it) -> x_509 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop (Q_ x_509) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp2_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_909$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$. Låt $x_909$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_909$.",
    "output": "axiom ACop_rect_CProp2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_909)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_S_to_permut. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $m$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $matita_arithmetics_nat.S$ appliqué à $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $matita_arithmetics_nat.S$ appliqué à $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à $f$ et $m$.",
    "output": "axiom permut_S_to_permut (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m))) : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type2_body. Soit $Q_$ une fonction des éléments $_x_48$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_I$ un élément de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_logic.I$. Soit $x_48$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_48$.",
    "output": "axiom True_rect_Type2_body (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) (x_48 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type2 (Q_ x_48)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_ind. Soient $x1$ et $x2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $x1$ et $x2$. Alors pour toutes les fonctions $P$ des éléments $_z724$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z725$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2$ et $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_419$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $x1$ et $m$ et des fonctions $_x_421$ des éléments $_z725$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $m$ et des éléments $_z725$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2$ et $matita_arithmetics_nat.S$ appliqué à $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $x2$.",
    "output": "axiom le_inv_ind (x1 x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_Hterm : cic.Term cic.prop (matita_arithmetics_nat.le x1 x2)) (P : (_z724 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H1 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 x1)) -> cic.Term cic.prop (P x1)) (_H2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_419 : cic.Term cic.prop (matita_arithmetics_nat.le x1 m)) -> (_x_421 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 m)) -> cic.Term cic.prop (P m)) -> (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) : cic.Term cic.prop (P x2)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10332. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $le_n$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Alors pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.",
    "output": "Axiom let_clause_10332 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_exp1. Let $p$ and $n$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$.",
    "output": "p_ord_to_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_add. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $l1$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Alors pour tous les éléments $x$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $l2$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $matita_basics_lists_list.cons$ appliqué à $A$ et $x$ et $l2$.",
    "output": "Exists_add : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> x : cic.Term univs.Type0 A -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2)) -> cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_ind. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1566$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1567$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "axiom ACop_inv_ind (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1566 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1567 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp3_body. För alla funktioner $Q_$ från element $_x_491$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $cic.prop$, för alla element $x_491$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_491$.",
    "output": "Axiom void_rect_CProp3_body : forall Q_ : ((_x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_491 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_491) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_73. Soient $n$ et $m$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posp$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$. Soient $x134$ et $x135$ et $x136$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.plus$ appliqué à $x134$ et $matita_arithmetics_nat.plus$ appliqué à $x135$ et $x136$ et $matita_arithmetics_nat.plus$ appliqué à $x135$ et $matita_arithmetics_nat.plus$ appliqué à $x134$ et $x136$.",
    "output": "let_clause_73 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1506$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1507$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom Aop_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound1. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type4_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_917$.",
    "output": "Axiom range_rect_Type4_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type4 (Q_ x_917) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_ind. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z972$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $x_522$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z973$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_522$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_522$. Soit $_H2$ une fonction des éléments $x_523$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z973$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_523$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_523$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "postulate Sum_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z972 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_522 : cic.Term univs.Type0 x1) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_522))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_522))) -> (_H2 : (x_523 : cic.Term univs.Type0 x2) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Prod. För alla element $A$ och $B$ av $cic.Univ$ av $univs.Type0$, för alla element $_fst$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $_snd$ av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$.",
    "output": "axiom mk_Prod (A B : cic.Univ univs.Type0) (_fst : cic.Term univs.Type0 A) (_snd : cic.Term univs.Type0 B) : cic.Term univs.Type0 (matita_basics_types.Prod A B)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp1. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_712$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_mk_Prod$ une fonction des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$. Alors pour tous les éléments $x_712$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_712$.",
    "output": "axiom Prod_rect_CProp1 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_712)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Sig$ be a function from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$. Then for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.",
    "output": "Sig_rect_CProp2 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_684) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_to_eq2. Soient $a$ et $b$ et $q$ et $r$ et $q1$ et $r1$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $a$ et $b$ et $q$ et $r$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $a$ et $b$ et $q1$ et $r1$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $r$ et $r1$.",
    "output": "axiom div_mod_spec_to_eq2 (a b q r q1 r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) (__1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r r1)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $nil$, pour tous les éléments $_x_969$ et $_x_970$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $univs.Type0$ et $A$.",
    "output": "prod : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> _x_969 : cic.Term univs.Type0 A -> _x_970 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_CProp4. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$. Alors pour toutes les fonctions $P$ des éléments $_z1140$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1141$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.",
    "output": "DPair_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1140 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ cic.prop) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1141 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type4. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$. Soit $P$ une fonction des éléments $_z1638$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H1$ une fonction des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ et des éléments $_z1639$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.range$ appliqué à $x1$ et $Hterm$ et $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$. Alors $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.",
    "output": "range_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1638 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ univs.Type4) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1639 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1530$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1531$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "axiom Aop_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1530 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type0) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1531 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_times. Let $n$ and $m$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "axiom divides_times (n m p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp1. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_630$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_None$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$. Låt $_H_Some$ vara en funktion från element $x_631$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_631$. Då för alla element $x_630$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_630$.",
    "output": "postulate option_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) -> (x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_630)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type2. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1518$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1519$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $Hterm$.",
    "output": "postulate Aop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $_R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $Q_$ be a function from elements $x_1233$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1232$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1231$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1234$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_lstar_O$ be a function from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_O$ applied to $B$ and $_R$ and $b$. Let $_H_lstar_S$ be a function from elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1236$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1235$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b$ and $b2$ and $x_1235$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $x_1236$ and $l$ and $b2$ and $x_1235$. Let $x_1233$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $x_1232$ and $x_1231$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1234$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.",
    "output": "axiom lstar_ind (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (Q_ : (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231)) -> cic.Univ cic.prop) (_H_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) (_H_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1236 : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> (_x_1238 : cic.Term cic.prop (Q_ l b b2 x_1235)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b x_1236 l b2 x_1235))) (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_1232 x_1231 : cic.Term univs.Type0 B) (x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231)) : cic.Term cic.prop (Q_ x_1233 x_1232 x_1231 x_1234)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "axiom le_n_Sn (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp2. Pour toutes les fonctions $Q_$ des éléments $_x_492$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_492$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_492$.",
    "output": "axiom void_rect_CProp2 (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_492 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_492)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp1_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_631$, for all elements $x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_630$.",
    "output": "axiom option_rect_CProp1_body (_A : cic.Univ univs.Type0) (Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) (x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_630)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "To_max. Let $i$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.",
    "output": "Axiom to_max : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m i), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_mod. Pour tous les éléments $p$ et $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $p$ et $a$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à la fonction qui envoie $n$ à $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $n$ et $p$ et $matita_arithmetics_nat.pred$ appliqué à $p$.",
    "output": "permut_mod : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p)) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "StreicherK. Soit $T$ un élément de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $t$ de $cic.Term$ de $univs.Type2$ et de $T$, pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $T$ et $t$ et $t$ à des éléments de $cic.Univ$ de $univs.Type2$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_basics_logic.refl$ appliqué à $T$ et $t$, pour tous les éléments $p$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $T$ et $t$ et $t$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $p$.",
    "output": "axiom streicherK (T : cic.Univ univs.Type2) (t : cic.Term univs.Type2 T) (P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2) (__ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t))) (p : cic.Term cic.prop (matita_basics_logic.eq T t t)) : cic.Term univs.Type2 (P p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_905$.",
    "output": "ACop_rect_CProp5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_905) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ex2_ind_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_P$ and $_Q$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_ex2_intro$ be a function from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$. Then for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "ex2_ind_body : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ cic.prop) -> _H_ex2_intro : (x : cic.Term univs.Type0 A -> x_276 : cic.Term cic.prop (_P x) -> x_275 : cic.Term cic.prop (_Q x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term cic.prop (Q_ x_274) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_All. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $P$ och $Q$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.Exists$ applicerat på $A$ och $P$ och $l$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.All$ applicerat på $A$ och $Q$ och $l$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och funktionen som avbildar $x$ som $matita_basics_logic.And$ applicerat på $P$ applicerat på $x$ och $Q$ applicerat på $x$.",
    "output": "postulate Exists_All : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A Q l)) -> cic.Term cic.prop (matita_basics_logic.ex A (\\ x : cic.Term univs.Type0 A -> matita_basics_logic.And (P x) (Q x)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_867$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Then for all elements $x_867$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_867$.",
    "output": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_867)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod. Soient $s1$ et $s2$ des éléments de $Sort$. Soit $a$ un élément de $Univ$ de $s1$. Soit $b$ une fonction des éléments de $Term$ de $s1$ et de $a$ à des éléments de $Univ$ de $s2$. Alors $Univ$ tient pour $rule$ appliqué à $s1$ et $s2$.",
    "output": "axiom prod (s1 s2 : Sort) (a : Univ s1) (b : Term s1 a -> Univ s2) : Univ (rule s1 s2)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_aux_Strue. Pour tous les éléments $n$ et $m$ et $p$ et $q$ et $r$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.O$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord_aux$ appliqué à $p$ et $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $m$ et $m$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $q$ et $r$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord_aux$ appliqué à $matita_arithmetics_nat.S$ appliqué à $p$ et $n$ et $m$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $q$ et $r$.",
    "output": "axiom p_ord_aux_Strue (n m p q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_div_and_mod.div n m) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S p) n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S q) r))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_inv_ind. Let $x1$ and $x2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z2006$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.times$ applied to $x1$ and $q$ and elements $_z2007$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom divides_inv_ind (x1 x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) (P : (_z2006 : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> cic.Univ cic.prop) (_H1 : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.times x1 q))) -> (_z2007 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_primes.divides x1 x2)) Hterm (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P (matita_arithmetics_primes.quotient x1 x2 q x_1193))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type2. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1518$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type2$. Låt $_H1$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1519$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Då håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom Aop_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_times1. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_log.log$ applicerat på $p$ och $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $m$.",
    "output": "Axiom log_times1 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.S (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "SameF_p_le. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $p$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla funktioner $f$ och $g$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $A$, för alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sameF_p$ applicerat på $m$ och $p$ och $A$ och $f$ och $g$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_bigops.sameF_p$ applicerat på $n$ och $p$ och $A$ och $f$ och $g$.",
    "output": "postulate sameF_p_le : (A : cic.Univ univs.Type0) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p m p A f g)) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_p n p A f g)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Checker. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate checker : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_mod. Soient $a$ et $b$ et $c$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $c$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $c$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $c$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $a$ et $b$.",
    "output": "Axiom times_mod : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)) (matita_arithmetics_nat.times c (matita_arithmetics_div_and_mod.mod a b))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_hd. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.option$ applicerat på $A$.",
    "output": "postulate option_hd : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp4. Soit $Q_$ une fonction des éléments $_x_54$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_I$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.I$. Soit $x_54$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_54$.",
    "output": "True_rect_CProp4 : Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_54 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_54) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_CProp0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1758$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $x1$ och $x2$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ och element $_z1759$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Dop$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ och $_null$ och $_distr$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $x1$ och $x2$ och $sum$ och $prod$ och $_null$ och $_distr$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "postulate Dop_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1758 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1759 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pad_bigop_nil. Let $k$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $i$ and $nil$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "Axiom pad_bigop_nil : forall k : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n k), forall __1 : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f i) nil))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (fun i => p i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f i)) (matita_arithmetics_bigops.bigop k (fun i => p i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f i))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp0_body. För alla element $A$ av $cic.Univ$ av $univs.Type2$, för alla element $_x$ av $cic.Term$ av $univs.Type2$ och $A$, för alla funktioner $Q_$ från element $x_37$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_38$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_37$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_refl$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$, för alla element $x_37$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_38$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_37$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_37$ och $x_38$.",
    "output": "postulate eq_rect_CProp0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_37 : cic.Term univs.Type2 A) -> (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Term cic.prop (Q_ x_37 x_38)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bc2. For all elements $n$ and $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_factorial.fact$ applied to $k$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $k$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "bc2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le k n) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact k) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k))) (matita_arithmetics_factorial.fact n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type1. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "div_mod_spec_rect_Type1 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type1) -> _H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type1 (Q_ x_829) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_787$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type3$. Alors pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_lists_list.mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_787$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_787$.",
    "output": "axiom Aop_rect_Type3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type3 (Q_ x_787)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type0_body. Låt $Q_$ vara en funktion från element $_x_507$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $univs.Type0$. Då för alla element $_H_it$ av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_507$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_507$.",
    "output": "unit_rect_Type0_body : Q_ : (_x_507 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type0) -> _H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it) -> x_507 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type0 (Q_ x_507) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B1. Pour tous les éléments $_n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.",
    "output": "axiom B1 (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1524$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ och element $_z1525$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_arithmetics_bigops.mk_Aop$ applicerat på $x1$ och $x2$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.",
    "output": "Aop_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type1) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_step. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$. Alors pour tous les éléments $b1$ et $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$ et $b2$, $cic.Term$ tient pour $cic.prop$ et $R$ appliqué à $b1$ et $b2$.",
    "output": "axiom lstar_inv_step (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) : cic.Term cic.prop (R b1 b2)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_All. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soient $P$ et $Q$ des fonctions des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.Exists$ appliqué à $A$ et $P$ et $l$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.All$ appliqué à $A$ et $Q$ et $l$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.ex$ appliqué à $A$ et la fonction qui envoie $x$ à $matita_basics_logic.And$ appliqué à $P$ appliqué à $x$ et $Q$ appliqué à $x$.",
    "output": "postulate Exists_All : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A Q l)) -> cic.Term cic.prop (matita_basics_logic.ex A (\\ x : cic.Term univs.Type0 A -> matita_basics_logic.And (P x) (Q x)))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10331. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $lt4n$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $m$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $le4m$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $Hind$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $a$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $lea$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$. Soit $Hinda$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $a$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$. Alors pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.",
    "output": "Axiom let_clause_10331 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m), forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a), forall Hinda : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S a)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_Type0. För alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $P$ från element $_z683$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H1$ från element $_z684$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.O$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H2$ från element $x_390$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_x_392$ från element $_z684$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $x_390$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $x_390$ och element $_z684$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.S$ applicerat på $x_390$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_390$, håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.",
    "output": "Axiom nat_inv_rect_Type0 : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0), forall _H1 : ((_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)), forall _H2 : ((x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390)) -> cic.Term univs.Type0 (P x_390)) -> (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))), cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1164$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1165$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom DPair_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1164 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1165 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Orb_elim. För alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_bool.match_bool$ applicerat på $cic.type$ applicerat på $cic.z$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$ och $P$ applicerat på $b2$ och $b1$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $matita_basics_bool.orb$ applicerat på $b1$ och $b2$.",
    "output": "postulate orb_elim : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (\\ __ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.univ cic.prop) (P matita_basics_bool.true) (P b2) b1)) -> cic.Term cic.prop (P (matita_basics_bool.orb b1 b2))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type4_body. For all functions $Q_$ from elements $_x_483$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $x_483$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_483$.",
    "output": "postulate void_rect_Type4_body : (Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type4 (Q_ x_483)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1704. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $posm$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Then for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_1704 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_le_minus_r. Låt $p$ och $q$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $q$ och $p$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $p$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $q$.",
    "output": "axiom monotonic_le_minus_r (p q n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_Type1. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$. Alors pour toutes les fonctions $P$ des éléments $_z930$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $_z931$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.",
    "output": "axiom unit_inv_rect_Type1 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_Sn_m. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$.",
    "output": "axiom times_Sn_m (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus m (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp2_body. Let $Q_$ be a function from elements $_x_515$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_it$ be an element of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$. Let $x_515$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_515$.",
    "output": "unit_rect_CProp2_body : Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H_it : cic.Term cic.prop (Q_ matita_basics_types.it) -> x_515 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop (Q_ x_515) ."
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn_transpose_l. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soient $n$ et $i$ et $j$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $j$ et $n$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.bijn$ appliqué à $f$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.bijn$ appliqué à la fonction qui envoie $p$ à $matita_arithmetics_permutation.transpose$ appliqué à $i$ et $j$ et $f$ appliqué à $p$ et $n$.",
    "output": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True. $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "Axiom true : cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_ind. Låt $x1$ och $x2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z724$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $_z725$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x1$. Då för alla funktioner $_H2$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_419$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x1$ och $m$ och funktioner $_x_421$ från element $_z725$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $m$ och element $_z725$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2$ och $matita_arithmetics_nat.S$ applicerat på $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.S$ applicerat på $m$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $x2$.",
    "output": "le_inv_ind : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _Hterm : cic.Term cic.prop (matita_arithmetics_nat.le x1 x2) -> P : (_z724 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 x1) -> cic.Term cic.prop (P x1)) -> _H2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_419 : cic.Term cic.prop (matita_arithmetics_nat.le x1 m) -> _x_421 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 m) -> cic.Term cic.prop (P m)) -> _z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.S m)) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P x2) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_cr_pair. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $a$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $b$ et $n$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.And$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_chinese_reminder.cr_pair$ appliqué à $m$ et $n$ et $a$ et $b$ et $m$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_chinese_reminder.cr_pair$ appliqué à $m$ et $n$ et $a$ et $b$ et $n$ et $b$.",
    "output": "axiom mod_cr_pair (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt b n)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) m) a) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) n) b))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Sum. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_inl$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $__$, for all functions $case_inr$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_Sum : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ return_sort) -> case_inl : (__ : cic.Term univs.Type0 _A -> cic.Term return_sort (return_type (matita_basics_types.inl _A _B __))) -> case_inr : (__ : cic.Term univs.Type0 _B -> cic.Term return_sort (return_type (matita_basics_types.inr _A _B __))) -> z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_smallest_factor_to_not_divides. Let $n$ and $i$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $i$ and $n$.",
    "output": "postulate lt_smallest_factor_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type4. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$. Then for all functions $_H_conj$ from elements $x_124$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_123$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_124$ and $x_123$, for all elements $x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_122$.",
    "output": "postulate And_rect_Type4 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4) -> (_H_conj : (x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> (x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type4 (Q_ x_122)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp4_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_875$.",
    "output": "axiom Aop_rect_CProp4_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_875)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_divides. För alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$, för alla element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.",
    "output": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp4_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_957$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_Dop$ vara en funktion från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$. Låt $x_957$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_957$.",
    "output": "Dop_rect_CProp4_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_957) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_div. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $m$ et $n$ et $n$ et $m$.",
    "output": "Axiom divides_to_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15601. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15601 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_plus_to_minus. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.",
    "output": "axiom lt_plus_to_minus (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.plus p m))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus n m) p)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp2. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_626$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_None$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_627$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_627$, för alla element $x_626$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_626$.",
    "output": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type1. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z347$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H1$ be a function from elements $x_140$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_139$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z348$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_140$ and $x_139$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_140$ and $x_139$. Then $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom And_inv_rect_Type1 : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2), forall P : ((_z347 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((x_140 : cic.Term cic.prop x1) -> (x_139 : cic.Term cic.prop x2) -> (_z348 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_140 x_139))) -> cic.Term univs.Type1 (P (matita_basics_logic.conj x1 x2 x_140 x_139))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_times. Let $n$ and $m$ and $n1$ and $m1$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $n1$ and $p$. Then for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $m$ and $m1$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $n1$ and $m1$ and $p$.",
    "output": "axiom congruent_times (n m n1 m1 p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n n1 p)) (__2 : cic.Term cic.prop (matita_arithmetics_congruence.congruent m m1 p)) : cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times n1 m1) p)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp0. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_688$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_688$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_688$.",
    "output": "postulate Sig_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_688)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp4. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_929$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$. Låt $x_929$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_929$.",
    "output": "range_rect_CProp4 : _A : cic.Univ univs.Type0 -> Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_929) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_1_to_divides_times_to_divides. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate gcd_1_to_divides_times_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p m)"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Or. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $_A$ et $_B$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "Axiom filter_Or : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.Or _A _B), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_783$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type4$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Låt $x_783$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$. Då håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_783$.",
    "output": "axiom Aop_rect_Type4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type4 (Q_ x_783)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type2_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_541$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type2$. Låt $_H_inl$ vara en funktion från element $x_542$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_542$. Låt $_H_inr$ vara en funktion från element $x_543$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_543$. Då för alla element $x_541$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_541$.",
    "output": "Axiom Sum_rect_Type2_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2), forall _H_inl : ((x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))), forall _H_inr : ((x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))), forall x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type2 (Q_ x_541) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_void. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "postulate filter_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_ACop$ be a function from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_903$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_903$.",
    "output": "axiom ACop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_903)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_max_spec. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $__$ till element av $cic.Univ$ av $return_sort$. Låt $case_found_max_spec$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $_n$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $__2$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $i$ och element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $_n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $i$ och $matita_basics_bool.false$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $m$ och $matita_arithmetics_minimization.found_max_spec$ applicerat på $_n$ och $_f$ och $m$ och $__$ och $__1$ och $__2$. Då för alla funktioner $case_not_found_max_spec$ från funktioner $__$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $_n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $i$ och $matita_basics_bool.false$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_minimization.not_found_max_spec$ applicerat på $_n$ och $_f$ och $__$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $__$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $__$ och $z$.",
    "output": "Axiom match_max_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort), forall case_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))), forall case_not_found_max_spec : ((__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f __))), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __), cic.Term return_sort (return_type __ z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Enum_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "axiom enum_body (A : cic.Univ univs.Type0) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_Type1. Pour toutes les fonctions $Q_$ des éléments $_x_71$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $univs.Type1$, pour tous les éléments $x_71$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_71$.",
    "output": "Axiom False_rect_Type1 : forall Q_ : ((_x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type1), forall x_71 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type1 (Q_ x_71) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "Axiom lt_sqrt_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_body. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.",
    "output": "postulate exp_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_801$.",
    "output": "axiom Aop_rect_CProp2 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_801)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_min_spec. Soient $_n$ et $_b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_minimization.min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $__$ à des éléments de $cic.Univ$ de $return_sort$. Soit $case_found_min_spec$ une fonction des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $m$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $matita_arithmetics_nat.plus$ appliqué à $_n$ et $_b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué à $m$ et $matita_basics_bool.true$ et des fonctions $__3$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $i$ et des éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué à $i$ et $matita_basics_bool.false$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $m$ et $matita_arithmetics_minimization.found_min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $m$ et $__$ et $__1$ et $__2$ et $__3$. Soit $case_not_found_min_spec$ une fonction des fonctions $__$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.plus$ appliqué à $_n$ et $_b$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué à $i$ et $matita_basics_bool.false$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $_n$ et $_b$ et $matita_arithmetics_minimization.not_found_min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $__$. Soit $__$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $z$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_minimization.min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $__$. Alors $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $__$ et $z$.",
    "output": "axiom match_min_spec (_n _b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_min_spec _n _b _f m __ __1 __2 __3))) (case_not_found_min_spec : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus _n _b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus _n _b) (matita_arithmetics_minimization.not_found_min_spec _n _b _f __))) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) : cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10471. Let $n1$ and $n2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p1$ and $p2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $op$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$. Let $f1$ and $f2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Let $h$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__$ to $matita_arithmetics_nat.nat$ and the function that maps $k$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $k$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $_clearme2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and the function that maps $__1$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Let $same$ be a function from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$. Let $i$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $Hind$ be a function from functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.O$ and the function that maps $i0$ to $p1$ applied to $i0$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f1$ applied to $i0$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i0$ to $f$ applied to $i0$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f2$ applied to $i0$. Let $p20$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n1$. Let $sub1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $matita_arithmetics_nat.S$ applied to $m$ and $p20$. Let $sub2$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $k$ and $h$ and $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $matita_arithmetics_nat.S$ applied to $m$ and $p20$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $matita_arithmetics_nat.O$ and $p1$. Let $x2571$ and $x2572$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2571$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2572$ and $matita_arithmetics_div_and_mod.div$ applied to $x2571$ and $x2572$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2571$ and $x2572$.",
    "output": "let_clause_10471 : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil) -> f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> _clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2)) -> h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> _clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.nat)) (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) => matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) => cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1)))) -> k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> _clearme1 : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) => cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 n2 p2) (matita_arithmetics_bigops.mk_range B f1 n1 p1))) -> _clearme2 : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) => cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))))) (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> same : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f1 i) (f2 (h i)))) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1) -> __1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 m f)) -> __2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 m f) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop matita_arithmetics_nat.O (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => p1 i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => f1 i0)) (matita_arithmetics_bigops.bigop m (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i0) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => f2 i0)))) -> p20 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n1) -> sub1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k B (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1) (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20)) -> sub2 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk k h B (matita_arithmetics_bigops.mk_range B f2 (matita_arithmetics_nat.S m) p20) (matita_arithmetics_bigops.mk_range B f1 matita_arithmetics_nat.O p1)) -> x2571 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2572 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2571 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2572 (matita_arithmetics_div_and_mod.div x2571 x2572)) (matita_arithmetics_div_and_mod.mod x2571 x2572))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp3_body. Låt $Q_$ vara en funktion från element $_x_353$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_true$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$. Låt $_H_false$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$. Då för alla element $x_353$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_353$.",
    "output": "bool_rect_CProp3_body : Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_353 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_353) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1686. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Hind$ vara en funktion från element $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $m$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$ till element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.pred$ applicerat på $p$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $a$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $a$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $a$. Låt $Hm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $a$. Låt $Hlt$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $a$. Då för alla element $Ha$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $a$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.pred$ applicerat på $m$ och $matita_arithmetics_nat.plus$ applicerat på $a$ och $a$.",
    "output": "Axiom let_clause_1686 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))), forall Hm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))), forall Hlt : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))), forall Ha : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.pred m) (matita_arithmetics_nat.plus a a)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rcomp. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_R1$ och $_R2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $A$. Låt $_a1$ och $_a2$ vara element av $cic.Term$ av $univs.Type0$ och $A$. Då håller $cic.Univ$ för $cic.prop$.",
    "output": "axiom Rcomp (A : cic.Univ univs.Type0) (_R1 _R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) (_a1 _a2 : cic.Term univs.Type0 A) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_DPair. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $return_sort$. Då för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.",
    "output": "filter_DPair : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sigma_p. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p1$ and $p2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $g1$ and $g2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be a function from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$. Let $__1$ be a function from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$. Let $__2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ and $matita_arithmetics_nat.lt$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ and $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $g2$ applied to $i$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "lt_sigma_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> __1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> __2 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) (matita_arithmetics_nat.lt (g1 i) (g2 i))) (matita_basics_logic.And (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) (matita_arithmetics_nat.lt matita_arithmetics_nat.O (g2 i)))))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p1 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g1 i)) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p2 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g2 i))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nilr_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $xxx$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $a$.",
    "output": "postulate nilr_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a nil) a)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_list. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $return_sort$, pour tous les éléments $case_nil$ de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $case_cons$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $__$ et $__1$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "axiom match_list (_A : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) (case_nil : cic.Term return_sort (return_type (matita_basics_lists_list.nil _A))) (case_cons : (__ : cic.Term univs.Type0 _A) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type (matita_basics_lists_list.cons _A __ __1))) (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_inv_rect_Type3. Soit $x1$ un élément de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z269$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type3$, pour toutes les fonctions $_H1$ des fonctions $x_89$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ et des éléments $_z270$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.Not$ appliqué à $x1$ et $Hterm$ et $matita_basics_logic.nmk$ appliqué à $x1$ et $x_89$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_logic.nmk$ appliqué à $x1$ et $x_89$, $cic.Term$ tient pour $univs.Type3$ et $P$ appliqué à $Hterm$.",
    "output": "axiom Not_inv_rect_Type3 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z269 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type3) (_H1 : (x_89 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z270 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_89))) -> cic.Term univs.Type3 (P (matita_basics_logic.nmk x1 x_89))) : cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop__o__op. Låt $x0$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x1$ vara ett element av $cic.Term$ av $univs.Type0$ och $x0$. Då för alla funktioner $x2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $x3$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ och $x2$, för alla element $_x_887$ och $_x_888$ av $cic.Term$ av $univs.Type0$ och $x0$, håller $cic.Term$ för $univs.Type0$ och $x0$.",
    "output": "postulate dpi1__o__aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact_pi_p2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate fact_pi_p2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times (matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))) (matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Sig. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $return_sort$. Alors pour toutes les fonctions $case_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.",
    "output": "postulate match_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (case_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term return_sort (return_type (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_exp1. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$.",
    "output": "p_ord_to_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) ."
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_div_div_div_div. Soient $n$ et $m$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $q$ et $n$ et $m$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $q$ et $m$ et $n$.",
    "output": "eq_div_div_div_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q n) m) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q m) n)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Tri_relation. För alla element $__$ och $__1$ och $__2$ av $cic.Univ$ av $univs.Type0$, håller $cic.Univ$ för $univs.Type0$.",
    "output": "axiom tri_relation (__ __1 __2 : cic.Univ univs.Type0) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "R1. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Soit $_x$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $Q_$ une fonction des éléments $x_19$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_20$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_19$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $_H_refl$ un élément de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$. Soit $x_19$ un élément de $cic.Term$ de $univs.Type2$ et de $A$. Soit $x_20$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_19$. Alors $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_19$ et $x_20$.",
    "output": "Axiom R1 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0), forall _H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)), forall x_19 : cic.Term univs.Type2 A, forall x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19), cic.Term univs.Type0 (Q_ x_19 x_20) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type1. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_546$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$. Let $_H_inl$ be a function from elements $x_547$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_547$. Let $_H_inr$ be a function from elements $x_548$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_548$. Then for all elements $x_546$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_546$.",
    "output": "Axiom Sum_rect_Type1 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1), forall _H_inl : ((x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))), forall _H_inr : ((x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))), forall x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type1 (Q_ x_546) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_O_to_not_divides. Let $n$ and $i$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $i$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.nth_prime$ applied to $i$ and $n$.",
    "output": "axiom p_ord_O_to_not_divides (n i r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n))"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_ind. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $cic.prop$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1170$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $x2$ applicerat på $pi1$ och element $_z1171$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.",
    "output": "Sig_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1170 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ cic.prop) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1171 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_ord_rem. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$.",
    "output": "axiom lt_O_ord_rem (p n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_ord.ord_rem n p))"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $pnm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $d$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme0$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $H$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $m$ et $d$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $c$.",
    "output": "postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus. Soient $n1$ et $n2$ et $m1$ et $m2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n1$ et $n2$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $m1$ et $m2$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $n1$ et $m1$ et $matita_arithmetics_nat.plus$ appliqué à $n2$ et $m2$.",
    "output": "axiom le_plus (n1 n2 m1 m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))"
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16004. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $pnm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $d$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $m$ et $d$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $c$.",
    "output": "Axiom let_clause_16004 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c))) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type1_body. För alla funktioner $Q_$ från element $_x_341$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $univs.Type1$, för alla element $_H_true$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_341$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_341$.",
    "output": "postulate bool_rect_Type1_body : (Q_ : (_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1) -> (_H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false)) -> (x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ x_341)"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type5. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_7$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_8$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_7$ till element av $cic.Univ$ av $univs.Type5$. Då för alla element $_H_refl$ av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$, för alla element $x_7$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_8$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_7$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_7$ och $x_8$.",
    "output": "Axiom eq_rect_Type5 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_7 : cic.Term univs.Type2 A) -> (_x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7)) -> cic.Univ univs.Type5), forall _H_refl : cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x)), forall x_7 : cic.Term univs.Type2 A, forall x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7), cic.Term univs.Type5 (Q_ x_7 x_8) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Or_div_mod. Låt $n$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $q$ och $q$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $q$ och $q$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $q$ och $q$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $q$ och $q$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $q$.",
    "output": "Axiom or_div_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n q)) q))) (matita_basics_logic.And (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n q) q) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)))))) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type4_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_721$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_nil$ un élément de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$. Soit $_H_cons$ une fonction des éléments $x_723$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_722$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_725$ de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $x_722$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_723$ et $x_722$. Soit $x_721$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$. Alors $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_721$.",
    "output": "Axiom list_rect_Type4_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type4), forall _H_nil : cic.Term univs.Type4 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_723 : cic.Term univs.Type0 _A) -> (x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_725 : cic.Term univs.Type4 (Q_ x_722)) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.cons _A x_723 x_722))), forall x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type4 (Q_ x_721) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type3. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1116$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type3$, pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1117$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $univs.Type3$ et $P$ appliqué à $Hterm$.",
    "output": "axiom DPair_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1116 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type3) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1117 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp5_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då för alla funktioner $Q_$ från element $_x_959$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_959$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_959$.",
    "output": "postulate Dop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp2_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_158$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_conj$ från element $x_160$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_159$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_160$ och $x_159$, för alla element $x_158$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_158$.",
    "output": "axiom And_rect_CProp2_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_158)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_le_to_lt_times. Låt $n$ och $m$ och $p$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $p$ och $q$. Då för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $q$.",
    "output": "axiom lt_to_le_to_lt_times (n m p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p q)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times m q))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp1. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_771$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_nil$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$. Alors pour toutes les fonctions $_H_cons$ des éléments $x_773$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_772$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_775$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_772$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_773$ et $x_772$, pour tous les éléments $x_771$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_771$.",
    "output": "axiom list_rect_CProp1 (_A : cic.Univ univs.Type0) (Q_ : (_x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_773 : cic.Term univs.Type0 _A) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_775 : cic.Term cic.prop (Q_ x_772)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_773 x_772))) (x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_771)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_transpose. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$.",
    "output": "postulate injective_transpose : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_permutation.transpose i j))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_pi. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $m$.",
    "output": "Axiom exp_pi : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp (f i) m)) (matita_arithmetics_exp.exp (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => f i)) m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_700$.",
    "output": "Prod_rect_Type1_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type1) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type1 (Q_ x_700) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16002. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Då för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $m$ och $d$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $c$.",
    "output": "axiom let_clause_16002 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_max_to_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$.",
    "output": "lt_max_to_false : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_CProp2. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1482$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_851$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_850$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1483$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp2 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1482 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1483 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_851 x_850))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_851 x_850))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following French statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$. Alors $cic.Univ$ tient pour $cic.prop$.",
    "output": "postulate transitive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_sub. Låt $h1$ och $k1$ och $h2$ och $k2$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $I$ och $J$ och $K$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $h1$ och $k1$ och $A$ och $I$ och $J$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på $h2$ och $k2$ och $A$ och $J$ och $K$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_bigops.sub_hk$ applicerat på funktionen som avbildar $x$ som $h2$ applicerat på $h1$ applicerat på $x$ och funktionen som avbildar $x$ som $k1$ applicerat på $k2$ applicerat på $x$ och $A$ och $I$ och $K$.",
    "output": "Axiom transitive_sub : forall h1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall k1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall h2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall k2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, forall I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall K : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall __ : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h1 k1 A I J), forall __1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h2 k2 A J K), cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (fun x => h2 (h1 x)) (fun x => k1 (k2 x)) A I K) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_865$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Then for all elements $x_865$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_865$.",
    "output": "postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)"
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_n_to_le. Låt $h$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $k$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $h$ och $n$. Låt $__2$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $k$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $h$ applicerat på $m$ och $m$. Låt $j$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__3$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $j$. Låt $__4$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $h$ applicerat på $j$.",
    "output": "axiom permut_n_to_le (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) : cic.Term cic.prop (matita_arithmetics_nat.le k (h j))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n2. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.prim$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.pred$ appliqué à $n$.",
    "output": "axiom le_prim_n2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n))"
  },
  {
    "instruction": "Translate the following French statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type3. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_644$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type3$, pour toutes les fonctions $_H_mk_DPair$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$, pour tous les éléments $x_644$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_644$.",
    "output": "DPair_rect_Type3 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type3) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type3 (Q_ x_644) ."
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_S. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $m$.",
    "output": "axiom not_eq_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_or_lt_eq. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "Axiom le_to_or_lt_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type2. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$. Då för alla funktioner $_H_mk_range$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$, för alla element $x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_923$.",
    "output": "postulate range_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_cr_pair. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $m$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $b$ and $n$. Let $__2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_chinese_reminder.cr_pair$ applied to $m$ and $n$ and $a$ and $b$ and $m$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_chinese_reminder.cr_pair$ applied to $m$ and $n$ and $a$ and $b$ and $n$ and $b$.",
    "output": "mod_cr_pair : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt a m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt b n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) m) a) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) n) b)) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_ind. Soient $_n$ et $_m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $Q_$ des éléments $_x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_quotient$ des éléments $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1193$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_m$ et $matita_arithmetics_nat.times$ appliqué à $_n$ et $q$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_primes.quotient$ appliqué à $_n$ et $_m$ et $q$ et $x_1193$, pour tous les éléments $x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_1192$.",
    "output": "Axiom divides_ind : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop), forall _H_quotient : ((q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))), forall x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m), cic.Term cic.prop (Q_ x_1192) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_aux_body. Let $_p$ and $_m$ and $_n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom mod_aux_body : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following Swedish statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reverse_single. Låt $S$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $a$ av $cic.Term$ av $univs.Type0$ och $S$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $S$ och $matita_basics_lists_list.reverse$ applicerat på $S$ och $matita_basics_lists_list.cons$ applicerat på $S$ och $a$ och $matita_basics_lists_list.nil$ applicerat på $S$ och $matita_basics_lists_list.cons$ applicerat på $S$ och $a$ och $matita_basics_lists_list.nil$ applicerat på $S$.",
    "output": "Axiom reverse_single : forall S : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 S, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_exists. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $t$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $t$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$. Let $k$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__2$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$. Let $__3$ be a function from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$. Let $__4$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $t$ and $matita_arithmetics_nat.plus$ applied to $k$ and $b$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $k$ and $b$ and $f$ and $m$.",
    "output": "postulate min_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (t : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m t)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_exp_to_lt. Let $a$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $n$ and $matita_arithmetics_exp.exp$ applied to $a$ and $m$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "lt_exp_to_lt : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp a n) (matita_arithmetics_exp.exp a m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."
  },
  {
    "instruction": "Translate the following French statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type5. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_694$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type5$. Soit $_H_mk_Prod$ une fonction des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$. Soit $x_694$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$. Alors $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_694$.",
    "output": "Axiom Prod_rect_Type5 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type5 (Q_ x_694) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Dop$ be a function from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$. Then for all elements $x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_967$.",
    "output": "axiom Dop_rect_CProp0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_967)"
  },
  {
    "instruction": "Translate the following Swedish statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length_unique_le. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.unique$ applicerat på $matita_arithmetics_nat.nat$ och $l$. Då för alla funktioner $__1$ från element $x$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.mem$ applicerat på $matita_arithmetics_nat.nat$ och $x$ och $l$ till element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_basics_lists_list.length$ applicerat på $matita_arithmetics_nat.nat$ och $l$ och $n$.",
    "output": "length_unique_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l) -> __1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n) ."
  },
  {
    "instruction": "Translate the following Swedish statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_times_l. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.injective$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.times$ applicerat på $m$ och $n$.",
    "output": "axiom injective_times_l (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (λ m => matita_arithmetics_nat.times m n))"
  },
  {
    "instruction": "Translate the following French statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_n_1. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_exp.exp$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.",
    "output": "axiom exp_n_1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  }
]