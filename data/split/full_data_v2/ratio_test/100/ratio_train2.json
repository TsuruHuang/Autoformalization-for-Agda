[
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_aux_to_exp. For all elements $p$ and $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $q$ and $r$.",
    "output": "postulate p_ord_aux_to_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m q) r))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_sqrt_nl. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $m$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_73. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then for all natural numbers $x134$ and $x135$ and $x136$, the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp0_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_885$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_885$.",
    "output": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $Lt$ of $_r$ and $_m$ and elements $x_814$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_813$.",
    "output": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_times_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ and $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, for all functions $P$ from elements $x0$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x0$ and $a$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $__$ of $cic.Term$ of $univs.Type3$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $x$ and $p$.",
    "output": "postulate eq_rect_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> (P : (x0 : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x0 a)) -> cic.Univ univs.Type3) -> (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) -> cic.Term univs.Type3 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type0_body. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "postulate nat_rect_Type0_body : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_mem_nat. For all natural numbers $n$, for all lists $l$ of natural numbers, $decidable$ holds for $mem$ applied to $Nat$ and $n$ and $l$.",
    "output": "postulate decidable_mem_nat : (n : Nat) -> (l : list Nat) -> decidable (mem Nat n l)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z161$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_965$.",
    "output": "postulate Dop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_965)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_nth. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $matita_basics_lists_list.nth_opt$ applied to $A$ and $n$ and $l$ and $matita_basics_types.Some$ applied to $A$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate All_nth : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a))) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_sqrt. $monotonic$ holds for $Nat$ and $Leq$ and $sqrt$.",
    "output": "postulate monotonic_sqrt : monotonic Nat Leq sqrt"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z647$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z647 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive_times_minus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.minus$.",
    "output": "postulate distributive_times_minus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.minus)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "To_max. For all natural numbers $i$ and $n$ and $m$, if $n$ is less than or equal to $i$, then if $m$ is less than or equal to $i$, then $max$ applied to $n$ and $m$ is less than or equal to $i$.",
    "output": "postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_ind_body. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1336$ and $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "postulate lstar_r_ind_body : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop) -> (_H_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (_H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))) -> (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_plus_l. For all natural numbers $m$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $n$ to the sum of $n$ and $m$.",
    "output": "postulate monotonic_le_plus_l : (m : Nat) -> monotonic Nat Leq (\\ n : Nat -> plus n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from natural numbers to natural numbers, for all sets $A$, for all elements $I$ and $J$ and $K$ of $range$ of $A$, for all elements $__$ of $sub_hk$ of $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $sub_hk$ of $h2$ and $k2$ and $A$ and $J$ and $K$, $sub_hk$ holds for the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "postulate transitive_sub : (h1 : (_ : Nat) -> Nat) -> (k1 : (_ : Nat) -> Nat) -> (h2 : (_ : Nat) -> Nat) -> (k2 : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (K : range A) -> (_ : sub_hk h1 k1 A I J) -> (__1 : sub_hk h2 k2 A J K) -> sub_hk (\\ x : Nat -> h2 (h1 x)) (\\ x : Nat -> k1 (k2 x)) A I K"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_pi_l. For all natural numbers $n$ and $a$, for all functions $f$ from natural numbers to natural numbers, the product of the exponentiation of $a$ and $n$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of $a$ and $f$ applied to $i$.",
    "output": "postulate exp_pi_l : (n : Nat) -> (a : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (times (pow a n) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> f i))) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> times a (f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable. For all elements $__$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate decidable : (__ : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.plus$ applied to $c$ and $b$.",
    "output": "postulate lt_minus_to_plus : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus c b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_ACop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $b$ and $a$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.",
    "output": "postulate mk_ACop : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil aop a b) (matita_arithmetics_bigops.op A nil aop b a))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_hk. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max'. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all natural numbers $__2$, $Nat$.",
    "output": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "postulate lt_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iff_sym. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $A$.",
    "output": "postulate iff_sym : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff B A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_assoc_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R1$ and $R2$ and $R3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R3$ and $matita_basics_relations.Rcomp$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R2$ and $R3$.",
    "output": "postulate sub_assoc_l : (A : cic.Univ univs.Type0) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R3 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "postulate transpose : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_times_n_to_lt_r. For all natural numbers $n$ and $p$ and $q$, if the product of $n$ and $p$ is less than the product of $n$ and $q$, then $p$ is less than $q$.",
    "output": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_primes. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate all_primes : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.",
    "output": "postulate ACop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B2. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate andb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_O_f. For all functions $f$ from natural numbers to booleans, for all natural numbers $b$, $min$ applied to $0$ and $b$ and $f$ is equal to $b$.",
    "output": "postulate min_O_f : (f : (_ : Nat) -> bool) -> (b : Nat) -> Eq (min 0 b f) b"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp4. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "postulate False_rect_CProp4 : (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_73)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_smallest_factor_n. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is prime.",
    "output": "postulate prime_smallest_factor_n : (n : Nat) -> (_ : Lt 1 n) -> prime (smallest_factor n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.",
    "output": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "postulate DPair_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_943$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_943$.",
    "output": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1278$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1279$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp5. For all functions $Q_$ from elements $_x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_74$.",
    "output": "postulate False_rect_CProp5 : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm09. For all circles $c$, for all instances $r$ of real numbers, if we can prove that $r$ is equal to the radius of $c$, then we can prove that the area of $c$ is equal to the product of the number \\(\\pi\\) and the exponentiation of $r$ and $2$.",
    "output": "postulate thm09 : (c : Circle) -> (r : Real) -> Eq r (radius c) -> Eq (area c) (times pi (pow r 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "postulate True_rect_Type4 : (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) -> (x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type4 (Q_ x_42)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ComplIntersection. For all sets $A$, we can prove that the intersection of $A$ and the complement of $A$ is equal to the empty set.",
    "output": "postulate complIntersection : (A : Set) -> equalset (intersection A (complement A)) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.",
    "output": "postulate commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z2006$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.times$ applied to $x1$ and $q$ and elements $_z2007$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate divides_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> (P : (_z2006 : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.times x1 q))) -> (_z2007 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_primes.divides x1 x2)) Hterm (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_793$.",
    "output": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example2. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$.",
    "output": "postulate lt_div_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m)) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.",
    "output": "postulate list_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_times_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $m$ to the product of $n$ and $m$.",
    "output": "postulate monotonic_le_times_r : (n : Nat) -> monotonic Nat Leq (\\ m : Nat -> times n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_O_to_divides. For all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $mod$ applied to $m$ and $n$ is equal to $0$, then $n$ is divisible by $m$.",
    "output": "postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_953$ of $Dop$ of $A$ and $_nil$ to elements of $Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "S_mod. For all natural numbers $_n$ and $_m$, $Nat$.",
    "output": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_div. For all natural numbers $a$ and $b$ and $c$, if $0$ is less than $b$, then if $c$ is divisible by $b$, then the product of $a$ and the quotient of $b$ and $c$ is equal to the quotient of the product of $a$ and $b$ and $c$.",
    "output": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate bigop : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10331. For all elements $p$ and $n$ and $n1$ and $q$ and $p1$ and $p2$ and $qa$ and $ra$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $p2$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S (matita_arithmetics_nat.S p2))) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nilr. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $a$.",
    "output": "postulate nilr : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx a nil) a"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Univ. For all elements $s$ of $Sort$, $Univ$ holds for $succ$ applied to $s$.",
    "output": "postulate univ : (s : Sort) -> Univ (succ s)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_times. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then the logarithm of $p$ and the product of $n$ and $m$ is less than or equal to the sum of the sum of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$ and $1$.",
    "output": "postulate log_times : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_aux_body. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_ind. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z257$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z258$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_80$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_80$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_ind : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_80 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z258 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_CProp3_body. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "postulate True_rect_CProp3_body : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "LePsi_prim. For all natural numbers $n$, the exponentiation of $n$ and $prim$ applied to $n$ is less than or equal to the product of $Psi$ applied to $n$ and $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$.",
    "output": "postulate lePsi_prim : (n : Nat) -> Leq (pow n (prim n)) (times (Psi n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sym_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$.",
    "output": "postulate sym_eq : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (y : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term cic.prop (matita_basics_logic.eq A y x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1573. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate let_clause_1573 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_O_to_not_divides. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate ord_O_to_not_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate monotonic : (A : cic.Univ univs.Type0) -> (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_ltl. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$ and $n$.",
    "output": "postulate length_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.ltl A l n)) (matita_arithmetics_nat.minus (matita_basics_lists_list.length A l) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_to_gcd_aux. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $n$ is not divisible by $m$, then $gcd_aux$ applied to the sum of $p$ and $1$ and $m$ and $n$ is equal to $gcd_aux$ applied to $p$ and $n$ and $mod$ applied to $m$ and $n$.",
    "output": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_m. For all natural numbers $m$ and $n$, if $m$ is less than or equal to $n$, then the difference of the sum of $n$ and $1$ and $m$ is equal to the sum of the difference of $n$ and $m$ and $1$.",
    "output": "postulate minus_Sn_m : (m : Nat) -> (n : Nat) -> (_ : Leq m n) -> Eq (minus (plus n 1) m) (plus (minus n m) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_rect_Type3. For all functions $Q_$ from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_true$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.",
    "output": "postulate bool_rect_Type3 : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2 : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_30. For all instances $x$ of integers, we can prove that if the difference of the product of $5$ and $x$ and $7$ is odd, then the sum of the product of $9$ and $x$ and $2$ is even.",
    "output": "postulate noLabel_30 : (x : Int) -> if (odd (minus (times 5 x) 7)) (even (plus (times 9 x) 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type3. For all functions $Q_$ from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.",
    "output": "postulate True_rect_Type3 : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "None. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_ind_body. For all functions $Q_$ from elements $_x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_495$.",
    "output": "postulate unit_ind_body : (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_495)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate prod_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (_x_969 : cic.Term univs.Type0 A) -> (_x_970 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_mod_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate divides_mod_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_p_ord_inv. For all natural numbers $p$ and $m$ and $x$, if $ord$ applied to $x$ and $p$ is less than $m$, then the quotient of $p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ is equal to $ord_rem$ applied to $x$ and $p$.",
    "output": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_x_times_x. For all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.",
    "output": "postulate le_x_times_x : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is irrational, if $x$ is not rational.",
    "output": "irrational : Real -> Prop\nirrational = \\ x -> not (rational x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_congruent. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and the function that maps $n$ and $m$ to $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate transitive_congruent : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_congruence.congruent n m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Hint_declaration_CProp1. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all elements $_a$ and $_b$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate hint_declaration_CProp1 : (A : cic.Univ cic.prop) -> (_a : cic.Term cic.prop A) -> (_b : cic.Term cic.prop A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc1. For all natural numbers $n$ and $k$, if $k$ is less than $n$, then $bc$ applied to the sum of $n$ and $1$ and the sum of $k$ and $1$ is equal to the sum of $bc$ applied to $n$ and $k$ and $bc$ applied to $n$ and the sum of $k$ and $1$.",
    "output": "postulate bc1 : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (bc (plus n 1) (plus k 1)) (plus (bc n k) (bc n (plus k 1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Confluent. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.",
    "output": "postulate confluent : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp3. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "div_mod_spec_rect_CProp3 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_845) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$.",
    "output": "lstar : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_relations.relation B) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. The number \\(\\pi\\) is an instance of real numbers.",
    "output": "pi : Elem Real ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "range_rect_Type0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type0) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type0 (Q_ x_927) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psi_exp5. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "le_Psi_exp5 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then the square of $x$ is an instance of real numbers defined as the function that maps $x$ to the exponentiation of $x$ and $2$.",
    "output": "def square : Elem Real -> Elem Real := x => pow x 2 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_to_log_r. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_log.log$ applied to $b$ and $m$.",
    "output": "exp_to_log_r : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) m) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_log.log b m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Enum_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "enum_body : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_inv_plus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$.",
    "output": "le_inv_plus_l : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "Aop_rect_CProp3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_879) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "iso : A : Set -> relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type4_body. For all functions $Q_$ from natural numbers $_x_369$ to elements of $Type4$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_370$ and elements $_x_372$ of $Q_$ of $x_370$ to elements of $Q_$ of the sum of $x_370$ and $1$, for all natural numbers $x_369$, $Q_$ holds for $x_369$.",
    "output": "nat_rect_Type4_body : Q_ : (_x_369 : Nat -> Type4) -> _H_O : Q_ 0 -> _H_S : (x_370 : Nat -> _x_372 : Q_ x_370 -> Q_ (plus x_370 (nd 1))) -> x_369 : Nat -> Q_ x_369 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.",
    "output": "Sig_rect_Type4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type4) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type4 (Q_ x_666) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_931$.",
    "output": "range_rect_CProp5_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_931) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_Conf3. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $matita_arithmetics_lstar.lstar$ applied to $A$ and $R$ and $l$.",
    "output": "lstar_Conf3 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B) -> R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> __ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Tail. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "tail : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nth_primeS. For all natural numbers $n$, $nth_prime$ applied to the sum of $n$ and $1$ is equal to $min$ applied to $let_upper_bound1$ applied to $n$ and the sum of $let_previous_prime1$ applied to $n$ and $1$ and $primeb$.",
    "output": "nth_primeS : n : Nat -> Eq (nth_prime (plus n (nd 1))) (min (let_upper_bound1 n) (plus (let_previous_prime1 n) (nd 1)) primeb) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_ind. For all functions $Q_$ from elements $_x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_326$.",
    "output": "bool_ind : Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_326 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_326) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_ind_r_aux. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "lstar_ind_r_aux : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> __2 : cic.Term cic.prop (R b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1) -> cic.Term cic.prop (P l b2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Psi_1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Psi_1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_div_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "eq_div_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n m) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Or_div_mod1. For all natural numbers $n$ and $q$, if $0$ is less than $q$, then $q$ is divisible by the sum of $n$ and $1$ and the sum of $n$ and $1$ is equal to the product of the sum of the quotient of $n$ and $q$ and $1$ and $q$ or $q$ is not divisible by the sum of $n$ and $1$ and the sum of $n$ and $1$ is equal to the sum of the product of the quotient of $n$ and $q$ and $q$ and the sum of $mod$ applied to $n$ and $q$ and $1$.",
    "output": "or_div_mod1 : n : Nat -> q : Nat -> __ : Lt 0 q -> or (and (divisible q (plus n (nd 1))) (Eq (plus n (nd 1)) (times (plus (div n q) (nd 1)) q))) (and (not (divisible q (plus n (nd 1)))) (Eq (plus n (nd 1)) (plus (times (div n q) q) (plus (mod n q) (nd 1))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_706$.",
    "output": "Prod_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_706) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transpose_i_j_i. For all natural numbers $i$ and $j$, $transpose$ applied to $i$ and $j$ and $i$ is equal to $j$.",
    "output": "transpose_i_j_i : i : Nat -> j : Nat -> Eq (transpose i j i) j ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B1_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.B1$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_psi_bounds.bool_to_nat$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.",
    "output": "B1_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.B1 n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_bertrand.k n p))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_fact_to_divides. For all natural numbers $p$ and $n$, if $p$ is prime, then if $p$ is divisible by the factorial of $n$, then $ex$ holds for $Nat$ and the function that maps $m$ to the conjunction of the conjunction of $Lt$ applied to $0$ and $m$ and $Leq$ applied to $m$ and $n$ and $divisible$ applied to $p$ and $m$.",
    "output": "divides_fact_to_divides : p : Nat -> n : Nat -> __ : prime p -> __1 : divisible p (factorial n) -> ex Nat (m : Nat => and (and (Lt 0 m) (Leq m n)) (divisible p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound7. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "let_upper_bound7 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_871$ of $Aop$ of $A$ and $_nil$ to elements of $Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_871$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_871$.",
    "output": "Aop_rect_Type1 : A : Set -> _nil : A -> Q_ : (_x_871 : Aop A _nil -> Type1) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_871 : Aop A _nil -> Q_ x_871 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1188$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1189$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Sig_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ univs.Type2) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "Aop_rect_Type3 : A : Set -> _nil : A -> Q_ : (_x_867 : Aop A _nil -> Type3) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_CProp0. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "nat_rect_CProp0 : Q_ : (_x_413 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_414 : Nat -> _x_416 : Q_ x_414 -> Q_ (plus x_414 (nd 1))) -> x_413 : Nat -> Q_ x_413 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_square_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "le_square_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "P_ord_aux_Strue. For all elements $n$ and $m$ and $p$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $q$ and $r$.",
    "output": "p_ord_aux_Strue : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_div_and_mod.div n m) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S p) n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S q) r)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1013. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $i$, for all functions $Hind$ from elements of $Eq$ of $max$ applied to $i$ and $f$ and $m$ and elements $__1$ of $Eq$ of $f$ applied to $m$ and absurdity to elements of $Eq$ of $m$ and $0$, if $f$ applied to $i$ is equal to $true$, then if $i$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then absurdity is equal to $true$.",
    "output": "let_clause_1013 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> i : Nat -> Hind : (__ : Eq (max i f) m -> __1 : Eq (f m) false -> Eq m 0) -> fi : Eq (f i) true -> eqm : Eq i m -> fm : Eq (f m) false -> Eq false true ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_fact_10. The factorial of the product of $2$ and $5$ is less than or equal to the product of the product of the exponentiation of $2$ and the difference of the product of $2$ and $5$ and $2$ and the factorial of $5$ and the factorial of $5$.",
    "output": "le_fact_10 : Leq (factorial (times (nd 2) (nd 5))) (times (times (pow (nd 2) (minus (times (nd 2) (nd 5)) (nd 2))) (factorial (nd 5))) (factorial (nd 5))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_ind. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z906$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z907$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_ind : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z906 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "Sum_rect_Type0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type0) -> _H_inl : (x_552 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> _H_inr : (x_553 : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type0 (Q_ x_551) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_m_exp_nm. For all natural numbers $n$ and $m$, if $1$ is less than $n$, then $m$ is less than the exponentiation of $n$ and $m$.",
    "output": "lt_m_exp_nm : n : Nat -> m : Nat -> __ : Lt (nd 1) n -> Lt m (pow n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.",
    "output": "eq_rect_CProp3 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_28 : cic.Term univs.Type2 A -> _x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_28 : cic.Term univs.Type2 A -> x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) -> cic.Term cic.prop (Q_ x_28 x_29) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "And_ind : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_120 : cic.Term cic.prop _A -> x_119 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) -> x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_118) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_times_gcd_aux. For all natural numbers $p$ and $m$ and $n$ and $d$ and $c$, if $0$ is less than $c$, then if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then if $d$ is divisible by the product of $c$ and $m$, then if $d$ is divisible by the product of $c$ and $n$, then $d$ is divisible by the product of $c$ and $gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "divides_times_gcd_aux : p : Nat -> m : Nat -> n : Nat -> d : Nat -> c : Nat -> __ : Lt 0 c -> __1 : Lt 0 n -> __2 : Leq n m -> __3 : Leq n p -> __4 : divisible d (times c m) -> __5 : divisible d (times c n) -> divisible d (times c (gcd_aux p m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_injective. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, $injective$ holds for $Nat$ and $Nat$ and $f$.",
    "output": "increasing_to_injective : f : (__ : Nat -> Nat) -> __ : increasing f -> injective Nat Nat f ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_4_to_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "lt_4_to_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_arithmetics_nat.plus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$.",
    "output": "length_append : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 l2)) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_bertrand_to_le1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "not_bertrand_to_le1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "min_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pad_bigop_nil. For all natural numbers $k$ and $n$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $or$ of $Eq$ applied to $p$ applied to $i$ and absurdity and $Eq$ applied to $f$ applied to $i$ and $nil$, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "pad_bigop_nil : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq n k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) (bigop k (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fact_to_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "fact_to_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_r_ind. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1336$ and $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "lstar_r_ind : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))) -> x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_Type1. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "div_mod_spec_rect_Type1 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type1) -> _H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type1 (Q_ x_829) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_ind. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "void_ind : Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_482 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_482) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_tail. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_arithmetics_nat.pred$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "length_tail : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_arithmetics_nat.pred (matita_basics_lists_list.length A l))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dividesb_true_to_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "dividesb_true_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "lt_to_not_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_eq_mod. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $mod$ applied to $n$ and $m$ is equal to $n$.",
    "output": "lt_to_eq_mod : n : Nat -> m : Nat -> __ : Lt n m -> Eq (mod n m) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_16003. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "let_clause_16003 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp0. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_859$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_858$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_859$ and $x_858$, for all elements $x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_857$.",
    "output": "div_mod_spec_rect_CProp0 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_857) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_eq_to_eqb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "not_eq_to_eqb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sigma_p_dividesb. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "sigma_p_dividesb : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop m (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10332. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10332 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eqb_body. For all natural numbers $__$ and $__1$, $bool$.",
    "output": "eqb_body : __ : Nat -> __1 : Nat -> bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_inv_rect_CProp2. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1482$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_851$ of $Lt$ of $x4$ and $x2$ and elements $x_850$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1483$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$, $P$ holds for $Hterm$.",
    "output": "div_mod_spec_inv_rect_CProp2 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1482 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_851 : Lt x4 x2 -> x_850 : Eq x1 (plus (times x3 x2) x4) -> _z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10331. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10331 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bdef. For all natural numbers $n$, $B$ applied to $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and $mod$ applied to the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ and $2$.",
    "output": "Bdef : n : Nat -> Eq (B n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (mod (div n (pow p (plus i (nd 1)))) (nd 2))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F2_ind_aux. For all elements $A1$ and $A2$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A1$ and $A2$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$.",
    "output": "f2_ind_aux : A1 : cic.Univ univs.Type0 -> A2 : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A1 -> __1 : cic.Term univs.Type0 A2 -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Invert_permut_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "invert_permut_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "Sum_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_562 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> _H_inr : (x_563 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_561) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_959$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_959$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_959$.",
    "output": "Dop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_959) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_spec_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_971$ and $x_972$.",
    "output": "max_spec_ind : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971) -> cic.Univ cic.prop) -> _H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n) -> x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))) -> _H_not_found_max_spec : (x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f x_976))) -> x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971) -> cic.Term cic.prop (Q_ x_971 x_972) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "plus_n_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus n matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.",
    "output": "eq_rect_Type1 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_16 : cic.Term univs.Type2 A -> _x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) -> cic.Univ univs.Type1) -> _H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x)) -> x_16 : cic.Term univs.Type2 A -> x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) -> cic.Term univs.Type1 (Q_ x_16 x_17) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_times_mod. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $0$ is less than $m$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and the product of $m$ and $p$ and $p$.",
    "output": "mod_times_mod : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Lt 0 m -> Eq (mod n p) (mod (mod n (times m p)) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "Dop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_963 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_963 : Dop A _nil -> Q_ x_963 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_sqrt_log_n. For all natural numbers $n$ and $b$, if $2$ is less than $b$, then the product of the square root of $n$ and the logarithm of $b$ and $n$ is less than or equal to $n$.",
    "output": "le_sqrt_log_n : n : Nat -> b : Nat -> __ : Lt (nd 2) b -> Leq (times (sqrt n) (log b n)) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1098$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_635$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_635$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_635$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "option_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1098 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ cic.prop) -> _H1 : (_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> _H2 : (x_635 : cic.Term univs.Type0 x1 -> _z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_635)) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_635))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_of_primes_def. For all natural numbers $n$, $list_of_primes$ applied to $n$ is equal to $lprim$ applied to $n$ and $2$ and $nil$ applied to $Nat$.",
    "output": "list_of_primes_def : n : Nat -> Eq (list_of_primes n) (lprim n (nd 2) (nil Nat)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_tail1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "length_tail1 : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_to_divides_ord_rem. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if $p$ is prime, then if $n$ is divisible by $m$, then $ord_rem$ applied to $n$ and $p$ is divisible by $ord_rem$ applied to $m$ and $p$.",
    "output": "divides_to_divides_ord_rem : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> divisible (ord_rem n p) (ord_rem m p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z954$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z955$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_CProp2 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z954 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z955 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_f_g. For all functions $f$ and $g$ from natural numbers to booleans, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ to elements of $Eq$ of $f$ applied to $i$ and $g$ applied to $i$, $max$ applied to $n$ and $f$ is equal to $max$ applied to $n$ and $g$.",
    "output": "max_f_g : f : (__ : Nat -> bool) -> g : (__ : Nat -> bool) -> n : Nat -> __ : (i : Nat -> __ : Lt i n -> Eq (f i) (g i)) -> Eq (max n f) (max n g) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "eq_fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type4_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_917$.",
    "output": "range_rect_Type4_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type4) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type4 (Q_ x_917) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log_exp1. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "log_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)) (matita_arithmetics_nat.times m (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_iter. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $g$ applied to $x$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$.",
    "output": "le_iter : g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ComplUniverse. We can prove that the complement of the universal set is equal to the empty set.",
    "output": "complUniverse : Proof (equalset (complement universeset) emptyset) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F_false_to_le_max. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $p$.",
    "output": "f_false_to_le_max : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) -> __1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_to_not_lt. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $m$ is not less than $n$.",
    "output": "le_to_not_lt : n : Nat -> m : Nat -> __ : Leq n m -> not (Lt m n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $x$ and $y$ be instances of natural numbers. Then the Legendre symbol of $x$ and $y$ is an instance of integers.",
    "output": "legendre : Elem Nat -> Elem Nat -> Elem Int ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Inv_eq_minus_O. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "inv_eq_minus_O : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_nat.le x y) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "M. If $Nat$, then if $Nat$, then $Nat$.",
    "output": "m : Nat -> Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "increasing_to_le2 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_to_mod_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "divides_to_mod_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $a1$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $a1$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z37$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z38$ to $P$ and $y$ and $x$.",
    "output": "option_discr : a1 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_basics_types.option a1) -> y : cic.Term univs.Type0 (matita_basics_types.option a1) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option a1)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z37 : cic.Term univs.Type1 P => P))) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) y) (t0 : cic.Term univs.Type0 a1 => matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) => P)) (_z38 : (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_singlevalued. For all sets $B$, for all elements $R$ of $relation2$ of $B$ and $B$, for all elements $__$ of $singlevalued$ of $B$ and $B$ and $R$, for all natural numbers $l$, $singlevalued$ holds for $B$ and $B$ and $lstar$ applied to $B$ and $R$ and $l$.",
    "output": "lstar_singlevalued : B : Set -> R : relation2 B B -> __ : singlevalued B B R -> l : Nat -> singlevalued B B (lstar B R l) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Cr_pair2. $cr_pair$ applied to $2$ and $3$ and $1$ and $0$ is equal to $3$.",
    "output": "cr_pair2 : Eq (cr_pair (nd 2) (nd 3) (nd 1) 0) (nd 3) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eqb_true_to_eq. For all natural numbers $n$ and $m$, if $eqb$ applied to $n$ and $m$ is equal to $true$, then $n$ is equal to $m$.",
    "output": "eqb_true_to_eq : n : Nat -> m : Nat -> __ : Eq (eqb n m) true -> Eq n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_bertrand_to_le_B. For all natural numbers $n$, if the exponentiation of $2$ and $7$ is less than or equal to $n$, then for all elements $__1$ of $not_bertrand$ of $n$, $B$ applied to the product of $2$ and $n$ is less than or equal to the product of the exponentiation of $2$ and the product of $2$ and the quotient of the product of $2$ and $n$ and $3$ and the exponentiation of the product of $2$ and $n$ and $pred$ applied to the quotient of the square root of the product of $2$ and $n$ and $2$.",
    "output": "not_bertrand_to_le_B : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> __1 : not_bertrand n -> Leq (B (times (nd 2) n)) (times (pow (nd 2) (times (nd 2) (div (times (nd 2) n) (nd 3)))) (pow (times (nd 2) n) (pred (div (sqrt (times (nd 2) n)) (nd 2))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "lt_to_not_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1308$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z1309$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_723$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_722$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_725$ from elements $_z1309$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_722$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $x_722$ and elements $_z1309$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_723$ and $x_722$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_723$ and $x_722$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "list_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1308 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type4) -> _H1 : (_z1309 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type4 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_723 : cic.Term univs.Type0 x1 -> x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_725 : (_z1309 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_722) -> cic.Term univs.Type4 (P x_722)) -> _z1309 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_723 x_722)) -> cic.Term univs.Type4 (P (matita_basics_lists_list.cons x1 x_723 x_722))) -> cic.Term univs.Type4 (P Hterm) ."
  }
]