[
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_aux_to_exp. For all elements $p$ and $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $q$ and $r$.",
    "output": "postulate p_ord_aux_to_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m q) r))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_sqrt_nl. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $m$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_73. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then for all natural numbers $x134$ and $x135$ and $x136$, the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp0_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_885$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_885$.",
    "output": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $Lt$ of $_r$ and $_m$ and elements $x_814$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_813$.",
    "output": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_times_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ and $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, for all functions $P$ from elements $x0$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x0$ and $a$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $__$ of $cic.Term$ of $univs.Type3$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $x$ and $p$.",
    "output": "postulate eq_rect_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> (P : (x0 : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x0 a)) -> cic.Univ univs.Type3) -> (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) -> cic.Term univs.Type3 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type0_body. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "postulate nat_rect_Type0_body : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_mem_nat. For all natural numbers $n$, for all lists $l$ of natural numbers, $decidable$ holds for $mem$ applied to $Nat$ and $n$ and $l$.",
    "output": "postulate decidable_mem_nat : (n : Nat) -> (l : list Nat) -> decidable (mem Nat n l)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z161$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_965$.",
    "output": "postulate Dop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_965)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_nth. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $matita_basics_lists_list.nth_opt$ applied to $A$ and $n$ and $l$ and $matita_basics_types.Some$ applied to $A$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate All_nth : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a))) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_sqrt. $monotonic$ holds for $Nat$ and $Leq$ and $sqrt$.",
    "output": "postulate monotonic_sqrt : monotonic Nat Leq sqrt"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z647$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z647 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive_times_minus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.minus$.",
    "output": "postulate distributive_times_minus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.minus)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "To_max. For all natural numbers $i$ and $n$ and $m$, if $n$ is less than or equal to $i$, then if $m$ is less than or equal to $i$, then $max$ applied to $n$ and $m$ is less than or equal to $i$.",
    "output": "postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_ind_body. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1336$ and $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "postulate lstar_r_ind_body : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop) -> (_H_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (_H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))) -> (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_plus_l. For all natural numbers $m$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $n$ to the sum of $n$ and $m$.",
    "output": "postulate monotonic_le_plus_l : (m : Nat) -> monotonic Nat Leq (\\ n : Nat -> plus n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from natural numbers to natural numbers, for all sets $A$, for all elements $I$ and $J$ and $K$ of $range$ of $A$, for all elements $__$ of $sub_hk$ of $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $sub_hk$ of $h2$ and $k2$ and $A$ and $J$ and $K$, $sub_hk$ holds for the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "postulate transitive_sub : (h1 : (_ : Nat) -> Nat) -> (k1 : (_ : Nat) -> Nat) -> (h2 : (_ : Nat) -> Nat) -> (k2 : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (K : range A) -> (_ : sub_hk h1 k1 A I J) -> (__1 : sub_hk h2 k2 A J K) -> sub_hk (\\ x : Nat -> h2 (h1 x)) (\\ x : Nat -> k1 (k2 x)) A I K"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_pi_l. For all natural numbers $n$ and $a$, for all functions $f$ from natural numbers to natural numbers, the product of the exponentiation of $a$ and $n$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of $a$ and $f$ applied to $i$.",
    "output": "postulate exp_pi_l : (n : Nat) -> (a : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (times (pow a n) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> f i))) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> times a (f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable. For all elements $__$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate decidable : (__ : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.plus$ applied to $c$ and $b$.",
    "output": "postulate lt_minus_to_plus : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus c b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_ACop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $b$ and $a$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.",
    "output": "postulate mk_ACop : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil aop a b) (matita_arithmetics_bigops.op A nil aop b a))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_hk. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max'. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all natural numbers $__2$, $Nat$.",
    "output": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "postulate lt_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iff_sym. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $A$.",
    "output": "postulate iff_sym : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff B A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_assoc_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R1$ and $R2$ and $R3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R3$ and $matita_basics_relations.Rcomp$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R2$ and $R3$.",
    "output": "postulate sub_assoc_l : (A : cic.Univ univs.Type0) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R3 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "postulate transpose : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_times_n_to_lt_r. For all natural numbers $n$ and $p$ and $q$, if the product of $n$ and $p$ is less than the product of $n$ and $q$, then $p$ is less than $q$.",
    "output": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_primes. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate all_primes : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.",
    "output": "postulate ACop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B2. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate andb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_O_f. For all functions $f$ from natural numbers to booleans, for all natural numbers $b$, $min$ applied to $0$ and $b$ and $f$ is equal to $b$.",
    "output": "postulate min_O_f : (f : (_ : Nat) -> bool) -> (b : Nat) -> Eq (min 0 b f) b"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp4. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "postulate False_rect_CProp4 : (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_73)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_smallest_factor_n. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is prime.",
    "output": "postulate prime_smallest_factor_n : (n : Nat) -> (_ : Lt 1 n) -> prime (smallest_factor n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.",
    "output": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "postulate DPair_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_943$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_943$.",
    "output": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1278$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1279$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp5. For all functions $Q_$ from elements $_x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_74$.",
    "output": "postulate False_rect_CProp5 : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm09. For all circles $c$, for all instances $r$ of real numbers, if we can prove that $r$ is equal to the radius of $c$, then we can prove that the area of $c$ is equal to the product of the number \\(\\pi\\) and the exponentiation of $r$ and $2$.",
    "output": "postulate thm09 : (c : Circle) -> (r : Real) -> Eq r (radius c) -> Eq (area c) (times pi (pow r 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "postulate True_rect_Type4 : (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) -> (x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type4 (Q_ x_42)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ComplIntersection. For all sets $A$, we can prove that the intersection of $A$ and the complement of $A$ is equal to the empty set.",
    "output": "postulate complIntersection : (A : Set) -> equalset (intersection A (complement A)) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.",
    "output": "postulate commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z2006$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.times$ applied to $x1$ and $q$ and elements $_z2007$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate divides_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> (P : (_z2006 : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.times x1 q))) -> (_z2007 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_primes.divides x1 x2)) Hterm (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_793$.",
    "output": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example2. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$.",
    "output": "postulate lt_div_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m)) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.",
    "output": "postulate list_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_times_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $m$ to the product of $n$ and $m$.",
    "output": "postulate monotonic_le_times_r : (n : Nat) -> monotonic Nat Leq (\\ m : Nat -> times n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_O_to_divides. For all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $mod$ applied to $m$ and $n$ is equal to $0$, then $n$ is divisible by $m$.",
    "output": "postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_953$ of $Dop$ of $A$ and $_nil$ to elements of $Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "S_mod. For all natural numbers $_n$ and $_m$, $Nat$.",
    "output": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_div. For all natural numbers $a$ and $b$ and $c$, if $0$ is less than $b$, then if $c$ is divisible by $b$, then the product of $a$ and the quotient of $b$ and $c$ is equal to the quotient of the product of $a$ and $b$ and $c$.",
    "output": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate bigop : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10331. For all elements $p$ and $n$ and $n1$ and $q$ and $p1$ and $p2$ and $qa$ and $ra$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $p2$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S (matita_arithmetics_nat.S p2))) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nilr. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $a$.",
    "output": "postulate nilr : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx a nil) a"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Univ. For all elements $s$ of $Sort$, $Univ$ holds for $succ$ applied to $s$.",
    "output": "postulate univ : (s : Sort) -> Univ (succ s)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_times. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then the logarithm of $p$ and the product of $n$ and $m$ is less than or equal to the sum of the sum of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$ and $1$.",
    "output": "postulate log_times : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_aux_body. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_ind. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z257$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z258$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_80$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_80$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_ind : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_80 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z258 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_CProp3_body. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "postulate True_rect_CProp3_body : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "LePsi_prim. For all natural numbers $n$, the exponentiation of $n$ and $prim$ applied to $n$ is less than or equal to the product of $Psi$ applied to $n$ and $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$.",
    "output": "postulate lePsi_prim : (n : Nat) -> Leq (pow n (prim n)) (times (Psi n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sym_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$.",
    "output": "postulate sym_eq : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (y : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term cic.prop (matita_basics_logic.eq A y x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1573. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate let_clause_1573 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_O_to_not_divides. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate ord_O_to_not_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate monotonic : (A : cic.Univ univs.Type0) -> (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_ltl. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$ and $n$.",
    "output": "postulate length_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.ltl A l n)) (matita_arithmetics_nat.minus (matita_basics_lists_list.length A l) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_to_gcd_aux. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $n$ is not divisible by $m$, then $gcd_aux$ applied to the sum of $p$ and $1$ and $m$ and $n$ is equal to $gcd_aux$ applied to $p$ and $n$ and $mod$ applied to $m$ and $n$.",
    "output": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_m. For all natural numbers $m$ and $n$, if $m$ is less than or equal to $n$, then the difference of the sum of $n$ and $1$ and $m$ is equal to the sum of the difference of $n$ and $m$ and $1$.",
    "output": "postulate minus_Sn_m : (m : Nat) -> (n : Nat) -> (_ : Leq m n) -> Eq (minus (plus n 1) m) (plus (minus n m) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_rect_Type3. For all functions $Q_$ from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_true$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.",
    "output": "postulate bool_rect_Type3 : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2 : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_30. For all instances $x$ of integers, we can prove that if the difference of the product of $5$ and $x$ and $7$ is odd, then the sum of the product of $9$ and $x$ and $2$ is even.",
    "output": "postulate noLabel_30 : (x : Int) -> if (odd (minus (times 5 x) 7)) (even (plus (times 9 x) 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type3. For all functions $Q_$ from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.",
    "output": "postulate True_rect_Type3 : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "None. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_ind_body. For all functions $Q_$ from elements $_x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_495$.",
    "output": "postulate unit_ind_body : (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_495)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate prod_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (_x_969 : cic.Term univs.Type0 A) -> (_x_970 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_mod_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate divides_mod_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_p_ord_inv. For all natural numbers $p$ and $m$ and $x$, if $ord$ applied to $x$ and $p$ is less than $m$, then the quotient of $p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ is equal to $ord_rem$ applied to $x$ and $p$.",
    "output": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_x_times_x. For all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.",
    "output": "postulate le_x_times_x : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is irrational, if $x$ is not rational.",
    "output": "irrational : Real -> Prop\nirrational = \\ x -> not (rational x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_congruent. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and the function that maps $n$ and $m$ to $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate transitive_congruent : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_congruence.congruent n m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Hint_declaration_CProp1. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all elements $_a$ and $_b$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate hint_declaration_CProp1 : (A : cic.Univ cic.prop) -> (_a : cic.Term cic.prop A) -> (_b : cic.Term cic.prop A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc1. For all natural numbers $n$ and $k$, if $k$ is less than $n$, then $bc$ applied to the sum of $n$ and $1$ and the sum of $k$ and $1$ is equal to the sum of $bc$ applied to $n$ and $k$ and $bc$ applied to $n$ and the sum of $k$ and $1$.",
    "output": "postulate bc1 : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (bc (plus n 1) (plus k 1)) (plus (bc n k) (bc n (plus k 1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Confluent. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.",
    "output": "postulate confluent : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_577$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_577$, for all functions $_H_inr$ from elements $x_578$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_578$, for all elements $x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_576$.",
    "output": "postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1134$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1135$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B2_exp. For all natural numbers $n$, if the exponentiation of $2$ and $7$ is less than or equal to $n$, then $B2$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of the product of $2$ and $n$ and $pred$ applied to the quotient of the square root of the product of $2$ and $n$ and $2$.",
    "output": "postulate le_B2_exp : (n : Nat) -> (_ : Leq (pow 2 7) n) -> Leq (B2 (times 2 n)) (pow (times 2 n) (pred (div (sqrt (times 2 n)) 2)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iff_or_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $C$ and $A$ and $matita_basics_logic.Or$ applied to $C$ and $B$.",
    "output": "postulate iff_or_l : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_plus_minus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $z$ and $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.plus$ applied to $x$ and $y$.",
    "output": "postulate minus_plus_minus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le y z)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.plus x y))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_893$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_893$.",
    "output": "postulate ACop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type5 (Q_ x_893)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_4. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate Psi_4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_divides_times. For all elements $p$ and $q$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $q$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $q$ and $n$.",
    "output": "postulate divides_to_divides_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p q))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides q n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times p q) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_893$ of $ACop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_893$.",
    "output": "postulate ACop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_893 : ACop A _nil) -> Type5) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_893 : ACop A _nil) -> Q_ x_893"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus1. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$.",
    "output": "postulate plus_minus1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound2. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "postulate let_upper_bound2 : (n : Nat) -> (m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_1. For all natural numbers $n$, for all functions $p$ from natural numbers to booleans, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $1$ is equal to $1$.",
    "output": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_rect_CProp3. For all functions $Q_$ from elements $_x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_353$.",
    "output": "postulate bool_rect_CProp3 : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_n_fact_n. For all natural numbers $n$, if $2$ is less than $n$, then $n$ is less than the factorial of $n$.",
    "output": "postulate lt_n_fact_n : (n : Nat) -> (_ : Lt 2 n) -> Lt n (factorial n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10332. For all natural numbers $n$, if the exponentiation of $2$ and $6$ is less than or equal to $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10332 : (n : Nat) -> (le_n : Leq (pow 2 6) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_lt. For all sets $A$, for all functions $e$ from natural numbers to elements of $A$, for all functions $p$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $sub_hk$ holds for the function that maps $x$ to $x$ and the function that maps $x$ to $x$ and $A$ and $mk_range$ applied to $A$ and $e$ and $n$ and $p$ and $mk_range$ applied to $A$ and $e$ and $m$ and $p$.",
    "output": "postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\\ x : Nat -> x) (\\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "postulate lt_O_bc : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_p_primeb_dividesb. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $andb$ applied to $primeb$ applied to $p$ and $dividesb$ applied to $p$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and $ord$ applied to $n$ and $p$.",
    "output": "postulate pi_p_primeb_dividesb : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\\ p : Nat -> andb (primeb p) (dividesb p n)) Nat 1 times (\\ p : Nat -> pow p (ord n p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_inv_O. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, if $0$ is equal to $l$, then $b1$ is equal to $b2$.",
    "output": "postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Find_body. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $B$.",
    "output": "postulate find_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp3. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "postulate nat_rect_CProp3 : (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_401)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the product of $a$ and $n$ is less than or equal to the product of $a$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_times_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Leq (times a n) (times a m)) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_prime_O. $0$ is not prime.",
    "output": "postulate not_prime_O : not (prime 0)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pred. For all natural numbers $_n$, $Nat$.",
    "output": "postulate pred : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_times_plus_to_congruent. For all natural numbers $n$ and $m$ and $p$ and $r$, if $0$ is less than $p$, then if $n$ is equal to the sum of the product of $r$ and $p$ and $m$, then $congruent$ holds for $n$ and $m$ and $p$.",
    "output": "postulate eq_times_plus_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : Eq n (plus (times r p) m)) -> congruent n m p"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "postulate le_n_Sn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fold_sum. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $I$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $J$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.append$ applied to $A$ and $I$ and $J$.",
    "output": "postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_mod. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $matita_arithmetics_nat.times$ applied to $c$ and $matita_arithmetics_div_and_mod.mod$ applied to $a$ and $b$.",
    "output": "postulate times_mod : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)) (matita_arithmetics_nat.times c (matita_arithmetics_div_and_mod.mod a b)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15691. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15691 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_SO_n. For all natural numbers $n$, the greatest common divisor of $1$ and $n$ is equal to $1$.",
    "output": "postulate gcd_SO_n : (n : Nat) -> Eq (gcd 1 n) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $A$ be a set. Let $_nil$ be an element of $A$. Then $ACop$ applied to $A$ and $_nil$ is a set.",
    "output": "postulate ACop : (A : Set) -> (_nil : A) -> Set"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_ord_rem. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord_rem$ applied to $m$ and $n$ and $m$.",
    "output": "postulate lt_ord_rem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord_rem m n) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_ind. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_809$.",
    "output": "postulate div_mod_spec_ind : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $n$ is less than or equal to $m$, then the exponentiation of $p$ and $n$ is less than or equal to the exponentiation of $p$ and $m$.",
    "output": "postulate le_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq n m) -> Leq (pow p n) (pow p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus_to_lt_l. For all natural numbers $n$ and $p$ and $q$, if the sum of $p$ and $n$ is less than the sum of $q$ and $n$, then $p$ is less than $q$.",
    "output": "postulate lt_plus_to_lt_l : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (plus p n) (plus q n)) -> Lt p q"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_f3. For all elements $A$ and $B$ and $C$ and $D$ of $cic.Univ$ of $univs.Type2$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type2$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type2$ and $C$ to elements of $cic.Term$ of $univs.Type2$ and $D$, for all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $y1$ and $y2$ of $cic.Term$ of $univs.Type2$ and $B$, for all elements $z1$ and $z2$ of $cic.Term$ of $univs.Type2$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x1$ and $x2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $B$ and $y1$ and $y2$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $C$ and $z1$ and $z2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $D$ and $f$ applied to $x1$ and $y1$ and $z1$ and $f$ applied to $x2$ and $y2$ and $z2$.",
    "output": "postulate eq_f3 : (A : cic.Univ univs.Type2) -> (B : cic.Univ univs.Type2) -> (C : cic.Univ univs.Type2) -> (D : cic.Univ univs.Type2) -> (f : (__ : cic.Term univs.Type2 A) -> (__1 : cic.Term univs.Type2 B) -> (__2 : cic.Term univs.Type2 C) -> cic.Term univs.Type2 D) -> (x1 : cic.Term univs.Type2 A) -> (x2 : cic.Term univs.Type2 A) -> (y1 : cic.Term univs.Type2 B) -> (y2 : cic.Term univs.Type2 B) -> (z1 : cic.Term univs.Type2 C) -> (z2 : cic.Term univs.Type2 C) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq C z1 z2)) -> cic.Term cic.prop (matita_basics_logic.eq D (f x1 y1 z1) (f x2 y2 z2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_O_to_eq_O. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate gcd_O_to_eq_O : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_smallest_factor_to_not_divides. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $i$ and $n$.",
    "output": "postulate lt_smallest_factor_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_895$ of $ACop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_895$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_895$.",
    "output": "postulate ACop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp2. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_572$, for all functions $_H_inr$ from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_573$, for all elements $x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_571$.",
    "output": "postulate Sum_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))) -> (_H_inr : (x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))) -> (x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_571)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_previous_prime6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_previous_prime6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_iter. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ and $b$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $g$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $b$.",
    "output": "postulate monotonic_iter : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Theta. For all natural numbers $__$, $Nat$.",
    "output": "postulate theta : (_ : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate exp_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_ind_body. For all functions $Q_$ from elements $_x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_66$.",
    "output": "postulate False_ind_body : (Q_ : (_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_66)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_div_mod_spec. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $return_sort$, for all functions $case_div_mod_spec_intro$ from elements of $Lt$ of $_r$ and $_m$ and elements $__1$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $return_type$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $__$ and $__1$, for all elements $z$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $return_type$ holds for $z$.",
    "output": "postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ProdF. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_m$ and $_x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$.",
    "output": "postulate prodF : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod A B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bk_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.",
    "output": "postulate Bk_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_bertrand.k n p))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_le_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "postulate not_le_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_pi2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ and $P'$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $P'$ applied to $x$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and the function that maps $x$ to $P$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $P'$ applied to $matita_basics_types.pi1$ applied to $A$ and the function that maps $x0$ to $P$ applied to $x0$ and $x$.",
    "output": "postulate sub_pi2 : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (P' : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (__ : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P x)) -> cic.Term cic.prop (P' x)) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig A (\\ x : cic.Term univs.Type0 A -> P x))) -> cic.Term cic.prop (P' (matita_basics_types.pi1 A (\\ x0 : cic.Term univs.Type0 A -> P x0) x))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_2. For all instances $x$ of real numbers, we can prove that if the sum of the difference of the exponentiation of $x$ and $2$ and the product of $2$ and $x$ and $2$ is less than or equal to $0$, then the exponentiation of $x$ and $3$ is greater than or equal to $8$.",
    "output": "postulate noLabel_2 : (x : Real) -> if (Leq (plus (minus (pow x 2) (times 2 x)) 2) 0) (Geq (pow x 3) 8)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_times. For all elements $p$ and $a$ and $b$ and $qa$ and $ra$ and $qb$ and $rb$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qb$ and $rb$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $qa$ and $qb$ and $matita_arithmetics_nat.times$ applied to $ra$ and $rb$.",
    "output": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.plus qa qb) (matita_arithmetics_nat.times ra rb)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_881$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_881$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_881$.",
    "output": "postulate Aop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_881 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_881 : Aop A _nil) -> Q_ x_881"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_previous_prime2. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "postulate let_previous_prime2 : (n : Nat) -> (m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_Type4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_692$.",
    "output": "postulate Prod_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type4 (Q_ x_692)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example4. $primeb$ applied to $3$ is equal to $true$.",
    "output": "postulate example4 : Eq (primeb 3) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "postulate Prod_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type5 (Q_ x_694)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le_div2. For all elements $m$ and $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $m$.",
    "output": "postulate le_times_to_le_div2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.times m q))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div n q) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, for all natural numbers $_x_941$, $bool$.",
    "output": "postulate filter_body : (A : Set) -> (_xxx : range A) -> (_x_941 : Nat) -> bool"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_leb_false. For all natural numbers $n$ and $m$, if $m$ is less than $n$, then $leb$ applied to $n$ and $m$ is equal to absurdity.",
    "output": "postulate lt_to_leb_false : (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> Eq (leb n m) false"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_m. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate minus_Sn_m : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.minus n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16002. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_797$.",
    "output": "postulate Aop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_797)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_pi_p_primeb_divides_b. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_primes.dividesb$ applied to $p$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$.",
    "output": "postulate eq_pi_p_primeb_divides_b : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p m)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p))) (matita_arithmetics_bigops.bigop n (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_congruent. For all natural numbers $p$, $transitive$ holds for $Nat$ and the function that maps $n$ and $m$ to $congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate transitive_congruent : (p : Nat) -> transitive Nat (\\ n : Nat -> \\ m : Nat -> congruent n m p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_gcd. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is equal to the greatest common divisor of $m$ and $n$.",
    "output": "postulate commutative_gcd : (n : Nat) -> (m : Nat) -> Eq (gcd n m) (gcd m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_p$ and $_n$ be natural numbers. Then the logarithm of $_p$ and $_n$ is a natural number.",
    "output": "postulate log : (_p : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_priml1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_priml1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exists_append_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "postulate Exists_append_l : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l1)) -> cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_le_times_to_lt_S_to_div. For all natural numbers $a$ and $c$ and $b$, if $0$ is less than $b$, then if the product of $b$ and $c$ is less than or equal to $a$, then if $a$ is less than the product of $b$ and the sum of $c$ and $1$, then the quotient of $a$ and $b$ is equal to $c$.",
    "output": "postulate lt_to_le_times_to_lt_S_to_div : (a : Nat) -> (c : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> (__1 : Leq (times b c) a) -> (__2 : Lt a (times b (plus c 1))) -> Eq (div a b) c"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_max. $commutative$ holds for $Nat$ and $max$.",
    "output": "postulate commutative_max : commutative Nat max"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_not_exists. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_nat.O$.",
    "output": "postulate max_not_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_ind_body. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all functions $Q_$ from natural numbers $x_1337$ and elements $x_1336$ of $B$ and elements $x_1335$ of $B$ and elements $_x_1338$ of $lstar_r$ of $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to propositions, for all functions $_H_lstar_r_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1340$ of $lstar_r$ of $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $B$ and elements $x_1339$ of $_R$ of $b$ and $b2$ and elements $_x_1342$ of $Q_$ of $l$ and $b1$ and $b$ and $x_1340$ to elements of $Q_$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all natural numbers $x_1337$, for all elements $x_1336$ and $x_1335$ of $B$, for all elements $x_1338$ of $lstar_r$ of $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $Q_$ holds for $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Cr_pair5. $cr_pair$ applied to $3$ and $7$ and $0$ and $4$ is equal to $18$.",
    "output": "postulate cr_pair5 : Eq (cr_pair 3 7 0 4) 18"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primeb. For all natural numbers $_n$, $bool$.",
    "output": "postulate primeb : (_n : Nat) -> bool"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_ind_aux. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate f_ind_aux : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "LePsi_r2. For all natural numbers $n$, the exponentiation of $n$ and $prim$ applied to $n$ is less than or equal to the product of $Psi$ applied to $n$ and $Psi$ applied to $n$.",
    "output": "postulate lePsi_r2 : (n : Nat) -> Leq (pow n (prim n)) (times (Psi n) (Psi n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate le_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exists_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l1$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l2$.",
    "output": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_O. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.O$ and $b$ and $b$.",
    "output": "postulate lstar_r_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15692. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.",
    "output": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "SubR. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ and $_S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate subR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $m$.",
    "output": "postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_divides. For all natural numbers $_n$ and $_m$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $divisible$ of $_n$ and $_m$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $divisible$ of $_n$ and $_m$ to elements of $return_type$ of $z$, if $_n$ is divisible by $_m$, then $return_type$ holds for $z$.",
    "output": "postulate filter_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (return : (z : divisible _n _m) -> return_type z) -> (z : divisible _n _m) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injective_to_injn. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "postulate injective_to_injn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_670$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_670$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_670$.",
    "output": "postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_Type4. For all functions $Q_$ from elements $_x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_67$.",
    "output": "postulate False_rect_Type4 : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $bertrand$ holds for $_n$.",
    "output": "postulate bertrand : (_n : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_961$.",
    "output": "postulate Dop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_658$.",
    "output": "postulate DPair_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_658)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_inv_rect_CProp2. For all sets $x1$, for all elements $Hterm$ of $range$ of $x1$, for all functions $P$ from elements $_z1680$ of $range$ of $x1$ to propositions, for all functions $_H1$ from functions $_enum$ from natural numbers to elements of $x1$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans and elements $_z1681$ of $Eq$ of $Hterm$ and $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $P$ of $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $P$ holds for $Hterm$.",
    "output": "postulate range_inv_rect_CProp2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1680 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1681 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_13$ and $x_14$.",
    "output": "postulate eq_rect_Type2 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_13 : cic.Term univs.Type2 A) -> (_x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) -> cic.Univ univs.Type2) -> (_H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_13 : cic.Term univs.Type2 A) -> (x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) -> cic.Term univs.Type2 (Q_ x_13 x_14)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_eq_true_false. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.true$ and $matita_basics_bool.false$.",
    "output": "postulate not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z671$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_384$ from elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $x_382$ and elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate nat_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z671 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H1 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type2 (P matita_arithmetics_nat.O)) -> (_H2 : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_382)) -> cic.Term univs.Type2 (P x_382)) -> (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1104$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1105$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_O_to_not_divides. For all natural numbers $p$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $ord$ applied to $m$ and $p$ is equal to $0$, then $p$ is not divisible by $m$.",
    "output": "postulate ord_O_to_not_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : Eq (ord m p) 0) -> not (divisible p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "IdemUnion. For all sets $A$, we can prove that the union of $A$ and $A$ is equal to $A$.",
    "output": "postulate idemUnion : (A : Set) -> equalset (union A A) A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_spec_ind. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_971$ and elements $_x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$ to propositions, for all functions $_H_found_max_spec$ from natural numbers $m$ and elements $x_975$ of $Lt$ of $m$ and $_n$ and elements $x_974$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all natural numbers $x_971$, for all elements $x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$, $Q_$ holds for $x_971$ and $x_972$.",
    "output": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_ord. For all natural numbers $p$ and $n$, if $1$ is less than $p$, then if $0$ is less than $n$, then $n$ is equal to the product of the exponentiation of $p$ and $ord$ applied to $n$ and $p$ and $ord_rem$ applied to $n$ and $p$.",
    "output": "postulate exp_ord : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq n (times (pow p (ord n p)) (ord_rem n p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate p_ord : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_gcd_times_1. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and the product of $n$ and $m$ is equal to $1$.",
    "output": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate log : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Upto. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, $Nat$.",
    "output": "postulate upto : (A : Set) -> (_xxx : range A) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_smallest_factor. For all natural numbers $n$, if $0$ is less than $n$, then $0$ is less than $smallest_factor$ applied to $n$.",
    "output": "postulate lt_O_smallest_factor : (n : Nat) -> (_ : Lt 0 n) -> Lt 0 (smallest_factor n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "same_parity : Int -> Int -> Prop\nsame_parity = \\ x -> \\ y -> or (and (even x) (even y)) (and (odd x) (odd y))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_prime_to_primeb_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$.",
    "output": "postulate not_prime_to_primeb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fmin_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $b$, if $m$ is equal to $min$ applied to $n$ and $b$ and $f$, then if $m$ is less than the sum of $n$ and $b$, then $f$ applied to $m$ is equal to $true$.",
    "output": "postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_mod. For all elements $m$ and $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.plus$ applied to $m$ and $n$ and $q$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$.",
    "output": "postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_17041. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x1029$, $x1029$ is equal to $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x1029$ and $0$.",
    "output": "postulate let_clause_17041 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_not. For all elements $P$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.Not$ applied to $P$.",
    "output": "postulate decidable_not : (P : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Not P))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_Aop. For all sets $A$, for all elements $_nil$ of $A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Aop$ of $A$ and $_nil$ to elements of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $return_type$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $Aop$ of $A$ and $_nil$, $return_type$ holds for $z$.",
    "output": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dpi1__o__aop. For all sets $x0$, for all elements $x1$ of $x0$, for all functions $x2$ from elements of $ACop$ of $x0$ and $x1$ to sets, for all elements $x3$ of $DPair$ of $ACop$ applied to $x0$ and $x1$ and $x2$, $Aop$ holds for $x0$ and $x1$.",
    "output": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_range. For all sets $A$, for all functions $_enum$ from natural numbers to elements of $A$, for all natural numbers $_upto$, for all functions $_filter$ from natural numbers to booleans, $range$ holds for $A$.",
    "output": "postulate mk_range : (A : Set) -> (_enum : (_ : Nat) -> A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> range A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Invert_permut_body. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to natural numbers, for all natural numbers $__2$, $Nat$.",
    "output": "postulate invert_permut_body : (_ : Nat) -> (__1 : (__1 : Nat) -> Nat) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type0. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1464$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to sets, for all functions $_H1$ from elements $x_835$ of $Lt$ of $x4$ and $x2$ and elements $x_834$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1465$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_835$ and $x_834$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_835$ and $x_834$, $P$ holds for $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1464 : div_mod_spec x1 x2 x3 x4) -> Set) -> (_H1 : (x_835 : Lt x4 x2) -> (x_834 : Eq x1 (plus (times x3 x2) x4)) -> (_z1465 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_aux. For all elements $__$ and $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate p_ord_aux : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_O_to_not_divides. For all natural numbers $n$ and $i$ and $r$, if $0$ is less than $n$, then if $p_ord$ applied to $n$ and $nth_prime$ applied to $i$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $0$ and $r$, then $nth_prime$ applied to $i$ is not divisible by $n$.",
    "output": "postulate p_ord_O_to_not_divides : (n : Nat) -> (i : Nat) -> (r : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 r)) -> not (divisible (nth_prime i) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1032$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_582$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1033$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_582$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_582$, for all functions $_H2$ from elements $x_583$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1033$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_583$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_583$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Sum_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1032 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_582 : cic.Term univs.Type0 x1) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_582))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_582))) -> (_H2 : (x_583 : cic.Term univs.Type0 x2) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_pi. For all natural numbers $n$, for all functions $p$ from natural numbers to booleans, for all functions $f$ and $g$ from natural numbers to natural numbers, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of $f$ applied to $i$ and $g$ applied to $i$ is equal to the product of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g$ applied to $i$.",
    "output": "postulate times_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> times (f i) (g i))) (times (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> f i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_times_times. For all natural numbers $a$ and $b$ and $c$, if $0$ is less than $c$, then if $0$ is less than $b$, then the quotient of $a$ and $b$ is equal to the quotient of the product of $a$ and $c$ and the product of $b$ and $c$.",
    "output": "postulate div_times_times : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (div a b) (div (times a c) (times b c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_Type1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_741$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_743$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_742$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_745$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_742$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_743$ and $x_742$, for all elements $x_741$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_741$.",
    "output": "postulate list_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type1) -> (_H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_743 : cic.Term univs.Type0 _A) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_745 : cic.Term univs.Type1 (Q_ x_742)) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))) -> (x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type1 (Q_ x_741)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_prime_times_2. For all natural numbers $n$, if $1$ is less than $n$, then the product of $2$ and $n$ is not prime.",
    "output": "postulate not_prime_times_2 : (n : Nat) -> (_ : Lt 1 n) -> not (prime (times 2 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "O. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate O : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $x1$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x4$ and $x5$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from elements $_z2089$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_z2088$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2087$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2092$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ and elements $_z2091$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b$ and elements $_z2090$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$, for all functions $_H2$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_x_1236$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_x_1235$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $x1$ and $x2$ and $l$ and $b$ and $b2$ and functions $_x_1238$ from elements $_z2092$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $l$ and elements $_z2091$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b$ and elements $_z2090$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ and $b2$ and elements $_z2092$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and elements $_z2091$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b1$ and elements $_z2090$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x3$ and $x4$ and $x5$.",
    "output": "postulate lstar_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1)) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 x1) -> (x5 : cic.Term univs.Type0 x1) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar x1 x2 x3 x4 x5)) -> (P : (_z2089 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_z2088 : cic.Term univs.Type0 x1) -> (_z2087 : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (_H1 : (b : cic.Term univs.Type0 x1) -> (_z2092 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> (_z2091 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2090 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b)) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)) -> (_H2 : (b1 : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (_x_1236 : cic.Term cic.prop (x2 b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 x1) -> (_x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar x1 x2 l b b2)) -> (_x_1238 : (_z2092 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 l)) -> (_z2091 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2090 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b2)) -> cic.Term cic.prop (P l b b2)) -> (_z2092 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (_z2091 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b1)) -> (_z2090 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b2)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)) -> cic.Term cic.prop (P x3 x4 x5)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop10. We can prove that $0$ is even.",
    "output": "postulate prop10 : even 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_coerc. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.succ$ applied to $univs.Type0$ and $univs.Type2$ and $cic.univ$ applied to $univs.Type0$ and $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate eq_coerc : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift (cic.succ univs.Type0) univs.Type2 (cic.univ univs.Type0)) A B)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16005. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_672$.",
    "output": "postulate Sig_rect_Type2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type2 (Q_ x_672)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1062. For all natural numbers $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$, for all elements $_clearme$ of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$, if $r$ is less than $b$, then if $a$ is equal to the sum of the product of $q$ and $b$ and $r$, then for all elements $_clearme0$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, if $r1$ is less than $b$, then if $a$ is equal to the sum of the product of $q1$ and $b$ and $r1$, then if $q$ is not less than or equal to $q1$, then $a$ is equal to the sum of $r1$ and the product of $b$ and $q1$.",
    "output": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_op. For all elements $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $g$ applied to $i$.",
    "output": "postulate bigop_op : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.aop__o__op B nil op (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.aop__o__op B nil op (f i) (g i))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_div_mod_spec_intro$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_823$ and $x_822$, for all elements $x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_821$.",
    "output": "postulate div_mod_spec_rect_Type3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3) -> (_H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> (x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type3 (Q_ x_821)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_exists. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $m$ is less than $n$, then if $f$ applied to $m$ is equal to $true$, then for all functions $__2$ from natural numbers $i$ and elements $__2$ of $Lt$ of $m$ and $i$ and elements $__3$ of $Lt$ of $i$ and $n$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, $max$ applied to $n$ and $f$ is equal to $m$.",
    "output": "postulate max_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> Eq (max n f) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_times_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $n$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate divides_times_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_primes.divides p n) (matita_arithmetics_primes.divides p m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exists_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Exists_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all natural numbers $__$, $relation$ holds for $B$.",
    "output": "postulate lstar : (B : Set) -> (_R : relation B) -> (_ : Nat) -> relation B"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Smallest_factor_to_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$.",
    "output": "postulate smallest_factor_to_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n)) -> cic.Term cic.prop (matita_arithmetics_primes.prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Compose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_x$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $C$.",
    "output": "postulate compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_x : cic.Term univs.Type0 A) -> cic.Term univs.Type0 C"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fmin_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.let_m$ applied to $f$ and $n$ and $b$ and $matita_basics_bool.false$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.let_m$ applied to $f$ and $n$ and $b$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.",
    "output": "postulate fmin_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) (\\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m f n b) (matita_arithmetics_nat.plus n b)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_1_to_lt_n. For all natural numbers $i$ and $n$, if $1$ is less than $n$, then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.",
    "output": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.",
    "output": "postulate div_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) (matita_arithmetics_div_and_mod.mod n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_to_plus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$.",
    "output": "postulate minus_to_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_unit. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_it$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.it$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_unit : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort) -> (case_it : cic.Term return_sort (return_type matita_basics_types.it)) -> (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_div_O. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then the quotient of $n$ and $m$ is equal to $0$.",
    "output": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "postulate lt_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound6. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then for all natural numbers $x$, $Nat$.",
    "output": "postulate let_upper_bound6 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> (x : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_inv_plus_l. For all natural numbers $x$ and $y$ and $z$, if the sum of $x$ and $y$ is less than $z$, then $x$ is less than $z$ and $y$ is less than the difference of $z$ and $x$.",
    "output": "postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Lt (plus x y) z) -> and (Lt x z) (Lt y (minus z x))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $n$.",
    "output": "postulate le_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le n n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_680$.",
    "output": "postulate Sig_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_680)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_O_elim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $P$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "postulate le_n_O_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_to_minus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.",
    "output": "postulate le_plus_to_minus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate gcd : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_false. For all natural numbers $n$, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, $bigop$ applied to $n$ and the function that maps $i$ to absurdity and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $nil$.",
    "output": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i)) nil"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bijn_transpose_l. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then for all elements $__2$ of $bijn$ of $f$ and $n$, $bijn$ holds for the function that maps $p$ to $transpose$ applied to $i$ and $j$ and $f$ applied to $p$ and $n$.",
    "output": "postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\\ p : Nat -> transpose i j (f p)) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_log2_sqrt. For all natural numbers $n$, if the exponentiation of $2$ and $4$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than or equal to the square root of $n$.",
    "output": "postulate le_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 4) n) -> Leq (log 2 n) (sqrt n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Congruent_ab. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then $ex$ holds for $Nat$ and the function that maps $x$ to the conjunction of $congruent$ applied to $x$ and $a$ and $m$ and $congruent$ applied to $x$ and $b$ and $n$.",
    "output": "postulate congruent_ab : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\\ x : Nat -> and (congruent x a m) (congruent x b n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus_associative. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $z$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $y$ and $z$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$.",
    "output": "postulate plus_minus_associative : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x y) z))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (plus x (minus y z)) (minus (plus x y) z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop8c. For all sets $A$ and $B$, we can prove that $A$ is a subset of $B$, if and only if the difference of $A$ and $B$ is equal to the empty set.",
    "output": "postulate prop8c : (A : Set) -> (B : Set) -> iff (subseteq A B) (equalset (difference A B) emptyset)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_CProp4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_903$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_903$.",
    "output": "postulate ACop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16004. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "postulate let_clause_16004 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_lt_O. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$.",
    "output": "postulate prime_to_lt_O : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_priml. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_priml : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus. For all natural numbers $a$ and $b$ and $c$, if the difference of $a$ and $b$ is less than $c$, then $a$ is less than the sum of $c$ and $b$.",
    "output": "postulate lt_minus_to_plus : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt (minus a b) c) -> Lt a (plus c b)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_62. For all instances $a$ and $b$ of integers, we can prove that if $a$ is even or $b$ is even, then the product of $a$ and $b$ is even.",
    "output": "postulate noLabel_62 : (a : Int) -> (b : Int) -> if (or (even a) (even b)) (even (times a b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_ind_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_810$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_809$.",
    "output": "postulate div_mod_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Find. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $B$.",
    "output": "postulate find : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then if $y$ is less than or equal to $x$, then the difference of $x$ and the difference of $y$ and $z$ is equal to the sum of the difference of $x$ and $y$ and $z$.",
    "output": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> (__1 : Leq y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primes_below_to_bertrand. For all natural numbers $pm$, for all lists $l$ of natural numbers, if $pm$ is prime, then for all elements $__1$ of $primes_below$ of $l$ and the sum of $pm$ and $1$, for all functions $__2$ from natural numbers $p$ and elements $__2$ of $mem$ of $Nat$ and $p$ and $l$ and elements $__3$ of $Lt$ of $2$ and $p$ to elements of $ex$ of $Nat$ and the function that maps $pp$ to the conjunction of the conjunction of $mem$ applied to $Nat$ and $pp$ and $l$ and $Lt$ applied to $pp$ and $p$ and $Leq$ applied to $p$ and the product of $2$ and $pp$, for all natural numbers $n$, if $0$ is less than $n$, then if $n$ is less than $pm$, then $bertrand$ holds for $n$.",
    "output": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm01. For all instances $m$ and $n$ of natural numbers, if we can prove that $n$ is not equal to $0$, then we can prove that the exponentiation of the quotient of $m$ and $n$ and $2$ is not equal to $2$.",
    "output": "postulate Thm01 : (m : Nat) -> (n : Nat) -> Neq n 0 -> Neq (pow (div m n) 2) 2"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then the equivalence of $_A$ and $_B$ is an element of $cic.Univ$ of $cic.prop$.",
    "output": "postulate iff : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate exp : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $ACop$ of $A$ and $nil$, $Aop$ holds for $A$ and $nil$.",
    "output": "postulate aop : (A : Set) -> (nil : A) -> (_xxx : ACop A nil) -> Aop A nil"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop100. For all instances $a$ and $b$ and $c$ of integers, if we can prove that the sum of the sum of $a$ and $b$ and $c$ is equal to $0$, then we can prove that the product of the product of $a$ and $b$ and $c$ is less than $0$.",
    "output": "postulate prop100 : (a : Int) -> (b : Int) -> (c : Int) -> Eq (plus (plus a b) c) 0 -> Lt (times (times a b) c) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1428$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1429$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1428 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1429 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_div_times_m. For all natural numbers $a$ and $i$ and $m$, if $0$ is less than $i$, then if $0$ is less than $m$, then the quotient of the product of $a$ and the quotient of $m$ and $i$ and $m$ is less than or equal to the quotient of $a$ and $i$.",
    "output": "postulate le_div_times_m : (a : Nat) -> (i : Nat) -> (m : Nat) -> (_ : Lt 0 i) -> (__1 : Lt 0 m) -> Leq (div (times a (div m i)) m) (div a i)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_exists. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $t$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $t$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all elements $k$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $t$ and $matita_arithmetics_nat.plus$ applied to $k$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $k$ and $b$ and $f$ and $m$.",
    "output": "postulate min_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (t : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m t)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ex2_intro. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ and $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $Q$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $P$ and $Q$.",
    "output": "postulate ex2_intro : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P x)) -> (__1 : cic.Term cic.prop (Q x)) -> cic.Term cic.prop (matita_basics_logic.ex2 A P Q)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_927$ of $range$ of $_A$ to sets, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $range$ of $_A$, $Q_$ holds for $x_927$.",
    "output": "postulate range_rect_Type0_body : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$ and functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $g2$ applied to $i$, for all functions $H1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$, for all functions $H2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$, for all elements $Hp2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $n1$ and $matita_basics_bool.true$, for all elements $Hp1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $n1$ and $matita_basics_bool.true$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))) -> (H1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.S n1))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (H2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.S n1))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> (Hp2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 n1) matita_basics_bool.true)) -> (Hp1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 n1) matita_basics_bool.true)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fmin_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, $prod$ holds for $Prop$ and $Prop$ and $Eq$ applied to $f$ applied to $let_m$ applied to $f$ and $n$ and $b$ and absurdity and the function that maps $__$ to $Eq$ applied to $let_m$ applied to $f$ and $n$ and $b$ and the sum of $n$ and $b$.",
    "output": "postulate fmin_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> prod Prop Prop (Eq (f (let_m f n b)) false) (\\ _ : Eq (f (let_m f n b)) false -> Eq (let_m f n b) (plus n b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate mod_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod matita_arithmetics_nat.O n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_transpose. For all elements $i$ and $j$ and $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $k$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $k$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $matita_arithmetics_permutation.transpose$ applied to $k$ and $j$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $n$.",
    "output": "postulate eq_transpose : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i))) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k))) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.",
    "output": "postulate not_exists_to_forall : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.Not (P i))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc_plus1. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $c$ and $matita_arithmetics_nat.plus$ applied to $b$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $b$ and $c$ and $a$.",
    "output": "postulate assoc_plus1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus c (matita_arithmetics_nat.plus b a)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus b c) a))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_p_primeb5. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "postulate pi_p_primeb5 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ex_prime. For all natural numbers $n$, if $1$ is less than or equal to $n$, then $ex$ holds for $Nat$ and the function that maps $m$ to the conjunction of the conjunction of $Lt$ applied to $n$ and $m$ and $Leq$ applied to $m$ and the sum of the factorial of $n$ and $1$ and $prime$ applied to $m$.",
    "output": "postulate ex_prime : (n : Nat) -> (_ : Leq 1 n) -> ex Nat (\\ m : Nat -> and (and (Lt n m) (Leq m (plus (factorial n) 1))) (prime m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_rect_CProp2. For all functions $Q_$ from elements $_x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_492$.",
    "output": "postulate void_rect_CProp2 : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Square_S. For all natural numbers $a$, the exponentiation of the sum of $a$ and $1$ and $2$ is equal to the sum of the sum of the exponentiation of $a$ and $2$ and the product of $2$ and $a$ and $1$.",
    "output": "postulate square_S : (a : Nat) -> Eq (pow (plus a 1) 2) (plus (plus (pow a 2) (times 2 a)) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate fact : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Opt_cons_tail_expand. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.option_cons$ applied to $A$ and $matita_basics_lists_list.option_hd$ applied to $A$ and $l$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$.",
    "output": "postulate opt_cons_tail_expand : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.option_cons A (matita_basics_lists_list.option_hd A l) (matita_basics_lists_list.tail A l)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_minus_O. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then the difference of $n$ and $m$ is equal to $0$.",
    "output": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (minus n m) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sigma_p_dividesb1. For all elements $m$ and $n$ and $p$ and $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $n$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $k$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate sigma_p_dividesb1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $x$.",
    "output": "postulate minus_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus x y) x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z365$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z366$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_156 : cic.Term cic.prop x1) -> (x_155 : cic.Term cic.prop x2) -> (_z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eqb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.eqb$ applied to $n$ and $m$.",
    "output": "postulate eqb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_exp_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$.",
    "output": "postulate divides_exp_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type1. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_829$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $Lt$ of $_r$ and $_m$ and elements $x_830$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_829$.",
    "output": "postulate div_mod_spec_rect_Type1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_829 : div_mod_spec _n _m _q _r) -> Type1) -> (_H_div_mod_spec_intro : (x_831 : Lt _r _m) -> (x_830 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)) -> (x_829 : div_mod_spec _n _m _q _r) -> Q_ x_829"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DominEmpty. For all sets $A$, we can prove that the intersection of $A$ and the empty set is equal to the empty set.",
    "output": "postulate dominEmpty : (A : Set) -> equalset (intersection A emptyset) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dpi1__o__coerc_pair_sigma. For all elements $x0$ and $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_basics_types.Prod$ applied to $x0$ and $x1$ and $x2$, for all elements $x5$ of $cic.Term$ of $cic.prop$ and $x3$ applied to $matita_basics_types.snd$ applied to $x0$ and $x1$ and $matita_basics_types.dpi1$ applied to $matita_basics_types.Prod$ applied to $x0$ and $x1$ and $x2$ and $x4$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $x0$ and $matita_basics_types.Sig$ applied to $x1$ and the function that maps $x$ to $x3$ applied to $x$.",
    "output": "postulate dpi1__o__coerc_pair_sigma : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 (matita_basics_types.Prod x0 x1)) -> cic.Univ univs.Type0) -> (x3 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (x4 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_types.Prod x0 x1) x2)) -> (x5 : cic.Term cic.prop (x3 (matita_basics_types.snd x0 x1 (matita_basics_types.dpi1 (matita_basics_types.Prod x0 x1) x2 x4)))) -> cic.Term univs.Type0 (matita_basics_types.Prod x0 (matita_basics_types.Sig x1 (\\ x : cic.Term univs.Type0 x1 -> x3 x)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1607. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "postulate let_clause_1607 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $permut$ of $f$ and $n$, $f$ applied to $invert_permut$ applied to $n$ and $f$ and $m$ is equal to $m$.",
    "output": "postulate f_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : permut f n) -> Eq (f (invert_permut n f m)) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_ACop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt1n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_to_not_eq_O. For all natural numbers $n$ and $m$ and $q$ and $r$, for all elements $__$ of $div_mod_spec$ of $n$ and $m$ and $q$ and $r$, $m$ is not equal to $0$.",
    "output": "postulate div_mod_spec_to_not_eq_O : (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : div_mod_spec n m q r) -> not (Eq m 0)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_SO_smallest_factor. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$.",
    "output": "postulate lt_SO_smallest_factor : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Symmetric. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate symmetric : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "It. $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.unit$.",
    "output": "postulate it : cic.Term univs.Type0 matita_basics_types.unit"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_CProp5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_905$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_905$.",
    "output": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1110$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1111$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact_pi_p3. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate fact_pi_p3 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_previous_prime. For all elements $__$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_previous_prime : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_10$ and $x_11$.",
    "output": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_exp1. For all natural numbers $p$ and $n$ and $q$ and $r$, if $0$ is less than $p$, then if $p$ is not divisible by $r$, then if $n$ is equal to the product of the exponentiation of $p$ and $q$ and $r$, then $p_ord$ applied to $n$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $q$ and $r$.",
    "output": "postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times (pow p q) r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16001. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $n$ and $c$ and the product of $m$ and $d$.",
    "output": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ and $_m$ and $_p$ be natural numbers. Then $congruent$ applied to $_n$ and $_m$ and $_p$ is a proposition.",
    "output": "postulate congruent : (_n : Nat) -> (_m : Nat) -> (_p : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_rect_Type2. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_91$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_nmk$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_92$, for all elements $x_91$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_91$.",
    "output": "postulate Not_rect_Type2 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type2) -> (_H_nmk : (x_92 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))) -> (x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type2 (Q_ x_91)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_n_times_nm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $n$.",
    "output": "postulate gcd_n_times_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_nat.times n m)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_exp_to_lt1. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $a$ and $matita_arithmetics_exp.exp$ applied to $m$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "postulate lt_exp_to_lt1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n a) (matita_arithmetics_exp.exp m a))) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool. $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate bool : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_to_le_theta_exp_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate lt_O_to_le_theta_exp_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_32. For all instances $n$ of integers, we can prove that if the product of $15$ and $n$ is even, then the product of $9$ and $n$ is even.",
    "output": "postulate noLabel_32 : (n : Int) -> if (even (times 15 n)) (even (times 9 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_lt_O. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then if $n$ is divisible by $m$, then $0$ is less than $n$.",
    "output": "postulate divides_to_lt_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Lt 0 n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_le_times_to_lt_S_to_div. For all elements $a$ and $c$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $c$.",
    "output": "postulate lt_to_le_times_to_lt_S_to_div : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.times b (matita_arithmetics_nat.S c)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) c)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n2. For all natural numbers $n$, if $7$ is less than or equal to $n$, then $prim$ applied to the sum of the product of $2$ and $n$ and $1$ is less than or equal to $pred$ applied to $n$.",
    "output": "postulate le_prim_n2 : (n : Nat) -> (_ : Leq 7 n) -> Leq (prim (plus (times 2 n) 1)) (pred n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop80. We can prove that $2$ is even.",
    "output": "postulate prop80 : even 2"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound4. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "postulate let_upper_bound4 : (n : Nat) -> (m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1595. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $1$ is less than the greatest common divisor of $p$ and the product of $n$ and $m$, then if $smallest_factor$ applied to the greatest common divisor of $p$ and the product of $n$ and $m$ is divisible by $m$, then the greatest common divisor of $p$ and $n$ is equal to the greatest common divisor of $p$ and $m$.",
    "output": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.",
    "output": "postulate inl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_exp_to_lt1. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the exponentiation of $n$ and $a$ is less than the exponentiation of $m$ and $a$, then $n$ is less than $m$.",
    "output": "postulate lt_exp_to_lt1 : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow n a) (pow m a)) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_a. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $matita_arithmetics_nat.S$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $f$ applied to $a$.",
    "output": "postulate bigop_a : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (matita_arithmetics_nat.S i0)) (matita_arithmetics_nat.plus i a))) (f a)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate injn : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_17041. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_17041 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_max_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$.",
    "output": "postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10131. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n0$ and $f$ and $m$, for all elements $fm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltj$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $j$ and $matita_arithmetics_nat.S$ applied to $n0$, for all elements $x7$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x7$ and $matita_arithmetics_nat.plus$ applied to $m$ and $x7$.",
    "output": "postulate let_clause_10131 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m)) -> (fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0))) -> (x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1686. For all natural numbers $n$ and $m$, for all functions $Hind$ from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi$ applied to $p$ and the product of $pred$ applied to $p$ and the exponentiation of $2$ and the difference of the product of $2$ and $p$ and $3$, for all natural numbers $a$, if $m$ is equal to the product of $2$ and $a$ or $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $1$ is less than the sum of the product of $2$ and $a$ and $1$, then if $0$ is less than $a$, then $pred$ applied to $m$ is equal to the sum of $a$ and $a$.",
    "output": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_previous_prime5. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_previous_prime5 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.",
    "output": "postulate And_rect_Type5_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5) -> (_H_conj : (x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) -> (x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type5 (Q_ x_126)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_lstar_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_S$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $l$ and $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $__$ and $l$ and $b2$ and $__1$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $__1$ and $__2$ and $z$.",
    "output": "postulate match_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> (case_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type2_body. For all functions $Q_$ from elements $_x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_I$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_48$.",
    "output": "postulate True_rect_Type2_body : (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) -> (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) -> (x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type2 (Q_ x_48)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_73. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $x134$ and $x135$ and $x136$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $x136$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psil1. For all natural numbers $n$, $Psi$ applied to $n$ is less than or equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $n$.",
    "output": "postulate le_Psil1 : (n : Nat) -> Leq (Psi n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NatD. $Dop$ holds for $Nat$ and $0$.",
    "output": "postulate natD : Dop Nat 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psi_BPsi. For all natural numbers $n$, $Psi$ applied to the product of $2$ and $n$ is less than or equal to the product of $B$ applied to the product of $2$ and $n$ and $Psi$ applied to $n$.",
    "output": "postulate le_Psi_BPsi : (n : Nat) -> Leq (Psi (times 2 n)) (times (B (times 2 n)) (Psi n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_not_ord_O. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$.",
    "output": "postulate divides_to_not_ord_O : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_times_plus_to_congruent. For all elements $n$ and $m$ and $p$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $r$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate eq_times_plus_to_congruent : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m))) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_gcd_1. For all natural numbers $n$ and $m$, if $n$ is prime, then if $n$ is not divisible by $m$, then the greatest common divisor of $n$ and $m$ is equal to $1$.",
    "output": "postulate prime_to_gcd_1 : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : not (divisible n m)) -> Eq (gcd n m) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1404$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1405$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1404 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1405 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bijn_fg. For all functions $f$ and $g$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $bijn$ of $f$ and $n$, for all elements $__1$ of $bijn$ of $g$ and $n$, $bijn$ holds for the function that maps $p$ to $f$ applied to $g$ applied to $p$ and $n$.",
    "output": "postulate bijn_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : bijn g n) -> bijn (\\ p : Nat -> f (g p)) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1560 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Reverse_append. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.append$ applied to $S$ and $l1$ and $l2$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l2$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l1$.",
    "output": "postulate reverse_append : (S : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.append S l1 l2)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l2) (matita_basics_lists_list.reverse S l1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_times. For all natural numbers $n$ and $m$ and $p$ and $q$, if $n$ is divisible by $p$, then if $m$ is divisible by $q$, then the product of $n$ and $m$ is divisible by the product of $p$ and $q$.",
    "output": "postulate divides_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible m q) -> divisible (times n m) (times p q)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord_rem$ applied to $x$ and $p$.",
    "output": "postulate div_p_ord_inv : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord_rem x p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type3. For all functions $Q_$ from natural numbers $_x_377$ to elements of $Type3$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_378$ and elements $_x_380$ of $Q_$ of $x_378$ to elements of $Q_$ of the sum of $x_378$ and $1$, for all natural numbers $x_377$, $Q_$ holds for $x_377$.",
    "output": "postulate nat_rect_Type3 : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (plus x_378 1)) -> (x_377 : Nat) -> Q_ x_377"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm19. For all instances $n$ of natural numbers, we can prove that there exists a natural number $a$, such that there exists a natural number $b$, such that there exists a natural number $c$, such that there exists a natural number $d$, such that $n$ is equal to the sum of the sum of the sum of the square of $a$ and the square of $b$ and the square of $c$ and the square of $d$.",
    "output": "postulate thm19 : (n : Nat) -> exists Nat (\\ a -> exists Nat (\\ b -> exists Nat (\\ c -> exists Nat (\\ d -> Eq n (plus (plus (plus (square a) (square b)) (square c)) (square d))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_minus_gcd_aux. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then $ex$ holds for $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $p$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "postulate eq_minus_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux p m n)) (Eq (minus (times b m) (times a n)) (gcd_aux p m n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10331. For all natural numbers $n$, if the exponentiation of $2$ and $8$ is less than or equal to $n$, then for all natural numbers $m$, if $3$ is less than or equal to $m$, then if the sum of the logarithm of $2$ and $m$ and $2$ is less than or equal to $m$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_le_S_S_to_not_le. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is not less than or equal to the sum of $m$ and $1$, then $n$ is not less than or equal to $m$.",
    "output": "postulate not_le_S_S_to_not_le : (n : Nat) -> (m : Nat) -> (_ : not (Leq (plus n 1) (plus m 1))) -> not (Leq n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type3_body. For all sets $_A$, for all functions $Q_$ from elements $_x_921$ of $range$ of $_A$ to elements of $Type3$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $range$ of $_A$, $Q_$ holds for $x_921$.",
    "output": "postulate range_rect_Type3_body : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nill. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.",
    "output": "postulate nill : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_lstar_r. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all natural numbers $__$, for all elements $__1$ and $__2$ of $B$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_type$ of $z$, for all elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$, $return_type$ holds for $z$.",
    "output": "postulate filter_lstar_r : (B : Set) -> (_R : relation B) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (return_sort : Sort) -> (return_type : (z : lstar_r B _R __ __1 __2) -> return_sort) -> (return : (z : lstar_r B _R __ __1 __2) -> return_type z) -> (z : lstar_r B _R __ __1 __2) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unique_filter. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$.",
    "output": "postulate unique_filter : (S : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique S l)) -> cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp1. For all elements $n$ and $m$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $a$ and $matita_arithmetics_exp.exp$ applied to $m$ and $a$.",
    "output": "postulate le_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n a) (matita_arithmetics_exp.exp m a))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min. For all natural numbers $__$ and $__1$, for all functions $__2$ from natural numbers $__2$ to booleans, $Nat$.",
    "output": "postulate min : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_not_bertrand_to_bertrand1. For all natural numbers $n$, if it is not the case that $not_bertrand$ holds for $n$, then for all natural numbers $x$, if $n$ is less than or equal to $x$, then if $x$ is less than or equal to the product of $2$ and $n$, then for all functions $__3$ from natural numbers $p$ and elements $__3$ of $Lt$ of $x$ and $p$ and elements $__4$ of $Leq$ of $p$ and the product of $2$ and $n$ to elements of $not$ of $prime$ applied to $p$, $ex$ holds for $Nat$ and the function that maps $p$ to the conjunction of the conjunction of $Lt$ applied to $n$ and $p$ and $Leq$ applied to $p$ and $x$ and $prime$ applied to $p$.",
    "output": "postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_minus_m_m. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $m$ and $n$ and $n$.",
    "output": "postulate minus_minus_m_m : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus m (matita_arithmetics_nat.minus m n)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type4. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1440$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1441$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1258. For all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $b$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1258 : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1b : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp b n) b) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times b (matita_arithmetics_exp.exp b n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_eq_to_le_to_lt. For all natural numbers $n$ and $m$, if $n$ is not equal to $m$, then if $n$ is less than or equal to $m$, then $n$ is less than $m$.",
    "output": "postulate not_eq_to_le_to_lt : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> (__1 : Leq n m) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate le_to_le_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Rintersection. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R1$ and $_R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Rintersection : (A : cic.Univ univs.Type0) -> (_R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp4_body. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "postulate False_rect_CProp4_body : (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_73)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_or_introl$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_introl$ applied to $_A$ and $_B$ and $x_171$, for all functions $_H_or_intror$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_intror$ applied to $_A$ and $_B$ and $x_172$, for all elements $x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_170$.",
    "output": "postulate Or_ind : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop) -> (_H_or_introl : (x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))) -> (_H_or_intror : (x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))) -> (x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term cic.prop (Q_ x_170)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Even_or_odd. For all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $a$ to the disjunction of $Eq$ applied to $n$ and the product of $2$ and $a$ and $Eq$ applied to $n$ and the sum of the product of $2$ and $a$ and $1$.",
    "output": "postulate even_or_odd : (n : Nat) -> ex Nat (\\ a : Nat -> or (Eq n (times 2 a)) (Eq n (plus (times 2 a) 1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B_Psi4. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_B_Psi4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bi_RC_reflexive. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.bi_reflexive$ applied to $A$ and $B$ and $matita_basics_relations.bi_RC$ applied to $A$ and $B$ and $R$.",
    "output": "postulate bi_RC_reflexive : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) -> cic.Term cic.prop (matita_basics_relations.bi_reflexive A B (matita_basics_relations.bi_RC A B R))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Permut_transpose. For all elements $i$ and $j$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$.",
    "output": "postulate permut_transpose : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.transpose i j) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_rect_CProp3. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_154$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_156$ and $x_155$, for all elements $x_154$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_154$.",
    "output": "postulate And_rect_CProp3 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_154)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_CProp2. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_935$.",
    "output": "postulate range_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_935)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Notb_notb. For all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.notb$ applied to $matita_basics_bool.notb$ applied to $b$ and $b$.",
    "output": "postulate notb_notb : (b : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.notb (matita_basics_bool.notb b)) b)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_ind_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "postulate And_ind_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) -> (x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_118)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injective_S. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$.",
    "output": "postulate injective_S : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.S)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_inv_rect_Type3. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z137$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_Type3 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z137 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H1 : (_z138 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type3 (P matita_basics_logic.I)) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Congruent_ab. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$.",
    "output": "postulate congruent_ab : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Smallest_factor_to_min. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $matita_arithmetics_minimization.min$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $m$ to $matita_arithmetics_nat.eqb$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate smallest_factor_to_min : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp2_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_850$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $g$.",
    "output": "postulate min_f_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_map_none. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $B$ and $matita_basics_types.option_map$ applied to $A$ and $B$ and $f$ and $x$ and $matita_basics_types.None$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$.",
    "output": "postulate option_map_none : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "FactS. For all natural numbers $n$, the factorial of the sum of $n$ and $1$ is equal to the product of the sum of $n$ and $1$ and the factorial of $n$.",
    "output": "postulate factS : (n : Nat) -> Eq (factorial (plus n 1)) (times (plus n 1) (factorial n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Foldr. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate foldr : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_prime. For all natural numbers $n$, $decidable$ holds for $prime$ applied to $n$.",
    "output": "postulate decidable_prime : (n : Nat) -> decidable (prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_to_fact2. For all natural numbers $n$, if $0$ is less than $n$, then the product of the exponentiation of $2$ and the product of $2$ and $n$ and the exponentiation of the factorial of $n$ and $2$ is less than or equal to the product of the product of $2$ and $n$ and the factorial of the product of $2$ and $n$.",
    "output": "postulate exp_to_fact2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (times (pow 2 (times 2 n)) (pow (factorial n) 2)) (times (times 2 n) (factorial (times 2 n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_bertrand_to_le2. For all natural numbers $n$, if the exponentiation of $2$ and $7$ is less than or equal to $n$, then for all elements $__1$ of $not_bertrand$ of $n$, the quotient of the product of $2$ and $n$ and $3$ is less than or equal to the product of the quotient of the square root of the product of $2$ and $n$ and $2$ and the sum of the logarithm of $2$ and the product of $2$ and $n$ and $1$.",
    "output": "postulate not_bertrand_to_le2 : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (div (times 2 n) 3) (times (div (sqrt (times 2 n)) 2) (plus (log 2 (times 2 n)) 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nill_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.",
    "output": "postulate nill_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus_r. For all natural numbers $a$ and $b$ and $c$, if $a$ is less than the difference of $b$ and $c$, then the sum of $a$ and $c$ is less than $b$.",
    "output": "postulate lt_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt a (minus b c)) -> Lt (plus a c) b"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp3. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "div_mod_spec_rect_CProp3 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_845) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$.",
    "output": "lstar : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_relations.relation B) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. The number \\(\\pi\\) is an instance of real numbers.",
    "output": "pi : Elem Real ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "range_rect_Type0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type0) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type0 (Q_ x_927) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psi_exp5. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "le_Psi_exp5 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then the square of $x$ is an instance of real numbers defined as the function that maps $x$ to the exponentiation of $x$ and $2$.",
    "output": "def square : Elem Real -> Elem Real := x => pow x 2 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_to_log_r. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_log.log$ applied to $b$ and $m$.",
    "output": "exp_to_log_r : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) m) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_log.log b m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Enum_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "enum_body : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_inv_plus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$.",
    "output": "le_inv_plus_l : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "Aop_rect_CProp3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_879) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "iso : A : Set -> relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type4_body. For all functions $Q_$ from natural numbers $_x_369$ to elements of $Type4$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_370$ and elements $_x_372$ of $Q_$ of $x_370$ to elements of $Q_$ of the sum of $x_370$ and $1$, for all natural numbers $x_369$, $Q_$ holds for $x_369$.",
    "output": "nat_rect_Type4_body : Q_ : (_x_369 : Nat -> Type4) -> _H_O : Q_ 0 -> _H_S : (x_370 : Nat -> _x_372 : Q_ x_370 -> Q_ (plus x_370 (nd 1))) -> x_369 : Nat -> Q_ x_369 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.",
    "output": "Sig_rect_Type4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type4) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type4 (Q_ x_666) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_931$.",
    "output": "range_rect_CProp5_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_931) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_Conf3. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $matita_arithmetics_lstar.lstar$ applied to $A$ and $R$ and $l$.",
    "output": "lstar_Conf3 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B) -> R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> __ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Tail. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "tail : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nth_primeS. For all natural numbers $n$, $nth_prime$ applied to the sum of $n$ and $1$ is equal to $min$ applied to $let_upper_bound1$ applied to $n$ and the sum of $let_previous_prime1$ applied to $n$ and $1$ and $primeb$.",
    "output": "nth_primeS : n : Nat -> Eq (nth_prime (plus n (nd 1))) (min (let_upper_bound1 n) (plus (let_previous_prime1 n) (nd 1)) primeb) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_ind. For all functions $Q_$ from elements $_x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_326$.",
    "output": "bool_ind : Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_326 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_326) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_ind_r_aux. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "lstar_ind_r_aux : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> __2 : cic.Term cic.prop (R b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1) -> cic.Term cic.prop (P l b2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Psi_1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Psi_1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_div_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "eq_div_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n m) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Or_div_mod1. For all natural numbers $n$ and $q$, if $0$ is less than $q$, then $q$ is divisible by the sum of $n$ and $1$ and the sum of $n$ and $1$ is equal to the product of the sum of the quotient of $n$ and $q$ and $1$ and $q$ or $q$ is not divisible by the sum of $n$ and $1$ and the sum of $n$ and $1$ is equal to the sum of the product of the quotient of $n$ and $q$ and $q$ and the sum of $mod$ applied to $n$ and $q$ and $1$.",
    "output": "or_div_mod1 : n : Nat -> q : Nat -> __ : Lt 0 q -> or (and (divisible q (plus n (nd 1))) (Eq (plus n (nd 1)) (times (plus (div n q) (nd 1)) q))) (and (not (divisible q (plus n (nd 1)))) (Eq (plus n (nd 1)) (plus (times (div n q) q) (plus (mod n q) (nd 1))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_706$.",
    "output": "Prod_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_706) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transpose_i_j_i. For all natural numbers $i$ and $j$, $transpose$ applied to $i$ and $j$ and $i$ is equal to $j$.",
    "output": "transpose_i_j_i : i : Nat -> j : Nat -> Eq (transpose i j i) j ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B1_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.B1$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_psi_bounds.bool_to_nat$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.",
    "output": "B1_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.B1 n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_bertrand.k n p))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_fact_to_divides. For all natural numbers $p$ and $n$, if $p$ is prime, then if $p$ is divisible by the factorial of $n$, then $ex$ holds for $Nat$ and the function that maps $m$ to the conjunction of the conjunction of $Lt$ applied to $0$ and $m$ and $Leq$ applied to $m$ and $n$ and $divisible$ applied to $p$ and $m$.",
    "output": "divides_fact_to_divides : p : Nat -> n : Nat -> __ : prime p -> __1 : divisible p (factorial n) -> ex Nat (m : Nat => and (and (Lt 0 m) (Leq m n)) (divisible p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound7. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "let_upper_bound7 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_871$ of $Aop$ of $A$ and $_nil$ to elements of $Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_871$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_871$.",
    "output": "Aop_rect_Type1 : A : Set -> _nil : A -> Q_ : (_x_871 : Aop A _nil -> Type1) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_871 : Aop A _nil -> Q_ x_871 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1188$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1189$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Sig_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ univs.Type2) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "Aop_rect_Type3 : A : Set -> _nil : A -> Q_ : (_x_867 : Aop A _nil -> Type3) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_CProp0. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "nat_rect_CProp0 : Q_ : (_x_413 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_414 : Nat -> _x_416 : Q_ x_414 -> Q_ (plus x_414 (nd 1))) -> x_413 : Nat -> Q_ x_413 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_square_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "le_square_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "P_ord_aux_Strue. For all elements $n$ and $m$ and $p$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $q$ and $r$.",
    "output": "p_ord_aux_Strue : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_div_and_mod.div n m) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S p) n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S q) r)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1013. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $i$, for all functions $Hind$ from elements of $Eq$ of $max$ applied to $i$ and $f$ and $m$ and elements $__1$ of $Eq$ of $f$ applied to $m$ and absurdity to elements of $Eq$ of $m$ and $0$, if $f$ applied to $i$ is equal to $true$, then if $i$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then absurdity is equal to $true$.",
    "output": "let_clause_1013 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> i : Nat -> Hind : (__ : Eq (max i f) m -> __1 : Eq (f m) false -> Eq m 0) -> fi : Eq (f i) true -> eqm : Eq i m -> fm : Eq (f m) false -> Eq false true ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_fact_10. The factorial of the product of $2$ and $5$ is less than or equal to the product of the product of the exponentiation of $2$ and the difference of the product of $2$ and $5$ and $2$ and the factorial of $5$ and the factorial of $5$.",
    "output": "le_fact_10 : Leq (factorial (times (nd 2) (nd 5))) (times (times (pow (nd 2) (minus (times (nd 2) (nd 5)) (nd 2))) (factorial (nd 5))) (factorial (nd 5))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_ind. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z906$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z907$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_ind : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z906 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "Sum_rect_Type0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type0) -> _H_inl : (x_552 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> _H_inr : (x_553 : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type0 (Q_ x_551) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_m_exp_nm. For all natural numbers $n$ and $m$, if $1$ is less than $n$, then $m$ is less than the exponentiation of $n$ and $m$.",
    "output": "lt_m_exp_nm : n : Nat -> m : Nat -> __ : Lt (nd 1) n -> Lt m (pow n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.",
    "output": "eq_rect_CProp3 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_28 : cic.Term univs.Type2 A -> _x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_28 : cic.Term univs.Type2 A -> x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) -> cic.Term cic.prop (Q_ x_28 x_29) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "And_ind : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_120 : cic.Term cic.prop _A -> x_119 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) -> x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_118) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_times_gcd_aux. For all natural numbers $p$ and $m$ and $n$ and $d$ and $c$, if $0$ is less than $c$, then if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then if $d$ is divisible by the product of $c$ and $m$, then if $d$ is divisible by the product of $c$ and $n$, then $d$ is divisible by the product of $c$ and $gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "divides_times_gcd_aux : p : Nat -> m : Nat -> n : Nat -> d : Nat -> c : Nat -> __ : Lt 0 c -> __1 : Lt 0 n -> __2 : Leq n m -> __3 : Leq n p -> __4 : divisible d (times c m) -> __5 : divisible d (times c n) -> divisible d (times c (gcd_aux p m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_injective. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, $injective$ holds for $Nat$ and $Nat$ and $f$.",
    "output": "increasing_to_injective : f : (__ : Nat -> Nat) -> __ : increasing f -> injective Nat Nat f ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_4_to_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "lt_4_to_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_arithmetics_nat.plus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$.",
    "output": "length_append : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 l2)) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_bertrand_to_le1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "not_bertrand_to_le1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "min_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pad_bigop_nil. For all natural numbers $k$ and $n$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $or$ of $Eq$ applied to $p$ applied to $i$ and absurdity and $Eq$ applied to $f$ applied to $i$ and $nil$, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "pad_bigop_nil : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq n k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) (bigop k (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fact_to_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "fact_to_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_r_ind. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1336$ and $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "lstar_r_ind : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))) -> x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_Type1. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "div_mod_spec_rect_Type1 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type1) -> _H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type1 (Q_ x_829) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_ind. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "void_ind : Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_482 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_482) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_tail. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_arithmetics_nat.pred$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "length_tail : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_arithmetics_nat.pred (matita_basics_lists_list.length A l))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dividesb_true_to_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "dividesb_true_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "lt_to_not_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_eq_mod. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $mod$ applied to $n$ and $m$ is equal to $n$.",
    "output": "lt_to_eq_mod : n : Nat -> m : Nat -> __ : Lt n m -> Eq (mod n m) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_16003. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "let_clause_16003 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp0. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_859$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_858$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_859$ and $x_858$, for all elements $x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_857$.",
    "output": "div_mod_spec_rect_CProp0 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_857) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_eq_to_eqb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "not_eq_to_eqb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sigma_p_dividesb. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "sigma_p_dividesb : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop m (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10332. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10332 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eqb_body. For all natural numbers $__$ and $__1$, $bool$.",
    "output": "eqb_body : __ : Nat -> __1 : Nat -> bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_inv_rect_CProp2. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1482$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_851$ of $Lt$ of $x4$ and $x2$ and elements $x_850$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1483$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$, $P$ holds for $Hterm$.",
    "output": "div_mod_spec_inv_rect_CProp2 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1482 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_851 : Lt x4 x2 -> x_850 : Eq x1 (plus (times x3 x2) x4) -> _z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10331. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10331 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bdef. For all natural numbers $n$, $B$ applied to $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and $mod$ applied to the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ and $2$.",
    "output": "Bdef : n : Nat -> Eq (B n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (mod (div n (pow p (plus i (nd 1)))) (nd 2))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F2_ind_aux. For all elements $A1$ and $A2$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A1$ and $A2$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$.",
    "output": "f2_ind_aux : A1 : cic.Univ univs.Type0 -> A2 : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A1 -> __1 : cic.Term univs.Type0 A2 -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Invert_permut_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "invert_permut_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "Sum_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_562 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> _H_inr : (x_563 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_561) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_959$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_959$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_959$.",
    "output": "Dop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_959) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_spec_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_971$ and $x_972$.",
    "output": "max_spec_ind : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971) -> cic.Univ cic.prop) -> _H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n) -> x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))) -> _H_not_found_max_spec : (x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f x_976))) -> x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971) -> cic.Term cic.prop (Q_ x_971 x_972) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "plus_n_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus n matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.",
    "output": "eq_rect_Type1 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_16 : cic.Term univs.Type2 A -> _x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) -> cic.Univ univs.Type1) -> _H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x)) -> x_16 : cic.Term univs.Type2 A -> x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) -> cic.Term univs.Type1 (Q_ x_16 x_17) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_times_mod. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $0$ is less than $m$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and the product of $m$ and $p$ and $p$.",
    "output": "mod_times_mod : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Lt 0 m -> Eq (mod n p) (mod (mod n (times m p)) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "Dop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_963 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_963 : Dop A _nil -> Q_ x_963 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_sqrt_log_n. For all natural numbers $n$ and $b$, if $2$ is less than $b$, then the product of the square root of $n$ and the logarithm of $b$ and $n$ is less than or equal to $n$.",
    "output": "le_sqrt_log_n : n : Nat -> b : Nat -> __ : Lt (nd 2) b -> Leq (times (sqrt n) (log b n)) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1098$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_635$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_635$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_635$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "option_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1098 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ cic.prop) -> _H1 : (_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> _H2 : (x_635 : cic.Term univs.Type0 x1 -> _z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_635)) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_635))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_of_primes_def. For all natural numbers $n$, $list_of_primes$ applied to $n$ is equal to $lprim$ applied to $n$ and $2$ and $nil$ applied to $Nat$.",
    "output": "list_of_primes_def : n : Nat -> Eq (list_of_primes n) (lprim n (nd 2) (nil Nat)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_tail1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "length_tail1 : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_to_divides_ord_rem. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if $p$ is prime, then if $n$ is divisible by $m$, then $ord_rem$ applied to $n$ and $p$ is divisible by $ord_rem$ applied to $m$ and $p$.",
    "output": "divides_to_divides_ord_rem : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> divisible (ord_rem n p) (ord_rem m p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z954$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z955$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_CProp2 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z954 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z955 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_f_g. For all functions $f$ and $g$ from natural numbers to booleans, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ to elements of $Eq$ of $f$ applied to $i$ and $g$ applied to $i$, $max$ applied to $n$ and $f$ is equal to $max$ applied to $n$ and $g$.",
    "output": "max_f_g : f : (__ : Nat -> bool) -> g : (__ : Nat -> bool) -> n : Nat -> __ : (i : Nat -> __ : Lt i n -> Eq (f i) (g i)) -> Eq (max n f) (max n g) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "eq_fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type4_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_917$.",
    "output": "range_rect_Type4_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type4) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type4 (Q_ x_917) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log_exp1. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "log_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)) (matita_arithmetics_nat.times m (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_iter. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $g$ applied to $x$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$.",
    "output": "le_iter : g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ComplUniverse. We can prove that the complement of the universal set is equal to the empty set.",
    "output": "complUniverse : Proof (equalset (complement universeset) emptyset) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F_false_to_le_max. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $p$.",
    "output": "f_false_to_le_max : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) -> __1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_to_not_lt. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $m$ is not less than $n$.",
    "output": "le_to_not_lt : n : Nat -> m : Nat -> __ : Leq n m -> not (Lt m n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $x$ and $y$ be instances of natural numbers. Then the Legendre symbol of $x$ and $y$ is an instance of integers.",
    "output": "legendre : Elem Nat -> Elem Nat -> Elem Int ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Inv_eq_minus_O. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "inv_eq_minus_O : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_nat.le x y) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "M. If $Nat$, then if $Nat$, then $Nat$.",
    "output": "m : Nat -> Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "increasing_to_le2 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_to_mod_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "divides_to_mod_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $a1$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $a1$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z37$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z38$ to $P$ and $y$ and $x$.",
    "output": "option_discr : a1 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_basics_types.option a1) -> y : cic.Term univs.Type0 (matita_basics_types.option a1) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option a1)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z37 : cic.Term univs.Type1 P => P))) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) y) (t0 : cic.Term univs.Type0 a1 => matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) => P)) (_z38 : (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_singlevalued. For all sets $B$, for all elements $R$ of $relation2$ of $B$ and $B$, for all elements $__$ of $singlevalued$ of $B$ and $B$ and $R$, for all natural numbers $l$, $singlevalued$ holds for $B$ and $B$ and $lstar$ applied to $B$ and $R$ and $l$.",
    "output": "lstar_singlevalued : B : Set -> R : relation2 B B -> __ : singlevalued B B R -> l : Nat -> singlevalued B B (lstar B R l) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Cr_pair2. $cr_pair$ applied to $2$ and $3$ and $1$ and $0$ is equal to $3$.",
    "output": "cr_pair2 : Eq (cr_pair (nd 2) (nd 3) (nd 1) 0) (nd 3) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eqb_true_to_eq. For all natural numbers $n$ and $m$, if $eqb$ applied to $n$ and $m$ is equal to $true$, then $n$ is equal to $m$.",
    "output": "eqb_true_to_eq : n : Nat -> m : Nat -> __ : Eq (eqb n m) true -> Eq n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_bertrand_to_le_B. For all natural numbers $n$, if the exponentiation of $2$ and $7$ is less than or equal to $n$, then for all elements $__1$ of $not_bertrand$ of $n$, $B$ applied to the product of $2$ and $n$ is less than or equal to the product of the exponentiation of $2$ and the product of $2$ and the quotient of the product of $2$ and $n$ and $3$ and the exponentiation of the product of $2$ and $n$ and $pred$ applied to the quotient of the square root of the product of $2$ and $n$ and $2$.",
    "output": "not_bertrand_to_le_B : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> __1 : not_bertrand n -> Leq (B (times (nd 2) n)) (times (pow (nd 2) (times (nd 2) (div (times (nd 2) n) (nd 3)))) (pow (times (nd 2) n) (pred (div (sqrt (times (nd 2) n)) (nd 2))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "lt_to_not_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1308$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z1309$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_723$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_722$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_725$ from elements $_z1309$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_722$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $x_722$ and elements $_z1309$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_723$ and $x_722$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_723$ and $x_722$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "list_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1308 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type4) -> _H1 : (_z1309 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type4 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_723 : cic.Term univs.Type0 x1 -> x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_725 : (_z1309 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_722) -> cic.Term univs.Type4 (P x_722)) -> _z1309 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_723 x_722)) -> cic.Term univs.Type4 (P (matita_basics_lists_list.cons x1 x_723 x_722))) -> cic.Term univs.Type4 (P Hterm) ."
  }
]