[
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_exp2. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $n$, then the product of $m$ and the logarithm of $p$ and $n$ is less than or equal to the logarithm of $p$ and the exponentiation of $n$ and $m$.",
    "output": "postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_795$.",
    "output": "postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_795)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_previous_prime1. For all natural numbers $n$, $Nat$.",
    "output": "postulate let_previous_prime1 : (n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_CProp1. For all sets $_A$, for all functions $Q_$ from elements $_x_937$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $range$ of $_A$, $Q_$ holds for $x_937$.",
    "output": "postulate range_rect_CProp1 : (_A : Set) -> (Q_ : (_x_937 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_exp2. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$.",
    "output": "postulate log_exp2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times m (matita_arithmetics_log.log p n)) (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pred. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate pred : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_gcd_r. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $m$.",
    "output": "postulate divides_gcd_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_max_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $n$.",
    "output": "postulate lt_max_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1549. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $eqm0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $x1106$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1106$ and $matita_arithmetics_nat.minus$ applied to $x1106$ and $m$.",
    "output": "postulate let_clause_1549 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (eqm0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (x1106 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1106 (matita_arithmetics_nat.minus x1106 m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp1. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_853$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_855$ of $Lt$ of $_r$ and $_m$ and elements $x_854$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_855$ and $x_854$, for all elements $x_853$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_853$.",
    "output": "postulate div_mod_spec_rect_CProp1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1034. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $n$, then if $0$ is less than $m$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.",
    "output": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (q : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_below. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate all_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15611. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $p$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $p$ is divisible by the product of $m$ and $n$, then for all natural numbers $c$, if the product of $m$ and $n$ is equal to the product of $p$ and $c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$, then the difference of the product of $m$ and $b$ and the product of $p$ and $a$ is equal to $1$.",
    "output": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive_times_plus. $distributive$ holds for $Nat$ and $times$ and $plus$.",
    "output": "postulate distributive_times_plus : distributive Nat times plus"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_div_div_times. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $m$.",
    "output": "postulate le_times_div_div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_ord_rem. For all natural numbers $m$ and $p$, if $0$ is less than $m$, then if $1$ is less than $p$, then $p$ is not divisible by $ord_rem$ applied to $m$ and $p$.",
    "output": "postulate not_divides_ord_rem : (m : Nat) -> (p : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 1 p) -> not (divisible p (ord_rem m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_divides_times. For all natural numbers $p$ and $q$ and $n$, if $p$ is prime, then if $p$ is not divisible by $q$, then if $p$ is divisible by $n$, then if $q$ is divisible by $n$, then the product of $p$ and $q$ is divisible by $n$.",
    "output": "postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1075. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $bijf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $fS$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lein$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $Hc$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $a$.",
    "output": "postulate let_clause_1075 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (bijf : cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))) -> (fS : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n))) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_to_le_max. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $m$ is less than $n$, then if $f$ applied to $m$ is equal to $true$, then $m$ is less than or equal to $max$ applied to $n$ and $f$.",
    "output": "postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> Leq m (max n f)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_to_le_r. For all natural numbers $a$ and $n$ and $m$, if the sum of $n$ and $a$ is less than or equal to the sum of $m$ and $a$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_plus_to_le_r : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus n a) (plus m a)) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "S. If $Nat$, then $Nat$.",
    "output": "postulate s : Nat -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z329$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $x_124$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_123$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z330$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_124$ and $x_123$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_124$ and $x_123$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_Type4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (x_124 : cic.Term cic.prop x1) -> (x_123 : cic.Term cic.prop x2) -> (_z330 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_rect_Type5. For all functions $Q_$ from elements $_x_484$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $x_484$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_484$.",
    "output": "postulate void_rect_Type5 : (Q_ : (_x_484 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type5) -> (x_484 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type5 (Q_ x_484)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ReflSubset. For all sets $A$, we can prove that $A$ is a subset of $A$.",
    "output": "postulate reflSubset : (A : Set) -> subseteq A A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_sn. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b$ and $b2$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $b1$ of $B$, for all elements $__1$ of $R$ of $b1$ and $b$, $lstar_r$ holds for $B$ and $R$ and the sum of $l$ and $1$ and $b1$ and $b2$.",
    "output": "postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (plus l 1) b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sigma_p_dividesb1. For all natural numbers $m$ and $n$ and $p$ and $k$, if $0$ is less than $n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then if $m$ is less than or equal to $k$, then $m$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_2_pred. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate times_2_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred n)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nilr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $a$.",
    "output": "postulate nilr_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a nil) a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_pi2$ of $cic.Term$ of $cic.prop$ and $f$ applied to $pi1$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $f$.",
    "output": "postulate mk_Sig : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (f pi1)) -> cic.Term univs.Type0 (matita_basics_types.Sig A f)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1544. For all elements $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $q$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$, for all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $lenm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $lenS$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $q$, for all elements $ndivnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $b$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "postulate let_clause_1544 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (lenm : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (lenS : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S q))) -> (ndivnm : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times b n)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times b n)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times b n)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times n b)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_inv_rect_Type3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z984$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$, for all functions $_H2$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate Sum_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z984 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_537 : cic.Term univs.Type0 x1) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_537))) -> cic.Term univs.Type3 (P (matita_basics_types.inl x1 x2 x_537))) -> (_H2 : (x_538 : cic.Term univs.Type0 x2) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $__$ be a natural number. Then the successor of $__$ is a natural number.",
    "output": "postulate succ : (_ : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_nth_prime_to_not_prime. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then if $m$ is less than $nth_prime$ applied to the sum of $n$ and $1$, then $m$ is not prime.",
    "output": "postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> (__1 : Lt m (nth_prime (plus n 1))) -> not (prime m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Or : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_smallest_factor_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $n$.",
    "output": "postulate prime_smallest_factor_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.smallest_factor n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_CProp2. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_626$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_627$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_627$, for all elements $x_626$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_626$.",
    "output": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_div_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $n$.",
    "output": "postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_exp. For all natural numbers $n$ and $m$ and $p$, if $1$ is less than $p$, then if $n$ is less than $m$, then the exponentiation of $p$ and $n$ is less than the exponentiation of $p$ and $m$.",
    "output": "postulate lt_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 1 p) -> (__1 : Lt n m) -> Lt (pow p n) (pow p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_plus_comm_23. For all natural numbers $x$ and $y$ and $z$, the sum of the sum of $x$ and $y$ and $z$ is equal to the sum of the sum of $x$ and $z$ and $y$.",
    "output": "postulate plus_plus_comm_23 : (x : Nat) -> (y : Nat) -> (z : Nat) -> Eq (plus (plus x y) z) (plus (plus x z) y)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_minus_l. For all elements $p$ and $q$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $q$ and $n$ and $matita_arithmetics_nat.minus$ applied to $p$ and $n$.",
    "output": "postulate monotonic_le_minus_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_SO_nth_prime_n. For all natural numbers $n$, $1$ is less than $nth_prime$ applied to $n$.",
    "output": "postulate lt_SO_nth_prime_n : (n : Nat) -> Lt 1 (nth_prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dexp. $Dop$ holds for $Nat$ and $1$.",
    "output": "postulate Dexp : Dop Nat 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_exp1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$.",
    "output": "postulate lt_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_div. For all natural numbers $n$, if $0$ is less than $n$, then $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $m$ to the quotient of $m$ and $n$.",
    "output": "postulate monotonic_div : (n : Nat) -> (_ : Lt 0 n) -> monotonic Nat Leq (\\ m : Nat -> div m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_bool. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_true$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.true$, for all elements $case_false$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.false$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_bool : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) -> (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) -> (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) -> (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primeb. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate primeb : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact_minus. For all elements $n$ and $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $k$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $k$ and $matita_arithmetics_nat.minus$ applied to $n$ and $k$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $k$.",
    "output": "postulate fact_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt k n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S k))) (matita_arithmetics_nat.minus n k)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pair_destruct_1. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $c$.",
    "output": "postulate pair_destruct_1 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> (c : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_sigma_pi_SO_n. For all natural numbers $n$, $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$ is equal to $n$.",
    "output": "postulate eq_sigma_pi_SO_n : (n : Nat) -> Eq (bigop n (\\ i : Nat -> true) Nat 0 plus (\\ i : Nat -> 1)) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unique. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1034. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.",
    "output": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_sumI. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $c$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $c$ and $b$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $b$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $b$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$.",
    "output": "postulate bigop_sumI : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le b c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i b)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i b))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a)))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "postulate nat_rect_CProp3_body : (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_401)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "PlusAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$.",
    "output": "postulate plusAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb_true_l. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$.",
    "output": "postulate andb_true_l : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp4_body. For all functions $Q_$ from natural numbers $_x_393$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_394$ and elements $_x_396$ of $Q_$ of $x_394$ to elements of $Q_$ of the sum of $x_394$ and $1$, for all natural numbers $x_393$, $Q_$ holds for $x_393$.",
    "output": "postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "postulate distr_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example11. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "postulate decidable_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_div_mod_spec. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $return_type$ of $z$, for all elements $z$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $return_type$ holds for $z$.",
    "output": "postulate filter_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (return : (z : div_mod_spec _n _m _q _r) -> return_type z) -> (z : div_mod_spec _n _m _q _r) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "postulate Dop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_exp. For all natural numbers $n$ and $m$ and $i$, if $0$ is less than $m$, then if $mod$ applied to $n$ and $m$ is not equal to $0$, then for all natural numbers $p$, if $i$ is less than or equal to $p$, then $p_ord_aux$ applied to $p$ and the product of the exponentiation of $m$ and $i$ and $n$ and $m$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $i$ and $n$.",
    "output": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_times_times. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$.",
    "output": "postulate div_times_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_divides. For all natural numbers $_n$ and $_m$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $divisible$ of $_n$ and $_m$ to elements of $return_sort$, for all functions $case_quotient$ from natural numbers $q$ and elements of $Eq$ of $_m$ and the product of $_n$ and $q$ to elements of $return_type$ of $quotient$ applied to $_n$ and $_m$ and $q$ and $__$, if $_n$ is divisible by $_m$, then $return_type$ holds for $z$.",
    "output": "postulate match_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_sigma_p. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, for all elements $__2$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and the disjunction of the conjunction of $Eq$ applied to $p1$ applied to $i$ and $true$ and $Lt$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ and the conjunction of the conjunction of $Eq$ applied to $p1$ applied to $i$ and absurdity and $Eq$ applied to $p2$ applied to $i$ and $true$ and $Lt$ applied to $0$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_572$, for all functions $_H_inr$ from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_573$, for all elements $x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_571$.",
    "output": "postulate Sum_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))) -> (_H_inr : (x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))) -> (x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_571)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop160. For all instances $a$ and $b$ of integers, we can prove that if $same_parity$ holds for the sum of $a$ and $b$ and the product of $a$ and $b$, then $a$ is even and $b$ is even.",
    "output": "postulate prop160 : (a : Int) -> (b : Int) -> if (same_parity (plus a b) (times a b)) (and (even a) (even b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bijn_fg. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to the function that maps $p$ to $f$ applied to $g$ applied to $p$ and $n$.",
    "output": "postulate bijn_fg : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (g p)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_maxl. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$.",
    "output": "postulate le_maxl : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)) -> cic.Term cic.prop (matita_arithmetics_nat.le n i)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus1. For all natural numbers $a$ and $b$ and $c$, if $c$ is less than or equal to $b$, then the sum of $a$ and the difference of $b$ and $c$ is equal to the difference of the sum of $a$ and $b$ and $c$.",
    "output": "postulate plus_minus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> Eq (plus a (minus b c)) (minus (plus a b) c)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp4. For all functions $Q_$ from natural numbers $_x_393$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_394$ and elements $_x_396$ of $Q_$ of $x_394$ to elements of $Q_$ of the sum of $x_394$ and $1$, for all natural numbers $x_393$, $Q_$ holds for $x_393$.",
    "output": "postulate nat_rect_CProp4 : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_divides_ord_rem. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$.",
    "output": "postulate divides_to_divides_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_spec_to_max. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$.",
    "output": "postulate max_spec_to_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primes_below_to_bertrand. For all elements $pm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $pm$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $pm$, for all functions $__2$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $pm$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "postulate primes_below_to_bertrand : (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) -> (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ pp : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_diff. For all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i$ is less than $n$, then if $p$ applied to $i$ is equal to $true$, then $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_option. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_None$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $case_Some$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.Some$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_option : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) -> (case_None : cic.Term return_sort (return_type (matita_basics_types.None _A))) -> (case_Some : (__ : cic.Term univs.Type0 _A) -> cic.Term return_sort (return_type (matita_basics_types.Some _A __))) -> (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_minus_r. For all natural numbers $p$ and $q$ and $n$, if $q$ is less than or equal to $p$, then the difference of $n$ and $p$ is less than or equal to the difference of $n$ and $q$.",
    "output": "postulate monotonic_le_minus_r : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq q p) -> Leq (minus n p) (minus n q)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_plus_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $q$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $q$.",
    "output": "postulate exp_plus_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.plus p q)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp n q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15691. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.",
    "output": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type0. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1464$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_835$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_834$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1465$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_835$ and $x_834$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_835$ and $x_834$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type0 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1464 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type0) -> (_H1 : (x_835 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_834 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1465 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_835 x_834))) -> cic.Term univs.Type0 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_835 x_834))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "postulate le_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_rect_CProp1_body. For all functions $Q_$ from elements $_x_517$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_517$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_517$.",
    "output": "postulate unit_rect_CProp1_body : (Q_ : (_x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_517)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_spec_inv_ind. For all elements $x1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $x1$ and $x2$ and $x3$, for all functions $P$ from elements $_z1769$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $x1$ and elements $_x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1770$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$, for all functions $_H2$ from functions $_x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1770$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x3$.",
    "output": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 m)) -> cic.Term cic.prop (P m)) -> (_H2 : (_x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P x3)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp2. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact_minus. For all natural numbers $n$ and $k$, if $k$ is less than $n$, then the product of the factorial of the difference of $n$ and the sum of $k$ and $1$ and the difference of $n$ and $k$ is equal to the factorial of the difference of $n$ and $k$.",
    "output": "postulate fact_minus : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (times (factorial (minus n (plus k 1))) (minus n k)) (factorial (minus n k))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_fn. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, for all natural numbers $n$, $n$ is less than or equal to $f$ applied to $n$.",
    "output": "postulate le_n_fn : (f : (_ : Nat) -> Nat) -> (_ : increasing f) -> (n : Nat) -> Leq n (f n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_times. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $p$ and $p$.",
    "output": "postulate mod_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times n m) p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod m p)) p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_rect_Type2. For all functions $Q_$ from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.",
    "output": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_le_minus_minus_comm. For all elements $b$ and $c$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $c$ and $b$.",
    "output": "postulate minus_le_minus_minus_comm : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a c) b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_648$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_648$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_648$.",
    "output": "postulate DPair_rect_Type1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type1) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type1 (Q_ x_648)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_b. For all natural numbers $b$ and $n$ and $m$, if the sum of $n$ and $b$ is less than or equal to $m$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_plus_b : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus n b) m) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Associative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.associative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate associative_plus : cic.Term cic.prop (matita_basics_relations.associative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_Type1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_700$.",
    "output": "postulate Prod_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type1) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type1 (Q_ x_700)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_maxl. For all natural numbers $i$ and $n$ and $m$, if $max$ applied to $n$ and $m$ is less than or equal to $i$, then $n$ is less than or equal to $i$.",
    "output": "postulate le_maxl : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq n i"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus_to_minus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.",
    "output": "postulate lt_plus_to_minus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus c b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B2_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.B2$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_B2_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_divides_M. For all natural numbers $m$ and $p$, if $p$ is prime, then if the sum of $m$ and $1$ is less than $p$, then if $p$ is less than or equal to the sum of the product of $2$ and $m$ and $1$, then $p$ is divisible by $M$ applied to $m$.",
    "output": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.",
    "output": "postulate div_mod_spec_rect_Type5 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)"
  }
]