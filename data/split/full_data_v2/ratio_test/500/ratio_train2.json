[
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_aux_to_exp. For all elements $p$ and $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $q$ and $r$.",
    "output": "postulate p_ord_aux_to_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m q) r))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_sqrt_nl. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $m$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_73. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then for all natural numbers $x134$ and $x135$ and $x136$, the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp0_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_885$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_885$.",
    "output": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $Lt$ of $_r$ and $_m$ and elements $x_814$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_813$.",
    "output": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_times_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ and $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, for all functions $P$ from elements $x0$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x0$ and $a$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $__$ of $cic.Term$ of $univs.Type3$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $x$ and $p$.",
    "output": "postulate eq_rect_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> (P : (x0 : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x0 a)) -> cic.Univ univs.Type3) -> (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) -> cic.Term univs.Type3 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type0_body. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "postulate nat_rect_Type0_body : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_mem_nat. For all natural numbers $n$, for all lists $l$ of natural numbers, $decidable$ holds for $mem$ applied to $Nat$ and $n$ and $l$.",
    "output": "postulate decidable_mem_nat : (n : Nat) -> (l : list Nat) -> decidable (mem Nat n l)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z161$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_965$.",
    "output": "postulate Dop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_965)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_nth. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $matita_basics_lists_list.nth_opt$ applied to $A$ and $n$ and $l$ and $matita_basics_types.Some$ applied to $A$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate All_nth : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a))) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_sqrt. $monotonic$ holds for $Nat$ and $Leq$ and $sqrt$.",
    "output": "postulate monotonic_sqrt : monotonic Nat Leq sqrt"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z647$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z647 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive_times_minus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.minus$.",
    "output": "postulate distributive_times_minus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.minus)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "To_max. For all natural numbers $i$ and $n$ and $m$, if $n$ is less than or equal to $i$, then if $m$ is less than or equal to $i$, then $max$ applied to $n$ and $m$ is less than or equal to $i$.",
    "output": "postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_ind_body. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1336$ and $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "postulate lstar_r_ind_body : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop) -> (_H_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (_H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))) -> (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_plus_l. For all natural numbers $m$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $n$ to the sum of $n$ and $m$.",
    "output": "postulate monotonic_le_plus_l : (m : Nat) -> monotonic Nat Leq (\\ n : Nat -> plus n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from natural numbers to natural numbers, for all sets $A$, for all elements $I$ and $J$ and $K$ of $range$ of $A$, for all elements $__$ of $sub_hk$ of $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $sub_hk$ of $h2$ and $k2$ and $A$ and $J$ and $K$, $sub_hk$ holds for the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "postulate transitive_sub : (h1 : (_ : Nat) -> Nat) -> (k1 : (_ : Nat) -> Nat) -> (h2 : (_ : Nat) -> Nat) -> (k2 : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (K : range A) -> (_ : sub_hk h1 k1 A I J) -> (__1 : sub_hk h2 k2 A J K) -> sub_hk (\\ x : Nat -> h2 (h1 x)) (\\ x : Nat -> k1 (k2 x)) A I K"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_pi_l. For all natural numbers $n$ and $a$, for all functions $f$ from natural numbers to natural numbers, the product of the exponentiation of $a$ and $n$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of $a$ and $f$ applied to $i$.",
    "output": "postulate exp_pi_l : (n : Nat) -> (a : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (times (pow a n) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> f i))) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> times a (f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable. For all elements $__$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate decidable : (__ : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.plus$ applied to $c$ and $b$.",
    "output": "postulate lt_minus_to_plus : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus c b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_ACop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $b$ and $a$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.",
    "output": "postulate mk_ACop : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil aop a b) (matita_arithmetics_bigops.op A nil aop b a))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_hk. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max'. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all natural numbers $__2$, $Nat$.",
    "output": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "postulate lt_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iff_sym. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $A$.",
    "output": "postulate iff_sym : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff B A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_assoc_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R1$ and $R2$ and $R3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R3$ and $matita_basics_relations.Rcomp$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R2$ and $R3$.",
    "output": "postulate sub_assoc_l : (A : cic.Univ univs.Type0) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R3 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "postulate transpose : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_times_n_to_lt_r. For all natural numbers $n$ and $p$ and $q$, if the product of $n$ and $p$ is less than the product of $n$ and $q$, then $p$ is less than $q$.",
    "output": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_primes. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate all_primes : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.",
    "output": "postulate ACop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B2. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate andb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_O_f. For all functions $f$ from natural numbers to booleans, for all natural numbers $b$, $min$ applied to $0$ and $b$ and $f$ is equal to $b$.",
    "output": "postulate min_O_f : (f : (_ : Nat) -> bool) -> (b : Nat) -> Eq (min 0 b f) b"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp4. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "postulate False_rect_CProp4 : (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_73)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_smallest_factor_n. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is prime.",
    "output": "postulate prime_smallest_factor_n : (n : Nat) -> (_ : Lt 1 n) -> prime (smallest_factor n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.",
    "output": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "postulate DPair_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_943$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_943$.",
    "output": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1278$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1279$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp5. For all functions $Q_$ from elements $_x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_74$.",
    "output": "postulate False_rect_CProp5 : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "postulate True_rect_Type4 : (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) -> (x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type4 (Q_ x_42)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ComplIntersection. For all sets $A$, we can prove that the intersection of $A$ and the complement of $A$ is equal to the empty set.",
    "output": "postulate complIntersection : (A : Set) -> equalset (intersection A (complement A)) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.",
    "output": "postulate commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z2006$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.times$ applied to $x1$ and $q$ and elements $_z2007$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate divides_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> (P : (_z2006 : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.times x1 q))) -> (_z2007 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_primes.divides x1 x2)) Hterm (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_793$.",
    "output": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example2. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$.",
    "output": "postulate lt_div_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m)) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.",
    "output": "postulate list_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_times_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $m$ to the product of $n$ and $m$.",
    "output": "postulate monotonic_le_times_r : (n : Nat) -> monotonic Nat Leq (\\ m : Nat -> times n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_O_to_divides. For all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $mod$ applied to $m$ and $n$ is equal to $0$, then $n$ is divisible by $m$.",
    "output": "postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_953$ of $Dop$ of $A$ and $_nil$ to elements of $Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "S_mod. For all natural numbers $_n$ and $_m$, $Nat$.",
    "output": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_div. For all natural numbers $a$ and $b$ and $c$, if $0$ is less than $b$, then if $c$ is divisible by $b$, then the product of $a$ and the quotient of $b$ and $c$ is equal to the quotient of the product of $a$ and $b$ and $c$.",
    "output": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate bigop : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10331. For all elements $p$ and $n$ and $n1$ and $q$ and $p1$ and $p2$ and $qa$ and $ra$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $p2$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S (matita_arithmetics_nat.S p2))) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nilr. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $a$.",
    "output": "postulate nilr : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx a nil) a"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Univ. For all elements $s$ of $Sort$, $Univ$ holds for $succ$ applied to $s$.",
    "output": "postulate univ : (s : Sort) -> Univ (succ s)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_times. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then the logarithm of $p$ and the product of $n$ and $m$ is less than or equal to the sum of the sum of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$ and $1$.",
    "output": "postulate log_times : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_aux_body. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_ind. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z257$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z258$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_80$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_80$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_ind : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_80 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z258 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_CProp3_body. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "postulate True_rect_CProp3_body : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "LePsi_prim. For all natural numbers $n$, the exponentiation of $n$ and $prim$ applied to $n$ is less than or equal to the product of $Psi$ applied to $n$ and $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$.",
    "output": "postulate lePsi_prim : (n : Nat) -> Leq (pow n (prim n)) (times (Psi n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sym_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$.",
    "output": "postulate sym_eq : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (y : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term cic.prop (matita_basics_logic.eq A y x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1573. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate let_clause_1573 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_O_to_not_divides. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate ord_O_to_not_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate monotonic : (A : cic.Univ univs.Type0) -> (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_ltl. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$ and $n$.",
    "output": "postulate length_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.ltl A l n)) (matita_arithmetics_nat.minus (matita_basics_lists_list.length A l) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_to_gcd_aux. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $n$ is not divisible by $m$, then $gcd_aux$ applied to the sum of $p$ and $1$ and $m$ and $n$ is equal to $gcd_aux$ applied to $p$ and $n$ and $mod$ applied to $m$ and $n$.",
    "output": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_m. For all natural numbers $m$ and $n$, if $m$ is less than or equal to $n$, then the difference of the sum of $n$ and $1$ and $m$ is equal to the sum of the difference of $n$ and $m$ and $1$.",
    "output": "postulate minus_Sn_m : (m : Nat) -> (n : Nat) -> (_ : Leq m n) -> Eq (minus (plus n 1) m) (plus (minus n m) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_rect_Type3. For all functions $Q_$ from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_true$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.",
    "output": "postulate bool_rect_Type3 : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2 : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_30. For all instances $x$ of integers, we can prove that if the difference of the product of $5$ and $x$ and $7$ is odd, then the sum of the product of $9$ and $x$ and $2$ is even.",
    "output": "postulate noLabel_30 : (x : Int) -> if (odd (minus (times 5 x) 7)) (even (plus (times 9 x) 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type3. For all functions $Q_$ from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.",
    "output": "postulate True_rect_Type3 : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "None. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_ind_body. For all functions $Q_$ from elements $_x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_495$.",
    "output": "postulate unit_ind_body : (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_495)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate prod_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (_x_969 : cic.Term univs.Type0 A) -> (_x_970 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_mod_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate divides_mod_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_p_ord_inv. For all natural numbers $p$ and $m$ and $x$, if $ord$ applied to $x$ and $p$ is less than $m$, then the quotient of $p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ is equal to $ord_rem$ applied to $x$ and $p$.",
    "output": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_x_times_x. For all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.",
    "output": "postulate le_x_times_x : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_congruent. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and the function that maps $n$ and $m$ to $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate transitive_congruent : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_congruence.congruent n m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Hint_declaration_CProp1. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all elements $_a$ and $_b$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate hint_declaration_CProp1 : (A : cic.Univ cic.prop) -> (_a : cic.Term cic.prop A) -> (_b : cic.Term cic.prop A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc1. For all natural numbers $n$ and $k$, if $k$ is less than $n$, then $bc$ applied to the sum of $n$ and $1$ and the sum of $k$ and $1$ is equal to the sum of $bc$ applied to $n$ and $k$ and $bc$ applied to $n$ and the sum of $k$ and $1$.",
    "output": "postulate bc1 : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (bc (plus n 1) (plus k 1)) (plus (bc n k) (bc n (plus k 1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Confluent. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.",
    "output": "postulate confluent : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type5_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.",
    "output": "postulate div_mod_spec_rect_Type5_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_exp_log. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "postulate lt_exp_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_log.log p n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_pi. For all natural numbers $n$ and $m$, for all functions $p$ from natural numbers to booleans, for all functions $f$ from natural numbers to natural numbers, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $f$ applied to $i$ and $m$ is equal to the exponentiation of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ and $m$.",
    "output": "postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> pow (f i) m)) (pow (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> f i)) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_921$.",
    "output": "postulate range_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type3 (Q_ x_921)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_4_to_le_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate lt_4_to_le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_pi. For all natural numbers $n$, for all functions $p$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_to_times. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $q$ and $m$.",
    "output": "postulate lt_div_to_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times q m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_CProp2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_935$.",
    "output": "postulate range_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_935)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Increasing_to_monotonic. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and $f$.",
    "output": "postulate increasing_to_monotonic : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt f)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_875$.",
    "output": "postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_875)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $ACop$ of $A$ and $nil$, $Aop$ holds for $A$ and $nil$.",
    "output": "postulate aop : (A : Set) -> (nil : A) -> (_xxx : ACop A nil) -> Aop A nil"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_lstar_r. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from natural numbers and elements $__1$ of $B$ and elements $__2$ of $B$ and elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_sort$, for all functions $case_lstar_r_O$ from elements $b$ of $B$ to elements of $return_type$ of $0$ and $b$ and $b$ and $lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_r_S$ from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements of $lstar_r$ of $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $B$ and elements $__1$ of $_R$ of $b$ and $b2$ to elements of $return_type$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $__$ and $b2$ and $__1$, for all natural numbers $__$, for all elements $__1$ and $__2$ of $B$, for all elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$, $return_type$ holds for $__$ and $__1$ and $__2$ and $z$.",
    "output": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1056$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_603$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_603$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_603$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate option_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1056 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type2) -> (_H1 : (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type2 (P (matita_basics_types.None x1))) -> (_H2 : (x_603 : cic.Term univs.Type0 x1) -> (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_925$.",
    "output": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_ltransitive. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.ltransitive$ applied to $B$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$.",
    "output": "postulate lstar_ltransitive : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> cic.Term cic.prop (matita_arithmetics_lstar.ltransitive B (matita_arithmetics_lstar.lstar B R))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_ind_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_720$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_717$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_718$ and $x_717$, for all elements $x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_716$.",
    "output": "postulate list_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_718 : cic.Term univs.Type0 _A) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_720 : cic.Term cic.prop (Q_ x_717)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> (x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_716)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Permut_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $permut$ of $f$ and $n$, $permut$ holds for $invert_permut$ applied to $n$ and $f$ and $n$.",
    "output": "postulate permut_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> permut (invert_permut n f) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_sigma. For all elements $n$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $a$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate exp_sigma : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) -> (divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1))) -> (eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_inv_step. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $b1$ and $b2$.",
    "output": "postulate lstar_inv_step : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) -> cic.Term cic.prop (R b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10335. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10335 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_CProp1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1488$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1489$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_to_p_ord_O. For all natural numbers $n$ and $i$, if $nth_prime$ applied to $i$ is not divisible by $n$, then $p_ord$ applied to $n$ and $nth_prime$ applied to $i$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $0$ and $n$.",
    "output": "postulate not_divides_to_p_ord_O : (n : Nat) -> (i : Nat) -> (_ : not (divisible (nth_prime i) n)) -> Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_664$.",
    "output": "postulate Sig_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_664)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_lt_minus_l. For all natural numbers $p$ and $q$ and $n$, if $n$ is less than or equal to $q$, then if $q$ is less than $p$, then the difference of $q$ and $n$ is less than the difference of $p$ and $n$.",
    "output": "postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq n q) -> (__1 : Lt q p) -> Lt (minus q n) (minus p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_not_bertrand_to_bertrand1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $x$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $__3$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $p$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $x$ and $matita_arithmetics_primes.prime$ applied to $p$.",
    "output": "postulate not_not_bertrand_to_bertrand1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n))) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n x)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> (__3 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt x p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime p))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_nat.le p x)) (matita_arithmetics_primes.prime p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_Bk_B1_B2. For all natural numbers $n$, $Bk$ applied to $n$ is equal to the product of $B1$ applied to $n$ and $B2$ applied to $n$.",
    "output": "postulate eq_Bk_B1_B2 : (n : Nat) -> Eq (Bk n) (times (B1 n) (B2 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "AssocIntersection. For all sets $A$, $B$ and $C$, we can prove that the intersection of the intersection of $A$ and $B$ and $C$ is equal to the intersection of $A$ and the intersection of $B$ and $C$.",
    "output": "postulate assocIntersection : (A : Set) -> (B : Set) -> (C : Set) -> equalset (intersection (intersection A B) C) (intersection A (intersection B C))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1236$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1237$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.",
    "output": "postulate DPair_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_652)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fst. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate fst : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_cases. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $f$ applied to $n$ is equal to $true$ and $max$ applied to the sum of $n$ and $1$ and $f$ is equal to $n$ or $f$ applied to $n$ is equal to absurdity and $max$ applied to the sum of $n$ and $1$ and $f$ is equal to $max$ applied to $n$ and $f$.",
    "output": "postulate max_cases : (f : (_ : Nat) -> bool) -> (n : Nat) -> or (and (Eq (f n) true) (Eq (max (plus n 1) f) n)) (and (Eq (f n) false) (Eq (max (plus n 1) f) (max n f)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $x$ and $y$ be instances of natural numbers. Then the Legendre symbol of $x$ and $y$ is an instance of integers.",
    "output": "postulate legendre : Nat -> Nat -> Int"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_to_eqb_true. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$.",
    "output": "postulate eq_to_eqb_true : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the exponentiation of $n$ and $m$, then $p$ is divisible by $n$.",
    "output": "postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type4. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1440$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to elements of $Type4$, for all functions $_H1$ from elements $x_815$ of $Lt$ of $x4$ and $x2$ and elements $x_814$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1441$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$, $P$ holds for $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type4 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1440 : div_mod_spec x1 x2 x3 x4) -> Type4) -> (_H1 : (x_815 : Lt x4 x2) -> (x_814 : Eq x1 (plus (times x3 x2) x4)) -> (_z1441 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Tri_relation. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate tri_relation : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> (__2 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_rect_CProp1_body. For all functions $Q_$ from elements $_x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_493$.",
    "output": "postulate void_rect_CProp1_body : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_ind_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_809$.",
    "output": "postulate div_mod_spec_ind_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1410$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1411$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1410 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1411 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp2_body. For all functions $Q_$ from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.",
    "output": "postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_n_n. For all natural numbers $n$, if $0$ is less than $n$, then $mod$ applied to $n$ and $n$ is equal to $0$.",
    "output": "postulate mod_n_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (mod n n) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_n. For all natural numbers $n$, $1$ is equal to the difference of the sum of $n$ and $1$ and $n$.",
    "output": "postulate minus_Sn_n : (n : Nat) -> Eq 1 (minus (plus n 1) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate fact : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate append : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B1. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_found_max_spec. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $n$ and $f$ and $matita_arithmetics_nat.O$.",
    "output": "postulate not_found_max_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Type3. $cic.Sort$.",
    "output": "postulate Type3 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_to_le. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_exp.exp$ applied to $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_exp_to_le : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_ind_l. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b2$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b1$.",
    "output": "postulate lstar_ind_l : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate div_mod_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "R1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "postulate R1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Is_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate is_nil : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_div_mod_spec. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $m$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_lt_to_lt. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$.",
    "output": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ and $_m$ and $_p$ be natural numbers. Then $congruent$ applied to $_n$ and $_m$ and $_p$ is a proposition.",
    "output": "postulate congruent : (_n : Nat) -> (_m : Nat) -> (_p : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1648. For all natural numbers $n$ and $q$, if $0$ is less than $q$, then for all natural numbers $n1$, if $n1$ is equal to the sum of the product of $bigop$ applied to the sum of $n1$ and $1$ and the function that maps $m$ to $andb$ applied to $leb$ applied to $1$ and $m$ and $dividesb$ applied to $q$ and $m$ and $Nat$ and $0$ and $plus$ and the function that maps $m$ to $1$ and $q$ and $mod$ applied to $n1$ and $q$, then if $q$ is divisible by the sum of $n1$ and $1$ and the sum of $n1$ and $1$ is equal to the product of the sum of the quotient of $n1$ and $q$ and $1$ and $q$, then if $q$ is divisible by the sum of $n1$ and $1$, then if the sum of $n1$ and $1$ is equal to the product of the sum of the quotient of $n1$ and $q$ and $1$ and $q$, then the sum of $n1$ and $1$ is equal to the sum of $q$ and the product of $q$ and the quotient of $n1$ and $q$.",
    "output": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "postulate div_mod_spec_rect_Type1_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) -> (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type1 (Q_ x_829)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $c$ and $b$.",
    "output": "postulate lt_minus_to_plus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus b c))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a c) b)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_theta_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "postulate div_theta_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NatD. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$.",
    "output": "postulate natD : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop matita_arithmetics_nat.nat matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than $m$, then $n$ is less than $m$.",
    "output": "postulate lt_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) m) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15622. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.",
    "output": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Checker_ab. For all natural numbers $a$ and $b$, for all lists $l$ of natural numbers, $checker$ applied to $cons$ applied to $Nat$ and $a$ and $cons$ applied to $Nat$ and $b$ and $l$ is equal to $andb$ applied to $andb$ applied to $leb$ applied to the sum of $a$ and $1$ and $b$ and $leb$ applied to $b$ and the product of $2$ and $a$ and $checker$ applied to $cons$ applied to $Nat$ and $b$ and $l$.",
    "output": "postulate checker_ab : (a : Nat) -> (b : Nat) -> (l : list Nat) -> Eq (checker (cons Nat a (cons Nat b l))) (andb (andb (leb (plus a 1) b) (leb b (times 2 a))) (checker (cons Nat b l)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Start_lprim. For all natural numbers $n$ and $m$ and $a$, for all lists $acc$ of natural numbers, $option_hd$ applied to $Nat$ and $lprim$ applied to $n$ and $m$ and $cons$ applied to $Nat$ and $a$ and $acc$ is equal to $Some$ applied to $Nat$ and $a$.",
    "output": "postulate start_lprim : (n : Nat) -> (m : Nat) -> (a : Nat) -> (acc : list Nat) -> Eq (option_hd Nat (lprim n m (cons Nat a acc))) (Some Nat a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_not_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "postulate lt_to_not_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injective_to_injn. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "postulate injective_to_injn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "It. $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.unit$.",
    "output": "postulate it : cic.Term univs.Type0 matita_basics_types.unit"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_951$.",
    "output": "postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate max : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z724$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x1$, for all functions $_H2$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x1$ and $m$ and functions $_x_421$ from elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$ and elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x2$.",
    "output": "postulate le_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_nat.le x1 x2)) -> (P : (_z724 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 x1)) -> cic.Term cic.prop (P x1)) -> (_H2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_419 : cic.Term cic.prop (matita_arithmetics_nat.le x1 m)) -> (_x_421 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 m)) -> cic.Term cic.prop (P m)) -> (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P x2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.",
    "output": "postulate assoc_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B_exp. For all natural numbers $n$, $B$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of $2$ and $pred$ applied to the product of $2$ and $n$.",
    "output": "postulate le_B_exp : (n : Nat) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type5_body. For all sets $_A$, for all functions $Q_$ from elements $_x_919$ of $range$ of $_A$ to elements of $Type5$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_919$ of $range$ of $_A$, $Q_$ holds for $x_919$.",
    "output": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_dividesb_true1. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then if $n$ is divisible by $m$, then $dividesb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "postulate divides_to_dividesb_true1 : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Eq (dividesb n m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "postulate Sum_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) -> (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type0 (Q_ x_551)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1753$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "postulate Dop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1752 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1753 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nil_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate nil_cons : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a l) (matita_basics_lists_list.nil A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_le_to_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then if $m$ is less than or equal to $n$, then $n$ is equal to $m$.",
    "output": "postulate le_to_le_to_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : Leq m n) -> Eq n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_ind. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "postulate void_ind : (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_482)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_iter2. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $i$ and $j$, for all functions $__$ from natural numbers $x$ to elements of $Leq$ of $x$ and $g$ applied to $x$, if $i$ is less than or equal to $j$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $j$ and $a$.",
    "output": "postulate monotonic_iter2 : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (i : Nat) -> (j : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (__1 : Leq i j) -> Leq (iter Nat g i a) (iter Nat g j a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate le_2_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate log : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_mod. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate gcd_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_exists. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$.",
    "output": "postulate max_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_elim2. For all functions $R$ from natural numbers and natural numbers $__1$ to propositions, for all functions $__$ from natural numbers $n$ to elements of $R$ of $0$ and $n$, for all functions $__1$ from natural numbers $n$ to elements of $R$ of the sum of $n$ and $1$ and $0$, for all functions $__2$ from natural numbers $n$ and natural numbers $m$ and elements $__2$ of $R$ of $n$ and $m$ to elements of $R$ of the sum of $n$ and $1$ and the sum of $m$ and $1$, for all natural numbers $n$ and $m$, $R$ holds for $n$ and $m$.",
    "output": "postulate nat_elim2 : (R : (_ : Nat) -> (__1 : Nat) -> Prop) -> (_ : (n : Nat) -> R 0 n) -> (__1 : (n : Nat) -> R (plus n 1) 0) -> (__2 : (n : Nat) -> (m : Nat) -> (__2 : R n m) -> R (plus n 1) (plus m 1)) -> (n : Nat) -> (m : Nat) -> R n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_pred_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.pred$ applied to $n$ and $n$.",
    "output": "postulate le_pred_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.pred n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Z. $Nat$.",
    "output": "postulate z : Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus_to_lt_r. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "postulate lt_plus_to_lt_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus n q))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bijn_transpose_l. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to the function that maps $p$ to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $f$ applied to $p$ and $n$.",
    "output": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example5. $primeb$ applied to $6$ is equal to absurdity.",
    "output": "postulate example5 : Eq (primeb 6) false"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_557$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_557$, for all functions $_H_inr$ from elements $x_558$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_558$, for all elements $x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_556$.",
    "output": "postulate Sum_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_556)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_d_times_gcd. For all natural numbers $m$ and $n$ and $d$ and $c$, if $0$ is less than $c$, then if $d$ is divisible by the product of $c$ and $m$, then if $d$ is divisible by the product of $c$ and $n$, then $d$ is divisible by the product of $c$ and the greatest common divisor of $n$ and $m$.",
    "output": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B. For all natural numbers $_n$, $Nat$.",
    "output": "postulate B : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_lt_plus_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Lt$ and the function that maps $m$ to the sum of $n$ and $m$.",
    "output": "postulate monotonic_lt_plus_r : (n : Nat) -> monotonic Nat Lt (\\ m : Nat -> plus n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "postulate Dop_rect_CProp2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_eq_nat. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate decidable_eq_nat : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb_true. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "postulate andb_true : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_O_to_not_divides. For all elements $n$ and $i$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $i$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.nth_prime$ applied to $i$ and $n$.",
    "output": "postulate p_ord_O_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O r))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_le_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "postulate not_le_Sn_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_lt_SO. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$.",
    "output": "postulate prime_to_lt_SO : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type2. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_inl$ from elements $x_542$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_542$, for all functions $_H_inr$ from elements $x_543$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_543$, for all elements $x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_541$.",
    "output": "postulate Sum_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2) -> (_H_inl : (x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> (_H_inr : (x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> (x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type2 (Q_ x_541)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_893$ of $ACop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_893$.",
    "output": "postulate ACop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_893 : ACop A _nil) -> Type5) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_893 : ACop A _nil) -> Q_ x_893"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_mod_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate divides_to_mod_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1530$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1531$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1530 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1531 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_ind_aux. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate f_ind_aux : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Opt_cons_tail_expand. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.option_cons$ applied to $A$ and $matita_basics_lists_list.option_hd$ applied to $A$ and $l$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$.",
    "output": "postulate opt_cons_tail_expand : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.option_cons A (matita_basics_lists_list.option_hd A l) (matita_basics_lists_list.tail A l)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop90. For all instances $n$ of natural numbers, we can prove that if $n$ is even and $n$ is prime, then $n$ is equal to $2$.",
    "output": "postulate prop90 : (n : Nat) -> if (and (even n) (prime n)) (Eq n 2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B2. For all natural numbers $_n$, $Nat$.",
    "output": "postulate B2 : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Enum. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, for all natural numbers $_x_942$, $A$.",
    "output": "postulate enum : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate commutative_plus : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exists. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Exists : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_b. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_plus_b : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n b) m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_unique_le. For all natural numbers $n$, for all lists $l$ of natural numbers, for all elements $__$ of $unique$ of $Nat$ and $l$, for all functions $__1$ from natural numbers $x$ and elements $__1$ of $mem$ of $Nat$ and $x$ and $l$ to elements of $Lt$ of $x$ and $n$, $length$ applied to $Nat$ and $l$ is less than or equal to $n$.",
    "output": "postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_ord_rem. For all natural numbers $p$ and $n$, if $1$ is less than $p$, then if $0$ is less than $n$, then $0$ is less than $ord_rem$ applied to $n$ and $p$.",
    "output": "postulate lt_O_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt 0 (ord_rem n p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.",
    "output": "postulate Sig_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Rewrite_l. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $x$, for all elements $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $y$.",
    "output": "postulate rewrite_l : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (P : (__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P x)) -> (y : cic.Term univs.Type2 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term univs.Type2 (P y)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1033. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all natural numbers $n1$, for all functions $Hind$ from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$, for all functions $H1$ from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $H2$ from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, if $p2$ applied to $n1$ is equal to $true$, then if $p1$ applied to $n1$ is equal to $true$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "M. For all elements $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate M : (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Square_double. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "postulate square_double : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate split : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list A) (matita_basics_lists_list.list A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Irreflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate irreflexive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bi_reflexive. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate bi_reflexive : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_filter_eqb. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.filter$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.eqb$ applied to $m$ and $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate length_filter_eqb : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat (matita_basics_lists_list.filter matita_arithmetics_nat.nat (matita_arithmetics_nat.eqb m) l)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop9d. For all sets $A$, $B$ and $C$, we can prove that the intersection of the difference of $B$ and $A$ and $C$ is equal to the difference of the intersection of $B$ and $C$ and the intersection of $A$ and $C$ and the difference of the intersection of $B$ and $C$ and the intersection of $A$ and $C$ is equal to the difference of the intersection of $B$ and $C$ and $A$.",
    "output": "postulate prop9d : (A : Set) -> (B : Set) -> (C : Set) -> and (equalset (intersection (difference B A) C) (difference (intersection B C) (intersection A C))) (equalset (difference (intersection B C) (intersection A C)) (difference (intersection B C) A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.",
    "output": "postulate inl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type3_body. For all sets $_A$, for all functions $Q_$ from elements $_x_921$ of $range$ of $_A$ to elements of $Type3$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $range$ of $_A$, $Q_$ holds for $x_921$.",
    "output": "postulate range_rect_Type3_body : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_rect_Type4_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_nmk$ from functions $x_83$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_83$, for all elements $x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_82$.",
    "output": "postulate Not_rect_Type4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4) -> (_H_nmk : (x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) -> (x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type4 (Q_ x_82)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_lt_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "postulate not_lt_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm01d. We can prove that the square root of $2$ is not rational.",
    "output": "postulate Thm01d : not (rational (sqrt 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_B_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_times_gcd_aux. For all elements $p$ and $m$ and $n$ and $d$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $m$, for all elements $__5$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_704$.",
    "output": "postulate Prod_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_704)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1554$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1555$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1554 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1555 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_le_to_leb_false. For all natural numbers $n$ and $m$, if $n$ is not less than or equal to $m$, then $leb$ applied to $n$ and $m$ is equal to absurdity.",
    "output": "postulate not_le_to_leb_false : (n : Nat) -> (m : Nat) -> (_ : not (Leq n m)) -> Eq (leb n m) false"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_p. For all natural numbers $p$, if $1$ is less than $p$, then $p_ord$ applied to $p$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $1$ and $1$.",
    "output": "postulate p_ord_p : (p : Nat) -> (_ : Lt 1 p) -> Eq (p_ord p p) (mk_Prod Nat Nat 1 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_prim4l. For all natural numbers $n$, if $0$ is less than $n$, then the exponentiation of $2$ and the sum of the product of $4$ and $n$ and $1$ is less than or equal to the exponentiation of the product of $4$ and $n$ and the sum of $prim$ applied to the product of $4$ and $n$ and $1$.",
    "output": "postulate le_exp_prim4l : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (plus (times 4 n) 1)) (pow (times 4 n) (plus (prim (times 4 n)) 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_inv. For all natural numbers $_p$ and $_m$ and $_x$, $Nat$.",
    "output": "postulate p_ord_inv : (_p : Nat) -> (_m : Nat) -> (_x : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_881$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_881$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_881$.",
    "output": "postulate Aop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_881 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_881 : Aop A _nil) -> Q_ x_881"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Dop$ of $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $A$, $A$.",
    "output": "postulate prod_body : (A : Set) -> (nil : A) -> (_xxx : Dop A nil) -> (_x_969 : A) -> (_x_970 : A) -> A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_times. For all natural numbers $a$ and $b$, if $0$ is less than $b$, then the quotient of the product of $a$ and $b$ and $b$ is equal to $a$.",
    "output": "postulate div_times : (a : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> Eq (div (times a b) b) a"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Flatten. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate flatten : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $b$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $b$ and $f$.",
    "output": "postulate false_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min (matita_arithmetics_nat.S n) b f) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S b) f))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_O. For all functions $f$ from natural numbers to booleans, $max$ applied to $0$ and $f$ is equal to $0$.",
    "output": "postulate max_O : (f : (_ : Nat) -> bool) -> Eq (max 0 f) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_minus_l. For all natural numbers $p$ and $q$ and $n$, if $q$ is less than or equal to $p$, then the difference of $q$ and $n$ is less than or equal to the difference of $p$ and $n$.",
    "output": "postulate monotonic_le_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq q p) -> Leq (minus q n) (minus p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1595. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $1$ is less than the greatest common divisor of $p$ and the product of $n$ and $m$, then if $smallest_factor$ applied to the greatest common divisor of $p$ and the product of $n$ and $m$ is divisible by $m$, then the greatest common divisor of $p$ and $n$ is equal to the greatest common divisor of $p$ and $m$.",
    "output": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lprim_invariant. For all natural numbers $n$ and $i$, for all lists $acc$ of natural numbers, if $1$ is less than $i$, then for all elements $__1$ of $primes_below$ of $acc$ and $i$, $primes_below$ holds for $lprim$ applied to $n$ and $i$ and $acc$ and the sum of $n$ and $i$.",
    "output": "postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (plus n i)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "postulate le_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_ind. For all natural numbers $_n$ and $_m$, for all functions $Q_$ from elements $_x_1192$ of $divisible$ of $_n$ and $_m$ to propositions, for all functions $_H_quotient$ from natural numbers $q$ and elements $x_1193$ of $Eq$ of $_m$ and the product of $_n$ and $q$ to elements of $Q_$ of $quotient$ applied to $_n$ and $_m$ and $q$ and $x_1193$, if $_n$ is divisible by $_m$, then $Q_$ holds for $x_1192$.",
    "output": "postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_to_not_eq_O. For all elements $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $n$ and $m$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate div_mod_spec_to_not_eq_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate Psi_1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_aux. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "postulate div_aux : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "postulate Prod_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_708)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "postulate le_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "postulate Prod_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type5 (Q_ x_694)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_fwd_plus_plus_ge. For all elements $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m2$ and $m1$, for all elements $n1$ and $n2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $m1$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $m2$ and $n2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$.",
    "output": "postulate le_fwd_plus_plus_ge : (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m2 m1)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus m1 n1) (matita_arithmetics_nat.plus m2 n2))) -> cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n2. For all natural numbers $n$, if $7$ is less than or equal to $n$, then $prim$ applied to the sum of the product of $2$ and $n$ and $1$ is less than or equal to $pred$ applied to $n$.",
    "output": "postulate le_prim_n2 : (n : Nat) -> (_ : Leq 7 n) -> Leq (prim (plus (times 2 n) 1)) (pred n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_1. $Psi$ applied to $1$ is equal to $1$.",
    "output": "postulate Psi_1 : Eq (Psi 1) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_spec_ind. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_971$ and elements $_x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$ to propositions, for all functions $_H_found_max_spec$ from natural numbers $m$ and elements $x_975$ of $Lt$ of $m$ and $_n$ and elements $x_974$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all natural numbers $x_971$, for all elements $x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$, $Q_$ holds for $x_971$ and $x_972$.",
    "output": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_787$.",
    "output": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact_to_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate fact_to_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $m$ and $m$.",
    "output": "postulate f_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_permutation.invert_permut n f m)) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_706$.",
    "output": "postulate Prod_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_706)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_comp_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ and $R1$ and $R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $R1$ and $R2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R$.",
    "output": "postulate sub_comp_l : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 R) (matita_basics_relations.Rcomp A R2 R))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_div. For all elements $d$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $n$.",
    "output": "postulate divides_div : (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_div_and_mod.div n d) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15441. For all elements $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $q$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$, for all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $lenm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $lenS$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $q$, for all elements $ndivnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $b$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "postulate let_clause_15441 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (lenm : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (lenS : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S q))) -> (ndivnm : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times b n)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times b n)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n b) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_955$ of $Dop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_955$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_955$.",
    "output": "postulate Dop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_955 : Dop A _nil) -> Set) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_955 : Dop A _nil) -> Q_ x_955"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1062. For all elements $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $ltrb$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $b$, for all elements $spec$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $b$ and $r$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, for all elements $ltr1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r1$ and $b$, for all elements $spec1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q1$ and $b$ and $r1$, for all elements $leqq1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $q$ and $q1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $r1$ and $matita_arithmetics_nat.times$ applied to $b$ and $q1$.",
    "output": "postulate let_clause_1062 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le q q1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r1 (matita_arithmetics_nat.times b q1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ltl_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate ltl_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n1. For all natural numbers $n$, if $4$ is less than or equal to $n$, then $prim$ applied to the sum of the product of $2$ and $n$ and $1$ is less than or equal to $n$.",
    "output": "postulate le_prim_n1 : (n : Nat) -> (_ : Leq 4 n) -> Leq (prim (plus (times 2 n) 1)) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "SameF_p. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__2$ to $A$.",
    "output": "postulate sameF_p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16921. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x358$ and $x359$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x358$ and $matita_arithmetics_nat.times$ applied to $x358$ and $x359$ and $matita_arithmetics_nat.times$ applied to $x358$ and $matita_arithmetics_nat.S$ applied to $x359$.",
    "output": "postulate let_clause_16921 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_Sm_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $P$ of $cic.Univ$ of $cic.prop$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, $cic.Term$ holds for $cic.prop$ and $P$.",
    "output": "postulate le_n_Sm_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))) -> (P : cic.Univ cic.prop) -> (__1 : (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> (__2 : (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> cic.Term cic.prop P"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.",
    "output": "postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_2. For all instances $x$ of real numbers, we can prove that if the sum of the difference of the exponentiation of $x$ and $2$ and the product of $2$ and $x$ and $2$ is less than or equal to $0$, then the exponentiation of $x$ and $3$ is greater than or equal to $8$.",
    "output": "postulate noLabel_2 : (x : Real) -> if (Leq (plus (minus (pow x 2) (times 2 x)) 2) 0) (Geq (pow x 3) 8)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_to_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.",
    "output": "postulate le_plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_686$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_686$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_686$.",
    "output": "postulate Sig_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_686)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_leb_true. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $leb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_CProp4_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_615$, for all elements $x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_614$.",
    "output": "postulate option_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_615 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_615))) -> (x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_614)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_minus. For all natural numbers $n$ and $m$ and $p$, if $p$ is less than or equal to $m$, then if $m$ is less than or equal to $n$, then the sum of $p$ and the difference of $n$ and $m$ is equal to the difference of $n$ and the difference of $m$ and $p$.",
    "output": "postulate minus_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq p m) -> (__1 : Leq m n) -> Eq (plus p (minus n m)) (minus n (minus m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.",
    "output": "postulate option_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) -> (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_618)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type3. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1446$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1447$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type3 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1446 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type3) -> (_H1 : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1447 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_865$ of $Aop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_865$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_865$.",
    "output": "postulate Aop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_le. For all natural numbers $_n$ and $__$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_type$ of $z$, if $_n$ is less than or equal to $__$, then $return_type$ holds for $z$.",
    "output": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $x$ be a circle. Then the radius of $x$ is an instance of real numbers.",
    "output": "postulate radius : Circle -> Real"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sqrt_bound. For all natural numbers $n$, if the exponentiation of $2$ and $8$ is less than or equal to $n$, then the product of $2$ and the sum of the logarithm of $2$ and the product of $2$ and $n$ and $1$ is less than or equal to the square root of the product of $2$ and $n$.",
    "output": "postulate sqrt_bound : (n : Nat) -> (_ : Leq (pow 2 8) n) -> Leq (times 2 (plus (log 2 (times 2 n)) 1)) (sqrt (times 2 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_tail1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "postulate length_tail1 : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "postulate psi_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_log.log p n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_l$ be a list of natural numbers. Then we can say that $all_primes$ holds for $_l$.",
    "output": "postulate all_primes : (_l : list Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16003. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type2$, for all functions $_H_div_mod_spec_intro$ from elements $x_827$ of $Lt$ of $_r$ and $_m$ and elements $x_826$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_827$ and $x_826$, for all elements $x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_825$.",
    "output": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psi_BPsi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate le_Psi_BPsi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nil_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate nil_to_nil : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10332. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10332 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_f$ be a function from natural numbers to natural numbers. Then we can say that $increasing$ holds for $_f$.",
    "output": "postulate increasing : (_f : (_ : Nat) -> Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$.",
    "output": "postulate lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_relations.relation B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_mod. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then $mod$ applied to the sum of $m$ and $n$ and $q$ is less than or equal to the sum of $mod$ applied to $m$ and $q$ and $mod$ applied to $n$ and $q$.",
    "output": "postulate le_plus_mod : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> Leq (mod (plus m n) q) (plus (mod m q) (mod n q))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lprim_ex. $lprim$ applied to $8$ and $2$ and $nil$ applied to $Nat$ is equal to $cons$ applied to $Nat$ and $2$ and $cons$ applied to $Nat$ and $3$ and $cons$ applied to $Nat$ and $5$ and $cons$ applied to $Nat$ and $7$ and $nil$ applied to $Nat$.",
    "output": "postulate lprim_ex : Eq (lprim 8 2 (nil Nat)) (cons Nat 2 (cons Nat 3 (cons Nat 5 (cons Nat 7 (nil Nat)))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_plus. For all natural numbers $n$ and $m$ and $p$, the difference of the difference of $n$ and $m$ and $p$ is equal to the difference of $n$ and the sum of $m$ and $p$.",
    "output": "postulate minus_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> Eq (minus (minus n m) p) (minus n (plus m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_plus. For all natural numbers $n$ and $p$ and $q$, if $n$ is divisible by $p$, then if $n$ is divisible by $q$, then $n$ is divisible by the sum of $p$ and $q$.",
    "output": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_951$ of $Dop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_951$.",
    "output": "postulate Dop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_951 : Dop A _nil) -> Type2) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_951 : Dop A _nil) -> Q_ x_951"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_spec_to_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.",
    "output": "postulate min_spec_to_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nil_append_elim. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.",
    "output": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_log_n_n. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $n$.",
    "output": "postulate lt_log_n_n : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_log.log p n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_73. For all natural numbers $n$, if $2$ is less than $n$, then for all natural numbers $x134$ and $x135$ and $x136$, the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (n : Nat) -> (posn : Lt 2 n) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z299$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z300$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_107$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_107$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_minus_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $m$.",
    "output": "postulate le_plus_minus_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_S_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than the sum of $m$ and $1$, then $n$ is less than $m$.",
    "output": "postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound4. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "postulate let_upper_bound4 : (n : Nat) -> (m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type0. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "postulate Sum_rect_Type0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) -> (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type0 (Q_ x_551)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lhd_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.lhd$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$ and $n$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate lhd_nil : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.lhd A (matita_basics_lists_list.nil A) n) (matita_basics_lists_list.nil A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_inv_rect_CProp4. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1602$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1603$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_947$.",
    "output": "postulate Dop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_rect_CProp0_body. For all functions $Q_$ from elements $_x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_519$.",
    "output": "postulate unit_rect_CProp0_body : (Q_ : (_x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_519)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.",
    "output": "postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Allr_fwd_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $l$.",
    "output": "postulate Allr_fwd_cons : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.cons A a l))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "TimesA. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate timesA : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_m1. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $_x_365$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_m1 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z954$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z955$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_CProp2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z954 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z955 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_minus_S_pred. For all natural numbers $n$ and $m$, the difference of $n$ and the sum of $m$ and $1$ is equal to $pred$ applied to the difference of $n$ and $m$.",
    "output": "postulate eq_minus_S_pred : (n : Nat) -> (m : Nat) -> Eq (minus n (plus m 1)) (pred (minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_m_exp_nm. For all natural numbers $n$ and $m$, if $1$ is less than $n$, then $m$ is less than the exponentiation of $n$ and $m$.",
    "output": "postulate lt_m_exp_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> Lt m (pow n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_n_1. For all natural numbers $n$, $n$ is equal to the product of $n$ and $1$.",
    "output": "postulate times_n_1 : (n : Nat) -> Eq n (times n 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $m$.",
    "output": "postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_intro. For all natural numbers $n$ and $m$ and $q$ and $r$, if $r$ is less than $m$, then if $n$ is equal to the sum of the product of $q$ and $m$ and $r$, then $div_mod_spec$ holds for $n$ and $m$ and $q$ and $r$.",
    "output": "postulate div_mod_spec_intro : (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> (__1 : Eq n (plus (times q m) r)) -> div_mod_spec n m q r"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15491. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $x1106$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1106$ and $matita_arithmetics_nat.minus$ applied to $x1106$ and $n$.",
    "output": "postulate let_clause_15491 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x1106 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1106 (matita_arithmetics_nat.minus x1106 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_863$ of $Aop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_863$.",
    "output": "postulate Aop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $m$ is less than or equal to $n$, then if $n$ is less than the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than $p$.",
    "output": "postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus p m)) -> Lt (minus n m) p"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "same_parity : Int -> Int -> Prop\nsame_parity = \\ x -> \\ y -> or (and (even x) (even y)) (and (odd x) (odd y))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_to_fact2. For all natural numbers $n$, if $0$ is less than $n$, then the product of the exponentiation of $2$ and the product of $2$ and $n$ and the exponentiation of the factorial of $n$ and $2$ is less than or equal to the product of the product of $2$ and $n$ and the factorial of the product of $2$ and $n$.",
    "output": "postulate exp_to_fact2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (times (pow 2 (times 2 n)) (pow (factorial n) 2)) (times (times 2 n) (factorial (times 2 n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp0_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_859$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_858$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_859$ and $x_858$, for all elements $x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_857$.",
    "output": "postulate div_mod_spec_rect_CProp0_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Comm_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $ACop$ of $A$ and $nil$, for all elements $a$ and $b$ of $A$, $op$ applied to $A$ and $nil$ and $aop$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ is equal to $op$ applied to $A$ and $nil$ and $aop$ applied to $A$ and $nil$ and $xxx$ and $b$ and $a$.",
    "output": "postulate comm_body : (A : Set) -> (nil : A) -> (xxx : ACop A nil) -> (a : A) -> (b : A) -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc. For all elements $_n$ and $_k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate bc : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.",
    "output": "postulate Sig_rect_Type4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type4) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type4 (Q_ x_666)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pair_destruct_2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $c$.",
    "output": "postulate pair_destruct_2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> (c : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b (matita_basics_types.snd A B c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Hint_declaration_Type2. For all elements $_a$ and $_b$ of $cic.Univ$ of $univs.Type2$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate hint_declaration_Type2 : (_a : cic.Univ univs.Type2) -> (_b : cic.Univ univs.Type2) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_S. For all natural numbers $n$, $0$ is less than the sum of $n$ and $1$.",
    "output": "postulate lt_O_S : (n : Nat) -> Lt 0 (plus n 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_1_max_prime. For all natural numbers $n$, if $1$ is less than $n$, then $1$ is less than $max$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $andb$ applied to $primeb$ applied to $i$ and $dividesb$ applied to $i$ and $n$.",
    "output": "postulate lt_1_max_prime : (n : Nat) -> (_ : Lt 1 n) -> Lt 1 (max (plus n 1) (\\ i : Nat -> andb (primeb i) (dividesb i n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Increasing_to_injective. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$.",
    "output": "postulate increasing_to_injective : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_Sn_m. For all natural numbers $n$ and $m$, the sum of $m$ and the product of $n$ and $m$ is equal to the product of the sum of $n$ and $1$ and $m$.",
    "output": "postulate times_Sn_m : (n : Nat) -> (m : Nat) -> Eq (plus m (times n m)) (times (plus n 1) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ExteqR. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ and $_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate exteqR : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (_S : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10333. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10333 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10331. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt4n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le4m$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lea$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hinda$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m)) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a)) -> (Hinda : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S a)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_Dop. For all sets $A$, for all elements $nil$ of $A$, for all elements $sum$ of $ACop$ of $A$ and $nil$, for all functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$, for all functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $nil$ and $nil$, for all functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$, $Dop$ holds for $A$ and $nil$.",
    "output": "postulate mk_Dop : (A : Set) -> (nil : A) -> (sum : ACop A nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_spec_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_971$ and $x_972$.",
    "output": "postulate max_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop) -> (_H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f x_976))) -> (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Term cic.prop (Q_ x_971 x_972)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_1_to_divides_times_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate gcd_1_to_divides_times_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop10. We can prove that $0$ is even.",
    "output": "postulate prop10 : even 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "postulate Aop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_783)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Smallest_factor_to_min. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is equal to $min$ applied to $n$ and $2$ and the function that maps $m$ to $eqb$ applied to $mod$ applied to $n$ and $m$ and $0$.",
    "output": "postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\\ m : Nat -> eqb (mod n m) 0))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primeb_false_to_not_prime. For all natural numbers $n$, if $primeb$ applied to $n$ is equal to absurdity, then $n$ is not prime.",
    "output": "postulate primeb_false_to_not_prime : (n : Nat) -> (_ : Eq (primeb n) false) -> not (prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1608$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1609$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1608 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1609 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_times_plus_to_congruent. For all elements $n$ and $m$ and $p$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $r$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate eq_times_plus_to_congruent : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m))) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_body. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "postulate exp_body : (_ : Nat) -> (__1 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_gcd. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate commutative_gcd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ and $l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $matita_basics_lists_list.nil$ applied to $A$ and $l1$.",
    "output": "postulate append_cons : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l (matita_basics_lists_list.cons A a l1)) (matita_basics_lists_list.append A (matita_basics_lists_list.append A l (matita_basics_lists_list.cons A a (matita_basics_lists_list.nil A))) l1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_CProp2. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1482$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_851$ of $Lt$ of $x4$ and $x2$ and elements $x_850$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1483$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$, $P$ holds for $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp2 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1482 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_851 : Lt x4 x2) -> (x_850 : Eq x1 (plus (times x3 x2) x4)) -> (_z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Permut_n_to_le. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $n$, for all functions $__2$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $m$ and $m$, for all elements $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $j$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $h$ applied to $j$.",
    "output": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_to_not. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.",
    "output": "postulate not_to_not : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop B) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not B)) -> cic.Term cic.prop (matita_basics_logic.Not A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_smallest_factor. For all natural numbers $n$, if $0$ is less than $n$, then $0$ is less than $smallest_factor$ applied to $n$.",
    "output": "postulate lt_O_smallest_factor : (n : Nat) -> (_ : Lt 0 n) -> Lt 0 (smallest_factor n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "postulate mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Cr_pair4. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate cr_pair4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inv_eq_minus_O. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "postulate inv_eq_minus_O : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or_ind_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_or_introl$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_introl$ applied to $_A$ and $_B$ and $x_171$, for all functions $_H_or_intror$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_intror$ applied to $_A$ and $_B$ and $x_172$, for all elements $x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_170$.",
    "output": "postulate Or_ind_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop) -> (_H_or_introl : (x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))) -> (_H_or_intror : (x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))) -> (x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term cic.prop (Q_ x_170)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_p_primeb5. For all natural numbers $n$, if $1$ is less than $n$, then $bigop$ applied to the sum of the product of $2$ and $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and the product of $2$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$.",
    "output": "postulate pi_p_primeb5 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example6. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_bool.true$.",
    "output": "postulate example6 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fmin_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $b$, if $m$ is equal to $min$ applied to $n$ and $b$ and $f$, then if $m$ is less than the sum of $n$ and $b$, then $f$ applied to $m$ is equal to $true$.",
    "output": "postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_spec_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1890$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $m$ and elements $_x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ and elements $_x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1891$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x4$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$, for all functions $_H2$ from functions $_x_1081$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1891$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x4$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x4$.",
    "output": "postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 m)) -> cic.Term cic.prop (P m)) -> (_H2 : (_x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P x4)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp1. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_577$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_577$, for all functions $_H_inr$ from elements $x_578$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_578$, for all elements $x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_576$.",
    "output": "postulate Sum_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.plus$ applied to $n2$ and $m2$.",
    "output": "postulate le_plus : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate plus_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus n matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_ord_rem. For all elements $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$.",
    "output": "postulate not_divides_ord_rem : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_ord.ord_rem m p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (plus x (minus y z)) (minus (plus x y) z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_m_exp_nm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$.",
    "output": "postulate lt_m_exp_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_exp.exp n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ and $_m$ be natural numbers. Then we can say that $_n$ is divisible by $_m$.",
    "output": "postulate divisible : (_n : Nat) -> (_m : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_lt_to_lt. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to $m$, then if $m$ is less than $p$, then $n$ is less than $p$.",
    "output": "postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lprim. For all natural numbers $__$ and $__1$, for all lists $__2$ of natural numbers, $list$ holds for $Nat$.",
    "output": "postulate lprim : (_ : Nat) -> (__1 : Nat) -> (__2 : list Nat) -> list Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_le_to_lt. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$.",
    "output": "postulate lt_to_le_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_nat. For all elements $return_sort$ of $Sort$, for all functions $return_type$ from natural numbers $z$ to elements of $return_sort$, for all elements $case_O$ of $return_type$ of $0$, for all functions $case_S$ from natural numbers to elements of $return_type$ of the sum of $__$ and $1$, for all natural numbers $z$, $return_type$ holds for $z$.",
    "output": "postulate match_nat : (return_sort : Sort) -> (return_type : (z : Nat) -> return_sort) -> (case_O : return_type 0) -> (case_S : (_ : Nat) -> return_type (plus __ 1)) -> (z : Nat) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_714$.",
    "output": "postulate Prod_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_714)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_Psil. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_exp_Psil : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bijn_transpose. For all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$.",
    "output": "postulate bijn_transpose : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_to_nat_body. For all elements $_b$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate bool_to_nat_body : (_b : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_50. For all instances $a$ and $b$ of integers, we can prove that if the product of $a$ and $b$ is odd, then the sum of the exponentiation of $a$ and $2$ and the exponentiation of $b$ and $2$ is even.",
    "output": "postulate noLabel_50 : (a : Int) -> (b : Int) -> if (odd (times a b)) (even (plus (pow a 2) (pow b 2)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_mod. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.",
    "output": "postulate le_to_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_div_and_mod.mod n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Split_exists. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l1$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l2$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $n$.",
    "output": "postulate split_exists : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A l1 l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp1_body. For all functions $Q_$ from natural numbers $_x_409$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_410$ and elements $_x_412$ of $Q_$ of $x_410$ to elements of $Q_$ of the sum of $x_410$ and $1$, for all natural numbers $x_409$, $Q_$ holds for $x_409$.",
    "output": "postulate nat_rect_CProp1_body : (Q_ : (_x_409 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_410 : Nat) -> (_x_412 : Q_ x_410) -> Q_ (plus x_410 1)) -> (x_409 : Nat) -> Q_ x_409"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_discr. For all sets $a1$, for all elements $x$ and $y$ of $range$ of $a1$, if $x$ is equal to $y$, then $match_range$ holds for $a1$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ to $match_range$ applied to $a1$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $Nat$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $Nat$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $bool$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $_e2$ to $P$ and the function that maps $_z59$ to $P$ and $y$ and $x$.",
    "output": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ t0 : ((_ : Nat) -> a1) -> \\ t1 : Nat -> \\ t2 : ((_ : Nat) -> bool) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ u0 : ((_ : Nat) -> a1) -> \\ u1 : Nat -> \\ u2 : ((_ : Nat) -> bool) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) (\\ e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) (\\ _e2 : Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2 -> P)))) (\\ _z59 : ((e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) -> (e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) -> (_e2 : Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) -> P) -> P))) y) x"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1078. For all elements $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $ltrb$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $b$, for all elements $spec$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $b$ and $r$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, for all elements $ltr1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r1$ and $b$, for all elements $spec1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q1$ and $b$ and $r1$, for all elements $leqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $q1$, for all elements $ltqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $q1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $r$ and $matita_arithmetics_nat.times$ applied to $b$ and $q$.",
    "output": "postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1272$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1273$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1272 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1273 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop100. For all instances $a$ and $b$ and $c$ of integers, if we can prove that the sum of the sum of $a$ and $b$ and $c$ is equal to $0$, then we can prove that the product of the product of $a$ and $b$ and $c$ is less than $0$.",
    "output": "postulate prop100 : (a : Int) -> (b : Int) -> (c : Int) -> Eq (plus (plus a b) c) 0 -> Lt (times (times a b) c) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unique_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate unique_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10335. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10335 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_inv_lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "postulate lstar_r_inv_lstar : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example12. $nth_prime$ applied to $3$ is equal to $7$.",
    "output": "postulate example12 : Eq (nth_prime 3) 7"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_body. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all sets $H$, for all elements $__2$ of $H$, for all functions $__3$ from elements $__3$ of $H$ and elements $__4$ of $H$ to elements of $H$, for all functions $__4$ from natural numbers $__4$ to elements of $H$, $H$.",
    "output": "postulate bigop_body : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15591. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.",
    "output": "postulate let_clause_15591 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_fact_pi_p. For all natural numbers $n$, the factorial of $n$ is equal to $bigop$ applied to the difference of the sum of $n$ and $1$ and $1$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $1$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to the sum of $i$ and $1$.",
    "output": "postulate eq_fact_pi_p : (n : Nat) -> Eq (factorial n) (bigop (minus (plus n 1) 1) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i 1)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> i0) (plus i 1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "postulate div_mod_spec_rect_CProp3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "To_min. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$.",
    "output": "postulate to_min : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i m)) -> cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate bc_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp4_body. For all functions $Q_$ from elements $_x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_396$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, for all elements $x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_393$.",
    "output": "postulate nat_rect_CProp4_body : (Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : cic.Term cic.prop (Q_ x_394)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) -> (x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_393)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_theta_M_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate le_theta_M_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z384$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injective_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $permut$ of $f$ and $n$, $injn$ holds for $invert_permut$ applied to $n$ and $f$ and $n$.",
    "output": "postulate injective_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> injn (invert_permut n f) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le_div. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$.",
    "output": "postulate le_times_to_le_div : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) -> cic.Term cic.prop (matita_arithmetics_nat.le c (matita_arithmetics_div_and_mod.div a b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_degenerate. For all natural numbers $p$ and $n$, $p_ord_aux$ applied to $p$ and $n$ and $1$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $p$ and $n$.",
    "output": "postulate p_ord_degenerate : (p : Nat) -> (n : Nat) -> Eq (p_ord_aux p n 1) (mk_Prod Nat Nat p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z593$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_Type4 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z593 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) -> (_H1 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type4 (P matita_basics_bool.true)) -> (_H2 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type4 (P matita_basics_bool.false)) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from natural numbers $_x_401$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_402$ and elements $_x_404$ of $Q_$ of $x_402$ to elements of $Q_$ of the sum of $x_402$ and $1$, for all natural numbers $x_401$, $Q_$ holds for $x_401$.",
    "output": "postulate nat_rect_CProp3_body : (Q_ : (_x_401 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_402 : Nat) -> (_x_404 : Q_ x_402) -> Q_ (plus x_402 1)) -> (x_401 : Nat) -> Q_ x_401"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_Psi_Psi'. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi'$ applied to $n$.",
    "output": "postulate eq_Psi_Psi' : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi' n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $m$ and $q$.",
    "output": "postulate lt_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus m q))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_ind. For all functions $Q_$ from elements $_x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_66$.",
    "output": "postulate False_ind : (Q_ : (_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_66)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_or_lt_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi'. For all natural numbers $__$, $Nat$.",
    "output": "postulate Psi' : (_ : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "postulate DPair_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_4. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate Psi_4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_I_gen. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $b$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Even_or_odd. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$.",
    "output": "postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_ord_sigma_p. For all natural numbers $n$ and $m$ and $x$, if $0$ is less than $n$, then if $x$ is prime, then if the exponentiation of $x$ and $m$ is less than or equal to $n$, then if $n$ is less than the exponentiation of $x$ and the sum of $m$ and $1$, then $ord$ applied to $n$ and $x$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $x$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1063. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $permf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lein$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $lejn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all elements $lebn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $n$, for all elements $fb$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all functions $__$ from elements $i0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i0$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $i0$ and $n$, for all elements $injf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $j$.",
    "output": "postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (__ : (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)) -> (injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) j)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_or_introl$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_introl$ applied to $_A$ and $_B$ and $x_171$, for all functions $_H_or_intror$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_intror$ applied to $_A$ and $_B$ and $x_172$, for all elements $x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_170$.",
    "output": "postulate Or_ind : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop) -> (_H_or_introl : (x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))) -> (_H_or_intror : (x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))) -> (x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term cic.prop (Q_ x_170)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_nth_prime_n. For all natural numbers $n$, $0$ is less than $nth_prime$ applied to $n$.",
    "output": "postulate lt_O_nth_prime_n : (n : Nat) -> Lt 0 (nth_prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z960$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z961$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Theta_pi_p_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate theta_pi_p_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_O_to_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "postulate mod_O_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Allr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Allr_body : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "S_pred. For all natural numbers $n$, if $0$ is less than $n$, then the sum of $pred$ applied to $n$ and $1$ is equal to $n$.",
    "output": "postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (plus (pred n) 1) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_div_le. For all natural numbers $a$ and $b$ and $c$ and $d$, if $0$ is less than $b$, then if $0$ is less than $d$, then the product of the quotient of $a$ and $b$ and the quotient of $c$ and $d$ is less than or equal to the quotient of the product of $a$ and $c$ and the product of $b$ and $d$.",
    "output": "postulate times_div_le : (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (_ : Lt 0 b) -> (__1 : Lt 0 d) -> Leq (times (div a b) (div c d)) (div (times a c) (times b d))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Start_lop. For all natural numbers $n$, if $1$ is less than or equal to $n$, then $option_hd$ applied to $Nat$ and $list_of_primes$ applied to $n$ is equal to $Some$ applied to $Nat$ and $2$.",
    "output": "postulate start_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (option_hd Nat (list_of_primes n)) (Some Nat 2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_x_times_x. For all natural numbers $x$, $x$ is less than or equal to the product of $x$ and $x$.",
    "output": "postulate le_x_times_x : (x : Nat) -> Leq x (times x x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_Type1_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $__$ of $cic.Term$ of $univs.Type1$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $x$ and $p$.",
    "output": "postulate eq_rect_Type1_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type1) -> (__ : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type1 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.",
    "output": "postulate eq_rect_CProp3_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_not_divides_fact. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate prime_to_not_divides_fact : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_mod. For all elements $m$ and $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.plus$ applied to $m$ and $n$ and $q$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$.",
    "output": "postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primeb_true_to_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$.",
    "output": "postulate primeb_true_to_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_primes.prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1553. For all elements $n$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $a$.",
    "output": "postulate let_clause_1553 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.plus a (matita_arithmetics_nat.S a)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "postulate max : (_ : Nat) -> (__1 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_31. For all instances $x$ of integers, we can prove that if the sum of the product of $7$ and $x$ and $5$ is odd, then $x$ is even.",
    "output": "postulate noLabel_31 : (x : Int) -> if (odd (plus (times 7 x) 5)) (even x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_discr. For all elements $a1$ and $a2$ and $a3$ and $a4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x$ and $y$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_arithmetics_div_and_mod.match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_arithmetics_div_and_mod.match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $matita_basics_logic.R0$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $a3$ and $a2$ and $a4$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $a3$ and $a2$ and $a4$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z53$ to $P$ and $y$ and $x$.",
    "output": "postulate div_mod_spec_discr : (a1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (y : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\\ t0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ t1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) -> matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\\ u0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ u1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1) -> P))) (\\ _z53 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "SameF_upto_le. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $m$ and $A$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $n$ and $A$ and $f$ and $g$.",
    "output": "postulate sameF_upto_le : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto m A f g)) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto n A f g)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DemorganIntersection. For all sets $A$ and $B$, we can prove that the complement of the intersection of $A$ and $B$ is equal to the union of the complement of $A$ and the complement of $B$.",
    "output": "postulate demorganIntersection : (A : Set) -> (B : Set) -> equalset (complement (intersection A B)) (union (complement A) (complement B))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ and $_m$ and $_q$ and $_r$ be natural numbers. Then $div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ is a proposition.",
    "output": "postulate div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Relation2. For all elements $__$ and $__1$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate relation2 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psi_exp4. For all natural numbers $n$, if $1$ is less than $n$, then $Psi$ applied to $n$ is less than or equal to the product of $pred$ applied to $n$ and the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "postulate le_Psi_exp4 : (n : Nat) -> (_ : Lt 1 n) -> Leq (Psi n) (times (pred n) (pow 2 (minus (times 2 n) 3)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eqb_true_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate eqb_true_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_mop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ and $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate let_mop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> (_x_969 : cic.Term univs.Type0 B) -> (_x_970 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_to_le. For all natural numbers $b$ and $n$ and $m$, if $1$ is less than $b$, then if the exponentiation of $b$ and $n$ is less than or equal to the exponentiation of $b$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Smallest_factor_fact. For all natural numbers $n$, $n$ is less than $smallest_factor$ applied to the sum of the factorial of $n$ and $1$.",
    "output": "postulate smallest_factor_fact : (n : Nat) -> Lt n (smallest_factor (plus (factorial n) 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_B_Bk. For all natural numbers $n$, $B$ applied to $n$ is equal to $Bk$ applied to $n$.",
    "output": "postulate eq_B_Bk : (n : Nat) -> Eq (B n) (Bk n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1560. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1560 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_CProp4. For all functions $Q_$ from elements $_x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_54$.",
    "output": "postulate True_rect_CProp4 : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1561. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $a$ and $matita_arithmetics_nat.times$ applied to $m$ and $b$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1561 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m))) -> (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_801$.",
    "output": "postulate Aop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_801)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16003. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "postulate let_clause_16003 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_949$ of $Dop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_949$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_949$.",
    "output": "postulate Dop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_949 : Dop A _nil) -> Type3) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_949 : Dop A _nil) -> Q_ x_949"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_exists_to_forall. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, if it is not the case that $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $P$ applied to $i$, then for all natural numbers $i$, if $i$ is less than $n$, then it is not the case that $P$ holds for $i$.",
    "output": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_minus_m_m. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $m$ and $n$ and $n$.",
    "output": "postulate minus_minus_m_m : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus m (matita_arithmetics_nat.minus m n)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1607. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "postulate let_clause_1607 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_mod_m_m. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then $mod$ applied to $n$ and $m$ is less than $m$.",
    "output": "postulate lt_mod_m_m : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt (mod n m) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mem_filter_true. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $a$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $a$ and $matita_basics_bool.true$.",
    "output": "postulate mem_filter_true : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem S a (matita_basics_lists_list.filter S f l))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f a) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inj_mk_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $P$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $A$ and $P$ and $x$ and $matita_basics_types.mk_Sig$ applied to $A$ and $P$ and $matita_basics_types.pi1$ applied to $A$ and $P$ and $x$ and $matita_basics_types.pi2$ applied to $A$ and $P$ and $x$.",
    "output": "postulate inj_mk_Sig : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig A P)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig A P)) x (matita_basics_types.mk_Sig A P (matita_basics_types.pi1 A P x) (matita_basics_types.pi2 A P x)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "TransitSubset. For all sets $A$, $B$ and $C$, we can prove that if $A$ is a subset of $B$ and $B$ is a subset of $C$, then $A$ is a subset of $C$.",
    "output": "postulate transitSubset : (A : Set) -> (B : Set) -> (C : Set) -> if (and (subseteq A B) (subseteq B C)) (subseteq A C)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eqb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.eqb$ applied to $n$ and $m$.",
    "output": "postulate eqb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15441. For all natural numbers $p$ and $q$, for all functions $Hind$ from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$, for all natural numbers $m$ and $n$, if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to the sum of $q$ and $1$, then if $n$ is not divisible by $m$, then for all natural numbers $a$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ or the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then if the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then the difference of the product of $n$ and $b$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$.",
    "output": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_prime. For all natural numbers $n$, $decidable$ holds for $prime$ applied to $n$.",
    "output": "postulate decidable_prime : (n : Nat) -> decidable (prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_CProp5_body. For all sets $_A$, for all functions $Q_$ from elements $_x_931$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $range$ of $_A$, $Q_$ holds for $x_931$.",
    "output": "postulate range_rect_CProp5_body : (_A : Set) -> (Q_ : (_x_931 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_to_lt_max. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $f$ applied to $n$ is equal to absurdity, then if $max$ applied to $m$ and $f$ is less than or equal to $n$, then $max$ applied to $m$ and $f$ is less than $n$.",
    "output": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "SameF_upto. For all natural numbers $__$, for all sets $A$, $relation$ holds for $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__1$ to $A$.",
    "output": "postulate sameF_upto : (_ : Nat) -> (A : Set) -> relation (prod Set Set Nat (\\ __1 : Nat -> A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_l2_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l3$ and $matita_basics_lists_list.length$ applied to $A$ and $l4$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_S. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then $n$ is less than the product of the sum of the quotient of $n$ and $m$ and $1$ and $m$.",
    "output": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (plus (div n m) 1) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_CProp4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_751$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_753$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_752$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_755$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_752$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_753$ and $x_752$, for all elements $x_751$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_751$.",
    "output": "postulate list_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_753 : cic.Term univs.Type0 _A) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_755 : cic.Term cic.prop (Q_ x_752)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_753 x_752))) -> (x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_751)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or_div_mod. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$.",
    "output": "postulate or_div_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n q)) q))) (matita_basics_logic.And (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n q) q) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact_body. For all natural numbers $__$, $Nat$.",
    "output": "postulate fact_body : (_ : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1621$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_div. For all natural numbers $n$ and $m$, if $n$ is divisible by $m$, then the product of the quotient of $m$ and $n$ and $n$ is equal to $m$.",
    "output": "postulate divides_to_div : (n : Nat) -> (m : Nat) -> (_ : divisible n m) -> Eq (times (div m n) n) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_S_fact. For all natural numbers $n$ and $i$, if $1$ is less than $i$, then if $i$ is less than or equal to $n$, then $i$ is not divisible by the sum of the factorial of $n$ and $1$.",
    "output": "postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (__1 : Leq i n) -> not (divisible i (plus (factorial n) 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.",
    "output": "postulate mod_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type3_body. For all functions $Q_$ from natural numbers $_x_377$ to elements of $Type3$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_378$ and elements $_x_380$ of $Q_$ of $x_378$ to elements of $Q_$ of the sum of $x_378$ and $1$, for all natural numbers $x_377$, $Q_$ holds for $x_377$.",
    "output": "postulate nat_rect_Type3_body : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (plus x_378 1)) -> (x_377 : Nat) -> Q_ x_377"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.times$ applied to $n2$ and $m2$.",
    "output": "postulate le_times : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n1 m1) (matita_arithmetics_nat.times n2 m2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z287$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $x_98$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z288$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_98$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_98$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z287 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type0) -> (_H1 : (x_98 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z288 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Refl. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $x$.",
    "output": "postulate refl : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> cic.Term cic.prop (matita_basics_logic.eq A x x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_Type1. For all functions $Q_$ from elements $_x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_71$.",
    "output": "postulate False_rect_Type1 : (Q_ : (_x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type1) -> (x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ x_71)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_945$ of $Dop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_945$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_945$.",
    "output": "postulate Dop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_p_primeb4. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "postulate pi_p_primeb4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_rect_Type2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_conj$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_136$ and $x_135$, for all elements $x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_134$.",
    "output": "postulate And_rect_Type2_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) -> (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type2 (Q_ x_134)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate max : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z131$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z132$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_Type4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z131 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H1 : (_z132 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type4 (P matita_basics_logic.I)) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.",
    "output": "postulate range_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sigma_const. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate sigma_const : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type1. For all functions $Q_$ from elements $_x_50$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_I$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_50$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_50$.",
    "output": "postulate True_rect_Type1 : (Q_ : (_x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) -> (_H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I)) -> (x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type1 (Q_ x_50)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type1. For all functions $Q_$ from elements $_x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_O$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_388$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_386$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_386$, for all elements $x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_385$.",
    "output": "postulate nat_rect_Type1 : (Q_ : (_x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type1) -> (_H_O : cic.Term univs.Type1 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_388 : cic.Term univs.Type1 (Q_ x_386)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_nat.S x_386))) -> (x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type1 (Q_ x_385)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Relation3. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "relation3 : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_Type4_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_813$.",
    "output": "div_mod_spec_rect_Type4_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type4) -> _H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) -> x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type4 (Q_ x_813) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z605$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z606$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z606$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "bool_inv_rect_Type2 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z605 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type2) -> _H1 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type2 (P matita_basics_bool.true)) -> _H2 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type2 (P matita_basics_bool.false)) -> cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_1_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "exp_1_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Distributive_times_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.plus$.",
    "output": "distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_879$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_879$.",
    "output": "Aop_rect_CProp3 : A : Set -> _nil : A -> Q_ : (_x_879 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_879 : Aop A _nil -> Q_ x_879 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_S_S. For all natural numbers $n$ and $m$, the difference of the sum of $n$ and $1$ and the sum of $m$ and $1$ is equal to the difference of $n$ and $m$.",
    "output": "minus_S_S : n : Nat -> m : Nat -> Eq (minus (plus n (nd 1)) (plus m (nd 1))) (minus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lhd_cons_ltl. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.lhd$ applied to $A$ and $l$ and $n$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $l$.",
    "output": "lhd_cons_ltl : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_dx. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.",
    "output": "lstar_dx : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (R b b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_zero. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $not_zero$ holds for $m$.",
    "output": "lt_to_not_zero : n : Nat -> m : Nat -> __ : Lt n m -> not_zero m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_times_to_lt_div. For all natural numbers $m$ and $n$ and $q$, if $n$ is less than the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than $m$.",
    "output": "lt_times_to_lt_div : m : Nat -> n : Nat -> q : Nat -> __ : Lt n (times m q) -> Lt (div n q) m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type1) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_le_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "not_le_to_leb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop8c. For all sets $A$ and $B$, we can prove that $A$ is a subset of $B$, if and only if the difference of $A$ and $B$ is equal to the empty set.",
    "output": "prop8c : (A : Set) -> (B : Set) -> Proof (iff (subseteq A B) (equalset (difference A B) emptyset)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fmin_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.let_m$ applied to $f$ and $n$ and $b$ and $matita_basics_bool.false$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.let_m$ applied to $f$ and $n$ and $b$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.",
    "output": "fmin_false : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m f n b) (matita_arithmetics_nat.plus n b))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iter. For all sets $H$, for all functions $__$ from elements of $H$ to elements of $H$, for all natural numbers $__1$, for all elements $__2$ of $H$, $H$.",
    "output": "iter : H : Set -> __ : (__ : H -> H) -> __1 : Nat -> __2 : H -> H ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_797$.",
    "output": "Aop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_797) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_le_Sn_n. For all natural numbers $n$, the sum of $n$ and $1$ is not less than or equal to $n$.",
    "output": "not_le_Sn_n : n : Nat -> not (Leq (plus n (nd 1)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_prim_n2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $n$.",
    "output": "le_prim_n2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injective_transpose. For all natural numbers $i$ and $j$, $injective$ holds for $Nat$ and $Nat$ and $transpose$ applied to $i$ and $j$.",
    "output": "injective_transpose : i : Nat -> j : Nat -> injective Nat Nat (transpose i j) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min0. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "min0 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10331. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp3_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $Lt$ of $_r$ and $_m$ and elements $x_846$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_845$.",
    "output": "div_mod_spec_rect_CProp3_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_845 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_847 : Lt _r _m -> x_846 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> x_845 : div_mod_spec _n _m _q _r -> Q_ x_845 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_times_plus_to_congruent. For all natural numbers $n$ and $m$ and $p$ and $r$, if $0$ is less than $p$, then if $n$ is equal to the sum of the product of $r$ and $p$ and $m$, then $congruent$ holds for $n$ and $m$ and $p$.",
    "output": "eq_times_plus_to_congruent : n : Nat -> m : Nat -> p : Nat -> r : Nat -> __ : Lt 0 p -> __1 : Eq n (plus (times r p) m) -> congruent n m p ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iter_iter. For all sets $A$, for all functions $g$ from elements of $A$ to elements of $A$, for all elements $a$ of $A$, for all natural numbers $b$ and $c$, $iter$ applied to $A$ and $g$ and $c$ and $iter$ applied to $A$ and $g$ and $b$ and $a$ is equal to $iter$ applied to $A$ and $g$ and the sum of $b$ and $c$ and $a$.",
    "output": "iter_iter : A : Set -> g : (__ : A -> A) -> a : A -> b : Nat -> c : Nat -> Eq (iter A g c (iter A g b a)) (iter A g (plus b c) a) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_O_to_eq_O. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.",
    "output": "permut_O_to_eq_O : h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut h matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h matita_arithmetics_nat.O) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transpose_i_j_j. For all natural numbers $i$ and $j$, $transpose$ applied to $i$ and $j$ and $j$ is equal to $i$.",
    "output": "transpose_i_j_j : i : Nat -> j : Nat -> Eq (transpose i j j) i ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ord_exp. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $m$ and $p$ and $m$.",
    "output": "ord_exp : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_exp.exp p m) p) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_le_plus_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $n$ to $matita_arithmetics_nat.plus$ applied to $n$ and $m$.",
    "output": "monotonic_le_plus_l : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.plus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_ind. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_80$, for all elements $x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_79$.",
    "output": "Not_ind : _A : cic.Univ cic.prop -> Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_80 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_79) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_times_div_m_m. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then the product of the quotient of $n$ and $m$ and $m$ is less than or equal to $n$.",
    "output": "le_times_div_m_m : n : Nat -> m : Nat -> __ : Lt 0 m -> Leq (times (div n m) m) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_exp_times. For all natural numbers $n$ and $p$ and $q$, the exponentiation of the exponentiation of $n$ and $p$ and $q$ is equal to the exponentiation of $n$ and the product of $p$ and $q$.",
    "output": "exp_exp_times : n : Nat -> p : Nat -> q : Nat -> Eq (pow (pow n p) q) (pow n (times p q)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_Prod : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ return_sort) -> case_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Antisymmetric_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "antisymmetric_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_n_Sm. For all natural numbers $n$ and $m$, the sum of $n$ and the product of $n$ and $m$ is equal to the product of $n$ and the sum of $m$ and $1$.",
    "output": "times_n_Sm : n : Nat -> m : Nat -> Eq (plus n (times n m)) (times n (plus m (nd 1))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_ind_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_690$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_690$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_690$.",
    "output": "Prod_ind_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_690) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "divides_n_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_primes.divides n matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type3. For all sets $_A$, for all functions $Q_$ from elements $_x_921$ of $range$ of $_A$ to elements of $Type3$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $range$ of $_A$, $Q_$ holds for $x_921$.",
    "output": "range_rect_Type3 : _A : Set -> Q_ : (_x_921 : range _A -> Type3) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_921 : range _A -> Q_ x_921 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Map_body. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "map_body : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list B) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bijn_transpose. For all natural numbers $n$ and $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then $bijn$ holds for $transpose$ applied to $i$ and $j$ and $n$.",
    "output": "bijn_transpose : n : Nat -> i : Nat -> j : Nat -> __ : Leq i n -> __1 : Leq j n -> bijn (transpose i j) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_1_to_lt_n. For all natural numbers $i$ and $n$, if $1$ is less than $n$, then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.",
    "output": "gcd_1_to_lt_n : i : Nat -> n : Nat -> __ : Lt (nd 1) n -> __1 : Leq i n -> __2 : Eq (gcd i n) (nd 1) -> Lt i n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_le_to_not_le_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "not_le_to_not_le_S_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSO. $B$ applied to $3$ is equal to $6$.",
    "output": "B_SSSO : Eq (B (nd 3)) (nd 6) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_Type4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_526$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_inl$ from elements $x_527$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_527$, for all functions $_H_inr$ from elements $x_528$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_528$, for all elements $x_526$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_526$.",
    "output": "Sum_rect_Type4_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type4) -> _H_inl : (x_527 : cic.Term univs.Type0 _A -> cic.Term univs.Type4 (Q_ (matita_basics_types.inl _A _B x_527))) -> _H_inr : (x_528 : cic.Term univs.Type0 _B -> cic.Term univs.Type4 (Q_ (matita_basics_types.inr _A _B x_528))) -> x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type4 (Q_ x_526) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop50. We can prove that for all natural numbers $n$, it is not the case that $n$ is even and $n$ is odd.",
    "output": "prop50 : Proof (forall Nat (n => not (and (even n) (odd n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ and $K$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h2$ and $k2$ and $A$ and $J$ and $K$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "transitive_sub : h1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> k1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> h2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> k2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> A : cic.Univ univs.Type0 -> I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> K : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> __ : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h1 k1 A I J) -> __1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h2 k2 A J K) -> cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => h2 (h1 x)) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => k1 (k2 x)) A I K) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fst_p_ord_times. For all natural numbers $p$ and $a$ and $b$, if $p$ is prime, then if $0$ is less than $a$, then if $0$ is less than $b$, then $fst$ applied to $Nat$ and $Nat$ and $p_ord$ applied to the product of $a$ and $b$ and $p$ is equal to the sum of $fst$ applied to $Nat$ and $Nat$ and $p_ord$ applied to $a$ and $p$ and $fst$ applied to $Nat$ and $Nat$ and $p_ord$ applied to $b$ and $p$.",
    "output": "fst_p_ord_times : p : Nat -> a : Nat -> b : Nat -> __ : prime p -> __1 : Lt 0 a -> __2 : Lt 0 b -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ltl. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "ltl : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list H) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "eq_fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_div. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$.",
    "output": "monotonic_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_div_and_mod.div m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_n_Sm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "plus_n_Sm : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_nat.plus n m)) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S m))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z930$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z931$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_Type1 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type1) -> _H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_max_spec. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $__$ and $__1$ and $__2$, for all functions $case_not_found_max_spec$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.not_found_max_spec$ applied to $_n$ and $_f$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "match_max_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __) -> cic.Univ return_sort) -> case_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))) -> case_not_found_max_spec : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f __))) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __) -> cic.Term return_sort (return_type __ z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_minus_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $m$.",
    "output": "plus_minus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_ind. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_720$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_717$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_718$ and $x_717$, for all elements $x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_716$.",
    "output": "list_ind : _A : cic.Univ univs.Type0 -> Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_718 : cic.Term univs.Type0 _A -> x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_720 : cic.Term cic.prop (Q_ x_717) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_716) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_times_mod. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $p$ and $p$.",
    "output": "mod_times_mod : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mem_filter. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $a$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $a$ and $l$.",
    "output": "mem_filter : S : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 S -> cic.Term univs.Type0 matita_basics_bool.bool) -> a : cic.Term univs.Type0 S -> l : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> __ : cic.Term cic.prop (matita_basics_lists_list.mem S a (matita_basics_lists_list.filter S f l)) -> cic.Term cic.prop (matita_basics_lists_list.mem S a l) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop8d. For all sets $A$ and $B$, we can prove that $A$ is a subset of $B$, if and only if the complement of $B$ is a subset of the complement of $A$.",
    "output": "prop8d : (A : Set) -> (B : Set) -> Proof (iff (subseteq A B) (subseteq (complement B) (complement A))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_rect_Type5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_893$ of $ACop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_893$.",
    "output": "ACop_rect_Type5 : A : Set -> _nil : A -> Q_ : (_x_893 : ACop A _nil -> Type5) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_893 : ACop A _nil -> Q_ x_893 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Smallest_factor_to_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$.",
    "output": "smallest_factor_to_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n) -> cic.Term cic.prop (matita_arithmetics_primes.prime n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nill. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.",
    "output": "nill : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Checker_ab. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.andb$ applied to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $b$ and $matita_arithmetics_nat.leb$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$.",
    "output": "checker_ab : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) (matita_basics_bool.andb (matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S a) b) (matita_arithmetics_nat.leb b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1258. For all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $b$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "let_clause_1258 : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt1b : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp b n) b) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times b (matita_arithmetics_exp.exp b n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_13$ and $x_14$.",
    "output": "eq_rect_Type2_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_13 : cic.Term univs.Type2 A -> _x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) -> cic.Univ univs.Type2) -> _H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x)) -> x_13 : cic.Term univs.Type2 A -> x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) -> cic.Term univs.Type2 (Q_ x_13 x_14) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_967$.",
    "output": "Dop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_967) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "option : _A : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_Sfalse. For all natural numbers $k$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $p$ applied to $k$ is equal to absurdity, then $bigop$ applied to the sum of $k$ and $1$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "bigop_Sfalse : k : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Eq (p k) false -> Eq (bigop (plus k (nd 1)) (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p i) B nil op (i : Nat => f i)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_to_log_r. For all natural numbers $b$ and $n$ and $m$, if $1$ is less than $b$, then if $n$ is less than $m$, then if the exponentiation of $b$ and $n$ is less than or equal to $m$, then $n$ is less than or equal to the logarithm of $b$ and $m$.",
    "output": "exp_to_log_r : b : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) b -> __1 : Lt n m -> __2 : Leq (pow b n) m -> Leq n (log b m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_668$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_668$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_668$.",
    "output": "Sig_rect_Type5 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type5) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type5 (Q_ x_668) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "SameF_p. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all sets $A$, $relation$ holds for $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__2$ to $A$.",
    "output": "sameF_p : __ : Nat -> __1 : (__1 : Nat -> bool) -> A : Set -> relation (prod Set Set Nat (__2 : Nat => A)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "PlusAC. $ACop$ holds for $Nat$ and $0$.",
    "output": "plusAC : ACop Nat 0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_gcd_aux_mn. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $m$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $n$.",
    "output": "divides_gcd_aux_mn : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_inv_rect_Type3. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1446$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to elements of $Type3$, for all functions $_H1$ from elements $x_823$ of $Lt$ of $x4$ and $x2$ and elements $x_822$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1447$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$, $P$ holds for $Hterm$.",
    "output": "div_mod_spec_inv_rect_Type3 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1446 : div_mod_spec x1 x2 x3 x4 -> Type3) -> _H1 : (x_823 : Lt x4 x2 -> x_822 : Eq x1 (plus (times x3 x2) x4) -> _z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_1572 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O) -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) -> auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Rev_append_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "rev_append_body : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_939$.",
    "output": "range_rect_CProp0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_939) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Tri_transitive. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.tri_relation$ applied to $A$ and $B$ and $C$, $cic.Univ$ holds for $cic.prop$.",
    "output": "tri_transitive : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dexp. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Dexp : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_rect_CProp1. For all functions $Q_$ from elements $_x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_493$.",
    "output": "void_rect_CProp1 : Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_493 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_493) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Commutative2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "commutative2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_654$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_654$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_654$.",
    "output": "DPair_rect_CProp5_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_654) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1600. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$.",
    "output": "let_clause_1600 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_r_sn. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.",
    "output": "lstar_r_sn : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2) -> b1 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (R b1 b) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Invert_permut_f. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ and $m$.",
    "output": "invert_permut_f : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> __1 : cic.Term cic.prop (matita_arithmetics_permutation.injn f n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.invert_permut n f (f m)) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_r_ind_body. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all functions $Q_$ from natural numbers $x_1337$ and elements $x_1336$ of $B$ and elements $x_1335$ of $B$ and elements $_x_1338$ of $lstar_r$ of $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to propositions, for all functions $_H_lstar_r_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1340$ of $lstar_r$ of $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $B$ and elements $x_1339$ of $_R$ of $b$ and $b2$ and elements $_x_1342$ of $Q_$ of $l$ and $b1$ and $b$ and $x_1340$ to elements of $Q_$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all natural numbers $x_1337$, for all elements $x_1336$ and $x_1335$ of $B$, for all elements $x_1338$ of $lstar_r$ of $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $Q_$ holds for $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "lstar_r_ind_body : B : Set -> _R : relation B -> Q_ : (x_1337 : Nat -> x_1336 : B -> x_1335 : B -> _x_1338 : lstar_r B _R x_1337 x_1336 x_1335 -> Prop) -> _H_lstar_r_O : (b : B -> Q_ 0 b b (lstar_r_O B _R b)) -> _H_lstar_r_S : (l : Nat -> b1 : B -> b : B -> x_1340 : lstar_r B _R l b1 b -> b2 : B -> x_1339 : _R b b2 -> _x_1342 : Q_ l b1 b x_1340 -> Q_ (plus l (nd 1)) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> x_1337 : Nat -> x_1336 : B -> x_1335 : B -> x_1338 : lstar_r B _R x_1337 x_1336 x_1335 -> Q_ x_1337 x_1336 x_1335 x_1338 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1536$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1537$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_previous_prime7. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_previous_prime7 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_inv_ind. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z587$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "bool_inv_ind : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z587 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type1_body. For all functions $Q_$ from elements $_x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_O$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_388$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_386$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_386$, for all elements $x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_385$.",
    "output": "nat_rect_Type1_body : Q_ : (_x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type1) -> _H_O : cic.Term univs.Type1 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_388 : cic.Term univs.Type1 (Q_ x_386) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_nat.S x_386))) -> x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type1 (Q_ x_385) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Congruent_ab_lt. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$ and $matita_arithmetics_nat.lt$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$.",
    "output": "congruent_ab_lt : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_n_to_le. For all functions $h$ from natural numbers to natural numbers, for all natural numbers $k$ and $n$, if $k$ is less than or equal to $n$, then for all elements $__1$ of $permut$ of $h$ and $n$, for all functions $__2$ from natural numbers $m$ and elements $__2$ of $Lt$ of $m$ and $k$ to elements of $Eq$ of $h$ applied to $m$ and $m$, for all natural numbers $j$, if $k$ is less than or equal to $j$, then if $j$ is less than or equal to $n$, then $k$ is less than or equal to $h$ applied to $j$.",
    "output": "permut_n_to_le : h : (__ : Nat -> Nat) -> k : Nat -> n : Nat -> __ : Leq k n -> __1 : permut h n -> __2 : (m : Nat -> __2 : Lt m k -> Eq (h m) m) -> j : Nat -> __3 : Leq k j -> __4 : Leq j n -> Leq k (h j) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_lstar_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_S$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $l$ and $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $__$ and $l$ and $b2$ and $__1$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $__1$ and $__2$ and $z$.",
    "output": "match_lstar : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2) -> cic.Univ return_sort) -> case_lstar_O : (b : cic.Term univs.Type0 B -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> case_lstar_S : (b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (_R b1 b) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2) -> cic.Term return_sort (return_type __ __1 __2 z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "lt_O_bc : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injective_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "injective_times_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Reverse_single. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "reverse_single : S : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 S -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_883$.",
    "output": "Aop_rect_CProp1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_883) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_le_to_lt_times. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $q$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $q$.",
    "output": "lt_to_le_to_lt_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le p q) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times m q)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lprim_invariant. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $i$ and $acc$ and $matita_arithmetics_nat.plus$ applied to $n$ and $i$.",
    "output": "lprim_invariant : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp3_body. For all sets $_A$, for all functions $Q_$ from elements $_x_933$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_933$ of $range$ of $_A$, $Q_$ holds for $x_933$.",
    "output": "range_rect_CProp3_body : _A : Set -> Q_ : (_x_933 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_933 : range _A -> Q_ x_933 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min. For all natural numbers $__$ and $__1$, for all functions $__2$ from natural numbers $__2$ to booleans, $Nat$.",
    "output": "min : __ : Nat -> __1 : Nat -> __2 : (__2 : Nat -> bool) -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psil1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.",
    "output": "le_Psil1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_O_n. For all natural numbers $n$, $0$ is equal to the difference of $0$ and $n$.",
    "output": "minus_O_n : n : Nat -> Eq 0 (minus 0 n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transpose. For all elements $__$ and $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "transpose : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_div. For all natural numbers $n$ and $d$, if $0$ is less than $n$, then if $d$ is divisible by $n$, then the quotient of $n$ and the quotient of $n$ and $d$ is equal to $d$.",
    "output": "div_div : n : Nat -> d : Nat -> __ : Lt 0 n -> __1 : divisible d n -> Eq (div n (div n d)) d ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_CProp1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_577$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_577$, for all functions $_H_inr$ from elements $x_578$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_578$, for all elements $x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_576$.",
    "output": "Sum_rect_CProp1_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_577 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> _H_inr : (x_578 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_576) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_sqrt. For all natural numbers $n$, $n$ is less than the exponentiation of the sum of the square root of $n$ and $1$ and $2$.",
    "output": "lt_sqrt : n : Nat -> Lt n (pow (plus (sqrt n) (nd 1)) (nd 2)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injective_S. $injective$ holds for $Nat$ and $Nat$ and $succ$.",
    "output": "injective_S : injective Nat Nat succ ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "True. $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "true : cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_660$.",
    "output": "DPair_rect_CProp1 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_660) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_inv_rect_Type3. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z599$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "bool_inv_rect_Type3 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> _H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z365$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z366$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "And_inv_rect_CProp3 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_156 : cic.Term cic.prop x1 -> x_155 : cic.Term cic.prop x2 -> _z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_inv_rect_CProp4. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1470$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_839$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_838$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1471$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_839$ and $x_838$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_839$ and $x_838$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "div_mod_spec_inv_rect_CProp4 : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> P : (_z1470 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> cic.Univ cic.prop) -> _H1 : (x_839 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2) -> x_838 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4)) -> _z1471 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_839 x_838)) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_839 x_838))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_div_mod_spec. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_div_mod_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_commute. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p11$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p12$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p21$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p22$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $j$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $p11$ applied to $i$ and $p12$ applied to $i$ and $j$ and $matita_basics_bool.andb$ applied to $p21$ applied to $j$ and $p22$ applied to $i$ and $j$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p11$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $j$ to $p12$ applied to $i$ and $j$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $f$ applied to $i$ and $j$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $j$ to $p21$ applied to $j$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p22$ applied to $i$ and $j$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $j$.",
    "output": "bigop_commute : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p11 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p12 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p21 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p22 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt j m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb (p11 i) (p12 i j)) (matita_basics_bool.andb (p21 j) (p22 i j)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p11 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop m (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => p12 i j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i j))) (matita_arithmetics_bigops.bigop m (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => p21 j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (j : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p22 i j) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i j)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_iter. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $g$ applied to $x$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$.",
    "output": "le_iter : g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_le_S_S_to_not_le. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is not less than or equal to the sum of $m$ and $1$, then $n$ is not less than or equal to $m$.",
    "output": "not_le_S_S_to_not_le : n : Nat -> m : Nat -> __ : not (Leq (plus n (nd 1)) (plus m (nd 1))) -> not (Leq n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then the equivalence of $_A$ and $_B$ is an element of $cic.Univ$ of $cic.prop$.",
    "output": "iff : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_list. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_nil$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $case_cons$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_list : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ return_sort) -> case_nil : cic.Term return_sort (return_type (matita_basics_lists_list.nil _A)) -> case_cons : (__ : cic.Term univs.Type0 _A -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term return_sort (return_type (matita_basics_lists_list.cons _A __ __1))) -> z : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_step. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.",
    "output": "lstar_step : B : cic.Univ univs.Type0 -> R : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (R b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_Type2. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1518$ of $Aop$ of $x1$ and $x2$ to elements of $Type2$, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1519$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "Aop_inv_rect_Type2 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1518 : Aop x1 x2 -> Type2) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1519 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_inv_rect_Type2. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $ACop$ of $x1$ and $x2$ to elements of $Type2$, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.",
    "output": "ACop_inv_rect_Type2 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1584 : ACop x1 x2 -> Type2) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1585 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ord_rem. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "ord_rem : __ : Nat -> __1 : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_SO_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "gcd_SO_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transitive_le. $transitive$ holds for $Nat$ and $Leq$.",
    "output": "transitive_le : transitive Nat Leq ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_n_nth_prime_n. For all natural numbers $n$, $n$ is less than $nth_prime$ applied to $n$.",
    "output": "lt_n_nth_prime_n : n : Nat -> Lt n (nth_prime n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ex2_intro. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ and $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $Q$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $P$ and $Q$.",
    "output": "ex2_intro : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> x : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (P x) -> __1 : cic.Term cic.prop (Q x) -> cic.Term cic.prop (matita_basics_logic.ex2 A P Q) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_pi_l. For all elements $n$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_nat.times$ applied to $a$ and $f$ applied to $i$.",
    "output": "exp_pi_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp a n) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i))) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times a (f i)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_903$.",
    "output": "ACop_rect_CProp4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_903) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_7$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_8$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_7$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_7$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_8$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_7$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_7$ and $x_8$.",
    "output": "eq_rect_Type5_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_7 : cic.Term univs.Type2 A -> _x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) -> cic.Univ univs.Type5) -> _H_refl : cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x)) -> x_7 : cic.Term univs.Type2 A -> x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) -> cic.Term univs.Type5 (Q_ x_7 x_8) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1009. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $Hfn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $n$ and $matita_basics_bool.false$, for all elements $Hmax$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$, for all elements $Hmax0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $matita_arithmetics_nat.O$, for all functions $auto$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.",
    "output": "let_clause_1009 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> Hfn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false) -> Hmax : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n) -> Hmax0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) n) -> _clearme : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i m) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i m) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) matita_arithmetics_nat.O)) -> auto : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_sqrt_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "le_sqrt_n1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_sqrt.sqrt n))) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fold_body. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_b$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "fold_body : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _b : cic.Term univs.Type0 B -> _p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_Type0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1530$ of $Aop$ of $x1$ and $x2$ to sets, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1531$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "Aop_inv_rect_Type0 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1530 : Aop x1 x2 -> Set) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Found_max_spec. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $n$ and $f$ and $m$.",
    "output": "found_max_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_spec_to_max. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, for all elements $__$ of $max_spec$ of $n$ and $f$ and $m$, $max$ applied to $n$ and $f$ is equal to $m$.",
    "output": "max_spec_to_max : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : max_spec n f m -> Eq (max n f) m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_a. For all natural numbers $a$ and $b$, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a$ is less than or equal to $b$, then $bigop$ applied to the difference of the sum of $b$ and $1$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$ is equal to $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to the successor of $i0$ applied to the sum of $i$ and $a$ and $f$ applied to $a$.",
    "output": "bigop_a : a : Nat -> b : Nat -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq a b -> Eq (bigop (minus (plus b (nd 1)) a) (i : Nat => (i0 : Nat => true) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a))) (op B nil op (bigop (minus b a) (i : Nat => (i0 : Nat => true) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f (succ i0)) (plus i a))) (f a)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_rect_Type0_body. For all functions $Q_$ from elements $_x_507$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_it$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_507$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_507$.",
    "output": "unit_rect_Type0_body : Q_ : (_x_507 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type0) -> _H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it) -> x_507 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type0 (Q_ x_507) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_SO_to_le_B_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "lt_SO_to_le_B_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1302$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1303$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_720$ from elements $_z1303$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_717$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_717$ and elements $_z1303$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_718$ and $x_717$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_718$ and $x_717$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "list_inv_ind : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1302 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ cic.prop) -> _H1 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_718 : cic.Term univs.Type0 x1 -> x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_720 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_717) -> cic.Term cic.prop (P x_717)) -> _z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_718 x_717)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_718 x_717))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "NoLabel_71. For all instances $x$ of integers, we can prove that if the difference of the product of $7$ and $x$ and $3$ is even, then the sum of the product of $3$ and $x$ and $8$ is odd.",
    "output": "noLabel_71 : x : Elem Int -> Proof (if (even (minus (times (nd 7) x) (nd 3))) (odd (plus (times (nd 3) x) (nd 8)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nill_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.",
    "output": "nill_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_sqrt_to_lt_times_r. For all natural numbers $m$ and $n$, if the square root of $m$ is less than $n$, then $m$ is less than the product of $n$ and $n$.",
    "output": "lt_sqrt_to_lt_times_r : m : Nat -> n : Nat -> __ : Lt (sqrt m) n -> Lt m (times n n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_divides_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "list_divides_body : __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_discr. For all sets $a1$, for all elements $a2$ of $a1$, for all elements $x$ and $y$ of $Aop$ of $a1$ and $a2$, if $x$ is equal to $y$, then $match_Aop$ holds for $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $match_Aop$ applied to $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R3$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $b$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $c$ to $Eq$ applied to $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z55$ to $P$ and $y$ and $x$.",
    "output": "Aop_discr : a1 : Set -> a2 : a1 -> x : Aop a1 a2 -> y : Aop a1 a2 -> _e : Eq x y -> match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (t0 : (__ : a1 -> __1 : a1 -> a1) => t1 : (a : a1 -> Eq (t0 a2 a) a) => t2 : (a : a1 -> Eq (t0 a a2) a) => t3 : (a : a1 -> b : a1 -> c : a1 -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) => match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (u0 : (__ : a1 -> __1 : a1 -> a1) => u1 : (a : a1 -> Eq (u0 a2 a) a) => u2 : (a : a1 -> Eq (u0 a a2) a) => u3 : (a : a1 -> b : a1 -> c : a1 -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0) (e0 : Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0 => prod Prop Type1 (Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (e1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) (e2 : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 => prod Prop Type1 (Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 => P))))) (_z55 : (e0 : Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0 -> e1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 -> e2 : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 -> _e3 : Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 -> P) => P))) y) x ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Example1. $smallest_factor$ applied to $3$ is equal to $3$.",
    "output": "example1 : Eq (smallest_factor (nd 3)) (nd 3) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "plus_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_plus_n. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $m$.",
    "output": "le_plus_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than or equal to $p$.",
    "output": "le_plus_to_minus : n : Nat -> m : Nat -> p : Nat -> __ : Leq n (plus p m) -> Leq (minus n m) p ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dividesb_true_to_divides. For all natural numbers $n$ and $m$, if $dividesb$ applied to $n$ and $m$ is equal to $true$, then $n$ is divisible by $m$.",
    "output": "dividesb_true_to_divides : n : Nat -> m : Nat -> __ : Eq (dividesb n m) true -> divisible n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "B : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_fg. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $m$ to $f$ applied to $g$ applied to $m$ and $n$.",
    "output": "permut_fg : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n) -> __1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => f (g m)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min0. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, $Nat$.",
    "output": "min0 : _n : Nat -> _f : (__ : Nat -> bool) -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "IntersEmpty. For all sets $A$, we can prove that the intersection of $A$ and the empty set is equal to the empty set.",
    "output": "intersEmpty : (A : Set) -> Proof (equalset (intersection A emptyset) emptyset) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Leq_sqrt_n. For all natural numbers $n$, the product of the square root of $n$ and the square root of $n$ is less than or equal to $n$.",
    "output": "leq_sqrt_n : n : Nat -> Leq (times (sqrt n) (sqrt n)) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1013. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $i$ and $f$ and $m$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $fi$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $m$, for all elements $fm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.false$ and $matita_basics_bool.true$.",
    "output": "let_clause_1013 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max i f) m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> fi : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true) -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i m) -> fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_Conf3. For all sets $A$ and $B$, for all elements $succ$ of $relation2$ of $A$ and $B$, for all elements $R$ of $relation$ of $A$, for all elements $__$ of $Conf3$ of $A$ and $B$ and $succ$ and $R$, for all natural numbers $l$, $Conf3$ holds for $A$ and $B$ and $succ$ and $lstar$ applied to $A$ and $R$ and $l$.",
    "output": "lstar_Conf3 : A : Set -> B : Set -> succ : relation2 A B -> R : relation A -> __ : Conf3 A B succ R -> l : Nat -> Conf3 A B succ (lstar A R l) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_875$.",
    "output": "Aop_rect_CProp4_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_875) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1266$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1267$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "Prod_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1266 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type0) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1267 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_1_max_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $i$ and $matita_arithmetics_primes.dividesb$ applied to $i$ and $n$.",
    "output": "lt_1_max_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_log_n_n. For all natural numbers $p$ and $n$, if $1$ is less than $p$, then if $0$ is less than $n$, then the logarithm of $p$ and $n$ is less than $n$.",
    "output": "lt_log_n_n : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Lt (log p n) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_1_n. For all natural numbers $n$, $1$ is equal to the exponentiation of $1$ and $n$.",
    "output": "exp_1_n : n : Nat -> Eq (nd 1) (pow (nd 1) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_n_fact_n. For all natural numbers $n$, $n$ is less than or equal to the factorial of $n$.",
    "output": "le_n_fact_n : n : Nat -> Leq n (factorial n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ex_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_236$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex_intro$ applied to $A$ and $_P$ and $x$ and $x_236$, for all elements $x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_235$.",
    "output": "ex_ind : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Univ cic.prop) -> _H_ex_intro : (x : cic.Term univs.Type0 A -> x_236 : cic.Term cic.prop (_P x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term cic.prop (Q_ x_235) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_minus_comm. For all natural numbers $a$ and $b$ and $c$, the difference of the difference of $a$ and $b$ and $c$ is equal to the difference of the difference of $a$ and $c$ and $b$.",
    "output": "minus_minus_comm : a : Nat -> b : Nat -> c : Nat -> Eq (minus (minus a b) c) (minus (minus a c) b) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_exp_to_eq. For all natural numbers $p$ and $q$ and $m$, if $p$ is prime, then if $q$ is prime, then if $p$ is divisible by the exponentiation of $q$ and $m$, then $p$ is equal to $q$.",
    "output": "divides_exp_to_eq : p : Nat -> q : Nat -> m : Nat -> __ : prime p -> __1 : prime q -> __2 : divisible p (pow q m) -> Eq p q ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_907$.",
    "output": "ACop_rect_CProp3_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_907) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_n_Sm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "times_n_Sm : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.times n (matita_arithmetics_nat.S m))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_log. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.",
    "output": "le_log : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Congruent_times. For all elements $n$ and $m$ and $n1$ and $m1$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $n1$ and $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $m$ and $m1$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $n1$ and $m1$ and $p$.",
    "output": "congruent_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n n1 p) -> __2 : cic.Term cic.prop (matita_arithmetics_congruence.congruent m m1 p) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times n1 m1) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Succ. If $Sort$, then $Sort$.",
    "output": "succ : Sort -> Sort ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_body. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "times_body : __ : Nat -> __1 : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bc_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "bc_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injective_times_r. For all natural numbers $n$, if $0$ is less than $n$, then $injective$ holds for $Nat$ and $Nat$ and the function that maps $m$ to the product of $n$ and $m$.",
    "output": "injective_times_r : n : Nat -> __ : Lt 0 n -> injective Nat Nat (m : Nat => times n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "NoLabel_26. For all instances $x$ of integers, we can prove that if the difference of the product of $5$ and $x$ and $7$ is even, then $x$ is odd.",
    "output": "noLabel_26 : x : Elem Int -> Proof (if (even (minus (times (nd 5) x) (nd 7))) (odd x)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_883$.",
    "output": "Aop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_883) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z942$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z943$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z942 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z943 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_781$.",
    "output": "Aop_ind_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_781) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_rect_CProp4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "And_rect_CProp4_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_148 : cic.Term cic.prop _A -> x_147 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_146) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Congruent_n_mod_n. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $p$.",
    "output": "congruent_n_mod_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n p) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_Or. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_Or : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.Or _A _B) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_inv_ltransitive. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.inv_ltransitive$ applied to $B$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$.",
    "output": "lstar_inv_ltransitive : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> cic.Term cic.prop (matita_arithmetics_lstar.inv_ltransitive B (matita_arithmetics_lstar.lstar B R)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1062$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z1063$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_607$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1063$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_607$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_607$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "option_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ univs.Type1) -> _H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> _H2 : (x_607 : cic.Term univs.Type0 x1 -> _z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607)) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_smallest_factor_to_not_divides. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $1$ is less than $i$, then if $i$ is less than $smallest_factor$ applied to $n$, then $i$ is not divisible by $n$.",
    "output": "lt_smallest_factor_to_not_divides : n : Nat -> i : Nat -> __ : Lt (nd 1) n -> __1 : Lt (nd 1) i -> __2 : Lt i (smallest_factor n) -> not (divisible i n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_16004. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "let_clause_16004 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_times. For all natural numbers $x$ and $y$ and $z$, the product of $x$ and the product of $y$ and $z$ is equal to the product of $y$ and the product of $x$ and $z$.",
    "output": "times_times : x : Nat -> y : Nat -> z : Nat -> Eq (times x (times y z)) (times y (times x z)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_sqrt_n. For all natural numbers $n$, if $1$ is less than $n$, then the square root of $n$ is less than $n$.",
    "output": "lt_sqrt_n : n : Nat -> __ : Lt (nd 1) n -> Lt (sqrt n) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.",
    "output": "DPair_rect_Type3_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type3) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type3 (Q_ x_644) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. $Sort$ is a type.",
    "output": "Sort : Type ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_Dop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ return_sort) -> case_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_pi_bc. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $c$ and $b$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $b$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $b$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $c$ and $b$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $b$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $matita_arithmetics_nat.times$ applied to $a$ and $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $b$.",
    "output": "exp_pi_bc : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus c b)) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i b)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i0) (matita_arithmetics_nat.plus i b)))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i b)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times a (f i0)) (matita_arithmetics_nat.plus i b)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_25$ and $x_26$.",
    "output": "eq_rect_CProp5 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_25 : cic.Term univs.Type2 A -> _x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_25 : cic.Term univs.Type2 A -> x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) -> cic.Term cic.prop (Q_ x_25 x_26) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log_div. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.",
    "output": "log_div : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 m -> __2 : Leq m n -> Leq (log p (div n m)) (minus (log p n) (log p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Thm07. For all instances $p$ and $q$ of natural numbers, if we can prove that $p$ is prime and $q$ is prime, then we can prove that the product of the Legendre symbol of $p$ and $q$ and the Legendre symbol of $q$ and $p$ is equal to the exponentiation of the negation of $1$ and the product of the quotient of the difference of $p$ and $1$ and $2$ and the quotient of the difference of $q$ and $1$ and $2$.",
    "output": "thm07 : (p : Elem Nat) -> (q : Elem Nat) -> Proof (and (prime p) (prime q)) -> Proof (Eq (times (legendre p q) (legendre q p)) (pow (neg 1) (times (div (minus p 1) 2) (div (minus q 1) 2)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10334. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10334 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_exp_to_eq. For all elements $p$ and $q$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $q$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $p$ and $q$.",
    "output": "divides_exp_to_eq : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.prime q) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp q m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) p q) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_sigma_p_div. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$.",
    "output": "eq_sigma_p_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n q)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type0. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "nat_rect_Type0 : Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : cic.Term univs.Type0 (Q_ x_390) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (Q_ x_389) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_676$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_676$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_676$.",
    "output": "Sig_rect_Type0 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type0) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type0 (Q_ x_676) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dividesb. For all natural numbers $__$ and $__1$, $bool$.",
    "output": "dividesb : __ : Nat -> __1 : Nat -> bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_zero. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.not_zero$ applied to $m$.",
    "output": "lt_to_not_zero : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_arithmetics_nat.not_zero m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_to_not_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "le_to_not_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Andb_true_r. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "andb_true_r : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Tri_symmetric. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.tri_relation$ applied to $A$ and $B$ and $C$, $cic.Univ$ holds for $cic.prop$.",
    "output": "tri_symmetric : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Cons_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.",
    "output": "cons_injective_r : A : cic.Univ univs.Type0 -> a1 : cic.Term univs.Type0 A -> a2 : cic.Term univs.Type0 A -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_iso. For all elements $n1$ and $n2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f1$ and $f2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f2$ applied to $i$.",
    "output": "bigop_iso : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil) -> f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> __ : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p1 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f1 i)) (matita_arithmetics_bigops.bigop n2 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p2 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f2 i))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1033. For all natural numbers $n$, if the exponentiation of $2$ and $4$ is less than or equal to $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_1033 : n : Nat -> le_n : Leq (pow (nd 2) (nd 4)) n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10331. For all natural numbers $p$ and $n$ and $n1$ and $q$ and $p1$ and $p2$ and $qa$ and $ra$, if $p_ord_aux$ applied to the sum of $n1$ and $1$ and the sum of $n1$ and $1$ and the sum of $p2$ and $2$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $qa$ and $ra$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10331 : p : Nat -> n : Nat -> n1 : Nat -> q : Nat -> p1 : Nat -> p2 : Nat -> qa : Nat -> ra : Nat -> H : Eq (p_ord_aux (plus n1 (nd 1)) (plus n1 (nd 1)) (plus p2 (nd 2))) (mk_Prod Nat Nat qa ra) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bijn_transpose_r. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to the function that maps $p$ to $f$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $p$ and $n$.",
    "output": "bijn_transpose_r : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le j n) -> __2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => f (matita_arithmetics_permutation.transpose i j p)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_rect_CProp3. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z948$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z949$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_CProp3 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z948 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z949 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop8b. For all sets $A$ and $B$, we can prove that $A$ is a subset of $B$, if and only if the union of $A$ and $B$ is equal to $B$.",
    "output": "prop8b : (A : Set) -> (B : Set) -> Proof (iff (subseteq A B) (equalset (union A B) B)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Breakup_pair. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $C$ to elements of $cic.Univ$ of $cic.prop$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $P$ applied to $matita_basics_types.fst$ applied to $A$ and $B$ and $x$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $x$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $_0$ to $C$ and the function that maps $a$ and $b$ to $P$ applied to $a$ and $b$ and $x$.",
    "output": "breakup_pair : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> R : (__ : cic.Term univs.Type0 C -> cic.Univ cic.prop) -> P : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> __ : cic.Term cic.prop (R (P (matita_basics_types.fst A B x) (matita_basics_types.snd A B x))) -> cic.Term cic.prop (R (matita_basics_types.match_Prod A B univs.Type0 (_0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) => C) (a : cic.Term univs.Type0 A => b : cic.Term univs.Type0 B => P a b) x)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_rect_Type0. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_nmk$ from functions $x_98$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_98$, for all elements $x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_97$.",
    "output": "Not_rect_Type0 : _A : cic.Univ cic.prop -> Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type0) -> _H_nmk : (x_98 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type0 (Q_ x_97) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max'_body. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all natural numbers $__2$, $Nat$.",
    "output": "max'_body : __ : Nat -> __1 : (__1 : Nat -> bool) -> __2 : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "RC. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$.",
    "output": "RC : A : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Term univs.Type0 (matita_basics_relations.relation A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_pi_p_primeb_divides_b. For all natural numbers $n$ and $m$, $bigop$ applied to $n$ and the function that maps $p$ to $andb$ applied to $primeb$ applied to $p$ and $dividesb$ applied to $p$ and $m$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and $ord$ applied to $m$ and $p$ is equal to $bigop$ applied to $n$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and $ord$ applied to $m$ and $p$.",
    "output": "eq_pi_p_primeb_divides_b : n : Nat -> m : Nat -> Eq (bigop n (p : Nat => andb (primeb p) (dividesb p m)) Nat (nd 1) times (p : Nat => pow p (ord m p))) (bigop n (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (ord m p))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp1_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_965$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_965$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_965$.",
    "output": "Dop_rect_CProp1_body : A : Set -> _nil : A -> Q_ : (_x_965 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_965 : Dop A _nil -> Q_ x_965 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_rect_CProp2_body. For all functions $Q_$ from elements $_x_515$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_515$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_515$.",
    "output": "unit_rect_CProp2_body : Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H_it : cic.Term cic.prop (Q_ matita_basics_types.it) -> x_515 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop (Q_ x_515) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_exp_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "exp_exp_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "False_rect_CProp0. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.",
    "output": "False_rect_CProp0 : Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_78 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_78) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prime_nth_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$.",
    "output": "prime_nth_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.nth_prime n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_CProp3. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1542$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1543$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "Aop_inv_rect_CProp3 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1542 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_fwd_plus_plus_ge. For all natural numbers $m1$ and $m2$, if $m2$ is less than or equal to $m1$, then for all natural numbers $n1$ and $n2$, if the sum of $m1$ and $n1$ is less than or equal to the sum of $m2$ and $n2$, then $n1$ is less than or equal to $n2$.",
    "output": "le_fwd_plus_plus_ge : m1 : Nat -> m2 : Nat -> __ : Leq m2 m1 -> n1 : Nat -> n2 : Nat -> __1 : Leq (plus m1 n1) (plus m2 n2) -> Leq n1 n2 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_gcd_aux. For all natural numbers $p$ and $m$ and $n$ and $d$, if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then if $d$ is divisible by $m$, then if $d$ is divisible by $n$, then $d$ is divisible by $gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "divides_gcd_aux : p : Nat -> m : Nat -> n : Nat -> d : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n p -> __3 : divisible d m -> __4 : divisible d n -> divisible d (gcd_aux p m n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_spec_ind_body. For all elements $_n$ and $_b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_min_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and $matita_arithmetics_minimization.not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1075$ and $x_1076$.",
    "output": "min_spec_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> _H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077))) -> _H_not_found_min_spec : (x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus _n _b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus _n _b) (matita_arithmetics_minimization.not_found_min_spec _n _b _f x_1081))) -> x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Term cic.prop (Q_ x_1075 x_1076) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_rect_CProp2. For all functions $Q_$ from elements $_x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_356$.",
    "output": "bool_rect_CProp2 : Q_ : (_x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_356) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F_max_true. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_basics_bool.true$.",
    "output": "f_max_true : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.max n f)) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Thm04. For all instances $u$ and $v$ of vectors, if we can prove that $u$ is perpendicular to $v$, then we can prove that the length of the sum of $u$ and $v$ is equal to the square root of the sum of the square of the length of $u$ and the square of the length of $v$.",
    "output": "Thm04 : (u : Elem Vector) -> (v : Elem Vector) -> Proof (perpendicular u v) -> Proof (Eq (length (resultant u v)) (sqrt (plus (square (length u)) (square (length v))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_rect_CProp0. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.",
    "output": "void_rect_CProp0 : Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_494 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_494) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_injective. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, $injective$ holds for $Nat$ and $Nat$ and $f$.",
    "output": "increasing_to_injective : f : (__ : Nat -> Nat) -> __ : increasing f -> injective Nat Nat f ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all natural numbers $__$, $relation$ holds for $B$.",
    "output": "lstar : B : Set -> _R : relation B -> __ : Nat -> relation B ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.",
    "output": "div_mod_spec_rect_CProp5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) -> x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_841) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_S_sigma_p. For all natural numbers $a$ and $n$, the exponentiation of the sum of $a$ and $1$ and $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $k$ to $true$ and $Nat$ and $0$ and $plus$ and the function that maps $k$ to the product of $bc$ applied to $n$ and $k$ and the exponentiation of $a$ and the difference of $n$ and $k$.",
    "output": "exp_S_sigma_p : a : Nat -> n : Nat -> Eq (pow (plus a (nd 1)) n) (bigop (plus n (nd 1)) (k : Nat => true) Nat 0 plus (k : Nat => times (bc n k) (pow a (minus n k)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_found_min_spec. For all natural numbers $n$ and $b$, for all functions $f$ from natural numbers to booleans, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $n$ and $b$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, $min_spec$ holds for $n$ and $b$ and $f$ and the sum of $n$ and $b$.",
    "output": "not_found_min_spec : n : Nat -> b : Nat -> f : (__ : Nat -> bool) -> __ : (i : Nat -> __ : Leq b i -> __1 : Lt i (plus n b) -> Eq (f i) false) -> min_spec n b f (plus n b) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_le2. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, for all natural numbers $m$, if $f$ applied to $0$ is less than or equal to $m$, then $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Leq$ applied to $f$ applied to $i$ and $m$ and $Lt$ applied to $m$ and $f$ applied to the sum of $i$ and $1$.",
    "output": "increasing_to_le2 : f : (__ : Nat -> Nat) -> __ : increasing f -> m : Nat -> __1 : Leq (f 0) m -> ex Nat (i : Nat => and (Leq (f i) m) (Lt m (f (plus i (nd 1))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_inv_rect_Type3. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z665$ to elements of $Type3$, for all functions $_H1$ from elements $_z666$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_378$ and functions $_x_380$ from elements $_z666$ of $Eq$ of $Hterm$ and $x_378$ to elements of $P$ of $x_378$ and elements $_z666$ of $Eq$ of $Hterm$ and the sum of $x_378$ and $1$ to elements of $P$ of the sum of $x_378$ and $1$, $P$ holds for $Hterm$.",
    "output": "nat_inv_rect_Type3 : Hterm : Nat -> P : (_z665 : Nat -> Type3) -> _H1 : (_z666 : Eq Hterm 0 -> P 0) -> _H2 : (x_378 : Nat -> _x_380 : (_z666 : Eq Hterm x_378 -> P x_378) -> _z666 : Eq Hterm (plus x_378 (nd 1)) -> P (plus x_378 (nd 1))) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.",
    "output": "filter : T : cic.Univ univs.Type0 -> _p : (__ : cic.Term univs.Type0 T -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list T) -> cic.Term univs.Type0 (matita_basics_lists_list.list T) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_4$ and $x_5$.",
    "output": "eq_rect_Type4_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_4 : cic.Term univs.Type2 A -> _x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) -> cic.Univ univs.Type4) -> _H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x)) -> x_4 : cic.Term univs.Type2 A -> x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) -> cic.Term univs.Type4 (Q_ x_4 x_5) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1704. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_1704 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eqb_body. For all natural numbers $__$ and $__1$, $bool$.",
    "output": "eqb_body : __ : Nat -> __1 : Nat -> bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1686. For all natural numbers $n$ and $m$, for all functions $Hind$ from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi$ applied to $p$ and the product of $pred$ applied to $p$ and the exponentiation of $2$ and the difference of the product of $2$ and $p$ and $3$, for all natural numbers $a$, if $m$ is equal to the product of $2$ and $a$ or $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $1$ is less than the sum of the product of $2$ and $a$ and $1$, then if $0$ is less than $a$, then $pred$ applied to $m$ is equal to the sum of $a$ and $a$.",
    "output": "let_clause_1686 : n : Nat -> m : Nat -> Hind : (p : Nat -> __ : Lt p m -> __1 : Lt (nd 1) p -> Leq (Psi p) (times (pred p) (pow (nd 2) (minus (times (nd 2) p) (nd 3))))) -> a : Nat -> _clearme : or (Eq m (times (nd 2) a)) (Eq m (plus (times (nd 2) a) (nd 1))) -> Hm : Eq m (plus (times (nd 2) a) (nd 1)) -> Hlt : Lt (nd 1) (plus (times (nd 2) a) (nd 1)) -> Ha : Lt 0 a -> Eq (pred m) (plus a a) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_Type4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_692$.",
    "output": "Prod_rect_Type4_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type4) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type4 (Q_ x_692) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_f3. For all elements $A$ and $B$ and $C$ and $D$ of $cic.Univ$ of $univs.Type2$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type2$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type2$ and $C$ to elements of $cic.Term$ of $univs.Type2$ and $D$, for all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $y1$ and $y2$ of $cic.Term$ of $univs.Type2$ and $B$, for all elements $z1$ and $z2$ of $cic.Term$ of $univs.Type2$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x1$ and $x2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $B$ and $y1$ and $y2$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $C$ and $z1$ and $z2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $D$ and $f$ applied to $x1$ and $y1$ and $z1$ and $f$ applied to $x2$ and $y2$ and $z2$.",
    "output": "eq_f3 : A : cic.Univ univs.Type2 -> B : cic.Univ univs.Type2 -> C : cic.Univ univs.Type2 -> D : cic.Univ univs.Type2 -> f : (__ : cic.Term univs.Type2 A -> __1 : cic.Term univs.Type2 B -> __2 : cic.Term univs.Type2 C -> cic.Term univs.Type2 D) -> x1 : cic.Term univs.Type2 A -> x2 : cic.Term univs.Type2 A -> y1 : cic.Term univs.Type2 B -> y2 : cic.Term univs.Type2 B -> z1 : cic.Term univs.Type2 C -> z2 : cic.Term univs.Type2 C -> __ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2) -> __1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2) -> __2 : cic.Term cic.prop (matita_basics_logic.eq C z1 z2) -> cic.Term cic.prop (matita_basics_logic.eq D (f x1 y1 z1) (f x2 y2 z2)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_le. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $m$ is not less than or equal to $n$.",
    "output": "lt_to_not_le : n : Nat -> m : Nat -> __ : Lt n m -> not (Leq m n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_gcd_SO_to_not_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "eq_gcd_SO_to_not_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pad_bigop1. For all natural numbers $k$ and $n$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $Eq$ of $p$ applied to $i$ and absurdity, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "pad_bigop1 : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Leq n k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> Eq (p i) false) -> Eq (bigop n (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p i) B nil op (i : Nat => f i)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_ind_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_810$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_809$.",
    "output": "div_mod_spec_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_809) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound7. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "let_upper_bound7 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iter_body. For all sets $H$, for all functions $__$ from elements of $H$ to elements of $H$, for all natural numbers $__1$, for all elements $__2$ of $H$, $H$.",
    "output": "iter_body : H : Set -> __ : (__ : H -> H) -> __1 : Nat -> __2 : H -> H ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injective_compose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $A$ and $B$ and $f$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $B$ and $C$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $A$ and $C$ and the function that maps $x$ to $g$ applied to $f$ applied to $x$.",
    "output": "injective_compose : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> g : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> __ : cic.Term cic.prop (matita_basics_relations.injective A B f) -> __1 : cic.Term cic.prop (matita_basics_relations.injective B C g) -> cic.Term cic.prop (matita_basics_relations.injective A C (x : cic.Term univs.Type0 A => g (f x))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_ord_log. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_ord.ord$ applied to $n$ and $p$ and $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "le_ord_log : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_log.log p n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_to_plus. For all natural numbers $n$ and $m$ and $p$, if $m$ is less than or equal to $n$, then if the difference of $n$ and $m$ is equal to $p$, then $n$ is equal to the sum of $m$ and $p$.",
    "output": "minus_to_plus : n : Nat -> m : Nat -> p : Nat -> __ : Leq m n -> __1 : Eq (minus n m) p -> Eq n (plus m p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1428$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1429$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1428 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1429 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $i$.",
    "output": "eq_fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => i))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp4_body. For all sets $_A$, for all functions $Q_$ from elements $_x_929$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_929$ of $range$ of $_A$, $Q_$ holds for $x_929$.",
    "output": "range_rect_CProp4_body : _A : Set -> Q_ : (_x_929 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_929 : range _A -> Q_ x_929 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_to_min_spec. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$ and $m$, if $min$ applied to $n$ and $b$ and $f$ is equal to $m$, then $min_spec$ holds for $n$ and $b$ and $f$ and $m$.",
    "output": "min_to_min_spec : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> m : Nat -> __ : Eq (min n b f) m -> min_spec n b f m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_inv_rect_Type1. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z677$ to elements of $Type1$, for all functions $_H1$ from elements $_z678$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_386$ and functions $_x_388$ from elements $_z678$ of $Eq$ of $Hterm$ and $x_386$ to elements of $P$ of $x_386$ and elements $_z678$ of $Eq$ of $Hterm$ and the sum of $x_386$ and $1$ to elements of $P$ of the sum of $x_386$ and $1$, $P$ holds for $Hterm$.",
    "output": "nat_inv_rect_Type1 : Hterm : Nat -> P : (_z677 : Nat -> Type1) -> _H1 : (_z678 : Eq Hterm 0 -> P 0) -> _H2 : (x_386 : Nat -> _x_388 : (_z678 : Eq Hterm x_386 -> P x_386) -> _z678 : Eq Hterm (plus x_386 (nd 1)) -> P (plus x_386 (nd 1))) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_678$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_678$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_678$.",
    "output": "Sig_rect_CProp4_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_678) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1206$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1207$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Sig_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ cic.prop) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_times_SO_to_gcd_SO. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "gcd_times_SO_to_gcd_SO : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_conj$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_144$ and $x_143$, for all elements $x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_142$.",
    "output": "And_rect_Type0_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type0) -> _H_conj : (x_144 : cic.Term cic.prop _A -> x_143 : cic.Term cic.prop _B -> cic.Term univs.Type0 (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) -> x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type0 (Q_ x_142) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Primes_all. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "primes_all : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_622$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_623$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_623$, for all elements $x_622$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_622$.",
    "output": "option_rect_CProp3_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_623 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))) -> x_622 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_622) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fold. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_b$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "fold : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _b : cic.Term univs.Type0 B -> _p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_mod. For all natural numbers $n$ and $p$, if $0$ is less than $p$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and $p$ and $p$.",
    "output": "mod_mod : n : Nat -> p : Nat -> __ : Lt 0 p -> Eq (mod n p) (mod (mod n p) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Tail. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "tail : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ex2_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "ex2_ind : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ cic.prop) -> _H_ex2_intro : (x : cic.Term univs.Type0 A -> x_276 : cic.Term cic.prop (_P x) -> x_275 : cic.Term cic.prop (_Q x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term cic.prop (Q_ x_274) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_M. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$.",
    "output": "lt_M : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_binomial.M m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_true. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $a$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$.",
    "output": "filter_true : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> a : cic.Term univs.Type0 A -> p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.filter A p (matita_basics_lists_list.cons A a l)) (matita_basics_lists_list.cons A a (matita_basics_lists_list.filter A p l))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_15601. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then if $0$ is equal to $n$, then if $0$ is divisible by $m$, then for all natural numbers $q$, if $m$ is equal to the product of $0$ and $q$, then $n$ is equal to $0$.",
    "output": "let_clause_15601 : n : Nat -> m : Nat -> posn : Lt 0 m -> eqn0 : Eq 0 n -> _clearme : divisible 0 m -> q : Nat -> eqm : Eq m (times 0 q) -> Eq n 0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Primes_below_lop. For all natural numbers $n$, $primes_below$ holds for $list_of_primes$ applied to $n$ and the sum of $n$ and $2$.",
    "output": "primes_below_lop : n : Nat -> primes_below (list_of_primes n) (plus n (nd 2)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bertrand. For all natural numbers $n$, if $0$ is less than $n$, then $bertrand$ holds for $n$.",
    "output": "bertrand : n : Nat -> __ : Lt 0 n -> bertrand n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_S_fact. For all natural numbers $n$ and $i$, if $1$ is less than $i$, then if $i$ is less than or equal to $n$, then $mod$ applied to the sum of the factorial of $n$ and $1$ and $i$ is equal to $1$.",
    "output": "mod_S_fact : n : Nat -> i : Nat -> __ : Lt (nd 1) i -> __1 : Leq i n -> Eq (mod (plus (factorial n) (nd 1)) i) (nd 1) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1621$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "ACop_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fmin_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, $prod$ holds for $Prop$ and $Prop$ and $Eq$ applied to $f$ applied to $let_m$ applied to $f$ and $n$ and $b$ and absurdity and the function that maps $__$ to $Eq$ applied to $let_m$ applied to $f$ and $n$ and $b$ and the sum of $n$ and $b$.",
    "output": "fmin_false : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> prod Prop Prop (Eq (f (let_m f n b)) false) (__ : Eq (f (let_m f n b)) false => Eq (let_m f n b) (plus n b)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_646$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_646$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_646$.",
    "output": "DPair_rect_Type2 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type2) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type2 (Q_ x_646) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_ind. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_586$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_587$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_587$, for all elements $x_586$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_586$.",
    "output": "option_ind : _A : cic.Univ univs.Type0 -> Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_587 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) -> x_586 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_586) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1626$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1627$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "ACop_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1626 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1627 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_17041. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_17041 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_plus_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $m$ and $m$.",
    "output": "minus_plus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n m) m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound5. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_upper_bound5 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_801$.",
    "output": "Aop_rect_CProp2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_801) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_rect_Type3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_nmk$ from functions $x_89$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_89$, for all elements $x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_88$.",
    "output": "Not_rect_Type3 : _A : cic.Univ cic.prop -> Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type3) -> _H_nmk : (x_89 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) -> x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type3 (Q_ x_88) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_times_to_le_div2. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then if $n$ is less than or equal to the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than or equal to $m$.",
    "output": "le_times_to_le_div2 : m : Nat -> n : Nat -> q : Nat -> __ : Lt 0 q -> __1 : Leq n (times m q) -> Leq (div n q) m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_prime_SO. $1$ is not prime.",
    "output": "not_prime_SO : not (prime (nd 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_inv_plus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$.",
    "output": "le_inv_plus_l : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_Conf3. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $matita_arithmetics_lstar.lstar$ applied to $A$ and $R$ and $l$.",
    "output": "lstar_Conf3 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B) -> R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> __ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_917$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_917$.",
    "output": "range_rect_Type4 : _A : cic.Univ univs.Type0 -> Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type4) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type4 (Q_ x_917) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nth_prime. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "nth_prime : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1562. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "let_clause_1562 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n c) (matita_arithmetics_nat.times m d)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Decidable_le. For all natural numbers $n$ and $m$, $decidable$ holds for $Leq$ applied to $n$ and $m$.",
    "output": "decidable_le : n : Nat -> m : Nat -> decidable (Leq n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_787$.",
    "output": "Aop_rect_Type3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type3) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type3 (Q_ x_787) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psi_exp. For all natural numbers $n$, $Psi$ applied to the product of $2$ and $n$ is less than or equal to the product of the exponentiation of $2$ and $pred$ applied to the product of $2$ and $n$ and $Psi$ applied to $n$.",
    "output": "le_Psi_exp : n : Nat -> Leq (Psi (times (nd 2) n)) (times (pow (nd 2) (pred (times (nd 2) n))) (Psi n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Append_l2_injective. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "append_l2_injective : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2)) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_range. For all sets $_A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $return_type$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.",
    "output": "match_range : _A : Set -> return_sort : Sort -> return_type : (z : range _A -> return_sort) -> case_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> z : range _A -> return_type z ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Commutative_times. $commutative$ holds for $Nat$ and $times$.",
    "output": "commutative_times : commutative Nat times ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound2. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "let_upper_bound2 : n : Nat -> m : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1590$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1591$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "ACop_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1590 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type1) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1591 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_r_inv_lstar. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $lstar$ holds for $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "lstar_r_inv_lstar : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar_r B R l b1 b2 -> lstar B R l b1 b2 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "True_rect_Type5_body. For all functions $Q_$ from elements $_x_44$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_I$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_44$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_44$.",
    "output": "True_rect_Type5_body : Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type5) -> _H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I) -> x_44 : cic.Term cic.prop matita_basics_logic.True -> cic.Term univs.Type5 (Q_ x_44) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "NoLabel_32. For all instances $n$ of integers, we can prove that if the product of $15$ and $n$ is even, then the product of $9$ and $n$ is even.",
    "output": "noLabel_32 : n : Elem Int -> Proof (if (even (times (nn 1 (nd 5)) n)) (even (times (nd 9) n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_exists. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $t$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $t$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all elements $k$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $t$ and $matita_arithmetics_nat.plus$ applied to $k$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $k$ and $b$ and $f$ and $m$.",
    "output": "min_exists : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> t : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m t) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> __4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $bertrand$ holds for $_n$.",
    "output": "bertrand : _n : Nat -> Prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_O_nth_prime_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.",
    "output": "lt_O_nth_prime_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_primes.nth_prime n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_exp_primr. For all natural numbers $n$, the exponentiation of $n$ and $prim$ applied to $n$ is less than or equal to the exponentiation of $2$ and the product of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "le_exp_primr : n : Nat -> Leq (pow n (prim n)) (pow (nd 2) (times (nd 2) (minus (times (nd 2) n) (nd 3)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lists_length_split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $la$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $lb$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$.",
    "output": "lists_length_split : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (la : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.ex (matita_basics_lists_list.list A) (lb : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $g$.",
    "output": "min_f_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "ACop_rect_Type2_body : A : Set -> _nil : A -> Q_ : (_x_897 : ACop A _nil -> Type2) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_897 : ACop A _nil -> Q_ x_897 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Antisymmetric_divides. For all natural numbers $n$ and $m$, if $n$ is divisible by $m$, then if $m$ is divisible by $n$, then $n$ is equal to $m$.",
    "output": "antisymmetric_divides : n : Nat -> m : Nat -> __ : divisible n m -> __1 : divisible m n -> Eq n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_squareS_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "le_squareS_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Theta. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "theta : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_times. For all natural numbers $n$ and $m$ and $p$ and $q$, if $n$ is less than $m$, then if $p$ is less than $q$, then the product of $n$ and $p$ is less than the product of $m$ and $q$.",
    "output": "lt_times : n : Nat -> m : Nat -> p : Nat -> q : Nat -> __ : Lt n m -> __1 : Lt p q -> Lt (times n p) (times m q) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_0. For all natural numbers $n$, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, $bigop$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to the sum of $i$ and $1$ and $f$ applied to $0$.",
    "output": "bigop_0 : n : Nat -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> Eq (bigop (plus n (nd 1)) (i : Nat => true) B nil (op B nil op) (i : Nat => f i)) (op B nil op (bigop n (i : Nat => true) B nil (op B nil op) (i : Nat => f (plus i (nd 1)))) (f 0)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_plus_to_le_r. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $a$ and $matita_arithmetics_nat.plus$ applied to $m$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "le_plus_to_le_r : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n a) (matita_arithmetics_nat.plus m a)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_unique_le. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__1$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $n$.",
    "output": "length_unique_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l) -> __1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $B$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "length_map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Position_of_aux. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_found$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_acc$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.",
    "output": "position_of_aux : A : cic.Univ univs.Type0 -> _found : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _acc : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_to_gcd_aux. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $p$, then if $0$ is less than $n$, then if $n$ is divisible by $m$, then $gcd_aux$ applied to $p$ and $m$ and $n$ is equal to $n$.",
    "output": "divides_to_gcd_aux : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 p -> __1 : Lt 0 n -> __2 : divisible n m -> Eq (gcd_aux p m n) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Cr_pair3. $cr_pair$ applied to $2$ and $3$ and $1$ and $2$ is equal to $5$.",
    "output": "cr_pair3 : Eq (cr_pair (nd 2) (nd 3) (nd 1) (nd 2)) (nd 5) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_gcd_aux_mn. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then $gcd_aux$ applied to $p$ and $m$ and $n$ is divisible by $m$ and $gcd_aux$ applied to $p$ and $m$ and $n$ is divisible by $n$.",
    "output": "divides_gcd_aux_mn : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n p -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Example4. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_bool.true$.",
    "output": "example4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp3. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $Lt$ of $_r$ and $_m$ and elements $x_846$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_845$.",
    "output": "div_mod_spec_rect_CProp3 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_845 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_847 : Lt _r _m -> x_846 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> x_845 : div_mod_spec _n _m _q _r -> Q_ x_845 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSSSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "B_SSSSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_686$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_686$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_686$.",
    "output": "Sig_rect_CProp1_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_686) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_plus_comm_23. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $z$ and $y$.",
    "output": "plus_plus_comm_23 : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_And. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_And : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_transpose_r. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $m$ and $i$ and $j$, if $i$ is less than or equal to $m$, then if $j$ is less than or equal to $m$, then for all elements $__2$ of $permut$ of $f$ and $m$, $permut$ holds for the function that maps $n$ to $f$ applied to $transpose$ applied to $i$ and $j$ and $n$ and $m$.",
    "output": "permut_transpose_r : f : (__ : Nat -> Nat) -> m : Nat -> i : Nat -> j : Nat -> __ : Leq i m -> __1 : Leq j m -> __2 : permut f m -> permut (n : Nat => f (transpose i j n)) m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_div. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $m$.",
    "output": "le_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div m n) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Congruent. For all elements $_n$ and $_m$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "congruent : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_transpose_l. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $f$ applied to $n$ and $m$.",
    "output": "permut_transpose_l : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le j m) -> __2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_permutation.transpose i j (f n)) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log_exp. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $m$, then the logarithm of $p$ and the product of the exponentiation of $p$ and $n$ and $m$ is equal to the sum of $n$ and the logarithm of $p$ and $m$.",
    "output": "log_exp : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 m -> Eq (log p (times (pow p n) m)) (plus n (log p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_previous_prime5. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "let_previous_prime5 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_rect_CProp5_body. For all functions $Q_$ from elements $_x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_490$.",
    "output": "void_rect_CProp5_body : Q_ : (_x_490 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_490 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_490) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_div_S_S_div. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then the quotient of the sum of $n$ and $1$ and $m$ is less than or equal to the sum of the quotient of $n$ and $m$ and $1$.",
    "output": "le_div_S_S_div : n : Nat -> m : Nat -> __ : Lt 0 m -> Leq (div (plus n (nd 1)) m) (plus (div n m) (nd 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_pi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "le_pi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g1 i)) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g2 i))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transpose_i_j_j_i. For all elements $i$ and $j$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $j$ and $i$ and $n$.",
    "output": "transpose_i_j_j_i : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose j i n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Quotient. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "quotient : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_iter2. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $g$ applied to $x$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $j$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $j$ and $a$.",
    "output": "monotonic_iter2 : g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le i j) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g j a)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop130. For all instances $x$ and $y$ of integers, we can prove that if the product of $x$ and $y$ is odd, then $x$ is odd and $y$ is odd.",
    "output": "prop130 : (x : Elem Int) -> (y : Elem Int) -> Proof (if (odd (times x y)) (and (odd x) (odd y))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_p_ord_q_O. For all elements $p$ and $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $q$ and $matita_arithmetics_nat.O$.",
    "output": "eq_p_ord_q_O : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sqrt_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $x$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.times$ applied to $x$ and $x$ and $n$.",
    "output": "sqrt_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pi_p_primeb. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and $ord$ applied to $n$ and $p$.",
    "output": "pi_p_primeb : n : Nat -> __ : Lt 0 n -> Eq n (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (ord n p))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "True_to_le_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.",
    "output": "true_to_le_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop. $Sort$.",
    "output": "prop : Sort ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injective_times_l. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $m$ and $n$.",
    "output": "injective_times_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_rect_CProp3_body. For all functions $Q_$ from elements $_x_513$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_513$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_513$.",
    "output": "unit_rect_CProp3_body : Q_ : (_x_513 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H_it : cic.Term cic.prop (Q_ matita_basics_types.it) -> x_513 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop (Q_ x_513) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1050$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z1051$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1051$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_599$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_599$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "option_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1050 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ univs.Type3) -> _H1 : (_z1051 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term univs.Type3 (P (matita_basics_types.None x1))) -> _H2 : (x_599 : cic.Term univs.Type0 x1 -> _z1051 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_599)) -> cic.Term univs.Type3 (P (matita_basics_types.Some x1 x_599))) -> cic.Term univs.Type3 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "False_rect_CProp3_body. For all functions $Q_$ from elements $_x_75$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_75$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_75$.",
    "output": "False_rect_CProp3_body : Q_ : (_x_75 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_75 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_75) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then if $y$ is less than or equal to $x$, then the difference of $x$ and the difference of $y$ and $z$ is equal to the sum of the difference of $x$ and $y$ and $z$.",
    "output": "minus_minus_associative : x : Nat -> y : Nat -> z : Nat -> __ : Leq z y -> __1 : Leq y x -> Eq (minus x (minus y z)) (plus (minus x y) z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injective_plus_r. For all natural numbers $n$, $injective$ holds for $Nat$ and $Nat$ and the function that maps $m$ to the sum of $n$ and $m$.",
    "output": "injective_plus_r : n : Nat -> injective Nat Nat (m : Nat => plus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dpi2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $f$ applied to $matita_basics_types.dpi1$ applied to $A$ and $f$ and $xxx$.",
    "output": "dpi2 : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f) -> cic.Term univs.Type0 (f (matita_basics_types.dpi1 A f xxx)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_inv_S1. For all natural numbers $x$ and $y$, if the sum of $x$ and $1$ is less than or equal to $y$, then $ex2$ holds for $Nat$ and the function that maps $z$ to $Leq$ applied to $x$ and $z$ and the function that maps $z$ to $Eq$ applied to $y$ and the sum of $z$ and $1$.",
    "output": "le_inv_S1 : x : Nat -> y : Nat -> __ : Leq (plus x (nd 1)) y -> ex2 Nat (z : Nat => Leq x z) (z : Nat => Eq y (plus z (nd 1))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Op. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $_x_807$ and $_x_808$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "op : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> _x_807 : cic.Term univs.Type0 A -> _x_808 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Snd_eq. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $b$.",
    "output": "snd_eq : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_to_eq. For all natural numbers $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$, for all elements $__$ of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$, for all elements $__1$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, $q$ is equal to $q1$.",
    "output": "div_mod_spec_to_eq : a : Nat -> b : Nat -> q : Nat -> r : Nat -> q1 : Nat -> r1 : Nat -> __ : div_mod_spec a b q r -> __1 : div_mod_spec a b q1 r1 -> Eq q q1 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1290$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1291$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Prod_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ cic.prop) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_rect_Type2_body. For all functions $Q_$ from elements $_x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_true$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_338$.",
    "output": "bool_rect_Type2_body : Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type2) -> _H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false) -> x_338 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type2 (Q_ x_338) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Primes_below. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "primes_below : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_spec_ind_body. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions, for all functions $_H_found_min_spec$ from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all natural numbers $x_1075$, for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.",
    "output": "min_spec_ind_body : _n : Nat -> _b : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_1075 : Nat -> _x_1076 : min_spec _n _b _f x_1075 -> Prop) -> _H_found_min_spec : (m : Nat -> x_1080 : Leq _b m -> x_1079 : Lt m (plus _n _b) -> x_1078 : Eq (_f m) true -> x_1077 : (i : Nat -> __ : Leq _b i -> __1 : Lt i m -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> _H_not_found_min_spec : (x_1081 : (i : Nat -> __ : Leq _b i -> __1 : Lt i (plus _n _b) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> x_1075 : Nat -> x_1076 : min_spec _n _b _f x_1075 -> Q_ x_1075 x_1076 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exists_append_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "Exists_append_r : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l2) -> cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1740$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1741$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Dop_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Null. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Dop$ of $A$ and $nil$, for all elements $a$ of $A$, $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $nil$.",
    "output": "null : A : Set -> nil : A -> xxx : Dop A nil -> a : A -> Eq (prod A nil xxx a nil) nil ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop10. We can prove that $0$ is even.",
    "output": "prop10 : Proof (even 0) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10332. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10332 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Commutative_max. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.max$.",
    "output": "commutative_max : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.max) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Associative_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.associative$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$.",
    "output": "associative_append : A : cic.Univ univs.Type0 -> cic.Term cic.prop (matita_basics_relations.associative (matita_basics_lists_list.list A) (matita_basics_lists_list.append A)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Tri_reflexive. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.tri_relation$ applied to $A$ and $B$ and $C$, $cic.Univ$ holds for $cic.prop$.",
    "output": "tri_reflexive : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_748$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_747$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_750$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_747$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_748$ and $x_747$, for all elements $x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_746$.",
    "output": "list_rect_Type0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type0) -> _H_nil : cic.Term univs.Type0 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_748 : cic.Term univs.Type0 _A -> x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_750 : cic.Term univs.Type0 (Q_ x_747) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.cons _A x_748 x_747))) -> x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type0 (Q_ x_746) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Decidable_or. For all propositions $P$ and $Q$, for all elements $__$ of $decidable$ of $P$, for all elements $__1$ of $decidable$ of $Q$, $decidable$ holds for the disjunction of $P$ and $Q$.",
    "output": "decidable_or : P : Prop -> Q : Prop -> __ : decidable P -> __1 : decidable Q -> decidable (or P Q) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_n_times_nm. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then the greatest common divisor of $n$ and the product of $n$ and $m$ is equal to $n$.",
    "output": "gcd_n_times_nm : n : Nat -> m : Nat -> __ : Lt 0 m -> Eq (gcd n (times n m)) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_104$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_104$, for all elements $x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_103$.",
    "output": "Not_rect_CProp5_body : _A : cic.Univ cic.prop -> Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_104 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> x_103 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_103) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_ind2. For all elements $T1$ and $T2$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T1$, for all elements $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T2$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T2$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $T1$ and $l1$ and $matita_basics_lists_list.length$ applied to $T2$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $T1$ and $matita_basics_lists_list.nil$ applied to $T2$, for all functions $__2$ from elements $tl1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T1$ and elements $tl2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T2$ and elements $hd1$ of $cic.Term$ of $univs.Type0$ and $T1$ and elements $hd2$ of $cic.Term$ of $univs.Type0$ and $T2$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $P$ applied to $tl1$ and $tl2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $T1$ and $hd1$ and $tl1$ and $matita_basics_lists_list.cons$ applied to $T2$ and $hd2$ and $tl2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.",
    "output": "list_ind2 : T1 : cic.Univ univs.Type0 -> T2 : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2) -> P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list T1) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list T2) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length T1 l1) (matita_basics_lists_list.length T2 l2)) -> __1 : cic.Term cic.prop (P (matita_basics_lists_list.nil T1) (matita_basics_lists_list.nil T2)) -> __2 : (tl1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1) -> tl2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2) -> hd1 : cic.Term univs.Type0 T1 -> hd2 : cic.Term univs.Type0 T2 -> __2 : cic.Term cic.prop (P tl1 tl2) -> cic.Term cic.prop (P (matita_basics_lists_list.cons T1 hd1 tl1) (matita_basics_lists_list.cons T2 hd2 tl2))) -> cic.Term cic.prop (P l1 l2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_log_O. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then if $m$ is less than $n$, then the logarithm of $n$ and $m$ is equal to $0$.",
    "output": "lt_to_log_O : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Lt m n -> Eq (log n m) 0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_957$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_957$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_957$.",
    "output": "Dop_rect_CProp4_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_957) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Reverse_append. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.append$ applied to $S$ and $l1$ and $l2$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l2$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l1$.",
    "output": "reverse_append : S : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.append S l1 l2)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l2) (matita_basics_lists_list.reverse S l1))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, for all natural numbers $_x_941$, $bool$.",
    "output": "filter_body : A : Set -> _xxx : range A -> _x_941 : Nat -> bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_861$.",
    "output": "Aop_ind : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_861) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_times_to_le_div2. For all elements $m$ and $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $m$.",
    "output": "le_times_to_le_div2 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.times m q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div n q) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_sqrt. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $matita_arithmetics_sqrt.sqrt$.",
    "output": "monotonic_sqrt : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le matita_arithmetics_sqrt.sqrt) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_exp_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$.",
    "output": "divides_exp_to_divides : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m)) -> cic.Term cic.prop (matita_arithmetics_primes.divides p n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1158$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1159$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "DPair_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1158 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ cic.prop) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1159 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_O_n. For all natural numbers $n$, $n$ is equal to the sum of $0$ and $n$.",
    "output": "plus_O_n : n : Nat -> Eq n (plus 0 n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_diff. For all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $i$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $x$ to $matita_basics_bool.andb$ applied to $matita_basics_bool.notb$ applied to $matita_arithmetics_nat.eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "bigop_diff : p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => p x) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => f x)) (matita_arithmetics_bigops.aop__o__op B nil op (f i) (matita_arithmetics_bigops.bigop n (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.eqb i x)) (p x)) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => f x)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Enum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "enum : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "times_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Foldr. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "foldr : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _b : cic.Term univs.Type0 B -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_Type4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_692$.",
    "output": "Prod_rect_Type4 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type4) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type4 (Q_ x_692) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_n_times_nm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $n$.",
    "output": "gcd_n_times_nm : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_nat.times n m)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $n$ and $n$.",
    "output": "gcd_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n n) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_rect_CProp5_body. For all functions $Q_$ from elements $_x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_511$.",
    "output": "unit_rect_CProp5_body : Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H_it : cic.Term cic.prop (Q_ matita_basics_types.it) -> x_511 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop (Q_ x_511) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_iter. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $b$ and $i$, for all elements $__$ of $monotonic$ of $Nat$ and $Leq$ and $g$, if $a$ is less than or equal to $b$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $i$ and $b$.",
    "output": "monotonic_iter : g : (__ : Nat -> Nat) -> a : Nat -> b : Nat -> i : Nat -> __ : monotonic Nat Leq g -> __1 : Leq a b -> Leq (iter Nat g i a) (iter Nat g i b) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_sum. For all elements $k1$ and $k2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.plus$ applied to $k1$ and $k2$ and the function that maps $i$ to $matita_basics_bool.match_bool$ applied to $univs.Type0$ and the function that maps $__$ to $matita_basics_bool.bool$ and $p1$ applied to $matita_arithmetics_nat.minus$ applied to $i$ and $k2$ and $p2$ applied to $i$ and $matita_arithmetics_nat.leb$ applied to $k2$ and $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $matita_basics_bool.match_bool$ applied to $univs.Type0$ and the function that maps $__$ to $B$ and $f$ applied to $matita_arithmetics_nat.minus$ applied to $i$ and $k2$ and $g$ applied to $i$ and $matita_arithmetics_nat.leb$ applied to $k2$ and $i$.",
    "output": "bigop_sum : k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p1 i) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) (matita_arithmetics_bigops.bigop k2 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p2 i) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.match_bool univs.Type0 (__ : cic.Term univs.Type0 matita_basics_bool.bool => matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.match_bool univs.Type0 (__ : cic.Term univs.Type0 matita_basics_bool.bool => B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_arithmetics_nat.leb k2 i)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1632$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1633$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "range_inv_ind : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1632 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1633 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1194$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1195$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Sig_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ univs.Type1) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_ind_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_943$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_943$.",
    "output": "Dop_ind_body : A : Set -> _nil : A -> Q_ : (_x_943 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_943 : Dop A _nil -> Q_ x_943 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_lstar_r. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all natural numbers $__$, for all elements $__1$ and $__2$ of $B$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_type$ of $z$, for all elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$, $return_type$ holds for $z$.",
    "output": "filter_lstar_r : B : Set -> _R : relation B -> __ : Nat -> __1 : B -> __2 : B -> return_sort : Sort -> return_type : (z : lstar_r B _R __ __1 __2 -> return_sort) -> return : (z : lstar_r B _R __ __1 __2 -> return_type z) -> z : lstar_r B _R __ __1 __2 -> return_type z ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F_min_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of the conjunction of $Leq$ applied to $b$ and $i$ and $Lt$ applied to $i$ and the sum of $n$ and $b$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $min$ applied to $n$ and $b$ and $f$ is equal to $true$.",
    "output": "f_min_true : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : ex Nat (i : Nat => and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true)) -> Eq (f (min n b f)) true ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_inv_rect_CProp1. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z707$ to propositions, for all functions $_H1$ from elements $_z708$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_410$ and functions $_x_412$ from elements $_z708$ of $Eq$ of $Hterm$ and $x_410$ to elements of $P$ of $x_410$ and elements $_z708$ of $Eq$ of $Hterm$ and the sum of $x_410$ and $1$ to elements of $P$ of the sum of $x_410$ and $1$, $P$ holds for $Hterm$.",
    "output": "nat_inv_rect_CProp1 : Hterm : Nat -> P : (_z707 : Nat -> Prop) -> _H1 : (_z708 : Eq Hterm 0 -> P 0) -> _H2 : (x_410 : Nat -> _x_412 : (_z708 : Eq Hterm x_410 -> P x_410) -> _z708 : Eq Hterm (plus x_410 (nd 1)) -> P (plus x_410 (nd 1))) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_rect_CProp2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_909$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_909$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_909$.",
    "output": "ACop_rect_CProp2_body : A : Set -> _nil : A -> Q_ : (_x_909 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_909 : ACop A _nil -> Q_ x_909 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fold_filter. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $p$ applied to $i$ and the function that maps $i$ to $f$ applied to $i$ and $l$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$.",
    "output": "fold_filter : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _a : cic.Term univs.Type0 A -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> nil : cic.Term univs.Type0 B -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => p i) (i : cic.Term univs.Type0 A => f i) l) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) (matita_basics_lists_list.filter A p l))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "gcd_aux_body : _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_pi_p_M1. For all elements $m$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_bigops.bigop$ applied to $i$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_binomial.M$ applied to $m$.",
    "output": "divides_pi_p_M1 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => p)) (matita_arithmetics_binomial.M m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pi1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "pi1 : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f) -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_941$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "filter_body : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_941 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Thm11. For all instances $n$ of natural numbers, we can prove that there exists a natural number $p$, such that $p$ is greater than or equal to $n$ and $p$ is prime.",
    "output": "thm11 : (n : Elem Nat) -> Proof (exists Nat (p => and (Geq p n) (prime p))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_conj$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_132$ and $x_131$, for all elements $x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_130$.",
    "output": "And_rect_Type3 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type3) -> _H_conj : (x_132 : cic.Term cic.prop _A -> x_131 : cic.Term cic.prop _B -> cic.Term univs.Type3 (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) -> x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type3 (Q_ x_130) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1002$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1003$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_552$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_552$, for all functions $_H2$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1003$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_553$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_553$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "Sum_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z1002 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ univs.Type0) -> _H1 : (x_552 : cic.Term univs.Type0 x1 -> _z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_552)) -> cic.Term univs.Type0 (P (matita_basics_types.inl x1 x2 x_552))) -> _H2 : (x_553 : cic.Term univs.Type0 x2 -> _z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_553)) -> cic.Term univs.Type0 (P (matita_basics_types.inr x1 x2 x_553))) -> cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_rect_Type3. For all functions $Q_$ from elements $_x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_485$.",
    "output": "void_rect_Type3 : Q_ : (_x_485 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type3) -> x_485 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type3 (Q_ x_485) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_sqrt_log_n. For all natural numbers $n$ and $b$, if $2$ is less than $b$, then the product of the square root of $n$ and the logarithm of $b$ and $n$ is less than or equal to $n$.",
    "output": "le_sqrt_log_n : n : Nat -> b : Nat -> __ : Lt (nd 2) b -> Leq (times (sqrt n) (log b n)) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $_n$ be a natural number. Then the square root of $_n$ is a natural number.",
    "output": "sqrt : _n : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_discr. For all sets $a1$, for all elements $a2$ of $a1$, for all elements $x$ and $y$ of $Dop$ of $a1$ and $a2$, if $x$ is equal to $y$, then $match_Dop$ holds for $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $match_Dop$ applied to $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $ACop$ applied to $a1$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $ACop$ applied to $a1$ and $a2$ and $t0$ and the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $ACop$ applied to $a1$ and $a2$ and $t0$ and the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x11$ applied to $a$ and $a2$ and $a2$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R3$ applied to $ACop$ applied to $a1$ and $a2$ and $t0$ and the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x11$ applied to $a$ and $a2$ and $a2$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $b$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $c$ to $Eq$ applied to $x11$ applied to $a$ and $aop__o__op$ applied to $a1$ and $a2$ and $x01$ and $b$ and $c$ and $aop__o__op$ applied to $a1$ and $a2$ and $x01$ and $x11$ applied to $a$ and $b$ and $x11$ applied to $a$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z61$ to $P$ and $y$ and $x$.",
    "output": "Dop_discr : a1 : Set -> a2 : a1 -> x : Dop a1 a2 -> y : Dop a1 a2 -> _e : Eq x y -> match_Dop a1 a2 (plus Type2 (nd 1)) (__ : Dop a1 a2 => univ Type2) (t0 : ACop a1 a2 => t1 : (__ : a1 -> __1 : a1 -> a1) => t2 : (a : a1 -> Eq (t1 a a2) a2) => t3 : (a : a1 -> b : a1 -> c : a1 -> Eq (t1 a (aop__o__op a1 a2 t0 b c)) (aop__o__op a1 a2 t0 (t1 a b) (t1 a c))) => match_Dop a1 a2 (plus Type2 (nd 1)) (__ : Dop a1 a2 => univ Type2) (u0 : ACop a1 a2 => u1 : (__ : a1 -> __1 : a1 -> a1) => u2 : (a : a1 -> Eq (u1 a a2) a2) => u3 : (a : a1 -> b : a1 -> c : a1 -> Eq (u1 a (aop__o__op a1 a2 u0 b c)) (aop__o__op a1 a2 u0 (u1 a b) (u1 a c))) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (ACop a1 a2) t0) u0) (e0 : Eq (R0 (ACop a1 a2) t0) u0 => prod Prop Type1 (Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1) (e1 : Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) (e2 : Eq (R2 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 => prod Prop Type1 (Eq (R3 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => p1 : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => x2 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__ : a1 -> __1 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 p1 => __ : Eq (R2 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x01 p01 => __ : Eq (R1 (ACop a1 a2) t0 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x12 a a2) a2)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x11 a a2) a2) => p2 : Eq (R2 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) x02 p02 => __1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => (x00 : ACop a1 a2 => p00 : Eq t0 x00 => x10 : (__2 : a1 -> __3 : a1 -> a1) => p10 : Eq (R1 (ACop a1 a2) t0 (x011 : ACop a1 a2 => p011 : Eq t0 x011 => prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x10 a a2) a2)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x11 a (aop__o__op a1 a2 x01 b c)) (aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : Eq (R3 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => p1 : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => x2 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__ : a1 -> __1 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 p1 => __ : Eq (R2 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x01 p01 => __ : Eq (R1 (ACop a1 a2) t0 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x12 a a2) a2)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x11 a a2) a2) => p2 : Eq (R2 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) x02 p02 => __1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => (x00 : ACop a1 a2 => p00 : Eq t0 x00 => x10 : (__2 : a1 -> __3 : a1 -> a1) => p10 : Eq (R1 (ACop a1 a2) t0 (x011 : ACop a1 a2 => p011 : Eq t0 x011 => prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x10 a a2) a2)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x11 a (aop__o__op a1 a2 x01 b c)) (aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 => P))))) (_z61 : (e0 : Eq (R0 (ACop a1 a2) t0) u0 -> e1 : Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1 -> e2 : Eq (R2 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 -> _e3 : Eq (R3 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => p1 : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => x2 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__ : a1 -> __1 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 p1 => __ : Eq (R2 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x01 p01 => __ : Eq (R1 (ACop a1 a2) t0 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x12 a a2) a2)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x11 a a2) a2) => p2 : Eq (R2 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) x02 p02 => __1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => (x00 : ACop a1 a2 => p00 : Eq t0 x00 => x10 : (__2 : a1 -> __3 : a1 -> a1) => p10 : Eq (R1 (ACop a1 a2) t0 (x011 : ACop a1 a2 => p011 : Eq t0 x011 => prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x10 a a2) a2)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x11 a (aop__o__op a1 a2 x01 b c)) (aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 -> P) => P))) y) x ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_957$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_957$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_957$.",
    "output": "Dop_rect_CProp4_body : A : Set -> _nil : A -> Q_ : (_x_957 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_957 : Dop A _nil -> Q_ x_957 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_mod. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $matita_arithmetics_nat.times$ applied to $c$ and $matita_arithmetics_div_and_mod.mod$ applied to $a$ and $b$.",
    "output": "times_mod : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)) (matita_arithmetics_nat.times c (matita_arithmetics_div_and_mod.mod a b))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_871$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_871$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_871$.",
    "output": "Aop_rect_Type1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type1 (Q_ x_871) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_intro. For all elements $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $m$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $n$ and $m$ and $q$ and $r$.",
    "output": "div_mod_spec_intro : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt r m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_15624. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "let_clause_15624 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_Type5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_947$ of $Dop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_947$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_947$.",
    "output": "Dop_rect_Type5 : A : Set -> _nil : A -> Q_ : (_x_947 : Dop A _nil -> Type5) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_947 : Dop A _nil -> Q_ x_947 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "True_rect_CProp1_body. For all functions $Q_$ from elements $_x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_62$.",
    "output": "True_rect_CProp1_body : Q_ : (_x_62 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_62 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_62) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_smallest_factor_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.",
    "output": "le_smallest_factor_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_primes.smallest_factor n) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_previous_prime5. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_previous_prime5 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_div_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "eq_div_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n m) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_times. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $y$ and $z$ and $matita_arithmetics_nat.times$ applied to $y$ and $matita_arithmetics_nat.times$ applied to $x$ and $z$.",
    "output": "times_times : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times x (matita_arithmetics_nat.times y z)) (matita_arithmetics_nat.times y (matita_arithmetics_nat.times x z))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_mod_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$.",
    "output": "lt_mod_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.mod n m) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list B) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing. For all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "increasing : _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1573. For all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $m$ is divisible by $n$, then for all natural numbers $d$, if $0$ is equal to $m$, then if $n$ is equal to the product of $m$ and $d$, then $n$ is equal to $m$.",
    "output": "let_clause_1573 : n : Nat -> m : Nat -> posn : Lt 0 n -> _clearme : divisible m n -> d : Nat -> auto : Eq 0 m -> auto' : Eq n (times m d) -> Eq n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_795$.",
    "output": "Aop_rect_CProp4_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_795) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1146$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1147$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "DPair_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ cic.prop) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop120. For all instances $a$ and $b$ of integers, we can prove that the product of $a$ and $b$ is even, if and only if $a$ is even or $b$ is even.",
    "output": "prop120 : (a : Elem Int) -> (b : Elem Int) -> Proof (iff (even (times a b)) (or (even a) (even b))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psi_BPsi. For all natural numbers $n$, $Psi$ applied to the product of $2$ and $n$ is less than or equal to the product of $B$ applied to the product of $2$ and $n$ and $Psi$ applied to $n$.",
    "output": "le_Psi_BPsi : n : Nat -> Leq (Psi (times (nd 2) n)) (times (B (times (nd 2) n)) (Psi n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Upto. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "upto : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_16171. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $b$ and $matita_arithmetics_nat.times$ applied to $p$ and $a$.",
    "output": "let_clause_16171 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)) -> H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m b) (matita_arithmetics_nat.times p a))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_to_ord. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if $p$ is prime, then if $n$ is divisible by $m$, then $ord_rem$ applied to $n$ and $p$ is divisible by $ord_rem$ applied to $m$ and $p$ and $ord$ applied to $n$ and $p$ is less than or equal to $ord$ applied to $m$ and $p$.",
    "output": "divides_to_ord : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> and (divisible (ord_rem n p) (ord_rem m p)) (Leq (ord n p) (ord m p)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_times_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the product of $n$ and $m$, then $p$ is divisible by $n$ or $p$ is divisible by $m$.",
    "output": "divides_times_to_divides : p : Nat -> n : Nat -> m : Nat -> __ : prime p -> __1 : divisible p (times n m) -> or (divisible p n) (divisible p m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_861$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_861$.",
    "output": "Aop_ind : A : Set -> _nil : A -> Q_ : (_x_861 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_861 : Aop A _nil -> Q_ x_861 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nth. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "nth : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H : cic.Univ univs.Type0 -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __2 : cic.Term univs.Type0 H -> cic.Term univs.Type0 H ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_singlevalued. For all sets $B$, for all elements $R$ of $relation2$ of $B$ and $B$, for all elements $__$ of $singlevalued$ of $B$ and $B$ and $R$, for all natural numbers $l$, $singlevalued$ holds for $B$ and $B$ and $lstar$ applied to $B$ and $R$ and $l$.",
    "output": "lstar_singlevalued : B : Set -> R : relation2 B B -> __ : singlevalued B B R -> l : Nat -> singlevalued B B (lstar B R l) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_O_f. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $matita_arithmetics_nat.O$ and $b$ and $f$ and $b$.",
    "output": "min_O_f : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min matita_arithmetics_nat.O b f) b) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_I. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.O$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "bigop_I : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus n matita_arithmetics_nat.O) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O)) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_865$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_865$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_865$.",
    "output": "Aop_rect_Type5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type5) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type5 (Q_ x_865) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iff_and_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.And$ applied to $C$ and $A$ and $matita_basics_logic.And$ applied to $C$ and $B$.",
    "output": "iff_and_l : A : cic.Univ cic.prop -> B : cic.Univ cic.prop -> C : cic.Univ cic.prop -> __ : cic.Term cic.prop (matita_basics_logic.iff A B) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.And C A) (matita_basics_logic.And C B)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_mod. For all natural numbers $p$ and $a$, if $p$ is prime, then if $p$ is not divisible by $a$, then $permut$ holds for the function that maps $n$ to $mod$ applied to the product of $a$ and $n$ and $p$ and $pred$ applied to $p$.",
    "output": "permut_mod : p : Nat -> a : Nat -> __ : prime p -> __1 : not (divisible p a) -> permut (n : Nat => mod (times a n) p) (pred p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_inv_rect_Type1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $Dop$ of $x1$ and $x2$ to elements of $Type1$, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "Dop_inv_rect_Type1 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1722 : Dop x1 x2 -> Type1) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1723 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_n_nth_prime_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.",
    "output": "lt_n_nth_prime_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.nth_prime n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Compose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $_l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $C$.",
    "output": "compose : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> _l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _l2 : cic.Term univs.Type0 (matita_basics_lists_list.list B) -> cic.Term univs.Type0 (matita_basics_lists_list.list C) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_previous_prime2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_previous_prime2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fmax_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $max$ applied to $n$ and $f$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then $m$ is equal to $0$.",
    "output": "fmax_false : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Eq (max n f) m -> __1 : Eq (f m) false -> Eq m 0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_Type0. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.",
    "output": "Prod_rect_Type0 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type0) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type0 (Q_ x_702) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_rect_Type2. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_740$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_738$ and $x_737$, for all elements $x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_736$.",
    "output": "list_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type2) -> _H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_738 : cic.Term univs.Type0 _A -> x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_740 : cic.Term univs.Type2 (Q_ x_737) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type2 (Q_ x_736) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pi_p_primeb. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.",
    "output": "pi_p_primeb : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_inv_rect_CProp0. For all sets $x1$, for all elements $Hterm$ of $range$ of $x1$, for all functions $P$ from elements $_z1692$ of $range$ of $x1$ to propositions, for all functions $_H1$ from functions $_enum$ from natural numbers to elements of $x1$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans and elements $_z1693$ of $Eq$ of $Hterm$ and $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $P$ of $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $P$ holds for $Hterm$.",
    "output": "range_inv_rect_CProp0 : x1 : Set -> Hterm : range x1 -> P : (_z1692 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1693 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_div_mod. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then $div_mod_spec$ holds for $n$ and $m$ and the quotient of $n$ and $m$ and $mod$ applied to $n$ and $m$.",
    "output": "div_mod_spec_div_mod : n : Nat -> m : Nat -> __ : Lt 0 m -> div_mod_spec n m (div n m) (mod n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Length_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "length_body : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp1_body. For all sets $_A$, for all functions $Q_$ from elements $_x_937$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $range$ of $_A$, $Q_$ holds for $x_937$.",
    "output": "range_rect_CProp1_body : _A : Set -> Q_ : (_x_937 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_937 : range _A -> Q_ x_937 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z689$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_396$ from elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_394$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_394$ and elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "nat_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z689 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> _H2 : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_396 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_394) -> cic.Term cic.prop (P x_394)) -> _z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_394)) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_394))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1044$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z1045$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_591$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1045$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_591$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_591$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "option_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ univs.Type4) -> _H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> _H2 : (x_591 : cic.Term univs.Type0 x1 -> _z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591)) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_O_to_eq_O. For all functions $h$ from natural numbers to natural numbers, for all elements $__$ of $permut$ of $h$ and $0$, $h$ applied to $0$ is equal to $0$.",
    "output": "permut_O_to_eq_O : h : (__ : Nat -> Nat) -> __ : permut h 0 -> Eq (h 0) 0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_rect_Type3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.",
    "output": "option_rect_Type3_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type3) -> _H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_599 : cic.Term univs.Type0 _A -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> x_598 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type3 (Q_ x_598) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_Type0_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_833$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_div_mod_spec_intro$ from elements $x_835$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_834$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_835$ and $x_834$, for all elements $x_833$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_833$.",
    "output": "div_mod_spec_rect_Type0_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_833 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type0) -> _H_div_mod_spec_intro : (x_835 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_834 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_835 x_834))) -> x_833 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type0 (Q_ x_833) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_inv_ind. For all sets $x1$, for all elements $Hterm$ of $range$ of $x1$, for all functions $P$ from elements $_z1632$ of $range$ of $x1$ to propositions, for all functions $_H1$ from functions $_enum$ from natural numbers to elements of $x1$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans and elements $_z1633$ of $Eq$ of $Hterm$ and $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $P$ of $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $P$ holds for $Hterm$.",
    "output": "range_inv_ind : x1 : Set -> Hterm : range x1 -> P : (_z1632 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1633 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $n$ is equal to the sum of $m$ and $p$, then the difference of $n$ and $m$ is equal to $p$.",
    "output": "plus_to_minus : n : Nat -> m : Nat -> p : Nat -> __ : Eq n (plus m p) -> Eq (minus n m) p ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psil. For all natural numbers $n$, $Psi$ applied to $n$ is less than or equal to the exponentiation of $n$ and $prim$ applied to $n$.",
    "output": "le_Psil : n : Nat -> Leq (Psi n) (pow n (prim n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "ACop_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type2) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bceq. For all elements $n$ and $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $k$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_factorial.fact$ applied to $k$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $k$.",
    "output": "bceq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n k) (matita_arithmetics_div_and_mod.div (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact k) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_log2_sqrt. For all natural numbers $n$, if the exponentiation of $2$ and $6$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than the square root of $n$.",
    "output": "lt_log2_sqrt : n : Nat -> __ : Leq (pow (nd 2) (nd 6)) n -> Lt (log (nd 2) n) (sqrt n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_n_O. For all natural numbers $n$, if $0$ is less than $n$, then the exponentiation of $0$ and $n$ is equal to $0$.",
    "output": "exp_n_O : n : Nat -> __ : Lt 0 n -> Eq (pow 0 n) 0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Absurdity is an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "false : cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1758$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1759$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "Dop_inv_rect_CProp0 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1758 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1759 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Example4. $primeb$ applied to $3$ is equal to $true$.",
    "output": "example4 : Eq (primeb (nd 3)) true ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sub_hk. For all functions $__$ from natural numbers to natural numbers, for all functions $__1$ from natural numbers $__1$ to natural numbers, for all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "sub_hk : __ : (__ : Nat -> Nat) -> __1 : (__1 : Nat -> Nat) -> A : Set -> relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound3. For all elements $n$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_upper_bound3 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_S_times_2. For all natural numbers $n$, if $0$ is less than $n$, then the sum of $n$ and $1$ is less than or equal to the product of $2$ and $n$.",
    "output": "le_S_times_2 : n : Nat -> __ : Lt 0 n -> Leq (plus n (nd 1)) (times (nd 2) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Assoc_plus1. For all natural numbers $a$ and $b$ and $c$, the sum of $c$ and the sum of $b$ and $a$ is equal to the sum of the sum of $b$ and $c$ and $a$.",
    "output": "assoc_plus1 : a : Nat -> b : Nat -> c : Nat -> Eq (plus c (plus b a)) (plus (plus b c) a) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_inv_rect_CProp2. For all sets $x1$, for all elements $Hterm$ of $range$ of $x1$, for all functions $P$ from elements $_z1680$ of $range$ of $x1$ to propositions, for all functions $_H1$ from functions $_enum$ from natural numbers to elements of $x1$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans and elements $_z1681$ of $Eq$ of $Hterm$ and $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $P$ of $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $P$ holds for $Hterm$.",
    "output": "range_inv_rect_CProp2 : x1 : Set -> Hterm : range x1 -> P : (_z1680 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1681 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Commutative_min. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.min$.",
    "output": "commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_minus_S_pred. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "eq_minus_S_pred : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_spec_ind_body. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_971$ and elements $_x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$ to propositions, for all functions $_H_found_max_spec$ from natural numbers $m$ and elements $x_975$ of $Lt$ of $m$ and $_n$ and elements $x_974$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all natural numbers $x_971$, for all elements $x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$, $Q_$ holds for $x_971$ and $x_972$.",
    "output": "max_spec_ind_body : _n : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_971 : Nat -> _x_972 : max_spec _n _f x_971 -> Prop) -> _H_found_max_spec : (m : Nat -> x_975 : Lt m _n -> x_974 : Eq (_f m) true -> x_973 : (i : Nat -> __ : Lt m i -> __1 : Lt i _n -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> _H_not_found_max_spec : (x_976 : (i : Nat -> __ : Lt i _n -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> x_971 : Nat -> x_972 : max_spec _n _f x_971 -> Q_ x_971 x_972 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_lt_times_r. For all natural numbers $c$, if $0$ is less than $c$, then $monotonic$ holds for $Nat$ and $Lt$ and the function that maps $t$ to the product of $c$ and $t$.",
    "output": "monotonic_lt_times_r : c : Nat -> __ : Lt 0 c -> monotonic Nat Lt (t : Nat => times c t) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Leb_elim. For all natural numbers $n$ and $m$, for all functions $P$ from booleans to propositions, for all functions $__$ from elements of $Leq$ of $n$ and $m$ to elements of $P$ of $true$, for all functions $__1$ from elements $__1$ of $not$ of $Leq$ applied to $n$ and $m$ to elements of $P$ of absurdity, $P$ holds for $leb$ applied to $n$ and $m$.",
    "output": "leb_elim : n : Nat -> m : Nat -> P : (__ : bool -> Prop) -> __ : (__ : Leq n m -> P true) -> __1 : (__1 : not (Leq n m) -> P false) -> P (leb n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime, then if $0$ is less than $m$, then if $n$ is divisible by $m$, then $ord_rem$ applied to $m$ and $n$ is less than $m$.",
    "output": "lt_ord_rem : n : Nat -> m : Nat -> __ : prime n -> __1 : Lt 0 m -> __2 : divisible n m -> Lt (ord_rem m n) m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_662$.",
    "output": "DPair_rect_CProp0 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_662) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_length_to_not_mem. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__1$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.Not$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $i$ and $l$.",
    "output": "lt_length_to_not_mem : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l) -> __1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.Not (matita_basics_lists_list.mem matita_arithmetics_nat.nat i l)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ComplEmpty. We can prove that the complement of the empty set is equal to the universal set.",
    "output": "complEmpty : Proof (equalset (complement emptyset) universeset) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pi2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $f$, $cic.Term$ holds for $cic.prop$ and $f$ applied to $matita_basics_types.pi1$ applied to $A$ and $f$ and $xxx$.",
    "output": "pi2_body : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f) -> cic.Term cic.prop (f (matita_basics_types.pi1 A f xxx)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_inv_rect_CProp4. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z359$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z360$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_148$ and $x_147$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_148$ and $x_147$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "And_inv_rect_CProp4 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_148 : cic.Term cic.prop x1 -> x_147 : cic.Term cic.prop x2 -> _z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_or_gt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "eq_or_gt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Fact_pi_p3. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "fact_pi_p3 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log_exp1. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "log_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)) (matita_arithmetics_nat.times m (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_678$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_678$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_678$.",
    "output": "Sig_rect_CProp4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_678) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp0. For all sets $_A$, for all functions $Q_$ from elements $_x_939$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $range$ of $_A$, $Q_$ holds for $x_939$.",
    "output": "range_rect_CProp0 : _A : Set -> Q_ : (_x_939 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_939 : range _A -> Q_ x_939 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exists_forall_lt. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$.",
    "output": "exists_forall_lt : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_919$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_919$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_919$.",
    "output": "range_rect_Type5_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type5) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type5 (Q_ x_919) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp4. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_839$ of $Lt$ of $_r$ and $_m$ and elements $x_838$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_839$ and $x_838$, for all elements $x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_837$.",
    "output": "div_mod_spec_rect_CProp4 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_837 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_839 : Lt _r _m -> x_838 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> x_837 : div_mod_spec _n _m _q _r -> Q_ x_837 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z966$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z967$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_CProp0 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z966 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z967 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_le_plus_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $m$ to the sum of $n$ and $m$.",
    "output": "monotonic_le_plus_r : n : Nat -> monotonic Nat Leq (m : Nat => plus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Cons_injective_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a1$ and $a2$.",
    "output": "cons_injective_l : A : cic.Univ univs.Type0 -> a1 : cic.Term univs.Type0 A -> a2 : cic.Term univs.Type0 A -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Not : _A : cic.Univ cic.prop -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "EqProp. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all elements $_x$ and $__$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "eqProp : A : cic.Univ cic.prop -> _x : cic.Term cic.prop A -> __ : cic.Term cic.prop A -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Vectors are a basic type.",
    "output": "Vector : Set ."
  }
]