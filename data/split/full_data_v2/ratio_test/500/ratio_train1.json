[
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_aux_to_exp. For all elements $p$ and $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $q$ and $r$.",
    "output": "postulate p_ord_aux_to_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m q) r))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_sqrt_nl. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $m$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_73. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then for all natural numbers $x134$ and $x135$ and $x136$, the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp0_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_885$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_885$.",
    "output": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $Lt$ of $_r$ and $_m$ and elements $x_814$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_813$.",
    "output": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_times_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ and $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, for all functions $P$ from elements $x0$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x0$ and $a$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $__$ of $cic.Term$ of $univs.Type3$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $x$ and $p$.",
    "output": "postulate eq_rect_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> (P : (x0 : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x0 a)) -> cic.Univ univs.Type3) -> (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) -> cic.Term univs.Type3 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type0_body. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "postulate nat_rect_Type0_body : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_mem_nat. For all natural numbers $n$, for all lists $l$ of natural numbers, $decidable$ holds for $mem$ applied to $Nat$ and $n$ and $l$.",
    "output": "postulate decidable_mem_nat : (n : Nat) -> (l : list Nat) -> decidable (mem Nat n l)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z161$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_965$.",
    "output": "postulate Dop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_965)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_nth. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $matita_basics_lists_list.nth_opt$ applied to $A$ and $n$ and $l$ and $matita_basics_types.Some$ applied to $A$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate All_nth : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a))) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_sqrt. $monotonic$ holds for $Nat$ and $Leq$ and $sqrt$.",
    "output": "postulate monotonic_sqrt : monotonic Nat Leq sqrt"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z647$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z647 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive_times_minus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.minus$.",
    "output": "postulate distributive_times_minus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.minus)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "To_max. For all natural numbers $i$ and $n$ and $m$, if $n$ is less than or equal to $i$, then if $m$ is less than or equal to $i$, then $max$ applied to $n$ and $m$ is less than or equal to $i$.",
    "output": "postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_ind_body. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1336$ and $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "postulate lstar_r_ind_body : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop) -> (_H_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (_H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))) -> (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_plus_l. For all natural numbers $m$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $n$ to the sum of $n$ and $m$.",
    "output": "postulate monotonic_le_plus_l : (m : Nat) -> monotonic Nat Leq (\\ n : Nat -> plus n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from natural numbers to natural numbers, for all sets $A$, for all elements $I$ and $J$ and $K$ of $range$ of $A$, for all elements $__$ of $sub_hk$ of $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $sub_hk$ of $h2$ and $k2$ and $A$ and $J$ and $K$, $sub_hk$ holds for the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "postulate transitive_sub : (h1 : (_ : Nat) -> Nat) -> (k1 : (_ : Nat) -> Nat) -> (h2 : (_ : Nat) -> Nat) -> (k2 : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (K : range A) -> (_ : sub_hk h1 k1 A I J) -> (__1 : sub_hk h2 k2 A J K) -> sub_hk (\\ x : Nat -> h2 (h1 x)) (\\ x : Nat -> k1 (k2 x)) A I K"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_pi_l. For all natural numbers $n$ and $a$, for all functions $f$ from natural numbers to natural numbers, the product of the exponentiation of $a$ and $n$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of $a$ and $f$ applied to $i$.",
    "output": "postulate exp_pi_l : (n : Nat) -> (a : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (times (pow a n) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> f i))) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> times a (f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable. For all elements $__$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate decidable : (__ : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.plus$ applied to $c$ and $b$.",
    "output": "postulate lt_minus_to_plus : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus c b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_ACop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $b$ and $a$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.",
    "output": "postulate mk_ACop : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil aop a b) (matita_arithmetics_bigops.op A nil aop b a))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_hk. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max'. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all natural numbers $__2$, $Nat$.",
    "output": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "postulate lt_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iff_sym. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $A$.",
    "output": "postulate iff_sym : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff B A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_assoc_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R1$ and $R2$ and $R3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R3$ and $matita_basics_relations.Rcomp$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R2$ and $R3$.",
    "output": "postulate sub_assoc_l : (A : cic.Univ univs.Type0) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R3 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "postulate transpose : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_times_n_to_lt_r. For all natural numbers $n$ and $p$ and $q$, if the product of $n$ and $p$ is less than the product of $n$ and $q$, then $p$ is less than $q$.",
    "output": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_primes. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate all_primes : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.",
    "output": "postulate ACop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B2. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate andb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_O_f. For all functions $f$ from natural numbers to booleans, for all natural numbers $b$, $min$ applied to $0$ and $b$ and $f$ is equal to $b$.",
    "output": "postulate min_O_f : (f : (_ : Nat) -> bool) -> (b : Nat) -> Eq (min 0 b f) b"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp4. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "postulate False_rect_CProp4 : (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_73)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_smallest_factor_n. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is prime.",
    "output": "postulate prime_smallest_factor_n : (n : Nat) -> (_ : Lt 1 n) -> prime (smallest_factor n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.",
    "output": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "postulate DPair_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_943$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_943$.",
    "output": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1278$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1279$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp5. For all functions $Q_$ from elements $_x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_74$.",
    "output": "postulate False_rect_CProp5 : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "postulate True_rect_Type4 : (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) -> (x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type4 (Q_ x_42)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ComplIntersection. For all sets $A$, we can prove that the intersection of $A$ and the complement of $A$ is equal to the empty set.",
    "output": "postulate complIntersection : (A : Set) -> equalset (intersection A (complement A)) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.",
    "output": "postulate commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z2006$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.times$ applied to $x1$ and $q$ and elements $_z2007$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate divides_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> (P : (_z2006 : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.times x1 q))) -> (_z2007 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_primes.divides x1 x2)) Hterm (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_793$.",
    "output": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example2. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$.",
    "output": "postulate lt_div_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m)) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.",
    "output": "postulate list_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_times_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Leq$ and the function that maps $m$ to the product of $n$ and $m$.",
    "output": "postulate monotonic_le_times_r : (n : Nat) -> monotonic Nat Leq (\\ m : Nat -> times n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_O_to_divides. For all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $mod$ applied to $m$ and $n$ is equal to $0$, then $n$ is divisible by $m$.",
    "output": "postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_953$ of $Dop$ of $A$ and $_nil$ to elements of $Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "S_mod. For all natural numbers $_n$ and $_m$, $Nat$.",
    "output": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_div. For all natural numbers $a$ and $b$ and $c$, if $0$ is less than $b$, then if $c$ is divisible by $b$, then the product of $a$ and the quotient of $b$ and $c$ is equal to the quotient of the product of $a$ and $b$ and $c$.",
    "output": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "postulate bigop : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10331. For all elements $p$ and $n$ and $n1$ and $q$ and $p1$ and $p2$ and $qa$ and $ra$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $p2$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S (matita_arithmetics_nat.S p2))) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nilr. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $a$.",
    "output": "postulate nilr : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx a nil) a"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Univ. For all elements $s$ of $Sort$, $Univ$ holds for $succ$ applied to $s$.",
    "output": "postulate univ : (s : Sort) -> Univ (succ s)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_times. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then the logarithm of $p$ and the product of $n$ and $m$ is less than or equal to the sum of the sum of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$ and $1$.",
    "output": "postulate log_times : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_aux_body. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_ind. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z257$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z258$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_80$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_80$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_ind : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_80 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z258 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_CProp3_body. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "postulate True_rect_CProp3_body : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "LePsi_prim. For all natural numbers $n$, the exponentiation of $n$ and $prim$ applied to $n$ is less than or equal to the product of $Psi$ applied to $n$ and $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$.",
    "output": "postulate lePsi_prim : (n : Nat) -> Leq (pow n (prim n)) (times (Psi n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sym_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$.",
    "output": "postulate sym_eq : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (y : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term cic.prop (matita_basics_logic.eq A y x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1573. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate let_clause_1573 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_O_to_not_divides. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate ord_O_to_not_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate monotonic : (A : cic.Univ univs.Type0) -> (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_ltl. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$ and $n$.",
    "output": "postulate length_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.ltl A l n)) (matita_arithmetics_nat.minus (matita_basics_lists_list.length A l) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_to_gcd_aux. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $n$ is not divisible by $m$, then $gcd_aux$ applied to the sum of $p$ and $1$ and $m$ and $n$ is equal to $gcd_aux$ applied to $p$ and $n$ and $mod$ applied to $m$ and $n$.",
    "output": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_m. For all natural numbers $m$ and $n$, if $m$ is less than or equal to $n$, then the difference of the sum of $n$ and $1$ and $m$ is equal to the sum of the difference of $n$ and $m$ and $1$.",
    "output": "postulate minus_Sn_m : (m : Nat) -> (n : Nat) -> (_ : Leq m n) -> Eq (minus (plus n 1) m) (plus (minus n m) 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_791$.",
    "output": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_rect_Type3. For all functions $Q_$ from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_true$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.",
    "output": "postulate bool_rect_Type3 : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2 : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_30. For all instances $x$ of integers, we can prove that if the difference of the product of $5$ and $x$ and $7$ is odd, then the sum of the product of $9$ and $x$ and $2$ is even.",
    "output": "postulate noLabel_30 : (x : Int) -> if (odd (minus (times 5 x) 7)) (even (plus (times 9 x) 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type3. For all functions $Q_$ from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.",
    "output": "postulate True_rect_Type3 : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "None. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_ind_body. For all functions $Q_$ from elements $_x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_495$.",
    "output": "postulate unit_ind_body : (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_495)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate prod_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (_x_969 : cic.Term univs.Type0 A) -> (_x_970 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_mod_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate divides_mod_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_p_ord_inv. For all natural numbers $p$ and $m$ and $x$, if $ord$ applied to $x$ and $p$ is less than $m$, then the quotient of $p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ is equal to $ord_rem$ applied to $x$ and $p$.",
    "output": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_x_times_x. For all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.",
    "output": "postulate le_x_times_x : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_congruent. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and the function that maps $n$ and $m$ to $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate transitive_congruent : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_congruence.congruent n m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Hint_declaration_CProp1. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all elements $_a$ and $_b$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate hint_declaration_CProp1 : (A : cic.Univ cic.prop) -> (_a : cic.Term cic.prop A) -> (_b : cic.Term cic.prop A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc1. For all natural numbers $n$ and $k$, if $k$ is less than $n$, then $bc$ applied to the sum of $n$ and $1$ and the sum of $k$ and $1$ is equal to the sum of $bc$ applied to $n$ and $k$ and $bc$ applied to $n$ and the sum of $k$ and $1$.",
    "output": "postulate bc1 : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (bc (plus n 1) (plus k 1)) (plus (bc n k) (bc n (plus k 1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Confluent. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.",
    "output": "postulate confluent : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type5_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.",
    "output": "postulate div_mod_spec_rect_Type5_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_exp_log. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "postulate lt_exp_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_log.log p n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_pi. For all natural numbers $n$ and $m$, for all functions $p$ from natural numbers to booleans, for all functions $f$ from natural numbers to natural numbers, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $f$ applied to $i$ and $m$ is equal to the exponentiation of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ and $m$.",
    "output": "postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> pow (f i) m)) (pow (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> f i)) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_921$.",
    "output": "postulate range_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type3 (Q_ x_921)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_4_to_le_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate lt_4_to_le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_pi. For all natural numbers $n$, for all functions $p$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_to_times. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $q$ and $m$.",
    "output": "postulate lt_div_to_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times q m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_CProp2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_935$.",
    "output": "postulate range_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_935)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Increasing_to_monotonic. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and $f$.",
    "output": "postulate increasing_to_monotonic : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt f)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_875$.",
    "output": "postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_875)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $ACop$ of $A$ and $nil$, $Aop$ holds for $A$ and $nil$.",
    "output": "postulate aop : (A : Set) -> (nil : A) -> (_xxx : ACop A nil) -> Aop A nil"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_lstar_r. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from natural numbers and elements $__1$ of $B$ and elements $__2$ of $B$ and elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_sort$, for all functions $case_lstar_r_O$ from elements $b$ of $B$ to elements of $return_type$ of $0$ and $b$ and $b$ and $lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_r_S$ from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements of $lstar_r$ of $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $B$ and elements $__1$ of $_R$ of $b$ and $b2$ to elements of $return_type$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $__$ and $b2$ and $__1$, for all natural numbers $__$, for all elements $__1$ and $__2$ of $B$, for all elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$, $return_type$ holds for $__$ and $__1$ and $__2$ and $z$.",
    "output": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1056$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_603$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_603$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_603$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate option_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1056 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type2) -> (_H1 : (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type2 (P (matita_basics_types.None x1))) -> (_H2 : (x_603 : cic.Term univs.Type0 x1) -> (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_925$.",
    "output": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_ltransitive. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.ltransitive$ applied to $B$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$.",
    "output": "postulate lstar_ltransitive : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> cic.Term cic.prop (matita_arithmetics_lstar.ltransitive B (matita_arithmetics_lstar.lstar B R))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_ind_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_720$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_717$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_718$ and $x_717$, for all elements $x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_716$.",
    "output": "postulate list_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_718 : cic.Term univs.Type0 _A) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_720 : cic.Term cic.prop (Q_ x_717)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> (x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_716)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Permut_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $permut$ of $f$ and $n$, $permut$ holds for $invert_permut$ applied to $n$ and $f$ and $n$.",
    "output": "postulate permut_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> permut (invert_permut n f) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_sigma. For all elements $n$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $a$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate exp_sigma : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) -> (divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1))) -> (eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_inv_step. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $b1$ and $b2$.",
    "output": "postulate lstar_inv_step : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) -> cic.Term cic.prop (R b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10335. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10335 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_CProp1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1488$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1489$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_to_p_ord_O. For all natural numbers $n$ and $i$, if $nth_prime$ applied to $i$ is not divisible by $n$, then $p_ord$ applied to $n$ and $nth_prime$ applied to $i$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $0$ and $n$.",
    "output": "postulate not_divides_to_p_ord_O : (n : Nat) -> (i : Nat) -> (_ : not (divisible (nth_prime i) n)) -> Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_664$.",
    "output": "postulate Sig_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_664)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_lt_minus_l. For all natural numbers $p$ and $q$ and $n$, if $n$ is less than or equal to $q$, then if $q$ is less than $p$, then the difference of $q$ and $n$ is less than the difference of $p$ and $n$.",
    "output": "postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq n q) -> (__1 : Lt q p) -> Lt (minus q n) (minus p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_not_bertrand_to_bertrand1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $x$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $__3$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $p$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $x$ and $matita_arithmetics_primes.prime$ applied to $p$.",
    "output": "postulate not_not_bertrand_to_bertrand1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n))) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n x)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> (__3 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt x p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime p))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_nat.le p x)) (matita_arithmetics_primes.prime p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_Bk_B1_B2. For all natural numbers $n$, $Bk$ applied to $n$ is equal to the product of $B1$ applied to $n$ and $B2$ applied to $n$.",
    "output": "postulate eq_Bk_B1_B2 : (n : Nat) -> Eq (Bk n) (times (B1 n) (B2 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "AssocIntersection. For all sets $A$, $B$ and $C$, we can prove that the intersection of the intersection of $A$ and $B$ and $C$ is equal to the intersection of $A$ and the intersection of $B$ and $C$.",
    "output": "postulate assocIntersection : (A : Set) -> (B : Set) -> (C : Set) -> equalset (intersection (intersection A B) C) (intersection A (intersection B C))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1236$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1237$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.",
    "output": "postulate DPair_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_652)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fst. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate fst : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_cases. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $f$ applied to $n$ is equal to $true$ and $max$ applied to the sum of $n$ and $1$ and $f$ is equal to $n$ or $f$ applied to $n$ is equal to absurdity and $max$ applied to the sum of $n$ and $1$ and $f$ is equal to $max$ applied to $n$ and $f$.",
    "output": "postulate max_cases : (f : (_ : Nat) -> bool) -> (n : Nat) -> or (and (Eq (f n) true) (Eq (max (plus n 1) f) n)) (and (Eq (f n) false) (Eq (max (plus n 1) f) (max n f)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $x$ and $y$ be instances of natural numbers. Then the Legendre symbol of $x$ and $y$ is an instance of integers.",
    "output": "postulate legendre : Nat -> Nat -> Int"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_to_eqb_true. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$.",
    "output": "postulate eq_to_eqb_true : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the exponentiation of $n$ and $m$, then $p$ is divisible by $n$.",
    "output": "postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type4. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1440$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to elements of $Type4$, for all functions $_H1$ from elements $x_815$ of $Lt$ of $x4$ and $x2$ and elements $x_814$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1441$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$, $P$ holds for $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type4 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1440 : div_mod_spec x1 x2 x3 x4) -> Type4) -> (_H1 : (x_815 : Lt x4 x2) -> (x_814 : Eq x1 (plus (times x3 x2) x4)) -> (_z1441 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Tri_relation. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate tri_relation : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> (__2 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_rect_CProp1_body. For all functions $Q_$ from elements $_x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_493$.",
    "output": "postulate void_rect_CProp1_body : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_ind_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_809$.",
    "output": "postulate div_mod_spec_ind_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1410$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1411$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1410 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1411 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp2_body. For all functions $Q_$ from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.",
    "output": "postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_n_n. For all natural numbers $n$, if $0$ is less than $n$, then $mod$ applied to $n$ and $n$ is equal to $0$.",
    "output": "postulate mod_n_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (mod n n) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_n. For all natural numbers $n$, $1$ is equal to the difference of the sum of $n$ and $1$ and $n$.",
    "output": "postulate minus_Sn_n : (n : Nat) -> Eq 1 (minus (plus n 1) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate fact : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate append : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B1. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate B1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_found_max_spec. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $n$ and $f$ and $matita_arithmetics_nat.O$.",
    "output": "postulate not_found_max_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Type3. $cic.Sort$.",
    "output": "postulate Type3 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_to_le. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_exp.exp$ applied to $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_exp_to_le : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_ind_l. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b2$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b1$.",
    "output": "postulate lstar_ind_l : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate div_mod_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "R1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "postulate R1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Is_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate is_nil : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_div_mod_spec. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $m$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_lt_to_lt. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$.",
    "output": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ and $_m$ and $_p$ be natural numbers. Then $congruent$ applied to $_n$ and $_m$ and $_p$ is a proposition.",
    "output": "postulate congruent : (_n : Nat) -> (_m : Nat) -> (_p : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1648. For all natural numbers $n$ and $q$, if $0$ is less than $q$, then for all natural numbers $n1$, if $n1$ is equal to the sum of the product of $bigop$ applied to the sum of $n1$ and $1$ and the function that maps $m$ to $andb$ applied to $leb$ applied to $1$ and $m$ and $dividesb$ applied to $q$ and $m$ and $Nat$ and $0$ and $plus$ and the function that maps $m$ to $1$ and $q$ and $mod$ applied to $n1$ and $q$, then if $q$ is divisible by the sum of $n1$ and $1$ and the sum of $n1$ and $1$ is equal to the product of the sum of the quotient of $n1$ and $q$ and $1$ and $q$, then if $q$ is divisible by the sum of $n1$ and $1$, then if the sum of $n1$ and $1$ is equal to the product of the sum of the quotient of $n1$ and $q$ and $1$ and $q$, then the sum of $n1$ and $1$ is equal to the sum of $q$ and the product of $q$ and the quotient of $n1$ and $q$.",
    "output": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "postulate div_mod_spec_rect_Type1_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) -> (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type1 (Q_ x_829)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_minus_to_plus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $c$ and $b$.",
    "output": "postulate lt_minus_to_plus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus b c))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a c) b)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_theta_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "postulate div_theta_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NatD. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$.",
    "output": "postulate natD : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop matita_arithmetics_nat.nat matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than $m$, then $n$ is less than $m$.",
    "output": "postulate lt_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) m) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15622. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.",
    "output": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Checker_ab. For all natural numbers $a$ and $b$, for all lists $l$ of natural numbers, $checker$ applied to $cons$ applied to $Nat$ and $a$ and $cons$ applied to $Nat$ and $b$ and $l$ is equal to $andb$ applied to $andb$ applied to $leb$ applied to the sum of $a$ and $1$ and $b$ and $leb$ applied to $b$ and the product of $2$ and $a$ and $checker$ applied to $cons$ applied to $Nat$ and $b$ and $l$.",
    "output": "postulate checker_ab : (a : Nat) -> (b : Nat) -> (l : list Nat) -> Eq (checker (cons Nat a (cons Nat b l))) (andb (andb (leb (plus a 1) b) (leb b (times 2 a))) (checker (cons Nat b l)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Start_lprim. For all natural numbers $n$ and $m$ and $a$, for all lists $acc$ of natural numbers, $option_hd$ applied to $Nat$ and $lprim$ applied to $n$ and $m$ and $cons$ applied to $Nat$ and $a$ and $acc$ is equal to $Some$ applied to $Nat$ and $a$.",
    "output": "postulate start_lprim : (n : Nat) -> (m : Nat) -> (a : Nat) -> (acc : list Nat) -> Eq (option_hd Nat (lprim n m (cons Nat a acc))) (Some Nat a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_not_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "postulate lt_to_not_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injective_to_injn. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "postulate injective_to_injn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "It. $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.unit$.",
    "output": "postulate it : cic.Term univs.Type0 matita_basics_types.unit"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_951$.",
    "output": "postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate max : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z724$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x1$, for all functions $_H2$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x1$ and $m$ and functions $_x_421$ from elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$ and elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x2$.",
    "output": "postulate le_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_nat.le x1 x2)) -> (P : (_z724 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 x1)) -> cic.Term cic.prop (P x1)) -> (_H2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_419 : cic.Term cic.prop (matita_arithmetics_nat.le x1 m)) -> (_x_421 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 m)) -> cic.Term cic.prop (P m)) -> (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P x2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.",
    "output": "postulate assoc_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B_exp. For all natural numbers $n$, $B$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of $2$ and $pred$ applied to the product of $2$ and $n$.",
    "output": "postulate le_B_exp : (n : Nat) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type5_body. For all sets $_A$, for all functions $Q_$ from elements $_x_919$ of $range$ of $_A$ to elements of $Type5$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_919$ of $range$ of $_A$, $Q_$ holds for $x_919$.",
    "output": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_dividesb_true1. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then if $n$ is divisible by $m$, then $dividesb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "postulate divides_to_dividesb_true1 : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Eq (dividesb n m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "postulate Sum_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) -> (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type0 (Q_ x_551)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1753$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "postulate Dop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1752 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1753 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nil_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate nil_cons : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a l) (matita_basics_lists_list.nil A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_le_to_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then if $m$ is less than or equal to $n$, then $n$ is equal to $m$.",
    "output": "postulate le_to_le_to_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : Leq m n) -> Eq n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_ind. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "postulate void_ind : (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_482)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_iter2. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $i$ and $j$, for all functions $__$ from natural numbers $x$ to elements of $Leq$ of $x$ and $g$ applied to $x$, if $i$ is less than or equal to $j$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $j$ and $a$.",
    "output": "postulate monotonic_iter2 : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (i : Nat) -> (j : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (__1 : Leq i j) -> Leq (iter Nat g i a) (iter Nat g j a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate le_2_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate log : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_mod. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate gcd_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_exists. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$.",
    "output": "postulate max_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_elim2. For all functions $R$ from natural numbers and natural numbers $__1$ to propositions, for all functions $__$ from natural numbers $n$ to elements of $R$ of $0$ and $n$, for all functions $__1$ from natural numbers $n$ to elements of $R$ of the sum of $n$ and $1$ and $0$, for all functions $__2$ from natural numbers $n$ and natural numbers $m$ and elements $__2$ of $R$ of $n$ and $m$ to elements of $R$ of the sum of $n$ and $1$ and the sum of $m$ and $1$, for all natural numbers $n$ and $m$, $R$ holds for $n$ and $m$.",
    "output": "postulate nat_elim2 : (R : (_ : Nat) -> (__1 : Nat) -> Prop) -> (_ : (n : Nat) -> R 0 n) -> (__1 : (n : Nat) -> R (plus n 1) 0) -> (__2 : (n : Nat) -> (m : Nat) -> (__2 : R n m) -> R (plus n 1) (plus m 1)) -> (n : Nat) -> (m : Nat) -> R n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_pred_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.pred$ applied to $n$ and $n$.",
    "output": "postulate le_pred_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.pred n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Z. $Nat$.",
    "output": "postulate z : Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus_to_lt_r. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "postulate lt_plus_to_lt_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus n q))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bijn_transpose_l. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to the function that maps $p$ to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $f$ applied to $p$ and $n$.",
    "output": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example5. $primeb$ applied to $6$ is equal to absurdity.",
    "output": "postulate example5 : Eq (primeb 6) false"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_557$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_557$, for all functions $_H_inr$ from elements $x_558$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_558$, for all elements $x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_556$.",
    "output": "postulate Sum_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_556)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_d_times_gcd. For all natural numbers $m$ and $n$ and $d$ and $c$, if $0$ is less than $c$, then if $d$ is divisible by the product of $c$ and $m$, then if $d$ is divisible by the product of $c$ and $n$, then $d$ is divisible by the product of $c$ and the greatest common divisor of $n$ and $m$.",
    "output": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B. For all natural numbers $_n$, $Nat$.",
    "output": "postulate B : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_lt_plus_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Lt$ and the function that maps $m$ to the sum of $n$ and $m$.",
    "output": "postulate monotonic_lt_plus_r : (n : Nat) -> monotonic Nat Lt (\\ m : Nat -> plus n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "postulate Dop_rect_CProp2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_eq_nat. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate decidable_eq_nat : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb_true. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "postulate andb_true : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_O_to_not_divides. For all elements $n$ and $i$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $i$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.nth_prime$ applied to $i$ and $n$.",
    "output": "postulate p_ord_O_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O r))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_le_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "postulate not_le_Sn_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_lt_SO. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$.",
    "output": "postulate prime_to_lt_SO : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type2. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_inl$ from elements $x_542$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_542$, for all functions $_H_inr$ from elements $x_543$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_543$, for all elements $x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_541$.",
    "output": "postulate Sum_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2) -> (_H_inl : (x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> (_H_inr : (x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> (x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type2 (Q_ x_541)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_893$ of $ACop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_893$.",
    "output": "postulate ACop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_893 : ACop A _nil) -> Type5) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_893 : ACop A _nil) -> Q_ x_893"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_mod_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate divides_to_mod_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1530$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1531$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1530 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1531 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_ind_aux. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "postulate f_ind_aux : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Opt_cons_tail_expand. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.option_cons$ applied to $A$ and $matita_basics_lists_list.option_hd$ applied to $A$ and $l$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$.",
    "output": "postulate opt_cons_tail_expand : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.option_cons A (matita_basics_lists_list.option_hd A l) (matita_basics_lists_list.tail A l)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop90. For all instances $n$ of natural numbers, we can prove that if $n$ is even and $n$ is prime, then $n$ is equal to $2$.",
    "output": "postulate prop90 : (n : Nat) -> if (and (even n) (prime n)) (Eq n 2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B2. For all natural numbers $_n$, $Nat$.",
    "output": "postulate B2 : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Enum. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, for all natural numbers $_x_942$, $A$.",
    "output": "postulate enum : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate example1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate commutative_plus : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exists. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Exists : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_b. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_plus_b : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n b) m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_unique_le. For all natural numbers $n$, for all lists $l$ of natural numbers, for all elements $__$ of $unique$ of $Nat$ and $l$, for all functions $__1$ from natural numbers $x$ and elements $__1$ of $mem$ of $Nat$ and $x$ and $l$ to elements of $Lt$ of $x$ and $n$, $length$ applied to $Nat$ and $l$ is less than or equal to $n$.",
    "output": "postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_ord_rem. For all natural numbers $p$ and $n$, if $1$ is less than $p$, then if $0$ is less than $n$, then $0$ is less than $ord_rem$ applied to $n$ and $p$.",
    "output": "postulate lt_O_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt 0 (ord_rem n p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.",
    "output": "postulate Sig_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Rewrite_l. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $x$, for all elements $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $y$.",
    "output": "postulate rewrite_l : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (P : (__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P x)) -> (y : cic.Term univs.Type2 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term univs.Type2 (P y)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1033. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all natural numbers $n1$, for all functions $Hind$ from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$, for all functions $H1$ from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $H2$ from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, if $p2$ applied to $n1$ is equal to $true$, then if $p1$ applied to $n1$ is equal to $true$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "M. For all elements $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate M : (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Square_double. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "postulate square_double : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate split : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list A) (matita_basics_lists_list.list A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Irreflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate irreflexive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bi_reflexive. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate bi_reflexive : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_filter_eqb. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.filter$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.eqb$ applied to $m$ and $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate length_filter_eqb : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat (matita_basics_lists_list.filter matita_arithmetics_nat.nat (matita_arithmetics_nat.eqb m) l)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop9d. For all sets $A$, $B$ and $C$, we can prove that the intersection of the difference of $B$ and $A$ and $C$ is equal to the difference of the intersection of $B$ and $C$ and the intersection of $A$ and $C$ and the difference of the intersection of $B$ and $C$ and the intersection of $A$ and $C$ is equal to the difference of the intersection of $B$ and $C$ and $A$.",
    "output": "postulate prop9d : (A : Set) -> (B : Set) -> (C : Set) -> and (equalset (intersection (difference B A) C) (difference (intersection B C) (intersection A C))) (equalset (difference (intersection B C) (intersection A C)) (difference (intersection B C) A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.",
    "output": "postulate inl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type3_body. For all sets $_A$, for all functions $Q_$ from elements $_x_921$ of $range$ of $_A$ to elements of $Type3$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $range$ of $_A$, $Q_$ holds for $x_921$.",
    "output": "postulate range_rect_Type3_body : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_rect_Type4_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_nmk$ from functions $x_83$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_83$, for all elements $x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_82$.",
    "output": "postulate Not_rect_Type4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4) -> (_H_nmk : (x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) -> (x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type4 (Q_ x_82)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_lt_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "postulate not_lt_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm01d. We can prove that the square root of $2$ is not rational.",
    "output": "postulate Thm01d : not (rational (sqrt 2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_B_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_times_gcd_aux. For all elements $p$ and $m$ and $n$ and $d$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $m$, for all elements $__5$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_704$.",
    "output": "postulate Prod_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_704)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1554$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1555$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1554 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1555 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_le_to_leb_false. For all natural numbers $n$ and $m$, if $n$ is not less than or equal to $m$, then $leb$ applied to $n$ and $m$ is equal to absurdity.",
    "output": "postulate not_le_to_leb_false : (n : Nat) -> (m : Nat) -> (_ : not (Leq n m)) -> Eq (leb n m) false"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_p. For all natural numbers $p$, if $1$ is less than $p$, then $p_ord$ applied to $p$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $1$ and $1$.",
    "output": "postulate p_ord_p : (p : Nat) -> (_ : Lt 1 p) -> Eq (p_ord p p) (mk_Prod Nat Nat 1 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_prim4l. For all natural numbers $n$, if $0$ is less than $n$, then the exponentiation of $2$ and the sum of the product of $4$ and $n$ and $1$ is less than or equal to the exponentiation of the product of $4$ and $n$ and the sum of $prim$ applied to the product of $4$ and $n$ and $1$.",
    "output": "postulate le_exp_prim4l : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (plus (times 4 n) 1)) (pow (times 4 n) (plus (prim (times 4 n)) 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_inv. For all natural numbers $_p$ and $_m$ and $_x$, $Nat$.",
    "output": "postulate p_ord_inv : (_p : Nat) -> (_m : Nat) -> (_x : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_881$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_881$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_881$.",
    "output": "postulate Aop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_881 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_881 : Aop A _nil) -> Q_ x_881"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Dop$ of $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $A$, $A$.",
    "output": "postulate prod_body : (A : Set) -> (nil : A) -> (_xxx : Dop A nil) -> (_x_969 : A) -> (_x_970 : A) -> A"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_times. For all natural numbers $a$ and $b$, if $0$ is less than $b$, then the quotient of the product of $a$ and $b$ and $b$ is equal to $a$.",
    "output": "postulate div_times : (a : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> Eq (div (times a b) b) a"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Flatten. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate flatten : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $b$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $b$ and $f$.",
    "output": "postulate false_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min (matita_arithmetics_nat.S n) b f) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S b) f))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_O. For all functions $f$ from natural numbers to booleans, $max$ applied to $0$ and $f$ is equal to $0$.",
    "output": "postulate max_O : (f : (_ : Nat) -> bool) -> Eq (max 0 f) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_minus_l. For all natural numbers $p$ and $q$ and $n$, if $q$ is less than or equal to $p$, then the difference of $q$ and $n$ is less than or equal to the difference of $p$ and $n$.",
    "output": "postulate monotonic_le_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq q p) -> Leq (minus q n) (minus p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1595. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $1$ is less than the greatest common divisor of $p$ and the product of $n$ and $m$, then if $smallest_factor$ applied to the greatest common divisor of $p$ and the product of $n$ and $m$ is divisible by $m$, then the greatest common divisor of $p$ and $n$ is equal to the greatest common divisor of $p$ and $m$.",
    "output": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lprim_invariant. For all natural numbers $n$ and $i$, for all lists $acc$ of natural numbers, if $1$ is less than $i$, then for all elements $__1$ of $primes_below$ of $acc$ and $i$, $primes_below$ holds for $lprim$ applied to $n$ and $i$ and $acc$ and the sum of $n$ and $i$.",
    "output": "postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (plus n i)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "postulate le_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_ind. For all natural numbers $_n$ and $_m$, for all functions $Q_$ from elements $_x_1192$ of $divisible$ of $_n$ and $_m$ to propositions, for all functions $_H_quotient$ from natural numbers $q$ and elements $x_1193$ of $Eq$ of $_m$ and the product of $_n$ and $q$ to elements of $Q_$ of $quotient$ applied to $_n$ and $_m$ and $q$ and $x_1193$, if $_n$ is divisible by $_m$, then $Q_$ holds for $x_1192$.",
    "output": "postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_to_not_eq_O. For all elements $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $n$ and $m$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate div_mod_spec_to_not_eq_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate Psi_1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_aux. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "postulate div_aux : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "postulate Prod_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_708)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "postulate le_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "postulate Prod_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type5 (Q_ x_694)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_fwd_plus_plus_ge. For all elements $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m2$ and $m1$, for all elements $n1$ and $n2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $m1$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $m2$ and $n2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$.",
    "output": "postulate le_fwd_plus_plus_ge : (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m2 m1)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus m1 n1) (matita_arithmetics_nat.plus m2 n2))) -> cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n2. For all natural numbers $n$, if $7$ is less than or equal to $n$, then $prim$ applied to the sum of the product of $2$ and $n$ and $1$ is less than or equal to $pred$ applied to $n$.",
    "output": "postulate le_prim_n2 : (n : Nat) -> (_ : Leq 7 n) -> Leq (prim (plus (times 2 n) 1)) (pred n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_1. $Psi$ applied to $1$ is equal to $1$.",
    "output": "postulate Psi_1 : Eq (Psi 1) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_spec_ind. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_971$ and elements $_x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$ to propositions, for all functions $_H_found_max_spec$ from natural numbers $m$ and elements $x_975$ of $Lt$ of $m$ and $_n$ and elements $x_974$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all natural numbers $x_971$, for all elements $x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$, $Q_$ holds for $x_971$ and $x_972$.",
    "output": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_787$.",
    "output": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact_to_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate fact_to_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $m$ and $m$.",
    "output": "postulate f_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_permutation.invert_permut n f m)) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_706$.",
    "output": "postulate Prod_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_706)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_comp_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ and $R1$ and $R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $R1$ and $R2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R$.",
    "output": "postulate sub_comp_l : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 R) (matita_basics_relations.Rcomp A R2 R))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_div. For all elements $d$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $n$.",
    "output": "postulate divides_div : (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_div_and_mod.div n d) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15441. For all elements $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $q$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$, for all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $lenm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $lenS$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $q$, for all elements $ndivnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $b$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "postulate let_clause_15441 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (lenm : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (lenS : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S q))) -> (ndivnm : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times b n)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_nat.times b n)) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n))))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b n) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times n b) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.mod m n))) (matita_arithmetics_gcd.gcd_aux q n (matita_arithmetics_div_and_mod.mod m n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_955$ of $Dop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_955$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_955$.",
    "output": "postulate Dop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_955 : Dop A _nil) -> Set) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_955 : Dop A _nil) -> Q_ x_955"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1062. For all elements $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $ltrb$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $b$, for all elements $spec$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $b$ and $r$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, for all elements $ltr1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r1$ and $b$, for all elements $spec1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q1$ and $b$ and $r1$, for all elements $leqq1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $q$ and $q1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $r1$ and $matita_arithmetics_nat.times$ applied to $b$ and $q1$.",
    "output": "postulate let_clause_1062 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le q q1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r1 (matita_arithmetics_nat.times b q1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ltl_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "postulate ltl_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n1. For all natural numbers $n$, if $4$ is less than or equal to $n$, then $prim$ applied to the sum of the product of $2$ and $n$ and $1$ is less than or equal to $n$.",
    "output": "postulate le_prim_n1 : (n : Nat) -> (_ : Leq 4 n) -> Leq (prim (plus (times 2 n) 1)) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "SameF_p. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__2$ to $A$.",
    "output": "postulate sameF_p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16921. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x358$ and $x359$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x358$ and $matita_arithmetics_nat.times$ applied to $x358$ and $x359$ and $matita_arithmetics_nat.times$ applied to $x358$ and $matita_arithmetics_nat.S$ applied to $x359$.",
    "output": "postulate let_clause_16921 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_Sm_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $P$ of $cic.Univ$ of $cic.prop$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, $cic.Term$ holds for $cic.prop$ and $P$.",
    "output": "postulate le_n_Sm_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))) -> (P : cic.Univ cic.prop) -> (__1 : (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> (__2 : (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> cic.Term cic.prop P"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.",
    "output": "postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_2. For all instances $x$ of real numbers, we can prove that if the sum of the difference of the exponentiation of $x$ and $2$ and the product of $2$ and $x$ and $2$ is less than or equal to $0$, then the exponentiation of $x$ and $3$ is greater than or equal to $8$.",
    "output": "postulate noLabel_2 : (x : Real) -> if (Leq (plus (minus (pow x 2) (times 2 x)) 2) 0) (Geq (pow x 3) 8)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_to_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.",
    "output": "postulate le_plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_686$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_686$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_686$.",
    "output": "postulate Sig_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_686)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_leb_true. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $leb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_CProp4_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_615$, for all elements $x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_614$.",
    "output": "postulate option_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_615 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_615))) -> (x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_614)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_minus. For all natural numbers $n$ and $m$ and $p$, if $p$ is less than or equal to $m$, then if $m$ is less than or equal to $n$, then the sum of $p$ and the difference of $n$ and $m$ is equal to the difference of $n$ and the difference of $m$ and $p$.",
    "output": "postulate minus_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq p m) -> (__1 : Leq m n) -> Eq (plus p (minus n m)) (minus n (minus m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.",
    "output": "postulate option_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) -> (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_618)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type3. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1446$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1447$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type3 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1446 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type3) -> (_H1 : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1447 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_865$ of $Aop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_865$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_865$.",
    "output": "postulate Aop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_le. For all natural numbers $_n$ and $__$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_type$ of $z$, if $_n$ is less than or equal to $__$, then $return_type$ holds for $z$.",
    "output": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $x$ be a circle. Then the radius of $x$ is an instance of real numbers.",
    "output": "postulate radius : Circle -> Real"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sqrt_bound. For all natural numbers $n$, if the exponentiation of $2$ and $8$ is less than or equal to $n$, then the product of $2$ and the sum of the logarithm of $2$ and the product of $2$ and $n$ and $1$ is less than or equal to the square root of the product of $2$ and $n$.",
    "output": "postulate sqrt_bound : (n : Nat) -> (_ : Leq (pow 2 8) n) -> Leq (times 2 (plus (log 2 (times 2 n)) 1)) (sqrt (times 2 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Length_tail1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.",
    "output": "postulate length_tail1 : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_log.log$ applied to $p$ and $n$.",
    "output": "postulate psi_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_log.log p n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_l$ be a list of natural numbers. Then we can say that $all_primes$ holds for $_l$.",
    "output": "postulate all_primes : (_l : list Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16003. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type2$, for all functions $_H_div_mod_spec_intro$ from elements $x_827$ of $Lt$ of $_r$ and $_m$ and elements $x_826$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_827$ and $x_826$, for all elements $x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_825$.",
    "output": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psi_BPsi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate le_Psi_BPsi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nil_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate nil_to_nil : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10332. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10332 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_f$ be a function from natural numbers to natural numbers. Then we can say that $increasing$ holds for $_f$.",
    "output": "postulate increasing : (_f : (_ : Nat) -> Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$.",
    "output": "postulate lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_relations.relation B)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_mod. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then $mod$ applied to the sum of $m$ and $n$ and $q$ is less than or equal to the sum of $mod$ applied to $m$ and $q$ and $mod$ applied to $n$ and $q$.",
    "output": "postulate le_plus_mod : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> Leq (mod (plus m n) q) (plus (mod m q) (mod n q))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lprim_ex. $lprim$ applied to $8$ and $2$ and $nil$ applied to $Nat$ is equal to $cons$ applied to $Nat$ and $2$ and $cons$ applied to $Nat$ and $3$ and $cons$ applied to $Nat$ and $5$ and $cons$ applied to $Nat$ and $7$ and $nil$ applied to $Nat$.",
    "output": "postulate lprim_ex : Eq (lprim 8 2 (nil Nat)) (cons Nat 2 (cons Nat 3 (cons Nat 5 (cons Nat 7 (nil Nat)))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_plus. For all natural numbers $n$ and $m$ and $p$, the difference of the difference of $n$ and $m$ and $p$ is equal to the difference of $n$ and the sum of $m$ and $p$.",
    "output": "postulate minus_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> Eq (minus (minus n m) p) (minus n (plus m p))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_plus. For all natural numbers $n$ and $p$ and $q$, if $n$ is divisible by $p$, then if $n$ is divisible by $q$, then $n$ is divisible by the sum of $p$ and $q$.",
    "output": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_951$ of $Dop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_951$.",
    "output": "postulate Dop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_951 : Dop A _nil) -> Type2) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_951 : Dop A _nil) -> Q_ x_951"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_spec_to_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.",
    "output": "postulate min_spec_to_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nil_append_elim. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.",
    "output": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_log_n_n. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $n$.",
    "output": "postulate lt_log_n_n : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_log.log p n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_73. For all natural numbers $n$, if $2$ is less than $n$, then for all natural numbers $x134$ and $x135$ and $x136$, the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (n : Nat) -> (posn : Lt 2 n) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z299$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z300$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_107$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_107$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_minus_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $m$.",
    "output": "postulate le_plus_minus_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_S_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than the sum of $m$ and $1$, then $n$ is less than $m$.",
    "output": "postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound4. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "postulate let_upper_bound4 : (n : Nat) -> (m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type0. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "postulate Sum_rect_Type0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) -> (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type0 (Q_ x_551)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lhd_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.lhd$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$ and $n$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate lhd_nil : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.lhd A (matita_basics_lists_list.nil A) n) (matita_basics_lists_list.nil A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_inv_rect_CProp4. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1602$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1603$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_947$.",
    "output": "postulate Dop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_rect_CProp0_body. For all functions $Q_$ from elements $_x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_519$.",
    "output": "postulate unit_rect_CProp0_body : (Q_ : (_x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_519)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.",
    "output": "postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Allr_fwd_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $l$.",
    "output": "postulate Allr_fwd_cons : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.cons A a l))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "TimesA. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate timesA : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_m1. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $_x_365$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_m1 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z954$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z955$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_CProp2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z954 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z955 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_minus_S_pred. For all natural numbers $n$ and $m$, the difference of $n$ and the sum of $m$ and $1$ is equal to $pred$ applied to the difference of $n$ and $m$.",
    "output": "postulate eq_minus_S_pred : (n : Nat) -> (m : Nat) -> Eq (minus n (plus m 1)) (pred (minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_m_exp_nm. For all natural numbers $n$ and $m$, if $1$ is less than $n$, then $m$ is less than the exponentiation of $n$ and $m$.",
    "output": "postulate lt_m_exp_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> Lt m (pow n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_n_1. For all natural numbers $n$, $n$ is equal to the product of $n$ and $1$.",
    "output": "postulate times_n_1 : (n : Nat) -> Eq n (times n 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $m$.",
    "output": "postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_intro. For all natural numbers $n$ and $m$ and $q$ and $r$, if $r$ is less than $m$, then if $n$ is equal to the sum of the product of $q$ and $m$ and $r$, then $div_mod_spec$ holds for $n$ and $m$ and $q$ and $r$.",
    "output": "postulate div_mod_spec_intro : (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> (__1 : Eq n (plus (times q m) r)) -> div_mod_spec n m q r"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15491. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $x1106$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1106$ and $matita_arithmetics_nat.minus$ applied to $x1106$ and $n$.",
    "output": "postulate let_clause_15491 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x1106 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1106 (matita_arithmetics_nat.minus x1106 n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_863$ of $Aop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_863$.",
    "output": "postulate Aop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $m$ is less than or equal to $n$, then if $n$ is less than the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than $p$.",
    "output": "postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus p m)) -> Lt (minus n m) p"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "same_parity : Int -> Int -> Prop\nsame_parity = \\ x -> \\ y -> or (and (even x) (even y)) (and (odd x) (odd y))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_to_fact2. For all natural numbers $n$, if $0$ is less than $n$, then the product of the exponentiation of $2$ and the product of $2$ and $n$ and the exponentiation of the factorial of $n$ and $2$ is less than or equal to the product of the product of $2$ and $n$ and the factorial of the product of $2$ and $n$.",
    "output": "postulate exp_to_fact2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (times (pow 2 (times 2 n)) (pow (factorial n) 2)) (times (times 2 n) (factorial (times 2 n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp0_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_859$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_858$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_859$ and $x_858$, for all elements $x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_857$.",
    "output": "postulate div_mod_spec_rect_CProp0_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Comm_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $ACop$ of $A$ and $nil$, for all elements $a$ and $b$ of $A$, $op$ applied to $A$ and $nil$ and $aop$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ is equal to $op$ applied to $A$ and $nil$ and $aop$ applied to $A$ and $nil$ and $xxx$ and $b$ and $a$.",
    "output": "postulate comm_body : (A : Set) -> (nil : A) -> (xxx : ACop A nil) -> (a : A) -> (b : A) -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc. For all elements $_n$ and $_k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate bc : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.",
    "output": "postulate Sig_rect_Type4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type4) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type4 (Q_ x_666)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pair_destruct_2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $c$.",
    "output": "postulate pair_destruct_2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> (c : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b (matita_basics_types.snd A B c))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Hint_declaration_Type2. For all elements $_a$ and $_b$ of $cic.Univ$ of $univs.Type2$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate hint_declaration_Type2 : (_a : cic.Univ univs.Type2) -> (_b : cic.Univ univs.Type2) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_S. For all natural numbers $n$, $0$ is less than the sum of $n$ and $1$.",
    "output": "postulate lt_O_S : (n : Nat) -> Lt 0 (plus n 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_1_max_prime. For all natural numbers $n$, if $1$ is less than $n$, then $1$ is less than $max$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $andb$ applied to $primeb$ applied to $i$ and $dividesb$ applied to $i$ and $n$.",
    "output": "postulate lt_1_max_prime : (n : Nat) -> (_ : Lt 1 n) -> Lt 1 (max (plus n 1) (\\ i : Nat -> andb (primeb i) (dividesb i n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Increasing_to_injective. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$.",
    "output": "postulate increasing_to_injective : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_Sn_m. For all natural numbers $n$ and $m$, the sum of $m$ and the product of $n$ and $m$ is equal to the product of the sum of $n$ and $1$ and $m$.",
    "output": "postulate times_Sn_m : (n : Nat) -> (m : Nat) -> Eq (plus m (times n m)) (times (plus n 1) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ExteqR. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ and $_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate exteqR : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (_S : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10333. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10333 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10331. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt4n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le4m$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lea$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hinda$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m)) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a)) -> (Hinda : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S a)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_Dop. For all sets $A$, for all elements $nil$ of $A$, for all elements $sum$ of $ACop$ of $A$ and $nil$, for all functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$, for all functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $nil$ and $nil$, for all functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$, $Dop$ holds for $A$ and $nil$.",
    "output": "postulate mk_Dop : (A : Set) -> (nil : A) -> (sum : ACop A nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_spec_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_minimization.not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_971$ and $x_972$.",
    "output": "postulate max_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop) -> (_H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O (matita_arithmetics_minimization.not_found_max_spec _n _f x_976))) -> (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Term cic.prop (Q_ x_971 x_972)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_1_to_divides_times_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "postulate gcd_1_to_divides_times_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop10. We can prove that $0$ is even.",
    "output": "postulate prop10 : even 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "postulate Aop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_783)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Smallest_factor_to_min. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is equal to $min$ applied to $n$ and $2$ and the function that maps $m$ to $eqb$ applied to $mod$ applied to $n$ and $m$ and $0$.",
    "output": "postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\\ m : Nat -> eqb (mod n m) 0))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primeb_false_to_not_prime. For all natural numbers $n$, if $primeb$ applied to $n$ is equal to absurdity, then $n$ is not prime.",
    "output": "postulate primeb_false_to_not_prime : (n : Nat) -> (_ : Eq (primeb n) false) -> not (prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1608$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1609$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1608 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1609 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_times_plus_to_congruent. For all elements $n$ and $m$ and $p$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $r$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.",
    "output": "postulate eq_times_plus_to_congruent : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m))) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_body. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "postulate exp_body : (_ : Nat) -> (__1 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_gcd. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "postulate commutative_gcd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ and $l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $matita_basics_lists_list.nil$ applied to $A$ and $l1$.",
    "output": "postulate append_cons : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l (matita_basics_lists_list.cons A a l1)) (matita_basics_lists_list.append A (matita_basics_lists_list.append A l (matita_basics_lists_list.cons A a (matita_basics_lists_list.nil A))) l1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_CProp2. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1482$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_851$ of $Lt$ of $x4$ and $x2$ and elements $x_850$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1483$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_851$ and $x_850$, $P$ holds for $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp2 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1482 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_851 : Lt x4 x2) -> (x_850 : Eq x1 (plus (times x3 x2) x4)) -> (_z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Permut_n_to_le. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $n$, for all functions $__2$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $m$ and $m$, for all elements $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $j$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $h$ applied to $j$.",
    "output": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_to_not. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.",
    "output": "postulate not_to_not : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop B) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not B)) -> cic.Term cic.prop (matita_basics_logic.Not A)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_smallest_factor. For all natural numbers $n$, if $0$ is less than $n$, then $0$ is less than $smallest_factor$ applied to $n$.",
    "output": "postulate lt_O_smallest_factor : (n : Nat) -> (_ : Lt 0 n) -> Lt 0 (smallest_factor n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "postulate mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Cr_pair4. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate cr_pair4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inv_eq_minus_O. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "postulate inv_eq_minus_O : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or_ind_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_or_introl$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_introl$ applied to $_A$ and $_B$ and $x_171$, for all functions $_H_or_intror$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_intror$ applied to $_A$ and $_B$ and $x_172$, for all elements $x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_170$.",
    "output": "postulate Or_ind_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop) -> (_H_or_introl : (x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))) -> (_H_or_intror : (x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))) -> (x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term cic.prop (Q_ x_170)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_p_primeb5. For all natural numbers $n$, if $1$ is less than $n$, then $bigop$ applied to the sum of the product of $2$ and $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and the product of $2$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$.",
    "output": "postulate pi_p_primeb5 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example6. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_bool.true$.",
    "output": "postulate example6 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fmin_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $b$, if $m$ is equal to $min$ applied to $n$ and $b$ and $f$, then if $m$ is less than the sum of $n$ and $b$, then $f$ applied to $m$ is equal to $true$.",
    "output": "postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_spec_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1890$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $m$ and elements $_x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ and elements $_x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1891$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x4$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$, for all functions $_H2$ from functions $_x_1081$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1891$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x4$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x4$.",
    "output": "postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 m)) -> cic.Term cic.prop (P m)) -> (_H2 : (_x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> (_z1891 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x4 (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus x1 x2))) -> cic.Term cic.prop (P x4)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp1. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_577$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_577$, for all functions $_H_inr$ from elements $x_578$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_578$, for all elements $x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_576$.",
    "output": "postulate Sum_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.plus$ applied to $n2$ and $m2$.",
    "output": "postulate le_plus : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate plus_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus n matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_ord_rem. For all elements $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$.",
    "output": "postulate not_divides_ord_rem : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_ord.ord_rem m p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (plus x (minus y z)) (minus (plus x y) z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_m_exp_nm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$.",
    "output": "postulate lt_m_exp_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_exp.exp n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ and $_m$ be natural numbers. Then we can say that $_n$ is divisible by $_m$.",
    "output": "postulate divisible : (_n : Nat) -> (_m : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_lt_to_lt. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to $m$, then if $m$ is less than $p$, then $n$ is less than $p$.",
    "output": "postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lprim. For all natural numbers $__$ and $__1$, for all lists $__2$ of natural numbers, $list$ holds for $Nat$.",
    "output": "postulate lprim : (_ : Nat) -> (__1 : Nat) -> (__2 : list Nat) -> list Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_le_to_lt. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$.",
    "output": "postulate lt_to_le_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_nat. For all elements $return_sort$ of $Sort$, for all functions $return_type$ from natural numbers $z$ to elements of $return_sort$, for all elements $case_O$ of $return_type$ of $0$, for all functions $case_S$ from natural numbers to elements of $return_type$ of the sum of $__$ and $1$, for all natural numbers $z$, $return_type$ holds for $z$.",
    "output": "postulate match_nat : (return_sort : Sort) -> (return_type : (z : Nat) -> return_sort) -> (case_O : return_type 0) -> (case_S : (_ : Nat) -> return_type (plus __ 1)) -> (z : Nat) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_714$.",
    "output": "postulate Prod_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_714)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_Psil. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_exp_Psil : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bijn_transpose. For all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$.",
    "output": "postulate bijn_transpose : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_to_nat_body. For all elements $_b$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate bool_to_nat_body : (_b : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_50. For all instances $a$ and $b$ of integers, we can prove that if the product of $a$ and $b$ is odd, then the sum of the exponentiation of $a$ and $2$ and the exponentiation of $b$ and $2$ is even.",
    "output": "postulate noLabel_50 : (a : Int) -> (b : Int) -> if (odd (times a b)) (even (plus (pow a 2) (pow b 2)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_mod. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.",
    "output": "postulate le_to_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_div_and_mod.mod n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Split_exists. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l1$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l2$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $n$.",
    "output": "postulate split_exists : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A l1 l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp1_body. For all functions $Q_$ from natural numbers $_x_409$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_410$ and elements $_x_412$ of $Q_$ of $x_410$ to elements of $Q_$ of the sum of $x_410$ and $1$, for all natural numbers $x_409$, $Q_$ holds for $x_409$.",
    "output": "postulate nat_rect_CProp1_body : (Q_ : (_x_409 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_410 : Nat) -> (_x_412 : Q_ x_410) -> Q_ (plus x_410 1)) -> (x_409 : Nat) -> Q_ x_409"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_discr. For all sets $a1$, for all elements $x$ and $y$ of $range$ of $a1$, if $x$ is equal to $y$, then $match_range$ holds for $a1$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ to $match_range$ applied to $a1$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $Nat$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $Nat$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $bool$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $_e2$ to $P$ and the function that maps $_z59$ to $P$ and $y$ and $x$.",
    "output": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ t0 : ((_ : Nat) -> a1) -> \\ t1 : Nat -> \\ t2 : ((_ : Nat) -> bool) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ u0 : ((_ : Nat) -> a1) -> \\ u1 : Nat -> \\ u2 : ((_ : Nat) -> bool) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) (\\ e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) (\\ _e2 : Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2 -> P)))) (\\ _z59 : ((e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) -> (e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) -> (_e2 : Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) -> P) -> P))) y) x"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1078. For all elements $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $ltrb$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $b$, for all elements $spec$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $b$ and $r$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, for all elements $ltr1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r1$ and $b$, for all elements $spec1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q1$ and $b$ and $r1$, for all elements $leqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $q1$, for all elements $ltqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $q1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $r$ and $matita_arithmetics_nat.times$ applied to $b$ and $q$.",
    "output": "postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1272$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1273$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1272 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1273 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop100. For all instances $a$ and $b$ and $c$ of integers, if we can prove that the sum of the sum of $a$ and $b$ and $c$ is equal to $0$, then we can prove that the product of the product of $a$ and $b$ and $c$ is less than $0$.",
    "output": "postulate prop100 : (a : Int) -> (b : Int) -> (c : Int) -> Eq (plus (plus a b) c) 0 -> Lt (times (times a b) c) 0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unique_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate unique_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10335. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10335 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_inv_lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "postulate lstar_r_inv_lstar : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Example12. $nth_prime$ applied to $3$ is equal to $7$.",
    "output": "postulate example12 : Eq (nth_prime 3) 7"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_body. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all sets $H$, for all elements $__2$ of $H$, for all functions $__3$ from elements $__3$ of $H$ and elements $__4$ of $H$ to elements of $H$, for all functions $__4$ from natural numbers $__4$ to elements of $H$, $H$.",
    "output": "postulate bigop_body : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15591. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.",
    "output": "postulate let_clause_15591 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_fact_pi_p. For all natural numbers $n$, the factorial of $n$ is equal to $bigop$ applied to the difference of the sum of $n$ and $1$ and $1$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $1$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to the sum of $i$ and $1$.",
    "output": "postulate eq_fact_pi_p : (n : Nat) -> Eq (factorial n) (bigop (minus (plus n 1) 1) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i 1)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> i0) (plus i 1)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "postulate div_mod_spec_rect_CProp3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "To_min. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$.",
    "output": "postulate to_min : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i m)) -> cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bc_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate bc_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp4_body. For all functions $Q_$ from elements $_x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_396$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, for all elements $x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_393$.",
    "output": "postulate nat_rect_CProp4_body : (Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : cic.Term cic.prop (Q_ x_394)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) -> (x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_393)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_theta_M_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate le_theta_M_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z384$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injective_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $permut$ of $f$ and $n$, $injn$ holds for $invert_permut$ applied to $n$ and $f$ and $n$.",
    "output": "postulate injective_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> injn (invert_permut n f) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le_div. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$.",
    "output": "postulate le_times_to_le_div : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) -> cic.Term cic.prop (matita_arithmetics_nat.le c (matita_arithmetics_div_and_mod.div a b))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_degenerate. For all natural numbers $p$ and $n$, $p_ord_aux$ applied to $p$ and $n$ and $1$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $p$ and $n$.",
    "output": "postulate p_ord_degenerate : (p : Nat) -> (n : Nat) -> Eq (p_ord_aux p n 1) (mk_Prod Nat Nat p n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z593$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate bool_inv_rect_Type4 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z593 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) -> (_H1 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type4 (P matita_basics_bool.true)) -> (_H2 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type4 (P matita_basics_bool.false)) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from natural numbers $_x_401$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_402$ and elements $_x_404$ of $Q_$ of $x_402$ to elements of $Q_$ of the sum of $x_402$ and $1$, for all natural numbers $x_401$, $Q_$ holds for $x_401$.",
    "output": "postulate nat_rect_CProp3_body : (Q_ : (_x_401 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_402 : Nat) -> (_x_404 : Q_ x_402) -> Q_ (plus x_402 1)) -> (x_401 : Nat) -> Q_ x_401"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_Psi_Psi'. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi'$ applied to $n$.",
    "output": "postulate eq_Psi_Psi' : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi' n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $m$ and $q$.",
    "output": "postulate lt_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus m q))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_ind. For all functions $Q_$ from elements $_x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_66$.",
    "output": "postulate False_ind : (Q_ : (_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_66)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_or_lt_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi'. For all natural numbers $__$, $Nat$.",
    "output": "postulate Psi' : (_ : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "postulate DPair_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi_4. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate Psi_4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_I_gen. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $b$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Even_or_odd. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$.",
    "output": "postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_ord_sigma_p. For all natural numbers $n$ and $m$ and $x$, if $0$ is less than $n$, then if $x$ is prime, then if the exponentiation of $x$ and $m$ is less than or equal to $n$, then if $n$ is less than the exponentiation of $x$ and the sum of $m$ and $1$, then $ord$ applied to $n$ and $x$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $x$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1063. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $permf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lein$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $lejn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all elements $lebn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $n$, for all elements $fb$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$, for all functions $__$ from elements $i0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i0$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $i0$ and $n$, for all elements $injf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $j$.",
    "output": "postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (__ : (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i0 n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (f i0) n)) -> (injf : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) j)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_or_introl$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_introl$ applied to $_A$ and $_B$ and $x_171$, for all functions $_H_or_intror$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_intror$ applied to $_A$ and $_B$ and $x_172$, for all elements $x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_170$.",
    "output": "postulate Or_ind : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop) -> (_H_or_introl : (x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))) -> (_H_or_intror : (x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))) -> (x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term cic.prop (Q_ x_170)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_nth_prime_n. For all natural numbers $n$, $0$ is less than $nth_prime$ applied to $n$.",
    "output": "postulate lt_O_nth_prime_n : (n : Nat) -> Lt 0 (nth_prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z960$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z961$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Theta_pi_p_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate theta_pi_p_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_O_to_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "postulate mod_O_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Allr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Allr_body : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "S_pred. For all natural numbers $n$, if $0$ is less than $n$, then the sum of $pred$ applied to $n$ and $1$ is equal to $n$.",
    "output": "postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (plus (pred n) 1) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_div_le. For all natural numbers $a$ and $b$ and $c$ and $d$, if $0$ is less than $b$, then if $0$ is less than $d$, then the product of the quotient of $a$ and $b$ and the quotient of $c$ and $d$ is less than or equal to the quotient of the product of $a$ and $c$ and the product of $b$ and $d$.",
    "output": "postulate times_div_le : (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (_ : Lt 0 b) -> (__1 : Lt 0 d) -> Leq (times (div a b) (div c d)) (div (times a c) (times b d))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Start_lop. For all natural numbers $n$, if $1$ is less than or equal to $n$, then $option_hd$ applied to $Nat$ and $list_of_primes$ applied to $n$ is equal to $Some$ applied to $Nat$ and $2$.",
    "output": "postulate start_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (option_hd Nat (list_of_primes n)) (Some Nat 2)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_x_times_x. For all natural numbers $x$, $x$ is less than or equal to the product of $x$ and $x$.",
    "output": "postulate le_x_times_x : (x : Nat) -> Leq x (times x x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_Type1_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $__$ of $cic.Term$ of $univs.Type1$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $x$ and $p$.",
    "output": "postulate eq_rect_Type1_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type1) -> (__ : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type1 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.",
    "output": "postulate eq_rect_CProp3_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_not_divides_fact. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate prime_to_not_divides_fact : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_mod. For all elements $m$ and $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.plus$ applied to $m$ and $n$ and $q$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$.",
    "output": "postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primeb_true_to_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$.",
    "output": "postulate primeb_true_to_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_primes.prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1553. For all elements $n$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $a$.",
    "output": "postulate let_clause_1553 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.plus a (matita_arithmetics_nat.S a)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "postulate max : (_ : Nat) -> (__1 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_31. For all instances $x$ of integers, we can prove that if the sum of the product of $7$ and $x$ and $5$ is odd, then $x$ is even.",
    "output": "postulate noLabel_31 : (x : Int) -> if (odd (plus (times 7 x) 5)) (even x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_discr. For all elements $a1$ and $a2$ and $a3$ and $a4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x$ and $y$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_arithmetics_div_and_mod.match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_arithmetics_div_and_mod.match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $matita_basics_logic.R0$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $a3$ and $a2$ and $a4$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $a3$ and $a2$ and $a4$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z53$ to $P$ and $y$ and $x$.",
    "output": "postulate div_mod_spec_discr : (a1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (y : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\\ t0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ t1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) -> matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\\ u0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ u1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1) -> P))) (\\ _z53 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "SameF_upto_le. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $m$ and $A$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $n$ and $A$ and $f$ and $g$.",
    "output": "postulate sameF_upto_le : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto m A f g)) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto n A f g)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DemorganIntersection. For all sets $A$ and $B$, we can prove that the complement of the intersection of $A$ and $B$ is equal to the union of the complement of $A$ and the complement of $B$.",
    "output": "postulate demorganIntersection : (A : Set) -> (B : Set) -> equalset (complement (intersection A B)) (union (complement A) (complement B))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ and $_m$ and $_q$ and $_r$ be natural numbers. Then $div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ is a proposition.",
    "output": "postulate div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Relation2. For all elements $__$ and $__1$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate relation2 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psi_exp4. For all natural numbers $n$, if $1$ is less than $n$, then $Psi$ applied to $n$ is less than or equal to the product of $pred$ applied to $n$ and the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "postulate le_Psi_exp4 : (n : Nat) -> (_ : Lt 1 n) -> Leq (Psi n) (times (pred n) (pow 2 (minus (times 2 n) 3)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eqb_true_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate eqb_true_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_mop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ and $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate let_mop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> (_x_969 : cic.Term univs.Type0 B) -> (_x_970 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_to_le. For all natural numbers $b$ and $n$ and $m$, if $1$ is less than $b$, then if the exponentiation of $b$ and $n$ is less than or equal to the exponentiation of $b$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Smallest_factor_fact. For all natural numbers $n$, $n$ is less than $smallest_factor$ applied to the sum of the factorial of $n$ and $1$.",
    "output": "postulate smallest_factor_fact : (n : Nat) -> Lt n (smallest_factor (plus (factorial n) 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_B_Bk. For all natural numbers $n$, $B$ applied to $n$ is equal to $Bk$ applied to $n$.",
    "output": "postulate eq_B_Bk : (n : Nat) -> Eq (B n) (Bk n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1560. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1560 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_CProp4. For all functions $Q_$ from elements $_x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_54$.",
    "output": "postulate True_rect_CProp4 : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1561. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $a$ and $matita_arithmetics_nat.times$ applied to $m$ and $b$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1561 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m))) -> (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_801$.",
    "output": "postulate Aop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_801)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16003. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "postulate let_clause_16003 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_949$ of $Dop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_949$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_949$.",
    "output": "postulate Dop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_949 : Dop A _nil) -> Type3) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_949 : Dop A _nil) -> Q_ x_949"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_exists_to_forall. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, if it is not the case that $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $P$ applied to $i$, then for all natural numbers $i$, if $i$ is less than $n$, then it is not the case that $P$ holds for $i$.",
    "output": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_minus_m_m. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $m$ and $n$ and $n$.",
    "output": "postulate minus_minus_m_m : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus m (matita_arithmetics_nat.minus m n)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1607. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "postulate let_clause_1607 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_mod_m_m. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then $mod$ applied to $n$ and $m$ is less than $m$.",
    "output": "postulate lt_mod_m_m : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt (mod n m) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mem_filter_true. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $a$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $a$ and $matita_basics_bool.true$.",
    "output": "postulate mem_filter_true : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem S a (matita_basics_lists_list.filter S f l))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f a) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inj_mk_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $P$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $A$ and $P$ and $x$ and $matita_basics_types.mk_Sig$ applied to $A$ and $P$ and $matita_basics_types.pi1$ applied to $A$ and $P$ and $x$ and $matita_basics_types.pi2$ applied to $A$ and $P$ and $x$.",
    "output": "postulate inj_mk_Sig : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig A P)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig A P)) x (matita_basics_types.mk_Sig A P (matita_basics_types.pi1 A P x) (matita_basics_types.pi2 A P x)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "TransitSubset. For all sets $A$, $B$ and $C$, we can prove that if $A$ is a subset of $B$ and $B$ is a subset of $C$, then $A$ is a subset of $C$.",
    "output": "postulate transitSubset : (A : Set) -> (B : Set) -> (C : Set) -> if (and (subseteq A B) (subseteq B C)) (subseteq A C)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eqb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.eqb$ applied to $n$ and $m$.",
    "output": "postulate eqb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15441. For all natural numbers $p$ and $q$, for all functions $Hind$ from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$, for all natural numbers $m$ and $n$, if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to the sum of $q$ and $1$, then if $n$ is not divisible by $m$, then for all natural numbers $a$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ or the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then if the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then the difference of the product of $n$ and $b$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$.",
    "output": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Decidable_prime. For all natural numbers $n$, $decidable$ holds for $prime$ applied to $n$.",
    "output": "postulate decidable_prime : (n : Nat) -> decidable (prime n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_CProp5_body. For all sets $_A$, for all functions $Q_$ from elements $_x_931$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $range$ of $_A$, $Q_$ holds for $x_931$.",
    "output": "postulate range_rect_CProp5_body : (_A : Set) -> (Q_ : (_x_931 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_to_lt_max. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $f$ applied to $n$ is equal to absurdity, then if $max$ applied to $m$ and $f$ is less than or equal to $n$, then $max$ applied to $m$ and $f$ is less than $n$.",
    "output": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "SameF_upto. For all natural numbers $__$, for all sets $A$, $relation$ holds for $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__1$ to $A$.",
    "output": "postulate sameF_upto : (_ : Nat) -> (A : Set) -> relation (prod Set Set Nat (\\ __1 : Nat -> A))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_l2_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l3$ and $matita_basics_lists_list.length$ applied to $A$ and $l4$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_div_S. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then $n$ is less than the product of the sum of the quotient of $n$ and $m$ and $1$ and $m$.",
    "output": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (plus (div n m) 1) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_CProp4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_751$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_753$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_752$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_755$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_752$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_753$ and $x_752$, for all elements $x_751$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_751$.",
    "output": "postulate list_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_753 : cic.Term univs.Type0 _A) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_755 : cic.Term cic.prop (Q_ x_752)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_753 x_752))) -> (x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_751)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Or_div_mod. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$.",
    "output": "postulate or_div_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n q)) q))) (matita_basics_logic.And (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n q) q) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Fact_body. For all natural numbers $__$, $Nat$.",
    "output": "postulate fact_body : (_ : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1621$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_div. For all natural numbers $n$ and $m$, if $n$ is divisible by $m$, then the product of the quotient of $m$ and $n$ and $n$ is equal to $m$.",
    "output": "postulate divides_to_div : (n : Nat) -> (m : Nat) -> (_ : divisible n m) -> Eq (times (div m n) n) m"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_S_fact. For all natural numbers $n$ and $i$, if $1$ is less than $i$, then if $i$ is less than or equal to $n$, then $i$ is not divisible by the sum of the factorial of $n$ and $1$.",
    "output": "postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (__1 : Leq i n) -> not (divisible i (plus (factorial n) 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.",
    "output": "postulate mod_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type3_body. For all functions $Q_$ from natural numbers $_x_377$ to elements of $Type3$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_378$ and elements $_x_380$ of $Q_$ of $x_378$ to elements of $Q_$ of the sum of $x_378$ and $1$, for all natural numbers $x_377$, $Q_$ holds for $x_377$.",
    "output": "postulate nat_rect_Type3_body : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (plus x_378 1)) -> (x_377 : Nat) -> Q_ x_377"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.times$ applied to $n2$ and $m2$.",
    "output": "postulate le_times : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n1 m1) (matita_arithmetics_nat.times n2 m2))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z287$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $x_98$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z288$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_98$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_98$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z287 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type0) -> (_H1 : (x_98 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z288 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Refl. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $x$.",
    "output": "postulate refl : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> cic.Term cic.prop (matita_basics_logic.eq A x x)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_Type1. For all functions $Q_$ from elements $_x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_71$.",
    "output": "postulate False_rect_Type1 : (Q_ : (_x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type1) -> (x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ x_71)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_945$ of $Dop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_945$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_945$.",
    "output": "postulate Dop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_p_primeb4. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "postulate pi_p_primeb4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_rect_Type2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_conj$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_136$ and $x_135$, for all elements $x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_134$.",
    "output": "postulate And_rect_Type2_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) -> (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type2 (Q_ x_134)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate max : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z131$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z132$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_Type4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z131 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H1 : (_z132 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type4 (P matita_basics_logic.I)) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.",
    "output": "postulate range_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sigma_const. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate sigma_const : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type1. For all functions $Q_$ from elements $_x_50$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_I$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_50$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_50$.",
    "output": "postulate True_rect_Type1 : (Q_ : (_x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) -> (_H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I)) -> (x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type1 (Q_ x_50)"
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type1. For all functions $Q_$ from elements $_x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_O$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_388$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_386$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_386$, for all elements $x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_385$.",
    "output": "postulate nat_rect_Type1 : (Q_ : (_x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type1) -> (_H_O : cic.Term univs.Type1 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_388 : cic.Term univs.Type1 (Q_ x_386)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_nat.S x_386))) -> (x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type1 (Q_ x_385)"
  }
]