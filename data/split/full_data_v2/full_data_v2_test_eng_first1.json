[
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop30. For all instances $n$ of natural numbers, if we can prove that $n$ is odd, then we can prove that the sum of $n$ and $1$ is even.",
    "output": "prop30 : (n : Elem Nat) -> Proof (odd n) -> Proof (even (plus n 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop30. For all instances $n$ of natural numbers, if we can prove that $n$ is odd, then we can prove that the sum of $n$ and $1$ is even.",
    "output": "postulate prop30 : (n : Nat) -> odd n -> even (plus n 1)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prop30. For all instances $n$ of natural numbers, if we can prove that $n$ is odd, then we can prove that the sum of $n$ and $1$ is even.",
    "output": "Axiom prop30 : forall n : nat, (odd n -> even (n + 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prop30. For all instances $n$ of natural numbers, if we can prove that $n$ is odd, then we can prove that the sum of $n$ and $1$ is even.",
    "output": "axiom prop30 (n : Nat) (x : odd n) : even (n + 1)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_rect_CProp1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_631$, for all elements $x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_630$.",
    "output": "option_rect_CProp1_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_631 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) -> x_630 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_630) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_CProp1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_631$, for all elements $x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_630$.",
    "output": "postulate option_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) -> (x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_630)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Option_rect_CProp1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_631$, for all elements $x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_630$.",
    "output": "Axiom option_rect_CProp1_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))), forall x_630 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_630) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Option_rect_CProp1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_631$, for all elements $x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_630$.",
    "output": "axiom option_rect_CProp1_body (_A : cic.Univ univs.Type0) (Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) (x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_630)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop90. For all instances $n$ of natural numbers, we can prove that if $n$ is even and $n$ is prime, then $n$ is equal to $2$.",
    "output": "prop90 : (n : Elem Nat) -> Proof (if (and (even n) (prime n)) (Eq n 2)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop90. For all instances $n$ of natural numbers, we can prove that if $n$ is even and $n$ is prime, then $n$ is equal to $2$.",
    "output": "postulate prop90 : (n : Nat) -> if (and (even n) (prime n)) (Eq n 2)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prop90. For all instances $n$ of natural numbers, we can prove that if $n$ is even and $n$ is prime, then $n$ is equal to $2$.",
    "output": "Axiom prop90 : forall n : nat, (even n /\\ prime n -> n = 2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prop90. For all instances $n$ of natural numbers, we can prove that if $n$ is even and $n$ is prime, then $n$ is equal to $2$.",
    "output": "axiom prop90 (n : Nat) : even n ∧ prime n → n = 2"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "def same_parity : Elem Int -> Elem Int -> Prop := x => y => or (and (even x) (even y)) (and (odd x) (odd y)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "same_parity : Int -> Int -> Prop\nsame_parity = \\ x -> \\ y -> or (and (even x) (even y)) (and (odd x) (odd y))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "Definition same_parity (x y : Int) : Prop := even x /\\ even y \\/ (odd x /\\ odd y) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "def same_parity (x y : Int) : Prop := even x ∧ even y ∨ (odd x ∧ odd y)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Refute_none_by_refl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $E$ to $matita_basics_logic.match_False$ applied to $univs.Type0$ and the function that maps $_0$ to $B$ and $H$ applied to $E$ and the function that maps $v$ and $_0$ to $P$ applied to $v$ and $x$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$.",
    "output": "refute_none_by_refl : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> Q : (__ : cic.Term univs.Type0 B -> cic.Univ univs.Type0) -> x : cic.Term univs.Type0 (matita_basics_types.option A) -> H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> cic.Term cic.prop matita_basics_logic.False) -> __ : (v : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v)) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (y : cic.Term univs.Type0 (matita_basics_types.option A) => cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) => B)) (E : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) => matita_basics_logic.match_False univs.Type0 (_0 : cic.Term cic.prop matita_basics_logic.False => B) (H E)) (v : cic.Term univs.Type0 A => _0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v)) => P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Refute_none_by_refl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $E$ to $matita_basics_logic.match_False$ applied to $univs.Type0$ and the function that maps $_0$ to $B$ and $H$ applied to $E$ and the function that maps $v$ and $_0$ to $P$ applied to $v$ and $x$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$.",
    "output": "postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\\ y : cic.Term univs.Type0 (matita_basics_types.option A) -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B)) (\\ E : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> matita_basics_logic.match_False univs.Type0 (\\ _0 : cic.Term cic.prop matita_basics_logic.False -> B) (H E)) (\\ v : cic.Term univs.Type0 A -> \\ _0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v)) -> P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Refute_none_by_refl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $E$ to $matita_basics_logic.match_False$ applied to $univs.Type0$ and the function that maps $_0$ to $B$ and $H$ applied to $E$ and the function that maps $v$ and $_0$ to $P$ applied to $v$ and $x$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$.",
    "output": "Axiom refute_none_by_refl : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall Q : ((__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0), forall x : cic.Term univs.Type0 (matita_basics_types.option A), forall H : ((__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False), forall __ : ((v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))), cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (fun y => cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (fun __1 => B)) (fun E => matita_basics_logic.match_False univs.Type0 (fun _0 => B) (H E)) (fun v => fun _0 => P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Refute_none_by_refl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $E$ to $matita_basics_logic.match_False$ applied to $univs.Type0$ and the function that maps $_0$ to $B$ and $H$ applied to $E$ and the function that maps $v$ and $_0$ to $P$ applied to $v$ and $x$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$.",
    "output": "axiom refute_none_by_refl (A B : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) : cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (λ y => cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (λ __1 => B)) (λ E => matita_basics_logic.match_False univs.Type0 (λ _0 => B) (H E)) (λ v => λ _0 => P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "NoLabel_17. We can prove that for all integers $n$, if $n$ is even, then the product of $3$ and the exponentiation of $n$ and $5$ is even.",
    "output": "noLabel_17 : Proof (forall Int (n => if (even n) (even (times (nd 3) (pow n (nd 5)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_17. We can prove that for all integers $n$, if $n$ is even, then the product of $3$ and the exponentiation of $n$ and $5$ is even.",
    "output": "postulate noLabel_17 : all Int (\\ n -> if (even n) (even (times 3 (pow n 5))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "NoLabel_17. We can prove that for all integers $n$, if $n$ is even, then the product of $3$ and the exponentiation of $n$ and $5$ is even.",
    "output": "Axiom noLabel_17 : forall n : Int, (even n -> even (3 * pow n 5)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "NoLabel_17. We can prove that for all integers $n$, if $n$ is even, then the product of $3$ and the exponentiation of $n$ and $5$ is even.",
    "output": "axiom noLabel_17 : ∀ n : Int, (even n → even (3 * pow n 5))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "NoLabel_20. We can prove that for all integers $b$, for all integers $a$, for all integers $c$, if $a$ is odd and $c$ is odd, then the sum of the product of $a$ and $b$ and the product of $b$ and $c$ is even.",
    "output": "noLabel_20 : Proof (forall Int (b => forall Int (a => forall Int (c => if (and (odd a) (odd c)) (even (plus (times a b) (times b c))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_20. We can prove that for all integers $b$, for all integers $a$, for all integers $c$, if $a$ is odd and $c$ is odd, then the sum of the product of $a$ and $b$ and the product of $b$ and $c$ is even.",
    "output": "postulate noLabel_20 : all Int (\\ b -> all Int (\\ a -> all Int (\\ c -> if (and (odd a) (odd c)) (even (plus (times a b) (times b c))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "NoLabel_20. We can prove that for all integers $b$, for all integers $a$, for all integers $c$, if $a$ is odd and $c$ is odd, then the sum of the product of $a$ and $b$ and the product of $b$ and $c$ is even.",
    "output": "Axiom noLabel_20 : forall b : Int, forall a : Int, forall c : Int, (odd a /\\ odd c -> even (a * b + b * c)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "NoLabel_20. We can prove that for all integers $b$, for all integers $a$, for all integers $c$, if $a$ is odd and $c$ is odd, then the sum of the product of $a$ and $b$ and the product of $b$ and $c$ is even.",
    "output": "axiom noLabel_20 : ∀ b : Int, ∀ a : Int, ∀ c : Int, (odd a ∧ odd c → even (a * b + b * c))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_642$.",
    "output": "DPair_rect_Type5_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type5) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type5 (Q_ x_642) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_642$.",
    "output": "postulate DPair_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type5 (Q_ x_642)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "DPair_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_642$.",
    "output": "Axiom DPair_rect_Type5_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type5 (Q_ x_642) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "DPair_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_642$.",
    "output": "axiom DPair_rect_Type5_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type5 (Q_ x_642)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.",
    "output": "DPair_rect_Type0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type0) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type0 (Q_ x_650) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.",
    "output": "postulate DPair_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "DPair_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.",
    "output": "Axiom DPair_rect_Type0_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type0 (Q_ x_650) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "DPair_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.",
    "output": "axiom DPair_rect_Type0_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type0 (Q_ x_650)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "NoLabel_68. For all instances $n$ of integers, we can prove that if the difference of the product of $3$ and $n$ and $8$ is odd, then $n$ is odd.",
    "output": "noLabel_68 : n : Elem Int -> Proof (if (odd (minus (times (nd 3) n) (nd 8))) (odd n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "NoLabel_68. For all instances $n$ of integers, we can prove that if the difference of the product of $3$ and $n$ and $8$ is odd, then $n$ is odd.",
    "output": "postulate noLabel_68 : (n : Int) -> if (odd (minus (times 3 n) 8)) (odd n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "NoLabel_68. For all instances $n$ of integers, we can prove that if the difference of the product of $3$ and $n$ and $8$ is odd, then $n$ is odd.",
    "output": "Axiom noLabel_68 : forall n : Int, (odd (3 * n - 8) -> odd n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "NoLabel_68. For all instances $n$ of integers, we can prove that if the difference of the product of $3$ and $n$ and $8$ is odd, then $n$ is odd.",
    "output": "axiom noLabel_68 (n : Int) : odd (3 * n - 8) → odd n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DPair_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1110$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1111$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "DPair_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ univs.Type4) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DPair_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1110$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1111$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "DPair_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1110$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1111$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "Axiom DPair_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "DPair_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1110$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1111$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "axiom DPair_inv_rect_Type4 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max. If $Sort$, then if $Sort$, then $Sort$.",
    "output": "max : Sort -> Sort -> Sort ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. If $Sort$, then if $Sort$, then $Sort$.",
    "output": "postulate max : Sort -> Sort -> Sort"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Max. If $Sort$, then if $Sort$, then $Sort$.",
    "output": "Axiom max : Sort -> Sort -> Sort ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Max. If $Sort$, then if $Sort$, then $Sort$.",
    "output": "axiom max (x y : Sort) : Sort"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_Sig : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Filter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_Sig : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Filter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_Sig (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.",
    "output": "bigop_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.false) B nil op (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) nil) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.",
    "output": "postulate bigop_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.false) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) nil)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Bigop_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.",
    "output": "Axiom bigop_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : ((__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (fun i => matita_basics_bool.false) B nil op (fun i => f i)) nil) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Bigop_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.",
    "output": "axiom bigop_false (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.false) B nil op (λ i => f i)) nil)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_863$.",
    "output": "Aop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type4 (Q_ x_863) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_863$.",
    "output": "postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_863)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_863$.",
    "output": "Axiom Aop_rect_Type4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term univs.Type4 (Q_ x_863) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_863$.",
    "output": "axiom Aop_rect_Type4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type4 (Q_ x_863)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "Aop_rect_CProp3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_879) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_879)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "Axiom Aop_rect_CProp3 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_879) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "axiom Aop_rect_CProp3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_879)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_885$.",
    "output": "Aop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_885) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_885$.",
    "output": "postulate Aop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_885)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_885$.",
    "output": "Axiom Aop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_885) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_885$.",
    "output": "axiom Aop_rect_CProp0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_885)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sig_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z43$ to $P$ and $y$ and $x$.",
    "output": "Sig_discr : a1 : cic.Univ univs.Type0 -> a2 : (__ : cic.Term univs.Type0 a1 -> cic.Univ cic.prop) -> x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 a1 => t1 : cic.Term cic.prop (a2 t0) => matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 a1 => u1 : cic.Term cic.prop (a2 u0) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (x_19 : cic.Term univs.Type0 a1 => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) => a2 x0) x_19 _x_20)) t1 u0 e0) u1) (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (x_19 : cic.Term univs.Type0 a1 => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) => a2 x0) x_19 _x_20)) t1 u0 e0) u1) => P))) (_z43 : (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (x_19 : cic.Term univs.Type0 a1 => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) => a2 x0) x_19 _x_20)) t1 u0 e0) u1) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sig_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z43$ to $P$ and $y$ and $x$.",
    "output": "postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term cic.prop (a2 t0) -> matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term cic.prop (a2 u0) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2 x0) x_19 _x_20)) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2 x0) x_19 _x_20)) t1 u0 e0) u1) -> P))) (\\ _z43 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2 x0) x_19 _x_20)) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sig_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z43$ to $P$ and $y$ and $x$.",
    "output": "Axiom Sig_discr : forall a1 : cic.Univ univs.Type0, forall a2 : ((__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop), forall x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((fun x0 => fun p0 => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (fun x_19 => fun _x_20 => cic.lift cic.prop univs.Type0 ((fun x0 => fun p0 => a2 x0) x_19 _x_20)) t1 u0 e0) u1) (fun _e1 => P))) (fun _z43 => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sig_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z43$ to $P$ and $y$ and $x$.",
    "output": "axiom Sig_discr (a1 : cic.Univ univs.Type0) (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) (x y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((λ x0 => λ p0 => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (λ x_19 => λ _x_20 => cic.lift cic.prop univs.Type0 ((λ x0 => λ p0 => a2 x0) x_19 _x_20)) t1 u0 e0) u1) (λ _e1 => P))) (λ _z43 => P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_Prod : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Filter_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_Prod : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Filter_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_Prod (_A _B : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type1) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom Aop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "axiom Aop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "Prod_rect_Type5 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type5) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type5 (Q_ x_694) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "postulate Prod_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type5 (Q_ x_694)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prod_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "Axiom Prod_rect_Type5 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type5 (Q_ x_694) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prod_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "axiom Prod_rect_Type5 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type5 (Q_ x_694)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Aop_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Aop_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "dpi1__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1) -> cic.Univ univs.Type0) -> x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2) -> _x_887 : cic.Term univs.Type0 x0 -> _x_888 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "Axiom dpi1__o__op : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : ((__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0), forall x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2), forall _x_887 : cic.Term univs.Type0 x0, forall _x_888 : cic.Term univs.Type0 x0, cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "axiom dpi1__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) (_x_887 _x_888 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pad_bigop_nil. For all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $i$ and $nil$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "pad_bigop_nil : k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n k) -> __1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n i) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f i) nil))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) (matita_arithmetics_bigops.bigop k (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) B nil (matita_arithmetics_bigops.op B nil op) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pad_bigop_nil. For all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $i$ and $nil$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate pad_bigop_nil : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f i) nil))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Pad_bigop_nil. For all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $i$ and $nil$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "Axiom pad_bigop_nil : forall k : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n k), forall __1 : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f i) nil))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (fun i => p i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f i)) (matita_arithmetics_bigops.bigop k (fun i => p i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f i))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Pad_bigop_nil. For all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $i$ and $nil$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "axiom pad_bigop_nil (k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f i) nil))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ i => p i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f i)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.",
    "output": "Prod_rect_Type0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type0) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type0 (Q_ x_702) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.",
    "output": "postulate Prod_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type0 (Q_ x_702)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prod_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.",
    "output": "Axiom Prod_rect_Type0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type0 (Q_ x_702) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prod_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.",
    "output": "axiom Prod_rect_Type0_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type0 (Q_ x_702)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "Prod_rect_CProp3_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_708) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "postulate Prod_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_708)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "Axiom Prod_rect_CProp3_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_708) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "axiom Prod_rect_CProp3_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_708)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "snd : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate snd : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "Axiom snd : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B), cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "axiom snd (A B : cic.Univ univs.Type0) (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) : cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1242$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1243$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "Prod_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type4) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1242$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1243$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prod_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1242$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1243$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "Axiom Prod_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prod_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1242$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1243$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "axiom Prod_inv_rect_Type4 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1290$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1291$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Prod_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ cic.prop) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1290$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1291$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prod_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1290$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1291$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Prod_inv_rect_CProp1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prod_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1290$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1291$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Prod_inv_rect_CProp1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1296$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1297$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Prod_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ cic.prop) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1296$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1297$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prod_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1296$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1297$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Prod_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prod_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1296$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1297$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Prod_inv_rect_CProp0 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prod_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $a2$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z45$ to $P$ and $y$ and $x$.",
    "output": "Prod_discr : a1 : cic.Univ univs.Type0 -> a2 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 a1 => t1 : cic.Term univs.Type0 a2 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 a1 => u1 : cic.Term univs.Type0 a2 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) => a2) t1 u0 e0) u1) (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) => a2) t1 u0 e0) u1) => P))) (_z45 : (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) => a2) t1 u0 e0) u1) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prod_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $a2$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z45$ to $P$ and $y$ and $x$.",
    "output": "postulate Prod_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1) -> P))) (\\ _z45 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prod_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $a2$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z45$ to $P$ and $y$ and $x$.",
    "output": "Axiom Prod_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((fun x0 => fun p0 => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (fun x0 => fun p0 => a2) t1 u0 e0) u1) (fun _e1 => P))) (fun _z45 => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prod_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $a2$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z45$ to $P$ and $y$ and $x$.",
    "output": "axiom Prod_discr (a1 a2 : cic.Univ univs.Type0) (x y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((λ x0 => λ p0 => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (λ x0 => λ p0 => a2) t1 u0 e0) u1) (λ _e1 => P))) (λ _z45 => P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Extract_pair. For all elements $A$ and $B$ and $C$ and $D$ of $cic.Univ$ of $univs.Type0$, for all elements $u$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $C$ and $D$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $C$, for all elements $y$ of $cic.Term$ of $univs.Type0$ and $D$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $__$ to $matita_basics_types.Prod$ applied to $C$ and $D$ and the function that maps $a$ and $b$ to $Q$ applied to $a$ and $b$ and $u$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $B$ and the function that maps $b$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $u$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $Q$ applied to $a$ and $b$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$.",
    "output": "extract_pair : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> D : cic.Univ univs.Type0 -> u : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> Q : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> x : cic.Term univs.Type0 C -> y : cic.Term univs.Type0 D -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B) => matita_basics_types.Prod C D) (a : cic.Term univs.Type0 A => b : cic.Term univs.Type0 B => Q a b) u) (matita_basics_types.mk_Prod C D x y)) -> cic.Term cic.prop (matita_basics_logic.ex A (a : cic.Term univs.Type0 A => matita_basics_logic.ex B (b : cic.Term univs.Type0 B => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Extract_pair. For all elements $A$ and $B$ and $C$ and $D$ of $cic.Univ$ of $univs.Type0$, for all elements $u$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $C$ and $D$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $C$, for all elements $y$ of $cic.Term$ of $univs.Type0$ and $D$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $__$ to $matita_basics_types.Prod$ applied to $C$ and $D$ and the function that maps $a$ and $b$ to $Q$ applied to $a$ and $b$ and $u$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $B$ and the function that maps $b$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $u$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $Q$ applied to $a$ and $b$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$.",
    "output": "postulate extract_pair : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (D : cic.Univ univs.Type0) -> (u : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (Q : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> (x : cic.Term univs.Type0 C) -> (y : cic.Term univs.Type0 D) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> matita_basics_types.Prod C D) (\\ a : cic.Term univs.Type0 A -> \\ b : cic.Term univs.Type0 B -> Q a b) u) (matita_basics_types.mk_Prod C D x y))) -> cic.Term cic.prop (matita_basics_logic.ex A (\\ a : cic.Term univs.Type0 A -> matita_basics_logic.ex B (\\ b : cic.Term univs.Type0 B -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Extract_pair. For all elements $A$ and $B$ and $C$ and $D$ of $cic.Univ$ of $univs.Type0$, for all elements $u$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $C$ and $D$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $C$, for all elements $y$ of $cic.Term$ of $univs.Type0$ and $D$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $__$ to $matita_basics_types.Prod$ applied to $C$ and $D$ and the function that maps $a$ and $b$ to $Q$ applied to $a$ and $b$ and $u$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $B$ and the function that maps $b$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $u$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $Q$ applied to $a$ and $b$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$.",
    "output": "Axiom extract_pair : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall C : cic.Univ univs.Type0, forall D : cic.Univ univs.Type0, forall u : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall Q : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod C D)), forall x : cic.Term univs.Type0 C, forall y : cic.Term univs.Type0 D, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (fun __ => matita_basics_types.Prod C D) (fun a => fun b => Q a b) u) (matita_basics_types.mk_Prod C D x y)), cic.Term cic.prop (matita_basics_logic.ex A (fun a => matita_basics_logic.ex B (fun b => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Extract_pair. For all elements $A$ and $B$ and $C$ and $D$ of $cic.Univ$ of $univs.Type0$, for all elements $u$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $C$ and $D$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $C$, for all elements $y$ of $cic.Term$ of $univs.Type0$ and $D$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $__$ to $matita_basics_types.Prod$ applied to $C$ and $D$ and the function that maps $a$ and $b$ to $Q$ applied to $a$ and $b$ and $u$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $B$ and the function that maps $b$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $u$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $Q$ applied to $a$ and $b$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$.",
    "output": "axiom extract_pair (A B C D : cic.Univ univs.Type0) (u : cic.Term univs.Type0 (matita_basics_types.Prod A B)) (Q : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) (x : cic.Term univs.Type0 C) (y : cic.Term univs.Type0 D) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (λ __ => matita_basics_types.Prod C D) (λ a => λ b => Q a b) u) (matita_basics_types.mk_Prod C D x y))) : cic.Term cic.prop (matita_basics_logic.ex A (λ a => matita_basics_logic.ex B (λ b => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y)))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "ACop_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type2) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate ACop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "ACop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Axiom ACop_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "ACop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "axiom ACop_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Type2. $cic.Sort$.",
    "output": "Type2 : cic.Sort ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Type2. $cic.Sort$.",
    "output": "postulate Type2 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Type2. $cic.Sort$.",
    "output": "Axiom Type2 : cic.Sort ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Type2. $cic.Sort$.",
    "output": "axiom Type2 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Type3. $cic.Sort$.",
    "output": "Type3 : cic.Sort ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Type3. $cic.Sort$.",
    "output": "postulate Type3 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Type3. $cic.Sort$.",
    "output": "Axiom Type3 : cic.Sort ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Type3. $cic.Sort$.",
    "output": "axiom Type3 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "aop__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1) -> _x_887 : cic.Term univs.Type0 x0 -> _x_888 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "postulate aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "Axiom aop__o__op : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1), forall _x_887 : cic.Term univs.Type0 x0, forall _x_888 : cic.Term univs.Type0 x0, cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "axiom aop__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) (_x_887 _x_888 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "mk_range : A : cic.Univ univs.Type0 -> _enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "Axiom mk_range : forall A : cic.Univ univs.Type0, forall _enum : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _filter : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 (matita_arithmetics_bigops.range A) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "axiom mk_range (A : cic.Univ univs.Type0) (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mk_Aop. For all sets $A$, for all elements $nil$ of $A$, for all functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$, for all functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $Aop$ holds for $A$ and $nil$.",
    "output": "mk_Aop : A : Set -> nil : A -> op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op nil a) a) -> _nilr : (a : A -> Eq (op a nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Aop A nil ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mk_Aop. For all sets $A$, for all elements $nil$ of $A$, for all functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$, for all functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $Aop$ holds for $A$ and $nil$.",
    "output": "postulate mk_Aop : (A : Set) -> (nil : A) -> (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op nil a) a) -> (_nilr : (a : A) -> Eq (op a nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Aop A nil"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Mk_Aop. For all sets $A$, for all elements $nil$ of $A$, for all functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$, for all functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $Aop$ holds for $A$ and $nil$.",
    "output": "Axiom mk_Aop : forall A : Set, forall nil : A, forall op : ((x__ : A) -> (__1 : A) -> A), forall _nill : ((a : A) -> op nil a = a), forall _nilr : ((a : A) -> op a nil = a), forall _assoc : ((a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c), Aop A nil ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Mk_Aop. For all sets $A$, for all elements $nil$ of $A$, for all functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$, for all functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $Aop$ holds for $A$ and $nil$.",
    "output": "axiom mk_Aop (A : Set) (nil : A) (op : (x__ : A) -> (__1 : A) -> A) (_nill : (a : A) -> op nil a = a) (_nilr : (a : A) -> op a nil = a) (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) : Aop A nil"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_861$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_861$.",
    "output": "Aop_ind : A : Set -> _nil : A -> Q_ : (_x_861 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_861 : Aop A _nil -> Q_ x_861 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_861$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_861$.",
    "output": "postulate Aop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_861 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_861 : Aop A _nil) -> Q_ x_861"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_861$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_861$.",
    "output": "Axiom Aop_ind : forall A : Set, forall _nil : A, forall Q_ : ((_x_861 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_861 : Aop A _nil, Q_ x_861 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_861$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_861$.",
    "output": "axiom Aop_ind (A : Set) (_nil : A) (Q_ : (_x_861 : Aop A _nil) -> Prop) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_861 : Aop A _nil) : Q_ x_861"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "range_rect_Type0 : _A : cic.Univ univs.Type0 -> Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type0) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type0 (Q_ x_927) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "postulate range_rect_Type0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type0 (Q_ x_927)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Range_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "Axiom range_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type0 (Q_ x_927) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Range_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "axiom range_rect_Type0 (_A : cic.Univ univs.Type0) (Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type0 (Q_ x_927)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "Aop_rect_Type3_body : A : Set -> _nil : A -> Q_ : (_x_867 : Aop A _nil -> Type3) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "postulate Aop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_Type3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "Axiom Aop_rect_Type3_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_867 : Aop A _nil) -> Type3), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_867 : Aop A _nil, Q_ x_867 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_Type3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "axiom Aop_rect_Type3_body (A : Set) (_nil : A) (Q_ : (_x_867 : Aop A _nil) -> Type3) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_867 : Aop A _nil) : Q_ x_867"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "Aop_rect_Type0 : A : Set -> _nil : A -> Q_ : (_x_873 : Aop A _nil -> Set) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_873 : Aop A _nil -> Q_ x_873 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "Axiom Aop_rect_Type0 : forall A : Set, forall _nil : A, forall Q_ : ((_x_873 : Aop A _nil) -> Set), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_873 : Aop A _nil, Q_ x_873 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "axiom Aop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_873 : Aop A _nil) -> Set) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_873 : Aop A _nil) : Q_ x_873"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.",
    "output": "Aop_rect_CProp4 : A : Set -> _nil : A -> Q_ : (_x_875 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_875 : Aop A _nil -> Q_ x_875 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.",
    "output": "postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_CProp4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.",
    "output": "Axiom Aop_rect_CProp4 : forall A : Set, forall _nil : A, forall Q_ : ((_x_875 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_875 : Aop A _nil, Q_ x_875 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_CProp4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.",
    "output": "axiom Aop_rect_CProp4 (A : Set) (_nil : A) (Q_ : (_x_875 : Aop A _nil) -> Prop) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_875 : Aop A _nil) : Q_ x_875"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Enum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "enum : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Enum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Enum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "Axiom enum : forall A : cic.Univ univs.Type0, forall _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Enum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "axiom enum (A : cic.Univ univs.Type0) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1644$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1645$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "range_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ univs.Type3) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1644$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1645$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Range_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1644$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1645$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "Axiom range_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term univs.Type3 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Range_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1644$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1645$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "axiom range_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Op_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.",
    "output": "op_body : A : Set -> nil : A -> _xxx : Aop A nil -> _x_887 : A -> _x_888 : A -> A ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Op_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.",
    "output": "postulate op_body : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Op_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.",
    "output": "Axiom op_body : forall A : Set, forall nil : A, forall _xxx : Aop A nil, forall _x_887 : A, forall _x_888 : A, A ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Op_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.",
    "output": "axiom op_body (A : Set) (nil : A) (_xxx : Aop A nil) (_x_887 _x_888 : A) : A"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "range_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Range_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom range_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Range_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom range_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iso. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "iso : A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iso. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "postulate iso : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Iso. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "Axiom iso : forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Iso. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "axiom iso (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sub_hkO. For all functions $h$ and $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $I$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $A$ and $I$ and $J$.",
    "output": "sub_hkO : h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> A : cic.Univ univs.Type0 -> I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A I J) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_hkO. For all functions $h$ and $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $I$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $A$ and $I$ and $J$.",
    "output": "postulate sub_hkO : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A I J)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sub_hkO. For all functions $h$ and $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $I$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $A$ and $I$ and $J$.",
    "output": "Axiom sub_hkO : forall h : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, forall I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O), cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A I J) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sub_hkO. For all functions $h$ and $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $I$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $A$ and $I$ and $J$.",
    "output": "axiom sub_hkO (h k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (A : cic.Univ univs.Type0) (I J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A I J)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Dop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom Dop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom Dop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "Aop_inv_rect_CProp0 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1560 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1560 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "Axiom Aop_inv_rect_CProp0 : forall x1 : Set, forall x2 : x1, forall Hterm : Aop x1 x2, forall P : ((_z1560 : Aop x1 x2) -> Prop), forall _H1 : ((op : (x__ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> op x2 a = a) -> (_nilr : (a : x1) -> op a x2 = a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> op a (op b c) = op (op a b) c) -> (_z1561 : Hterm = mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)), P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "axiom Aop_inv_rect_CProp0 (x1 : Set) (x2 : x1) (Hterm : Aop x1 x2) (P : (_z1560 : Aop x1 x2) -> Prop) (_H1 : (op : (x__ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> op x2 a = a) -> (_nilr : (a : x1) -> op a x2 = a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> op a (op b c) = op (op a b) c) -> (_z1561 : Hterm = mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_discr. For all sets $a1$, for all elements $a2$ of $a1$, for all elements $x$ and $y$ of $Aop$ of $a1$ and $a2$, if $x$ is equal to $y$, then $match_Aop$ holds for $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $match_Aop$ applied to $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R3$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $b$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $c$ to $Eq$ applied to $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z55$ to $P$ and $y$ and $x$.",
    "output": "Aop_discr : a1 : Set -> a2 : a1 -> x : Aop a1 a2 -> y : Aop a1 a2 -> _e : Eq x y -> match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (t0 : (__ : a1 -> __1 : a1 -> a1) => t1 : (a : a1 -> Eq (t0 a2 a) a) => t2 : (a : a1 -> Eq (t0 a a2) a) => t3 : (a : a1 -> b : a1 -> c : a1 -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) => match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (u0 : (__ : a1 -> __1 : a1 -> a1) => u1 : (a : a1 -> Eq (u0 a2 a) a) => u2 : (a : a1 -> Eq (u0 a a2) a) => u3 : (a : a1 -> b : a1 -> c : a1 -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0) (e0 : Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0 => prod Prop Type1 (Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (e1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) (e2 : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 => prod Prop Type1 (Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 => P))))) (_z55 : (e0 : Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0 -> e1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 -> e2 : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 -> _e3 : Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 -> P) => P))) y) x ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_discr. For all sets $a1$, for all elements $a2$ of $a1$, for all elements $x$ and $y$ of $Aop$ of $a1$ and $a2$, if $x$ is equal to $y$, then $match_Aop$ holds for $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $match_Aop$ applied to $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R3$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $b$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $c$ to $Eq$ applied to $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z55$ to $P$ and $y$ and $x$.",
    "output": "postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ t0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ t1 : ((a : a1) -> Eq (t0 a2 a) a) -> \\ t2 : ((a : a1) -> Eq (t0 a a2) a) -> \\ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ u0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ u1 : ((a : a1) -> Eq (u0 a2 a) a) -> \\ u2 : ((a : a1) -> Eq (u0 a a2) a) -> \\ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0) (\\ e0 : Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) (\\ e2 : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 -> prod Prop Type1 (Eq (R3 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> \\ x2 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 p1 -> \\ _ : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x01 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 __) t1 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 p01 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : ((a : a1) -> Eq (x02 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> \\ x21 : ((a : a1) -> Eq (x01 a a2) a) -> \\ p2 : Eq (R2 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ __1 : Eq t0 x02 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 __1) t1 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 p02 -> \\ __1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> \\ x10 : ((a : a1) -> Eq (x00 a2 a) a) -> \\ p10 : Eq (R1 (prod Set Set a1 (\\ __2 : a1 -> prod Set Set a1 (\\ __3 : a1 -> a1))) t0 (\\ x_19 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x011 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p011 : Eq t0 x011 -> prod Set Prop a1 (\\ a : a1 -> Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 -> prod Set Prop a1 (\\ a : a1 -> prod Set Prop a1 (\\ b : a1 -> prod Set Prop a1 (\\ c : a1 -> Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) (\\ _e3 : Eq (R3 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> \\ x2 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 p1 -> \\ _ : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x01 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 __) t1 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 p01 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : ((a : a1) -> Eq (x02 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> \\ x21 : ((a : a1) -> Eq (x01 a a2) a) -> \\ p2 : Eq (R2 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ __1 : Eq t0 x02 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 __1) t1 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 p02 -> \\ __1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> \\ x10 : ((a : a1) -> Eq (x00 a2 a) a) -> \\ p10 : Eq (R1 (prod Set Set a1 (\\ __2 : a1 -> prod Set Set a1 (\\ __3 : a1 -> a1))) t0 (\\ x_19 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x011 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p011 : Eq t0 x011 -> prod Set Prop a1 (\\ a : a1 -> Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 -> prod Set Prop a1 (\\ a : a1 -> prod Set Prop a1 (\\ b : a1 -> prod Set Prop a1 (\\ c : a1 -> Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 -> P))))) (\\ _z55 : ((e0 : Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0) -> (e1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) -> (e2 : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) -> (_e3 : Eq (R3 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> \\ x2 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 p1 -> \\ _ : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x01 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 __) t1 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 p01 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : ((a : a1) -> Eq (x02 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> \\ x21 : ((a : a1) -> Eq (x01 a a2) a) -> \\ p2 : Eq (R2 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ __1 : Eq t0 x02 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 __1) t1 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 p02 -> \\ __1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> \\ x10 : ((a : a1) -> Eq (x00 a2 a) a) -> \\ p10 : Eq (R1 (prod Set Set a1 (\\ __2 : a1 -> prod Set Set a1 (\\ __3 : a1 -> a1))) t0 (\\ x_19 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x011 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p011 : Eq t0 x011 -> prod Set Prop a1 (\\ a : a1 -> Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 -> prod Set Prop a1 (\\ a : a1 -> prod Set Prop a1 (\\ b : a1 -> prod Set Prop a1 (\\ c : a1 -> Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) -> P) -> P))) y) x"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_discr. For all sets $a1$, for all elements $a2$ of $a1$, for all elements $x$ and $y$ of $Aop$ of $a1$ and $a2$, if $x$ is equal to $y$, then $match_Aop$ holds for $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $match_Aop$ applied to $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R3$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $b$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $c$ to $Eq$ applied to $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z55$ to $P$ and $y$ and $x$.",
    "output": "Axiom Aop_discr : forall a1 : Set, forall a2 : a1, forall x : Aop a1 a2, forall y : Aop a1 a2, forall _e : (x = y), match_Aop a1 a2 (Type2 + 1) (fun x__ => univ Type2) (fun t0 => fun t1 => fun t2 => fun t3 => match_Aop a1 a2 (Type2 + 1) (fun x__ => univ Type2) (fun u0 => fun u1 => fun u2 => fun u3 => prod (Type1 + 1) Type1 (univ Type1) (fun P => prod Type1 Type1 (prod Prop Type1 (R0 (prod Set Set a1 (fun x__ => prod Set Set a1 (fun __1 => a1))) t0 = u0) (fun e0 => prod Prop Type1 (R1 (prod Set Set a1 (fun x__ => prod Set Set a1 (fun __1 => a1))) t0 (fun x_19 => fun _x_20 => (fun x0 => fun p0 => prod Set Prop a1 (fun a => x0 a2 a = a)) x_19 _x_20) t1 u0 e0 = u1) (fun e1 => prod Prop Type1 (R2 (prod Set Set a1 (fun x__ => prod Set Set a1 (fun __1 => a1))) t0 (fun x0 => fun x__ => (fun x01 => fun p0 => prod Set Prop a1 (fun a => x01 a2 a = a)) x0 x__) t1 (fun x0 => fun p0 => fun x1 => fun x__ => (fun x01 => fun p01 => fun x11 => fun p1 => prod Set Prop a1 (fun a => x01 a a2 = a)) x0 p0 x1 x__) t2 u0 e0 u1 e1 = u2) (fun e2 => prod Prop Type1 (R3 (prod Set Set a1 (fun x__ => prod Set Set a1 (fun __1 => a1))) t0 (fun x0 => fun x__ => (fun x01 => fun p0 => prod Set Prop a1 (fun a => x01 a2 a = a)) x0 x__) t1 (fun x0 => fun p0 => fun x1 => fun x__ => (fun x01 => fun p01 => fun x11 => fun p1 => prod Set Prop a1 (fun a => x01 a a2 = a)) x0 p0 x1 x__) t2 (fun x0 => fun p0 => fun x1 => fun p1 => fun x2 => fun x__ => (fun x01 => fun p01 => fun x11 => fun p11 => fun x21 => fun p2 => prod Set Prop a1 (fun a => prod Set Prop a1 (fun b => prod Set Prop a1 (fun c => x01 a (x01 b c) = x01 (x01 a b) c)))) x0 p0 x1 p1 x2 x__) t3 u0 e0 u1 e1 u2 e2 = u3) (fun _e3 => P))))) (fun _z55 => P))) y) x ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_discr. For all sets $a1$, for all elements $a2$ of $a1$, for all elements $x$ and $y$ of $Aop$ of $a1$ and $a2$, if $x$ is equal to $y$, then $match_Aop$ holds for $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $match_Aop$ applied to $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R3$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $b$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $c$ to $Eq$ applied to $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z55$ to $P$ and $y$ and $x$.",
    "output": "axiom Aop_discr (a1 : Set) (a2 : a1) (x y : Aop a1 a2) (_e : x = y) : match_Aop a1 a2 (Type2 + 1) (λ x__ => univ Type2) (λ t0 => λ t1 => λ t2 => λ t3 => match_Aop a1 a2 (Type2 + 1) (λ x__ => univ Type2) (λ u0 => λ u1 => λ u2 => λ u3 => prod (Type1 + 1) Type1 (univ Type1) (λ P => prod Type1 Type1 (prod Prop Type1 (R0 (prod Set Set a1 (λ x__ => prod Set Set a1 (λ __1 => a1))) t0 = u0) (λ e0 => prod Prop Type1 (R1 (prod Set Set a1 (λ x__ => prod Set Set a1 (λ __1 => a1))) t0 (λ x_19 => λ _x_20 => (λ x0 => λ p0 => prod Set Prop a1 (λ a => x0 a2 a = a)) x_19 _x_20) t1 u0 e0 = u1) (λ e1 => prod Prop Type1 (R2 (prod Set Set a1 (λ x__ => prod Set Set a1 (λ __1 => a1))) t0 (λ x0 => λ x__ => (λ x01 => λ p0 => prod Set Prop a1 (λ a => x01 a2 a = a)) x0 __) t1 (λ x0 => λ p0 => λ x1 => λ x__ => (λ x01 => λ p01 => λ x11 => λ p1 => prod Set Prop a1 (λ a => x01 a a2 = a)) x0 p0 x1 __) t2 u0 e0 u1 e1 = u2) (λ e2 => prod Prop Type1 (R3 (prod Set Set a1 (λ x__ => prod Set Set a1 (λ __1 => a1))) t0 (λ x0 => λ x__ => (λ x01 => λ p0 => prod Set Prop a1 (λ a => x01 a2 a = a)) x0 __) t1 (λ x0 => λ p0 => λ x1 => λ x__ => (λ x01 => λ p01 => λ x11 => λ p1 => prod Set Prop a1 (λ a => x01 a a2 = a)) x0 p0 x1 __) t2 (λ x0 => λ p0 => λ x1 => λ p1 => λ x2 => λ x__ => (λ x01 => λ p01 => λ x11 => λ p11 => λ x21 => λ p2 => prod Set Prop a1 (λ a => prod Set Prop a1 (λ b => prod Set Prop a1 (λ c => x01 a (x01 b c) = x01 (x01 a b) c)))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2 = u3) (λ _e3 => P))))) (λ _z55 => P))) y) x"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_951$.",
    "output": "Dop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type2 (Q_ x_951) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_951$.",
    "output": "postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_951$.",
    "output": "Axiom Dop_rect_Type2 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term univs.Type2 (Q_ x_951) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_951$.",
    "output": "axiom Dop_rect_Type2 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type2 (Q_ x_951)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "Dop_rect_Type1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type1 (Q_ x_953) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "Axiom Dop_rect_Type1 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term univs.Type1 (Q_ x_953) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "axiom Dop_rect_Type1 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type1 (Q_ x_953)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_961$.",
    "output": "Dop_rect_CProp3_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_961) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_961$.",
    "output": "postulate Dop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_961$.",
    "output": "Axiom Dop_rect_CProp3_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_961) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_961$.",
    "output": "axiom Dop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_961)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "ACop_rect_Type2_body : A : Set -> _nil : A -> Q_ : (_x_897 : ACop A _nil -> Type2) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_897 : ACop A _nil -> Q_ x_897 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "Axiom ACop_rect_Type2_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_897 : ACop A _nil) -> Type2), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)), forall x_897 : ACop A _nil, Q_ x_897 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "axiom ACop_rect_Type2_body (A : Set) (_nil : A) (Q_ : (_x_897 : ACop A _nil) -> Type2) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)) (x_897 : ACop A _nil) : Q_ x_897"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_967$.",
    "output": "Dop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_967) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_967$.",
    "output": "postulate Dop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_967)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_967$.",
    "output": "Axiom Dop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_967) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_967$.",
    "output": "axiom Dop_rect_CProp0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_967)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Null_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.",
    "output": "null_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Null_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.",
    "output": "postulate null_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Null_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.",
    "output": "Axiom null_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Null_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.",
    "output": "axiom null_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Distr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "distr : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Distr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "Axiom distr : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Distr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "axiom distr (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) (a b c : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ACop_rect_CProp0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_913$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_913$.",
    "output": "ACop_rect_CProp0 : A : Set -> _nil : A -> Q_ : (_x_913 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_913 : ACop A _nil -> Q_ x_913 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ACop_rect_CProp0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_913$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_913$.",
    "output": "postulate ACop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_913 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_913 : ACop A _nil) -> Q_ x_913"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "ACop_rect_CProp0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_913$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_913$.",
    "output": "Axiom ACop_rect_CProp0 : forall A : Set, forall _nil : A, forall Q_ : ((_x_913 : ACop A _nil) -> Prop), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)), forall x_913 : ACop A _nil, Q_ x_913 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "ACop_rect_CProp0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_913$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_913$.",
    "output": "axiom ACop_rect_CProp0 (A : Set) (_nil : A) (Q_ : (_x_913 : ACop A _nil) -> Prop) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)) (x_913 : ACop A _nil) : Q_ x_913"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Dop_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ univs.Type1) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom Dop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "axiom Dop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1734$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1735$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Dop_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1734$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1735$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1734$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1735$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Dop_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1734$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1735$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Dop_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "lt_O_bc : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "postulate lt_O_bc : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "Axiom lt_O_bc : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le m n), cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "axiom lt_O_bc (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bigop_diff. For all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i$ is less than $n$, then if $p$ applied to $i$ is equal to $true$, then $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "bigop_diff : p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (__ : Nat -> B) -> i : Nat -> n : Nat -> __ : Lt i n -> __1 : Eq (p i) true -> Eq (bigop n (x : Nat => p x) B nil (aop__o__op B nil op) (x : Nat => f x)) (aop__o__op B nil op (f i) (bigop n (x : Nat => andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (x : Nat => f x))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bigop_diff. For all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i$ is less than $n$, then if $p$ applied to $i$ is equal to $true$, then $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Bigop_diff. For all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i$ is less than $n$, then if $p$ applied to $i$ is equal to $true$, then $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "Axiom bigop_diff : forall p : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ACop B nil, forall f : ((x__ : nat) -> B), forall i : nat, forall n : nat, forall x__ : (i < n), forall __1 : (p i = true), bigop n (fun x => p x) B nil (aop__o__op B nil op) (fun x => f x) = aop__o__op B nil op (f i) (bigop n (fun x => andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (fun x => f x)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Bigop_diff. For all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i$ is less than $n$, then if $p$ applied to $i$ is equal to $true$, then $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "axiom bigop_diff (p : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : ACop B nil) (f : (x__ : Nat) -> B) (i n : Nat) (x__ : i < n) (__1 : p i = true) : bigop n (λ x => p x) B nil (aop__o__op B nil op) (λ x => f x) = aop__o__op B nil op (f i) (bigop n (λ x => andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (λ x => f x))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_range. For all sets $_A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $range$ of $_A$ to elements of $return_type$ of $z$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.",
    "output": "filter_range : _A : Set -> return_sort : Sort -> return_type : (z : range _A -> return_sort) -> return : (z : range _A -> return_type z) -> z : range _A -> return_type z ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_range. For all sets $_A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $range$ of $_A$ to elements of $return_type$ of $z$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.",
    "output": "postulate filter_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (return : (z : range _A) -> return_type z) -> (z : range _A) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Filter_range. For all sets $_A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $range$ of $_A$ to elements of $return_type$ of $z$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.",
    "output": "Axiom filter_range : forall _A : Set, forall return_sort : Sort, forall return_type : ((z : range _A) -> return_sort), forall return : ((z : range _A) -> return_type z), forall z : range _A, return_type z ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Filter_range. For all sets $_A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $range$ of $_A$ to elements of $return_type$ of $z$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.",
    "output": "axiom filter_range (_A : Set) (return_sort : Sort) (return_type : (z : range _A) -> return_sort) (return : (z : range _A) -> return_type z) (z : range _A) : return_type z"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.",
    "output": "not_exists_to_forall : P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i)))) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.Not (P i)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.",
    "output": "postulate not_exists_to_forall : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.Not (P i))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.",
    "output": "Axiom not_exists_to_forall : forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i)))), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n), cic.Term cic.prop (matita_basics_logic.Not (P i)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.",
    "output": "axiom not_exists_to_forall (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) : cic.Term cic.prop (matita_basics_logic.Not (P i))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_prim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $p$ and $matita_arithmetics_primes.prime$ applied to $p$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $q$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $p$ and the function that maps $__1$ to $matita_arithmetics_nat.le$ applied to $q$ and $n$.",
    "output": "min_prim : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (q : cic.Term univs.Type0 matita_arithmetics_nat.nat => cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime q) => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p) => matita_arithmetics_nat.le q n)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_prim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $p$ and $matita_arithmetics_primes.prime$ applied to $p$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $q$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $p$ and the function that maps $__1$ to $matita_arithmetics_nat.le$ applied to $q$ and $n$.",
    "output": "postulate min_prim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (\\ __ : cic.Term cic.prop (matita_arithmetics_primes.prime q) -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (\\ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p) -> matita_arithmetics_nat.le q n))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Min_prim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $p$ and $matita_arithmetics_primes.prime$ applied to $p$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $q$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $p$ and the function that maps $__1$ to $matita_arithmetics_nat.le$ applied to $q$ and $n$.",
    "output": "Axiom min_prim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun p => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun q => cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (fun __ => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (fun __1 => matita_arithmetics_nat.le q n)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Min_prim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $p$ and $matita_arithmetics_primes.prime$ applied to $p$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $q$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $p$ and the function that maps $__1$ to $matita_arithmetics_nat.le$ applied to $q$ and $n$.",
    "output": "axiom min_prim (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ p => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (λ q => cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (λ __ => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (λ __1 => matita_arithmetics_nat.le q n))))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Range_rect_CProp0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_939$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $range$ of $_A$, $Q_$ holds for $x_939$.",
    "output": "range_rect_CProp0_body : _A : Set -> Q_ : (_x_939 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_939 : range _A -> Q_ x_939 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Range_rect_CProp0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_939$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $range$ of $_A$, $Q_$ holds for $x_939$.",
    "output": "postulate range_rect_CProp0_body : (_A : Set) -> (Q_ : (_x_939 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_939 : range _A) -> Q_ x_939"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Range_rect_CProp0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_939$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $range$ of $_A$, $Q_$ holds for $x_939$.",
    "output": "Axiom range_rect_CProp0_body : forall _A : Set, forall Q_ : ((_x_939 : range _A) -> Prop), forall _H_mk_range : ((_enum : (x__ : nat) -> _A) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)), forall x_939 : range _A, Q_ x_939 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Range_rect_CProp0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_939$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $range$ of $_A$, $Q_$ holds for $x_939$.",
    "output": "axiom range_rect_CProp0_body (_A : Set) (Q_ : (_x_939 : range _A) -> Prop) (_H_mk_range : (_enum : (x__ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (x__ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) (x_939 : range _A) : Q_ x_939"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Upto_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, $Nat$.",
    "output": "upto_body : A : Set -> _xxx : range A -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Upto_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, $Nat$.",
    "output": "postulate upto_body : (A : Set) -> (_xxx : range A) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Upto_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, $Nat$.",
    "output": "Axiom upto_body : forall A : Set, forall _xxx : range A, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Upto_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, $Nat$.",
    "output": "axiom upto_body (A : Set) (_xxx : range A) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_bertrand_to_le2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "not_bertrand_to_le2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_bertrand_to_le2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate not_bertrand_to_le2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_bertrand_to_le2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom not_bertrand_to_le2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_bertrand_to_le2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom not_bertrand_to_le2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Square_double. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "square_double : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Square_double. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "postulate square_double : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Square_double. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "Axiom square_double : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Square_double. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "axiom square_double (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sub_hk. For all functions $__$ from natural numbers to natural numbers, for all functions $__1$ from natural numbers $__1$ to natural numbers, for all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "sub_hk : __ : (__ : Nat -> Nat) -> __1 : (__1 : Nat -> Nat) -> A : Set -> relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_hk. For all functions $__$ from natural numbers to natural numbers, for all functions $__1$ from natural numbers $__1$ to natural numbers, for all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "postulate sub_hk : (_ : (_ : Nat) -> Nat) -> (__1 : (__1 : Nat) -> Nat) -> (A : Set) -> relation (range A)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sub_hk. For all functions $__$ from natural numbers to natural numbers, for all functions $__1$ from natural numbers $__1$ to natural numbers, for all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "Axiom sub_hk : forall x__ : ((x__ : nat) -> nat), forall __1 : ((__1 : nat) -> nat), forall A : Set, relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sub_hk. For all functions $__$ from natural numbers to natural numbers, for all functions $__1$ from natural numbers $__1$ to natural numbers, for all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "axiom sub_hk (x__ : (x__ : Nat) -> Nat) (__1 : (__1 : Nat) -> Nat) (A : Set) : relation (range A)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "iso : A : Set -> relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "postulate iso : (A : Set) -> relation (range A)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "Axiom iso : forall A : Set, relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "axiom iso (A : Set) : relation (range A)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sub_lt. For all sets $A$, for all functions $e$ from natural numbers to elements of $A$, for all functions $p$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $sub_hk$ holds for the function that maps $x$ to $x$ and the function that maps $x$ to $x$ and $A$ and $mk_range$ applied to $A$ and $e$ and $n$ and $p$ and $mk_range$ applied to $A$ and $e$ and $m$ and $p$.",
    "output": "sub_lt : A : Set -> e : (__ : Nat -> A) -> p : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Leq n m -> sub_hk (x : Nat => x) (x : Nat => x) A (mk_range A e n p) (mk_range A e m p) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_lt. For all sets $A$, for all functions $e$ from natural numbers to elements of $A$, for all functions $p$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $sub_hk$ holds for the function that maps $x$ to $x$ and the function that maps $x$ to $x$ and $A$ and $mk_range$ applied to $A$ and $e$ and $n$ and $p$ and $mk_range$ applied to $A$ and $e$ and $m$ and $p$.",
    "output": "postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\\ x : Nat -> x) (\\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sub_lt. For all sets $A$, for all functions $e$ from natural numbers to elements of $A$, for all functions $p$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $sub_hk$ holds for the function that maps $x$ to $x$ and the function that maps $x$ to $x$ and $A$ and $mk_range$ applied to $A$ and $e$ and $n$ and $p$ and $mk_range$ applied to $A$ and $e$ and $m$ and $p$.",
    "output": "Axiom sub_lt : forall A : Set, forall e : ((x__ : nat) -> A), forall p : ((x__ : nat) -> bool), forall n : nat, forall m : nat, forall x__ : Leq n m, sub_hk (fun x => x) (fun x => x) A (mk_range A e n p) (mk_range A e m p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sub_lt. For all sets $A$, for all functions $e$ from natural numbers to elements of $A$, for all functions $p$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $sub_hk$ holds for the function that maps $x$ to $x$ and the function that maps $x$ to $x$ and $A$ and $mk_range$ applied to $A$ and $e$ and $n$ and $p$ and $mk_range$ applied to $A$ and $e$ and $m$ and $p$.",
    "output": "axiom sub_lt (A : Set) (e : (x__ : Nat) -> A) (p : (x__ : Nat) -> bool) (n m : Nat) (x__ : n ≤ m) : sub_hk (λ x => x) (λ x => x) A (mk_range A e n p) (mk_range A e m p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $A$ be a set. Let $_nil$ be an element of $A$. Then $Dop$ applied to $A$ and $_nil$ is a set.",
    "output": "Dop : A : Set -> _nil : A -> Set ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $A$ be a set. Let $_nil$ be an element of $A$. Then $Dop$ applied to $A$ and $_nil$ is a set.",
    "output": "postulate Dop : (A : Set) -> (_nil : A) -> Set"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Let $A$ be a set. Let $_nil$ be an element of $A$. Then $Dop$ applied to $A$ and $_nil$ is a set.",
    "output": "Axiom Dop : forall A : Set, forall _nil : A, Set ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Let $A$ be a set. Let $_nil$ be an element of $A$. Then $Dop$ applied to $A$ and $_nil$ is a set.",
    "output": "axiom Dop (A : Set) (_nil : A) : Set"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Start_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "start_lop : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Start_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Start_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom start_lop : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Start_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom start_lop (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lprim_invariant. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $i$ and $acc$ and $matita_arithmetics_nat.plus$ applied to $n$ and $i$.",
    "output": "lprim_invariant : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lprim_invariant. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $i$ and $acc$ and $matita_arithmetics_nat.plus$ applied to $n$ and $i$.",
    "output": "postulate lprim_invariant : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lprim_invariant. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $i$ and $acc$ and $matita_arithmetics_nat.plus$ applied to $n$ and $i$.",
    "output": "Axiom lprim_invariant : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lprim_invariant. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $i$ and $acc$ and $matita_arithmetics_nat.plus$ applied to $n$ and $i$.",
    "output": "axiom lprim_invariant (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Primes_below_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "primes_below_lop : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primes_below_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate primes_below_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Primes_below_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom primes_below_lop : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Primes_below_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom primes_below_lop (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Primes_below_to_bertrand. For all elements $pm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $pm$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $pm$, for all functions $__2$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $pm$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "primes_below_to_bertrand : pm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime pm) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm)) -> __2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (pp : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primes_below_to_bertrand. For all elements $pm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $pm$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $pm$, for all functions $__2$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $pm$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "postulate primes_below_to_bertrand : (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) -> (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ pp : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Primes_below_to_bertrand. For all elements $pm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $pm$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $pm$, for all functions $__2$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $pm$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "Axiom primes_below_to_bertrand : forall pm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime pm), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm)), forall __2 : ((p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Primes_below_to_bertrand. For all elements $pm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $pm$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $pm$, for all functions $__2$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $pm$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "axiom primes_below_to_bertrand (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Checker_ab. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.andb$ applied to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $b$ and $matita_arithmetics_nat.leb$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$.",
    "output": "checker_ab : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) (matita_basics_bool.andb (matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S a) b) (matita_arithmetics_nat.leb b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Checker_ab. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.andb$ applied to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $b$ and $matita_arithmetics_nat.leb$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$.",
    "output": "postulate checker_ab : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) (matita_basics_bool.andb (matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S a) b) (matita_arithmetics_nat.leb b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Checker_ab. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.andb$ applied to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $b$ and $matita_arithmetics_nat.leb$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$.",
    "output": "Axiom checker_ab : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) (matita_basics_bool.andb (matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S a) b) (matita_arithmetics_nat.leb b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Checker_ab. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.andb$ applied to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $b$ and $matita_arithmetics_nat.leb$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$.",
    "output": "axiom checker_ab (a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) (matita_basics_bool.andb (matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S a) b) (matita_arithmetics_nat.leb b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.",
    "output": "Dop_rect_CProp3 : A : Set -> _nil : A -> Q_ : (_x_961 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_961 : Dop A _nil -> Q_ x_961 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.",
    "output": "postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_rect_CProp3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.",
    "output": "Axiom Dop_rect_CProp3 : forall A : Set, forall _nil : A, forall Q_ : ((_x_961 : Dop A _nil) -> Prop), forall _H_mk_Dop : ((sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)), forall x_961 : Dop A _nil, Q_ x_961 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_rect_CProp3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.",
    "output": "axiom Dop_rect_CProp3 (A : Set) (_nil : A) (Q_ : (_x_961 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_961 : Dop A _nil) : Q_ x_961"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "Dop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_963 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_963 : Dop A _nil -> Q_ x_963 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "postulate Dop_rect_CProp2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "Axiom Dop_rect_CProp2 : forall A : Set, forall _nil : A, forall Q_ : ((_x_963 : Dop A _nil) -> Prop), forall _H_mk_Dop : ((sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)), forall x_963 : Dop A _nil, Q_ x_963 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "axiom Dop_rect_CProp2 (A : Set) (_nil : A) (Q_ : (_x_963 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_963 : Dop A _nil) : Q_ x_963"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_prim_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "le_prim_n1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_prim_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "Axiom le_prim_n1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_prim_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "axiom le_prim_n1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_prim_n2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $n$.",
    "output": "le_prim_n2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $n$.",
    "output": "postulate le_prim_n2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_prim_n2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $n$.",
    "output": "Axiom le_prim_n2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_prim_n2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $n$.",
    "output": "axiom le_prim_n2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Psi. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Psi : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Psi. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate Psi : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Psi. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom Psi : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Psi. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom Psi (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psil1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.",
    "output": "le_Psil1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => n))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psil1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.",
    "output": "postulate le_Psil1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_Psil1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.",
    "output": "Axiom le_Psil1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_Psil1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.",
    "output": "axiom le_Psil1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => n)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Null_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Dop$ of $A$ and $nil$, for all elements $a$ of $A$, $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $nil$.",
    "output": "null_body : A : Set -> nil : A -> xxx : Dop A nil -> a : A -> Eq (prod A nil xxx a nil) nil ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Null_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Dop$ of $A$ and $nil$, for all elements $a$ of $A$, $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $nil$.",
    "output": "postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Null_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Dop$ of $A$ and $nil$, for all elements $a$ of $A$, $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $nil$.",
    "output": "Axiom null_body : forall A : Set, forall nil : A, forall xxx : Dop A nil, forall a : A, prod A nil xxx a nil = nil ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Null_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Dop$ of $A$ and $nil$, for all elements $a$ of $A$, $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $nil$.",
    "output": "axiom null_body (A : Set) (nil : A) (xxx : Dop A nil) (a : A) : prod A nil xxx a nil = nil"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_fact_to_le. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$.",
    "output": "divides_fact_to_le : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)) -> cic.Term cic.prop (matita_arithmetics_nat.le p n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_fact_to_le. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$.",
    "output": "postulate divides_fact_to_le : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n))) -> cic.Term cic.prop (matita_arithmetics_nat.le p n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Divides_fact_to_le. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$.",
    "output": "Axiom divides_fact_to_le : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)), cic.Term cic.prop (matita_arithmetics_nat.le p n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Divides_fact_to_le. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$.",
    "output": "axiom divides_fact_to_le (p n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n))) : cic.Term cic.prop (matita_arithmetics_nat.le p n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1753$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "Dop_inv_rect_CProp1 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1752 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1753 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1753$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "postulate Dop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1752 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1753 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1753$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "Axiom Dop_inv_rect_CProp1 : forall x1 : Set, forall x2 : x1, forall Hterm : Dop x1 x2, forall P : ((_z1752 : Dop x1 x2) -> Prop), forall _H1 : ((sum : ACop x1 x2) -> (prod : (x__ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> prod a x2 = x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> prod a (aop__o__op x1 x2 sum b c) = aop__o__op x1 x2 sum (prod a b) (prod a c)) -> (_z1753 : Hterm = mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)), P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1753$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "axiom Dop_inv_rect_CProp1 (x1 : Set) (x2 : x1) (Hterm : Dop x1 x2) (P : (_z1752 : Dop x1 x2) -> Prop) (_H1 : (sum : ACop x1 x2) -> (prod : (x__ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> prod a x2 = x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> prod a (aop__o__op x1 x2 sum b c) = aop__o__op x1 x2 sum (prod a b) (prod a c)) -> (_z1753 : Hterm = mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_theta_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "div_theta_theta : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_theta_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "postulate div_theta_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_theta_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "Axiom div_theta_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (fun p => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => p))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_theta_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "axiom div_theta_theta (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (λ p => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => p)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_theta_M_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "le_theta_M_theta : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_theta_M_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate le_theta_M_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_theta_M_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "Axiom le_theta_M_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_theta_M_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "axiom le_theta_M_theta (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bceq. For all natural numbers $n$ and $k$, $bc$ applied to $n$ and $k$ is equal to the quotient of the factorial of $n$ and the product of the factorial of $k$ and the factorial of the difference of $n$ and $k$.",
    "output": "bceq : n : Nat -> k : Nat -> Eq (bc n k) (div (factorial n) (times (factorial k) (factorial (minus n k)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bceq. For all natural numbers $n$ and $k$, $bc$ applied to $n$ and $k$ is equal to the quotient of the factorial of $n$ and the product of the factorial of $k$ and the factorial of the difference of $n$ and $k$.",
    "output": "postulate bceq : (n : Nat) -> (k : Nat) -> Eq (bc n k) (div (factorial n) (times (factorial k) (factorial (minus n k))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Bceq. For all natural numbers $n$ and $k$, $bc$ applied to $n$ and $k$ is equal to the quotient of the factorial of $n$ and the product of the factorial of $k$ and the factorial of the difference of $n$ and $k$.",
    "output": "Axiom bceq : forall n : nat, forall k : nat, bc n k = factorial n / (factorial k * factorial (n - k)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Bceq. For all natural numbers $n$ and $k$, $bc$ applied to $n$ and $k$ is equal to the quotient of the factorial of $n$ and the product of the factorial of $k$ and the factorial of the difference of $n$ and $k$.",
    "output": "axiom bceq (n k : Nat) : bc n k = factorial n / (factorial k * factorial (n - k))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "let_clause_1648 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q))) -> _clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) -> eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) -> (divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1))) -> (eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "Axiom let_clause_1648 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (fun m => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun m => matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q))), forall _clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))), forall divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)), forall eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "axiom let_clause_1648 (n q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (λ m => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ m => matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) (divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1))) (eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1692. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.",
    "output": "let_clause_1692 : m : Nat -> posm : Lt 0 m -> a : Nat -> x358 : Nat -> x359 : Nat -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 (nd 1))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1692. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.",
    "output": "postulate let_clause_1692 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_1692. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.",
    "output": "Axiom let_clause_1692 : forall m : nat, forall posm : (0 < m), forall a : nat, forall x358 : nat, forall x359 : nat, aop__o__op nat 0 plusAC x358 (x358 * x359) = x358 * (x359 + 1) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_1692. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.",
    "output": "axiom let_clause_1692 (m : Nat) (posm : 0 < m) (a x358 x359 : Nat) : aop__o__op Nat 0 plusAC x358 (x358 * x359) = x358 * (x359 + 1)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $bertrand$ holds for $_n$.",
    "output": "bertrand : _n : Nat -> Prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $bertrand$ holds for $_n$.",
    "output": "postulate bertrand : (_n : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $bertrand$ holds for $_n$.",
    "output": "Axiom bertrand : forall _n : nat, Prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $bertrand$ holds for $_n$.",
    "output": "axiom bertrand (_n : Nat) : Prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "B_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "B_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $not_bertrand$ holds for $_n$.",
    "output": "not_bertrand : _n : Nat -> Prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $not_bertrand$ holds for $_n$.",
    "output": "postulate not_bertrand : (_n : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $not_bertrand$ holds for $_n$.",
    "output": "Axiom not_bertrand : forall _n : nat, Prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $not_bertrand$ holds for $_n$.",
    "output": "axiom not_bertrand (_n : Nat) : Prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "B_SSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B_SSSSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate B_SSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "B_SSSSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom B_SSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "B_SSSSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom B_SSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_1_to_le_exp_B. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "lt_1_to_le_exp_B : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_1_to_le_exp_B. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate lt_1_to_le_exp_B : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_1_to_le_exp_B. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom lt_1_to_le_exp_B : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_1_to_le_exp_B. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom lt_1_to_le_exp_B (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_B_Psi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "le_B_Psi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_B_Psi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate le_B_Psi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_B_Psi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "Axiom le_B_Psi : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_B_Psi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "axiom le_B_Psi (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psi_BPsi1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "le_Psi_BPsi1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psi_BPsi1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate le_Psi_BPsi1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_Psi_BPsi1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "Axiom le_Psi_BPsi1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_Psi_BPsi1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "axiom le_Psi_BPsi1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "list_divides_false : l : list Nat -> n : Nat -> __ : Eq (list_divides l n) false -> p : Nat -> __1 : mem Nat p l -> not (divisible p n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "Axiom list_divides_false : forall l : list nat, forall n : nat, forall x__ : (list_divides l n = false), forall p : nat, forall __1 : mem nat p l, ~ divisible p n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "axiom list_divides_false (l : list Nat) (n : Nat) (x__ : list_divides l n = false) (p : Nat) (__1 : mem Nat p l) : ¬ divisible p n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_exp_primr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "le_exp_primr : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_primr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate le_exp_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_exp_primr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom le_exp_primr : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_exp_primr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom le_exp_primr (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_15624. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "let_clause_15624 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15624. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15624 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_15624. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_15624 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_15624. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_15624 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prim. For all natural numbers $_n$, $Nat$.",
    "output": "prim : _n : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prim. For all natural numbers $_n$, $Nat$.",
    "output": "postulate prim : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prim. For all natural numbers $_n$, $Nat$.",
    "output": "Axiom prim : forall _n : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prim. For all natural numbers $_n$, $Nat$.",
    "output": "axiom prim (_n : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Congruent_ab. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$.",
    "output": "congruent_ab : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Congruent_ab. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$.",
    "output": "postulate congruent_ab : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Congruent_ab. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$.",
    "output": "Axiom congruent_ab : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun x => matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Congruent_ab. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$.",
    "output": "axiom congruent_ab (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ x => matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_prim_n3. For all natural numbers $n$, if $15$ is less than or equal to $n$, then $prim$ applied to $n$ is less than or equal to $pred$ applied to the quotient of $n$ and $2$.",
    "output": "le_prim_n3 : n : Nat -> __ : Leq (nn 1 (nd 5)) n -> Leq (prim n) (pred (div n (nd 2))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_prim_n3. For all natural numbers $n$, if $15$ is less than or equal to $n$, then $prim$ applied to $n$ is less than or equal to $pred$ applied to the quotient of $n$ and $2$.",
    "output": "postulate le_prim_n3 : (n : Nat) -> (_ : Leq 15 n) -> Leq (prim n) (pred (div n 2))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_prim_n3. For all natural numbers $n$, if $15$ is less than or equal to $n$, then $prim$ applied to $n$ is less than or equal to $pred$ applied to the quotient of $n$ and $2$.",
    "output": "Axiom le_prim_n3 : forall n : nat, forall x__ : Leq 15 n, Leq (prim n) (pred (n / 2)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_prim_n3. For all natural numbers $n$, if $15$ is less than or equal to $n$, then $prim$ applied to $n$ is less than or equal to $pred$ applied to the quotient of $n$ and $2$.",
    "output": "axiom le_prim_n3 (n : Nat) (x__ : 15 ≤ n) : prim n ≤ pred (n / 2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Congruent. For all elements $_n$ and $_m$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "congruent : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Congruent. For all elements $_n$ and $_m$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate congruent : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Congruent. For all elements $_n$ and $_m$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom congruent : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Congruent. For all elements $_n$ and $_m$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom congruent (_n _m _p : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_Psil. For all natural numbers $n$, $Psi$ applied to $n$ is less than or equal to the exponentiation of $n$ and $prim$ applied to $n$.",
    "output": "le_Psil : n : Nat -> Leq (Psi n) (pow n (prim n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_Psil. For all natural numbers $n$, $Psi$ applied to $n$ is less than or equal to the exponentiation of $n$ and $prim$ applied to $n$.",
    "output": "postulate le_Psil : (n : Nat) -> Leq (Psi n) (pow n (prim n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_Psil. For all natural numbers $n$, $Psi$ applied to $n$ is less than or equal to the exponentiation of $n$ and $prim$ applied to $n$.",
    "output": "Axiom le_Psil : forall n : nat, Leq (Psi n) (pow n (prim n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_Psil. For all natural numbers $n$, $Psi$ applied to $n$ is less than or equal to the exponentiation of $n$ and $prim$ applied to $n$.",
    "output": "axiom le_Psil (n : Nat) : Psi n ≤ pow n (prim n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prime_to_divides_M. For all natural numbers $m$ and $p$, if $p$ is prime, then if the sum of $m$ and $1$ is less than $p$, then if $p$ is less than or equal to the sum of the product of $2$ and $m$ and $1$, then $p$ is divisible by $M$ applied to $m$.",
    "output": "prime_to_divides_M : m : Nat -> p : Nat -> __ : prime p -> __1 : Lt (plus m (nd 1)) p -> __2 : Leq p (plus (times (nd 2) m) (nd 1)) -> divisible p (M m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prime_to_divides_M. For all natural numbers $m$ and $p$, if $p$ is prime, then if the sum of $m$ and $1$ is less than $p$, then if $p$ is less than or equal to the sum of the product of $2$ and $m$ and $1$, then $p$ is divisible by $M$ applied to $m$.",
    "output": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prime_to_divides_M. For all natural numbers $m$ and $p$, if $p$ is prime, then if the sum of $m$ and $1$ is less than $p$, then if $p$ is less than or equal to the sum of the product of $2$ and $m$ and $1$, then $p$ is divisible by $M$ applied to $m$.",
    "output": "Axiom prime_to_divides_M : forall m : nat, forall p : nat, forall x__ : prime p, forall __1 : (m + 1 < p), forall __2 : Leq p (2 * m + 1), divisible p (M m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prime_to_divides_M. For all natural numbers $m$ and $p$, if $p$ is prime, then if the sum of $m$ and $1$ is less than $p$, then if $p$ is less than or equal to the sum of the product of $2$ and $m$ and $1$, then $p$ is divisible by $M$ applied to $m$.",
    "output": "axiom prime_to_divides_M (m p : Nat) (x__ : prime p) (__1 : m + 1 < p) (__2 : p ≤ 2 * m + 1) : divisible p (M m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "mod_aux_body : _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate mod_aux_body : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Mod_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom mod_aux_body : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Mod_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom mod_aux_body (_p _m _n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sigma_p_dividesb. For all natural numbers $m$ and $n$ and $p$, if $0$ is less than $n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $m$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "sigma_p_dividesb : m : Nat -> n : Nat -> p : Nat -> __ : Lt 0 n -> __1 : prime p -> __2 : not (divisible p n) -> Eq m (bigop m (i : Nat => dividesb (pow p (plus i (nd 1))) (times (pow p m) n)) Nat 0 plus (i : Nat => nd 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sigma_p_dividesb. For all natural numbers $m$ and $n$ and $p$, if $0$ is less than $n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $m$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sigma_p_dividesb. For all natural numbers $m$ and $n$ and $p$, if $0$ is less than $n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $m$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "Axiom sigma_p_dividesb : forall m : nat, forall n : nat, forall p : nat, forall x__ : (0 < n), forall __1 : prime p, forall __2 : (~ divisible p n), m = bigop m (fun i => dividesb (pow p (i + 1)) (pow p m * n)) nat 0 plus (fun i => 1) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sigma_p_dividesb. For all natural numbers $m$ and $n$ and $p$, if $0$ is less than $n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $m$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "axiom sigma_p_dividesb (m n p : Nat) (x__ : 0 < n) (__1 : prime p) (__2 : ¬ divisible p n) : m = bigop m (λ i => dividesb (pow p (i + 1)) (pow p m * n)) Nat 0 plus (λ i => 1)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Pi_p_primeb1. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $p$.",
    "output": "pi_p_primeb1 : n : Nat -> __ : Lt 0 n -> Eq n (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => dividesb (pow p (plus i (nd 1))) n) Nat (nd 1) times (i : Nat => p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Pi_p_primeb1. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $p$.",
    "output": "postulate pi_p_primeb1 : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> dividesb (pow p (plus i 1)) n) Nat 1 times (\\ i : Nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Pi_p_primeb1. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $p$.",
    "output": "Axiom pi_p_primeb1 : forall n : nat, forall x__ : (0 < n), n = bigop (n + 1) (fun p => primeb p) nat 1 times (fun p => bigop (log p n) (fun i => dividesb (pow p (i + 1)) n) nat 1 times (fun i => p)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Pi_p_primeb1. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $p$.",
    "output": "axiom pi_p_primeb1 (n : Nat) (x__ : 0 < n) : n = bigop (n + 1) (λ p => primeb p) Nat 1 times (λ p => bigop (log p n) (λ i => dividesb (pow p (i + 1)) n) Nat 1 times (λ i => p))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "div_mod_spec_rect_Type1_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type1) -> _H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type1 (Q_ x_829) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "postulate div_mod_spec_rect_Type1_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) -> (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type1 (Q_ x_829)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "Axiom div_mod_spec_rect_Type1_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1), forall _H_div_mod_spec_intro : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))), forall x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type1 (Q_ x_829) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "axiom div_mod_spec_rect_Type1_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term univs.Type1 (Q_ x_829)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSO. $B$ applied to $4$ is equal to $6$.",
    "output": "B_SSSSO : Eq (B (nd 4)) (nd 6) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B_SSSSO. $B$ applied to $4$ is equal to $6$.",
    "output": "postulate B_SSSSO : Eq (B 4) 6"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "B_SSSSO. $B$ applied to $4$ is equal to $6$.",
    "output": "Axiom B_SSSSO : B 4 = 6 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "B_SSSSO. $B$ applied to $4$ is equal to $6$.",
    "output": "axiom B_SSSSO : B 4 = 6"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.",
    "output": "div_mod_spec_rect_CProp5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) -> x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_841) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.",
    "output": "postulate div_mod_spec_rect_CProp5 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) -> (x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_841)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_rect_CProp5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.",
    "output": "Axiom div_mod_spec_rect_CProp5 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))), forall x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_841) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_rect_CProp5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.",
    "output": "axiom div_mod_spec_rect_CProp5 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) (x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_841)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSSSO. $B$ applied to $6$ is equal to $20$.",
    "output": "B_SSSSSSO : Eq (B (nd 6)) (nn 2 (nd 0)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B_SSSSSSO. $B$ applied to $6$ is equal to $20$.",
    "output": "postulate B_SSSSSSO : Eq (B 6) 20"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "B_SSSSSSO. $B$ applied to $6$ is equal to $20$.",
    "output": "Axiom B_SSSSSSO : B 6 = 20 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "B_SSSSSSO. $B$ applied to $6$ is equal to $20$.",
    "output": "axiom B_SSSSSSO : B 6 = 20"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "B_SSSSSSSSO. $B$ applied to $8$ is equal to $70$.",
    "output": "B_SSSSSSSSO : Eq (B (nd 8)) (nn 7 (nd 0)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "B_SSSSSSSSO. $B$ applied to $8$ is equal to $70$.",
    "output": "postulate B_SSSSSSSSO : Eq (B 8) 70"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "B_SSSSSSSSO. $B$ applied to $8$ is equal to $70$.",
    "output": "Axiom B_SSSSSSSSO : B 8 = 70 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "B_SSSSSSSSO. $B$ applied to $8$ is equal to $70$.",
    "output": "axiom B_SSSSSSSSO : B 8 = 70"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "div_mod_spec_rect_CProp3_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_845) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "postulate div_mod_spec_rect_CProp3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "Axiom div_mod_spec_rect_CProp3_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))), forall x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_845) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "axiom div_mod_spec_rect_CProp3_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_845)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_4_to_le_B_exp. For all natural numbers $n$, if $4$ is less than $n$, then $B$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $2$.",
    "output": "lt_4_to_le_B_exp : n : Nat -> __ : Lt (nd 4) n -> Leq (B (times (nd 2) n)) (pow (nd 2) (minus (times (nd 2) n) (nd 2))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_4_to_le_B_exp. For all natural numbers $n$, if $4$ is less than $n$, then $B$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $2$.",
    "output": "postulate lt_4_to_le_B_exp : (n : Nat) -> (_ : Lt 4 n) -> Leq (B (times 2 n)) (pow 2 (minus (times 2 n) 2))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_4_to_le_B_exp. For all natural numbers $n$, if $4$ is less than $n$, then $B$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $2$.",
    "output": "Axiom lt_4_to_le_B_exp : forall n : nat, forall x__ : (4 < n), Leq (B (2 * n)) (pow 2 (2 * n - 2)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_4_to_le_B_exp. For all natural numbers $n$, if $4$ is less than $n$, then $B$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $2$.",
    "output": "axiom lt_4_to_le_B_exp (n : Nat) (x__ : 4 < n) : B (2 * n) ≤ pow 2 (2 * n - 2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_inv_rect_Type1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "div_mod_spec_inv_rect_Type1 : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> P : (_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> cic.Univ univs.Type1) -> _H1 : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2) -> x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4)) -> _z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_Type1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_Type1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1) -> (_H1 : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_inv_rect_Type1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom div_mod_spec_inv_rect_Type1 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1), forall _H1 : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_inv_rect_Type1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "axiom div_mod_spec_inv_rect_Type1 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1) (_H1 : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10334. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10334 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10334. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10334 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_10334. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "Axiom let_clause_10334 : forall n : nat, forall posn : (0 < n), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_10334. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "axiom let_clause_10334 (n : Nat) (posn : 0 < n) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_Psi. $monotonic$ holds for $Nat$ and $Leq$ and $Psi$.",
    "output": "monotonic_Psi : monotonic Nat Leq Psi ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_Psi. $monotonic$ holds for $Nat$ and $Leq$ and $Psi$.",
    "output": "postulate monotonic_Psi : monotonic Nat Leq Psi"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Monotonic_Psi. $monotonic$ holds for $Nat$ and $Leq$ and $Psi$.",
    "output": "Axiom monotonic_Psi : monotonic nat Leq Psi ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Monotonic_Psi. $monotonic$ holds for $Nat$ and $Leq$ and $Psi$.",
    "output": "axiom monotonic_Psi : monotonic Nat Leq Psi"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_n_8_to_le_Psi_exp. For all natural numbers $n$, if $n$ is less than or equal to $8$, then $Psi$ applied to $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "le_n_8_to_le_Psi_exp : n : Nat -> __ : Leq n (nd 8) -> Leq (Psi n) (pow (nd 2) (minus (times (nd 2) n) (nd 3))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_8_to_le_Psi_exp. For all natural numbers $n$, if $n$ is less than or equal to $8$, then $Psi$ applied to $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (minus (times 2 n) 3))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_n_8_to_le_Psi_exp. For all natural numbers $n$, if $n$ is less than or equal to $8$, then $Psi$ applied to $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "Axiom le_n_8_to_le_Psi_exp : forall n : nat, forall x__ : Leq n 8, Leq (Psi n) (pow 2 (2 * n - 3)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_n_8_to_le_Psi_exp. For all natural numbers $n$, if $n$ is less than or equal to $8$, then $Psi$ applied to $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "axiom le_n_8_to_le_Psi_exp (n : Nat) (x__ : n ≤ 8) : Psi n ≤ pow 2 (2 * n - 3)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_Sn. For all natural numbers $b$ and $n$, the exponentiation of $b$ and the sum of $n$ and $1$ is equal to the product of $b$ and the exponentiation of $b$ and $n$.",
    "output": "exp_Sn : b : Nat -> n : Nat -> Eq (pow b (plus n (nd 1))) (times b (pow b n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_Sn. For all natural numbers $b$ and $n$, the exponentiation of $b$ and the sum of $n$ and $1$ is equal to the product of $b$ and the exponentiation of $b$ and $n$.",
    "output": "postulate exp_Sn : (b : Nat) -> (n : Nat) -> Eq (pow b (plus n 1)) (times b (pow b n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Exp_Sn. For all natural numbers $b$ and $n$, the exponentiation of $b$ and the sum of $n$ and $1$ is equal to the product of $b$ and the exponentiation of $b$ and $n$.",
    "output": "Axiom exp_Sn : forall b : nat, forall n : nat, pow b (n + 1) = b * pow b n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Exp_Sn. For all natural numbers $b$ and $n$, the exponentiation of $b$ and the sum of $n$ and $1$ is equal to the product of $b$ and the exponentiation of $b$ and $n$.",
    "output": "axiom exp_Sn (b n : Nat) : pow b (n + 1) = b * pow b n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_16001. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $n$ and $c$ and the product of $m$ and $d$.",
    "output": "let_clause_16001 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (gcd m n) (minus (times n c) (times m d)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16001. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $n$ and $c$ and the product of $m$ and $d$.",
    "output": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_16001. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $n$ and $c$ and the product of $m$ and $d$.",
    "output": "Axiom let_clause_16001 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), gcd m n = n * c - m * d ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_16001. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $n$ and $c$ and the product of $m$ and $d$.",
    "output": "axiom let_clause_16001 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : gcd m n = n * c - m * d"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_times_times. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$.",
    "output": "div_times_times : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_times_times. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$.",
    "output": "postulate div_times_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_times_times. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$.",
    "output": "Axiom div_times_times : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_times_times. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$.",
    "output": "axiom div_times_times (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1607. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "let_clause_1607 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1607. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_1607. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "Axiom let_clause_1607 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_1607. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "axiom let_clause_1607 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_16005. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "let_clause_16005 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16005. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_16005. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "Axiom let_clause_16005 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_16005. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "axiom let_clause_16005 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_exp_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "exp_exp_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_exp_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "postulate exp_exp_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Exp_exp_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "Axiom exp_exp_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Exp_exp_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "axiom exp_exp_times (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_exp_to_le1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "le_exp_to_le1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_exp_to_le1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_exp_to_le1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_exp_to_le1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "Axiom le_exp_to_le1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p)), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_exp_to_le1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "axiom le_exp_to_le1 (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))) : cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_mod. For all natural numbers $n$ and $p$, if $0$ is less than $p$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and $p$ and $p$.",
    "output": "mod_mod : n : Nat -> p : Nat -> __ : Lt 0 p -> Eq (mod n p) (mod (mod n p) p) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_mod. For all natural numbers $n$ and $p$, if $0$ is less than $p$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and $p$ and $p$.",
    "output": "postulate mod_mod : (n : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod n p) (mod (mod n p) p)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Mod_mod. For all natural numbers $n$ and $p$, if $0$ is less than $p$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and $p$ and $p$.",
    "output": "Axiom mod_mod : forall n : nat, forall p : nat, forall x__ : (0 < p), mod n p = mod (mod n p) p ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Mod_mod. For all natural numbers $n$ and $p$, if $0$ is less than $p$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and $p$ and $p$.",
    "output": "axiom mod_mod (n p : Nat) (x__ : 0 < p) : mod n p = mod (mod n p) p"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "FactS. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "factS : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "FactS. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate factS : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_factorial.fact n)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "FactS. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "Axiom factS : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "FactS. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "axiom factS (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_factorial.fact n)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Congruent_n_mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $0$ is less than $m$, then $congruent$ holds for $n$ and $mod$ applied to $n$ and the product of $m$ and $p$ and $p$.",
    "output": "congruent_n_mod_times : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Lt 0 m -> congruent n (mod n (times m p)) p ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Congruent_n_mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $0$ is less than $m$, then $congruent$ holds for $n$ and $mod$ applied to $n$ and the product of $m$ and $p$ and $p$.",
    "output": "postulate congruent_n_mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> congruent n (mod n (times m p)) p"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Congruent_n_mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $0$ is less than $m$, then $congruent$ holds for $n$ and $mod$ applied to $n$ and the product of $m$ and $p$ and $p$.",
    "output": "Axiom congruent_n_mod_times : forall n : nat, forall m : nat, forall p : nat, forall x__ : (0 < p), forall __1 : (0 < m), congruent n (mod n (m * p)) p ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Congruent_n_mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $0$ is less than $m$, then $congruent$ holds for $n$ and $mod$ applied to $n$ and the product of $m$ and $p$ and $p$.",
    "output": "axiom congruent_n_mod_times (n m p : Nat) (x__ : 0 < p) (__1 : 0 < m) : congruent n (mod n (m * p)) p"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "le_2_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate le_2_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "Axiom le_2_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "axiom le_2_fact (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "mod_times : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "postulate mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "Axiom mod_times : forall n : nat, forall m : nat, forall p : nat, forall x__ : (0 < p), mod (n * m) p = mod (mod n p * mod m p) p ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "axiom mod_times (n m p : Nat) (x__ : 0 < p) : mod (n * m) p = mod (mod n p * mod m p) p"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_to_fact1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "exp_to_fact1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_to_fact1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate exp_to_fact1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Exp_to_fact1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom exp_to_fact1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Exp_to_fact1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom exp_to_fact1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_S_mod. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "permut_S_mod : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Permut_S_mod. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "postulate permut_S_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Permut_S_mod. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "Axiom permut_S_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Permut_S_mod. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "axiom permut_S_mod (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "eq_fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate eq_fact_pi_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom eq_fact_pi_p : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (fun i => (fun i0 => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => (fun i0 => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom eq_fact_pi_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (λ i => (λ i0 => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => (λ i0 => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "gcd : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate gcd : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom gcd : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom gcd (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "gcd_O_l : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "Axiom gcd_O_l : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "axiom gcd_O_l (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "not_divides_to_gcd_aux : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "postulate not_divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "Axiom not_divides_to_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "axiom not_divides_to_gcd_aux (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_839$ of $Lt$ of $_r$ and $_m$ and elements $x_838$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_839$ and $x_838$, for all elements $x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_837$.",
    "output": "div_mod_spec_rect_CProp4_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_837 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_839 : Lt _r _m -> x_838 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> x_837 : div_mod_spec _n _m _q _r -> Q_ x_837 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_839$ of $Lt$ of $_r$ and $_m$ and elements $x_838$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_839$ and $x_838$, for all elements $x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_837$.",
    "output": "postulate div_mod_spec_rect_CProp4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_839 : Lt _r _m) -> (x_838 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> (x_837 : div_mod_spec _n _m _q _r) -> Q_ x_837"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_rect_CProp4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_839$ of $Lt$ of $_r$ and $_m$ and elements $x_838$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_839$ and $x_838$, for all elements $x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_837$.",
    "output": "Axiom div_mod_spec_rect_CProp4_body : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_837 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_839 : _r < _m) -> (x_838 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)), forall x_837 : div_mod_spec _n _m _q _r, Q_ x_837 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_rect_CProp4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_839$ of $Lt$ of $_r$ and $_m$ and elements $x_838$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_839$ and $x_838$, for all elements $x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_837$.",
    "output": "axiom div_mod_spec_rect_CProp4_body (_n _m _q _r : Nat) (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_839 : _r < _m) -> (x_838 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) (x_837 : div_mod_spec _n _m _q _r) : Q_ x_837"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_rect_CProp2. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "div_mod_spec_rect_CProp2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_849 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_851 : Lt _r _m -> x_850 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> x_849 : div_mod_spec _n _m _q _r -> Q_ x_849 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_rect_CProp2. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "postulate div_mod_spec_rect_CProp2 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_rect_CProp2. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "Axiom div_mod_spec_rect_CProp2 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_849 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_851 : _r < _m) -> (x_850 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)), forall x_849 : div_mod_spec _n _m _q _r, Q_ x_849 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_rect_CProp2. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "axiom div_mod_spec_rect_CProp2 (_n _m _q _r : Nat) (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_851 : _r < _m) -> (x_850 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) (x_849 : div_mod_spec _n _m _q _r) : Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_1572 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O) -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) -> auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_1572 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_1572 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O), forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O), forall auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_1572 (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_inv_ind. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1434$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_811$ of $Lt$ of $x4$ and $x2$ and elements $x_810$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1435$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$, $P$ holds for $Hterm$.",
    "output": "div_mod_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1434 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_811 : Lt x4 x2 -> x_810 : Eq x1 (plus (times x3 x2) x4) -> _z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_ind. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1434$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_811$ of $Lt$ of $x4$ and $x2$ and elements $x_810$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1435$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$, $P$ holds for $Hterm$.",
    "output": "postulate div_mod_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1434 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_811 : Lt x4 x2) -> (x_810 : Eq x1 (plus (times x3 x2) x4)) -> (_z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_inv_ind. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1434$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_811$ of $Lt$ of $x4$ and $x2$ and elements $x_810$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1435$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$, $P$ holds for $Hterm$.",
    "output": "Axiom div_mod_spec_inv_ind : forall x1 : nat, forall x2 : nat, forall x3 : nat, forall x4 : nat, forall Hterm : div_mod_spec x1 x2 x3 x4, forall P : ((_z1434 : div_mod_spec x1 x2 x3 x4) -> Prop), forall _H1 : ((x_811 : x4 < x2) -> (x_810 : x1 = x3 * x2 + x4) -> (_z1435 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)), P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_inv_ind. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1434$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_811$ of $Lt$ of $x4$ and $x2$ and elements $x_810$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1435$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$, $P$ holds for $Hterm$.",
    "output": "axiom div_mod_spec_inv_ind (x1 x2 x3 x4 : Nat) (Hterm : div_mod_spec x1 x2 x3 x4) (P : (_z1434 : div_mod_spec x1 x2 x3 x4) -> Prop) (_H1 : (x_811 : x4 < x2) -> (x_810 : x1 = x3 * x2 + x4) -> (_z1435 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_mod_spec_inv_rect_CProp3. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_847$ of $Lt$ of $x4$ and $x2$ and elements $x_846$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1477$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $P$ holds for $Hterm$.",
    "output": "div_mod_spec_inv_rect_CProp3 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1476 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_847 : Lt x4 x2 -> x_846 : Eq x1 (plus (times x3 x2) x4) -> _z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_mod_spec_inv_rect_CProp3. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_847$ of $Lt$ of $x4$ and $x2$ and elements $x_846$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1477$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $P$ holds for $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1476 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_847 : Lt x4 x2) -> (x_846 : Eq x1 (plus (times x3 x2) x4)) -> (_z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_mod_spec_inv_rect_CProp3. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_847$ of $Lt$ of $x4$ and $x2$ and elements $x_846$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1477$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $P$ holds for $Hterm$.",
    "output": "Axiom div_mod_spec_inv_rect_CProp3 : forall x1 : nat, forall x2 : nat, forall x3 : nat, forall x4 : nat, forall Hterm : div_mod_spec x1 x2 x3 x4, forall P : ((_z1476 : div_mod_spec x1 x2 x3 x4) -> Prop), forall _H1 : ((x_847 : x4 < x2) -> (x_846 : x1 = x3 * x2 + x4) -> (_z1477 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_847 x_846) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)), P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_mod_spec_inv_rect_CProp3. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_847$ of $Lt$ of $x4$ and $x2$ and elements $x_846$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1477$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $P$ holds for $Hterm$.",
    "output": "axiom div_mod_spec_inv_rect_CProp3 (x1 x2 x3 x4 : Nat) (Hterm : div_mod_spec x1 x2 x3 x4) (P : (_z1476 : div_mod_spec x1 x2 x3 x4) -> Prop) (_H1 : (x_847 : x4 < x2) -> (x_846 : x1 = x3 * x2 + x4) -> (_z1477 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_847 x_846) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Div_times. For all natural numbers $a$ and $b$, if $0$ is less than $b$, then the quotient of the product of $a$ and $b$ and $b$ is equal to $a$.",
    "output": "div_times : a : Nat -> b : Nat -> __ : Lt 0 b -> Eq (div (times a b) b) a ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Div_times. For all natural numbers $a$ and $b$, if $0$ is less than $b$, then the quotient of the product of $a$ and $b$ and $b$ is equal to $a$.",
    "output": "postulate div_times : (a : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> Eq (div (times a b) b) a"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Div_times. For all natural numbers $a$ and $b$, if $0$ is less than $b$, then the quotient of the product of $a$ and $b$ and $b$ is equal to $a$.",
    "output": "Axiom div_times : forall a : nat, forall b : nat, forall x__ : (0 < b), a * b / b = a ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Div_times. For all natural numbers $a$ and $b$, if $0$ is less than $b$, then the quotient of the product of $a$ and $b$ and $b$ is equal to $a$.",
    "output": "axiom div_times (a b : Nat) (x__ : 0 < b) : a * b / b = a"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "log : _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate log : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom log : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom log (_p _n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_times_to_le_div2. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then if $n$ is less than or equal to the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than or equal to $m$.",
    "output": "le_times_to_le_div2 : m : Nat -> n : Nat -> q : Nat -> __ : Lt 0 q -> __1 : Leq n (times m q) -> Leq (div n q) m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_times_to_le_div2. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then if $n$ is less than or equal to the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than or equal to $m$.",
    "output": "postulate le_times_to_le_div2 : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Leq n (times m q)) -> Leq (div n q) m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_times_to_le_div2. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then if $n$ is less than or equal to the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than or equal to $m$.",
    "output": "Axiom le_times_to_le_div2 : forall m : nat, forall n : nat, forall q : nat, forall x__ : (0 < q), forall __1 : Leq n (m * q), Leq (n / q) m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_times_to_le_div2. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then if $n$ is less than or equal to the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than or equal to $m$.",
    "output": "axiom le_times_to_le_div2 (m n q : Nat) (x__ : 0 < q) (__1 : n ≤ m * q) : n / q ≤ m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_times_to_lt_div. For all natural numbers $m$ and $n$ and $q$, if $n$ is less than the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than $m$.",
    "output": "lt_times_to_lt_div : m : Nat -> n : Nat -> q : Nat -> __ : Lt n (times m q) -> Lt (div n q) m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_times_to_lt_div. For all natural numbers $m$ and $n$ and $q$, if $n$ is less than the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than $m$.",
    "output": "postulate lt_times_to_lt_div : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt n (times m q)) -> Lt (div n q) m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_times_to_lt_div. For all natural numbers $m$ and $n$ and $q$, if $n$ is less than the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than $m$.",
    "output": "Axiom lt_times_to_lt_div : forall m : nat, forall n : nat, forall q : nat, forall x__ : (n < m * q), n / q < m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_times_to_lt_div. For all natural numbers $m$ and $n$ and $q$, if $n$ is less than the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than $m$.",
    "output": "axiom lt_times_to_lt_div (m n q : Nat) (x__ : n < m * q) : n / q < m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1034. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $n$, then if $0$ is less than $m$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.",
    "output": "let_clause_1034 : n : Nat -> m : Nat -> q : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1034. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $n$, then if $0$ is less than $m$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.",
    "output": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (q : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_1034. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $n$, then if $0$ is less than $m$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.",
    "output": "Axiom let_clause_1034 : forall n : nat, forall m : nat, forall q : nat, forall posn : (0 < n), forall posm : (0 < m), forall x2515 : nat, forall x2516 : nat, x2515 = mod x2515 x2516 + x2516 * (x2515 / x2516) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_1034. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $n$, then if $0$ is less than $m$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.",
    "output": "axiom let_clause_1034 (n m q : Nat) (posn : 0 < n) (posm : 0 < m) (x2515 x2516 : Nat) : x2515 = mod x2515 x2516 + x2516 * (x2515 / x2516)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "log_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate log_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Log_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom log_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Log_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom log_n_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then the exponentiation of $__$ and $__1$ is a natural number.",
    "output": "pow : __ : Nat -> __1 : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then the exponentiation of $__$ and $__1$ is a natural number.",
    "output": "postulate pow : (_ : Nat) -> (__1 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then the exponentiation of $__$ and $__1$ is a natural number.",
    "output": "Axiom pow : forall x__ : nat, forall __1 : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then the exponentiation of $__$ and $__1$ is a natural number.",
    "output": "axiom pow (x__ __1 : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exp_1_n. For all natural numbers $n$, $1$ is equal to the exponentiation of $1$ and $n$.",
    "output": "exp_1_n : n : Nat -> Eq (nd 1) (pow (nd 1) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exp_1_n. For all natural numbers $n$, $1$ is equal to the exponentiation of $1$ and $n$.",
    "output": "postulate exp_1_n : (n : Nat) -> Eq 1 (pow 1 n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Exp_1_n. For all natural numbers $n$, $1$ is equal to the exponentiation of $1$ and $n$.",
    "output": "Axiom exp_1_n : forall n : nat, 1 = pow 1 n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Exp_1_n. For all natural numbers $n$, $1$ is equal to the exponentiation of $1$ and $n$.",
    "output": "axiom exp_1_n (n : Nat) : 1 = pow 1 n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_exp_to_lt. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the exponentiation of $a$ and $n$ is less than the exponentiation of $a$ and $m$, then $n$ is less than $m$.",
    "output": "lt_exp_to_lt : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 a -> __1 : Lt (pow a n) (pow a m) -> Lt n m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_exp_to_lt. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the exponentiation of $a$ and $n$ is less than the exponentiation of $a$ and $m$, then $n$ is less than $m$.",
    "output": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_exp_to_lt. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the exponentiation of $a$ and $n$ is less than the exponentiation of $a$ and $m$, then $n$ is less than $m$.",
    "output": "Axiom lt_exp_to_lt : forall a : nat, forall n : nat, forall m : nat, forall x__ : (0 < a), forall __1 : (pow a n < pow a m), n < m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_exp_to_lt. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the exponentiation of $a$ and $n$ is less than the exponentiation of $a$ and $m$, then $n$ is less than $m$.",
    "output": "axiom lt_exp_to_lt (a n m : Nat) (x__ : 0 < a) (__1 : pow a n < pow a m) : n < m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_2_fact. For all natural numbers $n$, if $1$ is less than $n$, then $2$ is less than or equal to the factorial of $n$.",
    "output": "le_2_fact : n : Nat -> __ : Lt (nd 1) n -> Leq (nd 2) (factorial n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_2_fact. For all natural numbers $n$, if $1$ is less than $n$, then $2$ is less than or equal to the factorial of $n$.",
    "output": "postulate le_2_fact : (n : Nat) -> (_ : Lt 1 n) -> Leq 2 (factorial n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_2_fact. For all natural numbers $n$, if $1$ is less than $n$, then $2$ is less than or equal to the factorial of $n$.",
    "output": "Axiom le_2_fact : forall n : nat, forall x__ : (1 < n), Leq 2 (factorial n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_2_fact. For all natural numbers $n$, if $1$ is less than $n$, then $2$ is less than or equal to the factorial of $n$.",
    "output": "axiom le_2_fact (n : Nat) (x__ : 1 < n) : 2 ≤ factorial n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_lstar_r : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Filter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_lstar_r : forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 B, forall __2 : cic.Term univs.Type0 B, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Filter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_lstar_r (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 __2 : cic.Term univs.Type0 B) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "lstar_lstar_r : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "postulate lstar_lstar_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lstar_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "Axiom lstar_lstar_r : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lstar_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "axiom lstar_lstar_r (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_ind_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "lstar_ind_r : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> __2 : cic.Term cic.prop (R b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> cic.Term cic.prop (P l b2) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_ind_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "postulate lstar_ind_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b2)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lstar_ind_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "Axiom lstar_ind_r : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B), forall __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1), forall __1 : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b2 : cic.Term univs.Type0 B, forall __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2), cic.Term cic.prop (P l b2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lstar_ind_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "axiom lstar_ind_r (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 : cic.Term univs.Type0 B) (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b2 : cic.Term univs.Type0 B) (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) : cic.Term cic.prop (P l b2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_gcd_nm. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is divisible by $m$ and the greatest common divisor of $n$ and $m$ is divisible by $n$.",
    "output": "divides_gcd_nm : n : Nat -> m : Nat -> and (divisible (gcd n m) m) (divisible (gcd n m) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_gcd_nm. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is divisible by $m$ and the greatest common divisor of $n$ and $m$ is divisible by $n$.",
    "output": "postulate divides_gcd_nm : (n : Nat) -> (m : Nat) -> and (divisible (gcd n m) m) (divisible (gcd n m) n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Divides_gcd_nm. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is divisible by $m$ and the greatest common divisor of $n$ and $m$ is divisible by $n$.",
    "output": "Axiom divides_gcd_nm : forall n : nat, forall m : nat, divisible (gcd n m) m /\\ divisible (gcd n m) n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Divides_gcd_nm. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is divisible by $m$ and the greatest common divisor of $n$ and $m$ is divisible by $n$.",
    "output": "axiom divides_gcd_nm (n m : Nat) : divisible (gcd n m) m ∧ divisible (gcd n m) n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_d_gcd. For all natural numbers $m$ and $n$ and $d$, if $d$ is divisible by $m$, then if $d$ is divisible by $n$, then $d$ is divisible by the greatest common divisor of $n$ and $m$.",
    "output": "divides_d_gcd : m : Nat -> n : Nat -> d : Nat -> __ : divisible d m -> __1 : divisible d n -> divisible d (gcd n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_d_gcd. For all natural numbers $m$ and $n$ and $d$, if $d$ is divisible by $m$, then if $d$ is divisible by $n$, then $d$ is divisible by the greatest common divisor of $n$ and $m$.",
    "output": "postulate divides_d_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : divisible d m) -> (__1 : divisible d n) -> divisible d (gcd n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Divides_d_gcd. For all natural numbers $m$ and $n$ and $d$, if $d$ is divisible by $m$, then if $d$ is divisible by $n$, then $d$ is divisible by the greatest common divisor of $n$ and $m$.",
    "output": "Axiom divides_d_gcd : forall m : nat, forall n : nat, forall d : nat, forall x__ : divisible d m, forall __1 : divisible d n, divisible d (gcd n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Divides_d_gcd. For all natural numbers $m$ and $n$ and $d$, if $d$ is divisible by $m$, then if $d$ is divisible by $n$, then $d$ is divisible by the greatest common divisor of $n$ and $m$.",
    "output": "axiom divides_d_gcd (m n d : Nat) (x__ : divisible d m) (__1 : divisible d n) : divisible d (gcd n m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.",
    "output": "max_f_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.",
    "output": "postulate max_f_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Max_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.",
    "output": "Axiom max_f_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Max_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.",
    "output": "axiom max_f_g (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "min_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate min_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Min_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom min_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Min_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom min_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.",
    "output": "gcd_n_n : n : Nat -> Eq (gcd n n) n ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.",
    "output": "postulate gcd_n_n : (n : Nat) -> Eq (gcd n n) n"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Gcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.",
    "output": "Axiom gcd_n_n : forall n : nat, gcd n n = n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Gcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.",
    "output": "axiom gcd_n_n (n : Nat) : gcd n n = n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Gcd_1_to_lt_n. For all natural numbers $i$ and $n$, if $1$ is less than $n$, then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.",
    "output": "gcd_1_to_lt_n : i : Nat -> n : Nat -> __ : Lt (nd 1) n -> __1 : Leq i n -> __2 : Eq (gcd i n) (nd 1) -> Lt i n ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Gcd_1_to_lt_n. For all natural numbers $i$ and $n$, if $1$ is less than $n$, then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.",
    "output": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Gcd_1_to_lt_n. For all natural numbers $i$ and $n$, if $1$ is less than $n$, then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.",
    "output": "Axiom gcd_1_to_lt_n : forall i : nat, forall n : nat, forall x__ : (1 < n), forall __1 : Leq i n, forall __2 : (gcd i n = 1), i < n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Gcd_1_to_lt_n. For all natural numbers $i$ and $n$, if $1$ is less than $n$, then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.",
    "output": "axiom gcd_1_to_lt_n (i n : Nat) (x__ : 1 < n) (__1 : i ≤ n) (__2 : gcd i n = 1) : i < n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the exponentiation of $n$ and $m$, then $p$ is divisible by $n$.",
    "output": "divides_exp_to_divides : p : Nat -> n : Nat -> m : Nat -> __ : prime p -> __1 : divisible p (pow n m) -> divisible p n ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the exponentiation of $n$ and $m$, then $p$ is divisible by $n$.",
    "output": "postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Divides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the exponentiation of $n$ and $m$, then $p$ is divisible by $n$.",
    "output": "Axiom divides_exp_to_divides : forall p : nat, forall n : nat, forall m : nat, forall x__ : prime p, forall __1 : divisible p (pow n m), divisible p n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Divides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the exponentiation of $n$ and $m$, then $p$ is divisible by $n$.",
    "output": "axiom divides_exp_to_divides (p n m : Nat) (x__ : prime p) (__1 : divisible p (pow n m)) : divisible p n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_iter. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $b$ and $i$, for all elements $__$ of $monotonic$ of $Nat$ and $Leq$ and $g$, if $a$ is less than or equal to $b$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $i$ and $b$.",
    "output": "monotonic_iter : g : (__ : Nat -> Nat) -> a : Nat -> b : Nat -> i : Nat -> __ : monotonic Nat Leq g -> __1 : Leq a b -> Leq (iter Nat g i a) (iter Nat g i b) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_iter. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $b$ and $i$, for all elements $__$ of $monotonic$ of $Nat$ and $Leq$ and $g$, if $a$ is less than or equal to $b$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $i$ and $b$.",
    "output": "postulate monotonic_iter : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (b : Nat) -> (i : Nat) -> (_ : monotonic Nat Leq g) -> (__1 : Leq a b) -> Leq (iter Nat g i a) (iter Nat g i b)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Monotonic_iter. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $b$ and $i$, for all elements $__$ of $monotonic$ of $Nat$ and $Leq$ and $g$, if $a$ is less than or equal to $b$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $i$ and $b$.",
    "output": "Axiom monotonic_iter : forall g : ((x__ : nat) -> nat), forall a : nat, forall b : nat, forall i : nat, forall x__ : monotonic nat Leq g, forall __1 : Leq a b, Leq (iter nat g i a) (iter nat g i b) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Monotonic_iter. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $b$ and $i$, for all elements $__$ of $monotonic$ of $Nat$ and $Leq$ and $g$, if $a$ is less than or equal to $b$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $i$ and $b$.",
    "output": "axiom monotonic_iter (g : (x__ : Nat) -> Nat) (a b i : Nat) (x__ : monotonic Nat Leq g) (__1 : a ≤ b) : iter Nat g i a ≤ iter Nat g i b"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_nat. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_O$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$, for all functions $case_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_nat : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ return_sort) -> case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O) -> case_S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))) -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_nat. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_O$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$, for all functions $case_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_nat : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ return_sort) -> (case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O)) -> (case_S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Match_nat. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_O$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$, for all functions $case_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_nat : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ return_sort), forall case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O), forall case_S : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))), forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Match_nat. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_O$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$, for all functions $case_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_nat (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ return_sort) (case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O)) (case_S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))) (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type3. For all functions $Q_$ from elements $_x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_O$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_380$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, for all elements $x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_377$.",
    "output": "nat_rect_Type3 : Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type3) -> _H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_380 : cic.Term univs.Type3 (Q_ x_378) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type3 (Q_ x_377) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type3. For all functions $Q_$ from elements $_x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_O$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_380$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, for all elements $x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_377$.",
    "output": "postulate nat_rect_Type3 : (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type3 (Q_ x_377)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_Type3. For all functions $Q_$ from elements $_x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_O$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_380$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, for all elements $x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_377$.",
    "output": "Axiom nat_rect_Type3 : forall Q_ : ((_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3), forall _H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))), forall x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type3 (Q_ x_377) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_Type3. For all functions $Q_$ from elements $_x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_O$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_380$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, for all elements $x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_377$.",
    "output": "axiom nat_rect_Type3 (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type3 (Q_ x_377)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from elements $_x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_O$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_384$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, for all elements $x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_381$.",
    "output": "nat_rect_Type2_body : Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type2) -> _H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_384 : cic.Term univs.Type2 (Q_ x_382) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) -> x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type2 (Q_ x_381) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from elements $_x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_O$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_384$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, for all elements $x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_381$.",
    "output": "postulate nat_rect_Type2_body : (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) -> (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type2 (Q_ x_381)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from elements $_x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_O$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_384$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, for all elements $x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_381$.",
    "output": "Axiom nat_rect_Type2_body : forall Q_ : ((_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2), forall _H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))), forall x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type2 (Q_ x_381) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from elements $_x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_O$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_384$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, for all elements $x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_381$.",
    "output": "axiom nat_rect_Type2_body (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type2 (Q_ x_381)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type0. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "nat_rect_Type0 : Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : cic.Term univs.Type0 (Q_ x_390) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (Q_ x_389) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type0. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "postulate nat_rect_Type0 : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_Type0. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "Axiom nat_rect_Type0 : forall Q_ : ((_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0), forall _H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))), forall x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (Q_ x_389) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_Type0. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "axiom nat_rect_Type0 (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (Q_ x_389)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Log_div. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.",
    "output": "log_div : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 m -> __2 : Leq m n -> Leq (log p (div n m)) (minus (log p n) (log p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Log_div. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.",
    "output": "postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Log_div. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.",
    "output": "Axiom log_div : forall p : nat, forall n : nat, forall m : nat, forall x__ : (1 < p), forall __1 : (0 < m), forall __2 : Leq m n, Leq (log p (n / m)) (log p n - log p m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Log_div. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.",
    "output": "axiom log_div (p n m : Nat) (x__ : 1 < p) (__1 : 0 < m) (__2 : m ≤ n) : log p (n / m) ≤ log p n - log p m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "nat_rect_CProp3_body : Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_404 : cic.Term cic.prop (Q_ x_402) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_401) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "postulate nat_rect_CProp3_body : (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_401)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "Axiom nat_rect_CProp3_body : forall Q_ : ((_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))), forall x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_401) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "axiom nat_rect_CProp3_body (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_401)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_CProp2_body. For all functions $Q_$ from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.",
    "output": "nat_rect_CProp2_body : Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_408 : cic.Term cic.prop (Q_ x_406) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_405) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp2_body. For all functions $Q_$ from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.",
    "output": "postulate nat_rect_CProp2_body : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_CProp2_body. For all functions $Q_$ from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.",
    "output": "Axiom nat_rect_CProp2_body : forall Q_ : ((_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))), forall x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_405) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_CProp2_body. For all functions $Q_$ from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.",
    "output": "axiom nat_rect_CProp2_body (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_405)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.",
    "output": "nat_rect_CProp0_body : Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_416 : cic.Term cic.prop (Q_ x_414) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_413) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.",
    "output": "postulate nat_rect_CProp0_body : (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_413)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.",
    "output": "Axiom nat_rect_CProp0_body : forall Q_ : ((_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))), forall x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_413) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.",
    "output": "axiom nat_rect_CProp0_body (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_413)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_ind_body. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all functions $Q_$ from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions, for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $x_1236$ and $l$ and $b2$ and $x_1235$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.",
    "output": "lstar_ind_body : B : Set -> _R : relation B -> Q_ : (x_1233 : Nat -> x_1232 : B -> x_1231 : B -> _x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Prop) -> _H_lstar_O : (b : B -> Q_ 0 b b (lstar_O B _R b)) -> _H_lstar_S : (b1 : B -> b : B -> x_1236 : _R b1 b -> l : Nat -> b2 : B -> x_1235 : lstar B _R l b b2 -> _x_1238 : Q_ l b b2 x_1235 -> Q_ (plus l (nd 1)) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> x_1233 : Nat -> x_1232 : B -> x_1231 : B -> x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Q_ x_1233 x_1232 x_1231 x_1234 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_ind_body. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all functions $Q_$ from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions, for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $x_1236$ and $l$ and $b2$ and $x_1235$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.",
    "output": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lstar_ind_body. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all functions $Q_$ from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions, for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $x_1236$ and $l$ and $b2$ and $x_1235$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.",
    "output": "Axiom lstar_ind_body : forall B : Set, forall _R : relation B, forall Q_ : ((x_1233 : nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop), forall _H_lstar_O : ((b : B) -> Q_ 0 b b (lstar_O B _R b)), forall _H_lstar_S : ((b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)), forall x_1233 : nat, forall x_1232 : B, forall x_1231 : B, forall x_1234 : lstar B _R x_1233 x_1232 x_1231, Q_ x_1233 x_1232 x_1231 x_1234 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lstar_ind_body. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all functions $Q_$ from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions, for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $x_1236$ and $l$ and $b2$ and $x_1235$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.",
    "output": "axiom lstar_ind_body (B : Set) (_R : relation B) (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) (x_1233 : Nat) (x_1232 x_1231 : B) (x_1234 : lstar B _R x_1233 x_1232 x_1231) : Q_ x_1233 x_1232 x_1231 x_1234"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_inv_step. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $1$ and $b1$ and $b2$, $R$ holds for $b1$ and $b2$.",
    "output": "lstar_inv_step : B : Set -> R : relation B -> b1 : B -> b2 : B -> __ : lstar B R (nd 1) b1 b2 -> R b1 b2 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_inv_step. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $1$ and $b1$ and $b2$, $R$ holds for $b1$ and $b2$.",
    "output": "postulate lstar_inv_step : (B : Set) -> (R : relation B) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R 1 b1 b2) -> R b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lstar_inv_step. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $1$ and $b1$ and $b2$, $R$ holds for $b1$ and $b2$.",
    "output": "Axiom lstar_inv_step : forall B : Set, forall R : relation B, forall b1 : B, forall b2 : B, forall x__ : lstar B R 1 b1 b2, R b1 b2 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lstar_inv_step. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $1$ and $b1$ and $b2$, $R$ holds for $b1$ and $b2$.",
    "output": "axiom lstar_inv_step (B : Set) (R : relation B) (b1 b2 : B) (x__ : lstar B R 1 b1 b2) : R b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_zero. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "not_zero : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_zero. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate not_zero : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_zero. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom not_zero : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_zero. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom not_zero (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "le_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate le_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "Axiom le_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "axiom le_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_r_S. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $B$, for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and the sum of $l$ and $1$ and $b1$ and $b2$.",
    "output": "lstar_r_S : B : Set -> R : relation B -> l : Nat -> b1 : B -> b : B -> __ : lstar_r B R l b1 b -> b2 : B -> __1 : R b b2 -> lstar_r B R (plus l (nd 1)) b1 b2 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_S. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $B$, for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and the sum of $l$ and $1$ and $b1$ and $b2$.",
    "output": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lstar_r_S. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $B$, for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and the sum of $l$ and $1$ and $b1$ and $b2$.",
    "output": "Axiom lstar_r_S : forall B : Set, forall R : relation B, forall l : nat, forall b1 : B, forall b : B, forall x__ : lstar_r B R l b1 b, forall b2 : B, forall __1 : R b b2, lstar_r B R (l + 1) b1 b2 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lstar_r_S. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $B$, for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and the sum of $l$ and $1$ and $b1$ and $b2$.",
    "output": "axiom lstar_r_S (B : Set) (R : relation B) (l : Nat) (b1 b : B) (x__ : lstar_r B R l b1 b) (b2 : B) (__1 : R b b2) : lstar_r B R (l + 1) b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "match_le : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Univ return_sort) -> case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n)) -> case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _n m) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type __ z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "Axiom match_le : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort), forall case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n)), forall case_le_S : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term cic.prop (matita_arithmetics_nat.le _n __), cic.Term return_sort (return_type __ z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "axiom match_le (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) : cic.Term return_sort (return_type __ z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "le_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417) -> cic.Univ cic.prop) -> _H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n)) -> _H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m) -> _x_421 : cic.Term cic.prop (Q_ m x_419) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417) -> cic.Term cic.prop (Q_ x_417 x_418) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "postulate le_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "Axiom le_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop), forall _H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n)), forall _H_le_S : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))), forall x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417), cic.Term cic.prop (Q_ x_417 x_418) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "axiom le_ind_body (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) : cic.Term cic.prop (Q_ x_417 x_418)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_r_inv_ind. For all sets $x1$, for all elements $x2$ of $relation$ of $x1$, for all natural numbers $x3$, for all elements $x4$ and $x5$ of $x1$, for all elements $_Hterm$ of $lstar_r$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from natural numbers $_z2386$ and elements $_z2385$ of $x1$ and elements $_z2384$ of $x1$ to propositions, for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2389$ of $Eq$ of $x3$ and $0$ and elements $_z2388$ of $Eq$ of $x4$ and $b$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from natural numbers $l$ and elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1340$ of $lstar_r$ of $x1$ and $x2$ and $l$ and $b1$ and $b$ and elements $b2$ of $x1$ and elements $_x_1339$ of $x2$ of $b$ and $b2$ and functions $_x_1342$ from elements $_z2389$ of $Eq$ of $x3$ and $l$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $l$ and $b1$ and $b$ and elements $_z2389$ of $Eq$ of $x3$ and the sum of $l$ and $1$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of the sum of $l$ and $1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.",
    "output": "lstar_r_inv_ind : x1 : Set -> x2 : relation x1 -> x3 : Nat -> x4 : x1 -> x5 : x1 -> _Hterm : lstar_r x1 x2 x3 x4 x5 -> P : (_z2386 : Nat -> _z2385 : x1 -> _z2384 : x1 -> Prop) -> _H1 : (b : x1 -> _z2389 : Eq x3 0 -> _z2388 : Eq x4 b -> _z2387 : Eq x5 b -> P 0 b b) -> _H2 : (l : Nat -> b1 : x1 -> b : x1 -> _x_1340 : lstar_r x1 x2 l b1 b -> b2 : x1 -> _x_1339 : x2 b b2 -> _x_1342 : (_z2389 : Eq x3 l -> _z2388 : Eq x4 b1 -> _z2387 : Eq x5 b -> P l b1 b) -> _z2389 : Eq x3 (plus l (nd 1)) -> _z2388 : Eq x4 b1 -> _z2387 : Eq x5 b2 -> P (plus l (nd 1)) b1 b2) -> P x3 x4 x5 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_r_inv_ind. For all sets $x1$, for all elements $x2$ of $relation$ of $x1$, for all natural numbers $x3$, for all elements $x4$ and $x5$ of $x1$, for all elements $_Hterm$ of $lstar_r$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from natural numbers $_z2386$ and elements $_z2385$ of $x1$ and elements $_z2384$ of $x1$ to propositions, for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2389$ of $Eq$ of $x3$ and $0$ and elements $_z2388$ of $Eq$ of $x4$ and $b$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from natural numbers $l$ and elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1340$ of $lstar_r$ of $x1$ and $x2$ and $l$ and $b1$ and $b$ and elements $b2$ of $x1$ and elements $_x_1339$ of $x2$ of $b$ and $b2$ and functions $_x_1342$ from elements $_z2389$ of $Eq$ of $x3$ and $l$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $l$ and $b1$ and $b$ and elements $_z2389$ of $Eq$ of $x3$ and the sum of $l$ and $1$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of the sum of $l$ and $1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.",
    "output": "postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (plus l 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lstar_r_inv_ind. For all sets $x1$, for all elements $x2$ of $relation$ of $x1$, for all natural numbers $x3$, for all elements $x4$ and $x5$ of $x1$, for all elements $_Hterm$ of $lstar_r$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from natural numbers $_z2386$ and elements $_z2385$ of $x1$ and elements $_z2384$ of $x1$ to propositions, for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2389$ of $Eq$ of $x3$ and $0$ and elements $_z2388$ of $Eq$ of $x4$ and $b$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from natural numbers $l$ and elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1340$ of $lstar_r$ of $x1$ and $x2$ and $l$ and $b1$ and $b$ and elements $b2$ of $x1$ and elements $_x_1339$ of $x2$ of $b$ and $b2$ and functions $_x_1342$ from elements $_z2389$ of $Eq$ of $x3$ and $l$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $l$ and $b1$ and $b$ and elements $_z2389$ of $Eq$ of $x3$ and the sum of $l$ and $1$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of the sum of $l$ and $1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.",
    "output": "Axiom lstar_r_inv_ind : forall x1 : Set, forall x2 : relation x1, forall x3 : nat, forall x4 : x1, forall x5 : x1, forall _Hterm : lstar_r x1 x2 x3 x4 x5, forall P : ((_z2386 : nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop), forall _H1 : ((b : x1) -> (_z2389 : x3 = 0) -> (_z2388 : x4 = b) -> (_z2387 : x5 = b) -> P 0 b b), forall _H2 : ((l : nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : x3 = l) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b) -> P l b1 b) -> (_z2389 : x3 = l + 1) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b2) -> P (l + 1) b1 b2), P x3 x4 x5 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lstar_r_inv_ind. For all sets $x1$, for all elements $x2$ of $relation$ of $x1$, for all natural numbers $x3$, for all elements $x4$ and $x5$ of $x1$, for all elements $_Hterm$ of $lstar_r$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from natural numbers $_z2386$ and elements $_z2385$ of $x1$ and elements $_z2384$ of $x1$ to propositions, for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2389$ of $Eq$ of $x3$ and $0$ and elements $_z2388$ of $Eq$ of $x4$ and $b$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from natural numbers $l$ and elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1340$ of $lstar_r$ of $x1$ and $x2$ and $l$ and $b1$ and $b$ and elements $b2$ of $x1$ and elements $_x_1339$ of $x2$ of $b$ and $b2$ and functions $_x_1342$ from elements $_z2389$ of $Eq$ of $x3$ and $l$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $l$ and $b1$ and $b$ and elements $_z2389$ of $Eq$ of $x3$ and the sum of $l$ and $1$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of the sum of $l$ and $1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.",
    "output": "axiom lstar_r_inv_ind (x1 : Set) (x2 : relation x1) (x3 : Nat) (x4 x5 : x1) (_Hterm : lstar_r x1 x2 x3 x4 x5) (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) (_H1 : (b : x1) -> (_z2389 : x3 = 0) -> (_z2388 : x4 = b) -> (_z2387 : x5 = b) -> P 0 b b) (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : x3 = l) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b) -> P l b1 b) -> (_z2389 : x3 = l + 1) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b2) -> P (l + 1) b1 b2) : P x3 x4 x5"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lstar_ind_r. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ of $B$, for all elements $P$ of $relation2$ of $Nat$ and $B$, for all elements $__$ of $P$ of $0$ and $b1$, for all functions $__1$ from natural numbers $l$ and elements $b$ of $B$ and elements $b2$ of $B$ and elements $__1$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $R$ of $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b2$, for all natural numbers $l$, for all elements $b2$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b2$.",
    "output": "lstar_ind_r : B : Set -> R : relation B -> b1 : B -> P : relation2 Nat B -> __ : P 0 b1 -> __1 : (l : Nat -> b : B -> b2 : B -> __1 : lstar B R l b1 b -> __2 : R b b2 -> __3 : P l b -> P (plus l (nd 1)) b2) -> l : Nat -> b2 : B -> __2 : lstar B R l b1 b2 -> P l b2 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lstar_ind_r. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ of $B$, for all elements $P$ of $relation2$ of $Nat$ and $B$, for all elements $__$ of $P$ of $0$ and $b1$, for all functions $__1$ from natural numbers $l$ and elements $b$ of $B$ and elements $b2$ of $B$ and elements $__1$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $R$ of $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b2$, for all natural numbers $l$, for all elements $b2$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b2$.",
    "output": "postulate lstar_ind_r : (B : Set) -> (R : relation B) -> (b1 : B) -> (P : relation2 Nat B) -> (_ : P 0 b1) -> (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (plus l 1) b2) -> (l : Nat) -> (b2 : B) -> (__2 : lstar B R l b1 b2) -> P l b2"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lstar_ind_r. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ of $B$, for all elements $P$ of $relation2$ of $Nat$ and $B$, for all elements $__$ of $P$ of $0$ and $b1$, for all functions $__1$ from natural numbers $l$ and elements $b$ of $B$ and elements $b2$ of $B$ and elements $__1$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $R$ of $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b2$, for all natural numbers $l$, for all elements $b2$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b2$.",
    "output": "Axiom lstar_ind_r : forall B : Set, forall R : relation B, forall b1 : B, forall P : relation2 nat B, forall x__ : P 0 b1, forall __1 : ((l : nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2), forall l : nat, forall b2 : B, forall __2 : lstar B R l b1 b2, P l b2 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lstar_ind_r. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ of $B$, for all elements $P$ of $relation2$ of $Nat$ and $B$, for all elements $__$ of $P$ of $0$ and $b1$, for all functions $__1$ from natural numbers $l$ and elements $b$ of $B$ and elements $b2$ of $B$ and elements $__1$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $R$ of $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b2$, for all natural numbers $l$, for all elements $b2$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b2$.",
    "output": "axiom lstar_ind_r (B : Set) (R : relation B) (b1 : B) (P : relation2 Nat B) (x__ : P 0 b1) (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2) (l : Nat) (b2 : B) (__2 : lstar B R l b1 b2) : P l b2"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max_O. For all functions $f$ from natural numbers to booleans, $max$ applied to $0$ and $f$ is equal to $0$.",
    "output": "max_O : f : (__ : Nat -> bool) -> Eq (max 0 f) 0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max_O. For all functions $f$ from natural numbers to booleans, $max$ applied to $0$ and $f$ is equal to $0$.",
    "output": "postulate max_O : (f : (_ : Nat) -> bool) -> Eq (max 0 f) 0"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Max_O. For all functions $f$ from natural numbers to booleans, $max$ applied to $0$ and $f$ is equal to $0$.",
    "output": "Axiom max_O : forall f : ((x__ : nat) -> bool), max 0 f = 0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Max_O. For all functions $f$ from natural numbers to booleans, $max$ applied to $0$ and $f$ is equal to $0$.",
    "output": "axiom max_O (f : (x__ : Nat) -> bool) : max 0 f = 0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_case. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "nat_case : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> __ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> __1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m)) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_case. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "postulate nat_case : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_case. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "Axiom nat_case : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall __1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))), cic.Term cic.prop (P n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_case. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "axiom nat_case (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) : cic.Term cic.prop (P n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "plus_O_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate plus_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Plus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom plus_O_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Plus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom plus_O_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Distributive_times_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.plus$.",
    "output": "distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive_times_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Distributive_times_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.plus$.",
    "output": "Axiom distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Distributive_times_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.plus$.",
    "output": "axiom distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_10131. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $n0$, if $max$ applied to the sum of $n0$ and $1$ and $f$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then for all natural numbers $i$ and $j$, if the sum of $j$ and $1$ is less than the sum of $n0$ and $1$, then for all natural numbers $x7$, $x7$ is equal to the sum of $m$ and $x7$.",
    "output": "let_clause_10131 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> n0 : Nat -> eqm : Eq (max (plus n0 (nd 1)) f) m -> fm : Eq (f m) false -> i : Nat -> j : Nat -> ltj : Lt (plus j (nd 1)) (plus n0 (nd 1)) -> x7 : Nat -> Eq x7 (plus m x7) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_10131. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $n0$, if $max$ applied to the sum of $n0$ and $1$ and $f$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then for all natural numbers $i$ and $j$, if the sum of $j$ and $1$ is less than the sum of $n0$ and $1$, then for all natural numbers $x7$, $x7$ is equal to the sum of $m$ and $x7$.",
    "output": "postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_10131. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $n0$, if $max$ applied to the sum of $n0$ and $1$ and $f$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then for all natural numbers $i$ and $j$, if the sum of $j$ and $1$ is less than the sum of $n0$ and $1$, then for all natural numbers $x7$, $x7$ is equal to the sum of $m$ and $x7$.",
    "output": "Axiom let_clause_10131 : forall f : ((x__ : nat) -> bool), forall n : nat, forall m : nat, forall n0 : nat, forall eqm : (max (n0 + 1) f = m), forall fm : (f m = false), forall i : nat, forall j : nat, forall ltj : (j + 1 < n0 + 1), forall x7 : nat, x7 = m + x7 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_10131. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $n0$, if $max$ applied to the sum of $n0$ and $1$ and $f$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then for all natural numbers $i$ and $j$, if the sum of $j$ and $1$ is less than the sum of $n0$ and $1$, then for all natural numbers $x7$, $x7$ is equal to the sum of $m$ and $x7$.",
    "output": "axiom let_clause_10131 (f : (x__ : Nat) -> bool) (n m n0 : Nat) (eqm : max (n0 + 1) f = m) (fm : f m = false) (i j : Nat) (ltj : j + 1 < n0 + 1) (x7 : Nat) : x7 = m + x7"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Times_n_1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "times_n_1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Times_n_1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate times_n_1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Times_n_1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom times_n_1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Times_n_1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom times_n_1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "minus_S_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate minus_S_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Minus_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "Axiom minus_S_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Minus_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "axiom minus_S_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F_max_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$.",
    "output": "f_max_true : f : (__ : Nat -> bool) -> n : Nat -> __ : ex Nat (i : Nat => and (Lt i n) (Eq (f i) true)) -> Eq (f (max n f)) true ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F_max_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$.",
    "output": "postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "F_max_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$.",
    "output": "Axiom f_max_true : forall f : ((x__ : nat) -> bool), forall n : nat, forall x__ : ex nat (fun i => i < n /\\ f i = true), f (max n f) = true ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "F_max_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$.",
    "output": "axiom f_max_true (f : (x__ : Nat) -> bool) (n : Nat) (x__ : ex Nat (λ i => i < n ∧ f i = true)) : f (max n f) = true"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exists_forall_lt. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity.",
    "output": "exists_forall_lt : f : (__ : Nat -> bool) -> n : Nat -> or (ex Nat (i : Nat => and (Lt i n) (Eq (f i) true))) (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n) (__ : Lt i n => Eq (f i) false))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exists_forall_lt. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity.",
    "output": "postulate exists_forall_lt : (f : (_ : Nat) -> bool) -> (n : Nat) -> or (ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ _ : Lt i n -> Eq (f i) false)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Exists_forall_lt. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity.",
    "output": "Axiom exists_forall_lt : forall f : ((x__ : nat) -> bool), forall n : nat, ex nat (fun i => i < n /\\ f i = true) \\/ prod Set Prop nat (fun i => prod Prop Prop (i < n) (fun x__ => f i = false)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Exists_forall_lt. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity.",
    "output": "axiom exists_forall_lt (f : (x__ : Nat) -> bool) (n : Nat) : ex Nat (λ i => i < n ∧ f i = true) ∨ prod Set Prop Nat (λ i => prod Prop Prop (i < n) (λ x__ => f i = false))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Exists_max_forall_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ and $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity and $max$ applied to $n$ and $f$ is equal to $0$.",
    "output": "exists_max_forall_false : f : (__ : Nat -> bool) -> n : Nat -> or (and (ex Nat (i : Nat => and (Lt i n) (Eq (f i) true))) (Eq (f (max n f)) true)) (and (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n) (__ : Lt i n => Eq (f i) false))) (Eq (max n f) 0)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Exists_max_forall_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ and $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity and $max$ applied to $n$ and $f$ is equal to $0$.",
    "output": "postulate exists_max_forall_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> or (and (ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) (Eq (f (max n f)) true)) (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ _ : Lt i n -> Eq (f i) false))) (Eq (max n f) 0))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Exists_max_forall_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ and $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity and $max$ applied to $n$ and $f$ is equal to $0$.",
    "output": "Axiom exists_max_forall_false : forall f : ((x__ : nat) -> bool), forall n : nat, ex nat (fun i => i < n /\\ f i = true) /\\ f (max n f) = true \\/ (prod Set Prop nat (fun i => prod Prop Prop (i < n) (fun x__ => f i = false)) /\\ max n f = 0) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Exists_max_forall_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ and $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity and $max$ applied to $n$ and $f$ is equal to $0$.",
    "output": "axiom exists_max_forall_false (f : (x__ : Nat) -> bool) (n : Nat) : ex Nat (λ i => i < n ∧ f i = true) ∧ f (max n f) = true ∨ (prod Set Prop Nat (λ i => prod Prop Prop (i < n) (λ x__ => f i = false)) ∧ max n f = 0)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "minus_Sn_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "postulate minus_Sn_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Minus_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "Axiom minus_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Minus_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "axiom minus_Sn_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min. For all natural numbers $__$ and $__1$, for all functions $__2$ from natural numbers $__2$ to booleans, $Nat$.",
    "output": "min : __ : Nat -> __1 : Nat -> __2 : (__2 : Nat -> bool) -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min. For all natural numbers $__$ and $__1$, for all functions $__2$ from natural numbers $__2$ to booleans, $Nat$.",
    "output": "postulate min : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Min. For all natural numbers $__$ and $__1$, for all functions $__2$ from natural numbers $__2$ to booleans, $Nat$.",
    "output": "Axiom min : forall x__ : nat, forall __1 : nat, forall __2 : ((__2 : nat) -> bool), nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Min. For all natural numbers $__$ and $__1$, for all functions $__2$ from natural numbers $__2$ to booleans, $Nat$.",
    "output": "axiom min (x__ __1 : Nat) (__2 : (__2 : Nat) -> bool) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "False_min. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, if $f$ applied to $b$ is equal to absurdity, then $min$ applied to the sum of $n$ and $1$ and $b$ and $f$ is equal to $min$ applied to $n$ and the sum of $b$ and $1$ and $f$.",
    "output": "false_min : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : Eq (f b) false -> Eq (min (plus n (nd 1)) b f) (min n (plus b (nd 1)) f) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_min. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, if $f$ applied to $b$ is equal to absurdity, then $min$ applied to the sum of $n$ and $1$ and $b$ and $f$ is equal to $min$ applied to $n$ and the sum of $b$ and $1$ and $f$.",
    "output": "postulate false_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : Eq (f b) false) -> Eq (min (plus n 1) b f) (min n (plus b 1) f)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "False_min. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, if $f$ applied to $b$ is equal to absurdity, then $min$ applied to the sum of $n$ and $1$ and $b$ and $f$ is equal to $min$ applied to $n$ and the sum of $b$ and $1$ and $f$.",
    "output": "Axiom false_min : forall f : ((x__ : nat) -> bool), forall n : nat, forall b : nat, forall x__ : (f b = false), min (n + 1) b f = min n (b + 1) f ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "False_min. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, if $f$ applied to $b$ is equal to absurdity, then $min$ applied to the sum of $n$ and $1$ and $b$ and $f$ is equal to $min$ applied to $n$ and the sum of $b$ and $1$ and $f$.",
    "output": "axiom false_min (f : (x__ : Nat) -> bool) (n b : Nat) (x__ : f b = false) : min (n + 1) b f = min n (b + 1) f"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "le_O_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom le_O_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom le_O_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "le_n_Sn : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "postulate le_n_Sn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "Axiom le_n_Sn : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "axiom le_n_Sn (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Monotonic_le_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "monotonic_le_times_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Monotonic_le_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "postulate monotonic_le_times_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times n m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Monotonic_le_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "Axiom monotonic_le_times_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (fun m => matita_arithmetics_nat.times n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Monotonic_le_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "axiom monotonic_le_times_r (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (λ m => matita_arithmetics_nat.times n m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min_spec_ind. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions, for all functions $_H_found_min_spec$ from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all natural numbers $x_1075$, for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.",
    "output": "min_spec_ind : _n : Nat -> _b : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_1075 : Nat -> _x_1076 : min_spec _n _b _f x_1075 -> Prop) -> _H_found_min_spec : (m : Nat -> x_1080 : Leq _b m -> x_1079 : Lt m (plus _n _b) -> x_1078 : Eq (_f m) true -> x_1077 : (i : Nat -> __ : Leq _b i -> __1 : Lt i m -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> _H_not_found_min_spec : (x_1081 : (i : Nat -> __ : Leq _b i -> __1 : Lt i (plus _n _b) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> x_1075 : Nat -> x_1076 : min_spec _n _b _f x_1075 -> Q_ x_1075 x_1076 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min_spec_ind. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions, for all functions $_H_found_min_spec$ from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all natural numbers $x_1075$, for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.",
    "output": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Min_spec_ind. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions, for all functions $_H_found_min_spec$ from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all natural numbers $x_1075$, for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.",
    "output": "Axiom min_spec_ind : forall _n : nat, forall _b : nat, forall _f : ((x__ : nat) -> bool), forall Q_ : ((x_1075 : nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop), forall _H_found_min_spec : ((m : nat) -> (x_1080 : Leq _b m) -> (x_1079 : m < _n + _b) -> (x_1078 : _f m = true) -> (x_1077 : (i : nat) -> (x__ : Leq _b i) -> (__1 : i < m) -> _f i = false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)), forall _H_not_found_min_spec : ((x_1081 : (i : nat) -> (x__ : Leq _b i) -> (__1 : i < _n + _b) -> _f i = false) -> Q_ (_n + _b) (not_found_min_spec _n _b _f x_1081)), forall x_1075 : nat, forall x_1076 : min_spec _n _b _f x_1075, Q_ x_1075 x_1076 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Min_spec_ind. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions, for all functions $_H_found_min_spec$ from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all natural numbers $x_1075$, for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.",
    "output": "axiom min_spec_ind (_n _b : Nat) (_f : (x__ : Nat) -> bool) (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) (_H_found_min_spec : (m : Nat) -> (x_1080 : _b ≤ m) -> (x_1079 : m < _n + _b) -> (x_1078 : _f m = true) -> (x_1077 : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < m) -> _f i = false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < _n + _b) -> _f i = false) -> Q_ (_n + _b) (not_found_min_spec _n _b _f x_1081)) (x_1075 : Nat) (x_1076 : min_spec _n _b _f x_1075) : Q_ x_1075 x_1076"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "lt_to_le : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt x y) -> cic.Term cic.prop (matita_arithmetics_nat.le x y) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "Axiom lt_to_le : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt x y), cic.Term cic.prop (matita_arithmetics_nat.le x y) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "axiom lt_to_le (x y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) : cic.Term cic.prop (matita_arithmetics_nat.le x y)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "lt_S_to_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "postulate lt_S_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "Axiom lt_S_to_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m), cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "axiom lt_S_to_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) : cic.Term cic.prop (matita_arithmetics_nat.lt n m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type4_body. For all functions $Q_$ from natural numbers $_x_369$ to elements of $Type4$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_370$ and elements $_x_372$ of $Q_$ of $x_370$ to elements of $Q_$ of the sum of $x_370$ and $1$, for all natural numbers $x_369$, $Q_$ holds for $x_369$.",
    "output": "nat_rect_Type4_body : Q_ : (_x_369 : Nat -> Type4) -> _H_O : Q_ 0 -> _H_S : (x_370 : Nat -> _x_372 : Q_ x_370 -> Q_ (plus x_370 (nd 1))) -> x_369 : Nat -> Q_ x_369 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type4_body. For all functions $Q_$ from natural numbers $_x_369$ to elements of $Type4$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_370$ and elements $_x_372$ of $Q_$ of $x_370$ to elements of $Q_$ of the sum of $x_370$ and $1$, for all natural numbers $x_369$, $Q_$ holds for $x_369$.",
    "output": "postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_Type4_body. For all functions $Q_$ from natural numbers $_x_369$ to elements of $Type4$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_370$ and elements $_x_372$ of $Q_$ of $x_370$ to elements of $Q_$ of the sum of $x_370$ and $1$, for all natural numbers $x_369$, $Q_$ holds for $x_369$.",
    "output": "Axiom nat_rect_Type4_body : forall Q_ : ((_x_369 : nat) -> Type4), forall _H_O : Q_ 0, forall _H_S : ((x_370 : nat) -> (_x_372 : Q_ x_370) -> Q_ (x_370 + 1)), forall x_369 : nat, Q_ x_369 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_Type4_body. For all functions $Q_$ from natural numbers $_x_369$ to elements of $Type4$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_370$ and elements $_x_372$ of $Q_$ of $x_370$ to elements of $Q_$ of the sum of $x_370$ and $1$, for all natural numbers $x_369$, $Q_$ holds for $x_369$.",
    "output": "axiom nat_rect_Type4_body (Q_ : (_x_369 : Nat) -> Type4) (_H_O : Q_ 0) (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (x_370 + 1)) (x_369 : Nat) : Q_ x_369"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_plus_to_lt_l. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $p$ and $n$ and $matita_arithmetics_nat.plus$ applied to $q$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "lt_plus_to_lt_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_plus_to_lt_l. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $p$ and $n$ and $matita_arithmetics_nat.plus$ applied to $q$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "postulate lt_plus_to_lt_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_plus_to_lt_l. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $p$ and $n$ and $matita_arithmetics_nat.plus$ applied to $q$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "Axiom lt_plus_to_lt_l : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n)), cic.Term cic.prop (matita_arithmetics_nat.lt p q) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_plus_to_lt_l. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $p$ and $n$ and $matita_arithmetics_nat.plus$ applied to $q$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "axiom lt_plus_to_lt_l (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "nat_rect_Type2_body : Q_ : (_x_381 : Nat -> Type2) -> _H_O : Q_ 0 -> _H_S : (x_382 : Nat -> _x_384 : Q_ x_382 -> Q_ (plus x_382 (nd 1))) -> x_381 : Nat -> Q_ x_381 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "Axiom nat_rect_Type2_body : forall Q_ : ((_x_381 : nat) -> Type2), forall _H_O : Q_ 0, forall _H_S : ((x_382 : nat) -> (_x_384 : Q_ x_382) -> Q_ (x_382 + 1)), forall x_381 : nat, Q_ x_381 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "axiom nat_rect_Type2_body (Q_ : (_x_381 : Nat) -> Type2) (_H_O : Q_ 0) (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (x_382 + 1)) (x_381 : Nat) : Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_16. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $x32$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $x32$ and $matita_arithmetics_nat.plus$ applied to $x32$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "let_clause_16 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) -> x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_16. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $x32$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $x32$ and $matita_arithmetics_nat.plus$ applied to $x32$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_16 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> (x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_16. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $x32$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $x32$ and $matita_arithmetics_nat.plus$ applied to $x32$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_16 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall auto : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)), forall x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_16. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $x32$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $x32$ and $matita_arithmetics_nat.plus$ applied to $x32$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_16 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) (x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "not_le_to_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "postulate not_le_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt m n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "Axiom not_le_to_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)), cic.Term cic.prop (matita_arithmetics_nat.lt m n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "axiom not_le_to_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) : cic.Term cic.prop (matita_arithmetics_nat.lt m n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "nat_rect_CProp0_body : Q_ : (_x_413 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_414 : Nat -> _x_416 : Q_ x_414 -> Q_ (plus x_414 (nd 1))) -> x_413 : Nat -> Q_ x_413 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "postulate nat_rect_CProp0_body : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "Axiom nat_rect_CProp0_body : forall Q_ : ((_x_413 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_414 : nat) -> (_x_416 : Q_ x_414) -> Q_ (x_414 + 1)), forall x_413 : nat, Q_ x_413 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "axiom nat_rect_CProp0_body (Q_ : (_x_413 : Nat) -> Prop) (_H_O : Q_ 0) (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (x_414 + 1)) (x_413 : Nat) : Q_ x_413"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_lt_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "not_lt_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le m n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_lt_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "postulate not_lt_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_lt_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "Axiom not_lt_to_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m)), cic.Term cic.prop (matita_arithmetics_nat.le m n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_lt_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "axiom not_lt_to_le (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m))) : cic.Term cic.prop (matita_arithmetics_nat.le m n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "increasing_to_le2 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Increasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "postulate increasing_to_le2 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Increasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "Axiom increasing_to_le2 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Increasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "axiom increasing_to_le2 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m)) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i)))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nat_inv_rect_CProp3. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z695$ to propositions, for all functions $_H1$ from elements $_z696$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_402$ and functions $_x_404$ from elements $_z696$ of $Eq$ of $Hterm$ and $x_402$ to elements of $P$ of $x_402$ and elements $_z696$ of $Eq$ of $Hterm$ and the sum of $x_402$ and $1$ to elements of $P$ of the sum of $x_402$ and $1$, $P$ holds for $Hterm$.",
    "output": "nat_inv_rect_CProp3 : Hterm : Nat -> P : (_z695 : Nat -> Prop) -> _H1 : (_z696 : Eq Hterm 0 -> P 0) -> _H2 : (x_402 : Nat -> _x_404 : (_z696 : Eq Hterm x_402 -> P x_402) -> _z696 : Eq Hterm (plus x_402 (nd 1)) -> P (plus x_402 (nd 1))) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nat_inv_rect_CProp3. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z695$ to propositions, for all functions $_H1$ from elements $_z696$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_402$ and functions $_x_404$ from elements $_z696$ of $Eq$ of $Hterm$ and $x_402$ to elements of $P$ of $x_402$ and elements $_z696$ of $Eq$ of $Hterm$ and the sum of $x_402$ and $1$ to elements of $P$ of the sum of $x_402$ and $1$, $P$ holds for $Hterm$.",
    "output": "postulate nat_inv_rect_CProp3 : (Hterm : Nat) -> (P : (_z695 : Nat) -> Prop) -> (_H1 : (_z696 : Eq Hterm 0) -> P 0) -> (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Eq Hterm x_402) -> P x_402) -> (_z696 : Eq Hterm (plus x_402 1)) -> P (plus x_402 1)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nat_inv_rect_CProp3. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z695$ to propositions, for all functions $_H1$ from elements $_z696$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_402$ and functions $_x_404$ from elements $_z696$ of $Eq$ of $Hterm$ and $x_402$ to elements of $P$ of $x_402$ and elements $_z696$ of $Eq$ of $Hterm$ and the sum of $x_402$ and $1$ to elements of $P$ of the sum of $x_402$ and $1$, $P$ holds for $Hterm$.",
    "output": "Axiom nat_inv_rect_CProp3 : forall Hterm : nat, forall P : ((_z695 : nat) -> Prop), forall _H1 : ((_z696 : Hterm = 0) -> P 0), forall _H2 : ((x_402 : nat) -> (_x_404 : (_z696 : Hterm = x_402) -> P x_402) -> (_z696 : Hterm = x_402 + 1) -> P (x_402 + 1)), P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nat_inv_rect_CProp3. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z695$ to propositions, for all functions $_H1$ from elements $_z696$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_402$ and functions $_x_404$ from elements $_z696$ of $Eq$ of $Hterm$ and $x_402$ to elements of $P$ of $x_402$ and elements $_z696$ of $Eq$ of $Hterm$ and the sum of $x_402$ and $1$ to elements of $P$ of the sum of $x_402$ and $1$, $P$ holds for $Hterm$.",
    "output": "axiom nat_inv_rect_CProp3 (Hterm : Nat) (P : (_z695 : Nat) -> Prop) (_H1 : (_z696 : Hterm = 0) -> P 0) (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Hterm = x_402) -> P x_402) -> (_z696 : Hterm = x_402 + 1) -> P (x_402 + 1)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_inv_S1. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $matita_arithmetics_nat.nat$ and the function that maps $z$ to $matita_arithmetics_nat.le$ applied to $x$ and $z$ and the function that maps $z$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.S$ applied to $z$.",
    "output": "le_inv_S1 : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S x) y) -> cic.Term cic.prop (matita_basics_logic.ex2 matita_arithmetics_nat.nat (z : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.le x z) (z : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y (matita_arithmetics_nat.S z))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_inv_S1. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $matita_arithmetics_nat.nat$ and the function that maps $z$ to $matita_arithmetics_nat.le$ applied to $x$ and $z$ and the function that maps $z$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.S$ applied to $z$.",
    "output": "postulate le_inv_S1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S x) y)) -> cic.Term cic.prop (matita_basics_logic.ex2 matita_arithmetics_nat.nat (\\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.le x z) (\\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y (matita_arithmetics_nat.S z)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_inv_S1. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $matita_arithmetics_nat.nat$ and the function that maps $z$ to $matita_arithmetics_nat.le$ applied to $x$ and $z$ and the function that maps $z$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.S$ applied to $z$.",
    "output": "Axiom le_inv_S1 : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S x) y), cic.Term cic.prop (matita_basics_logic.ex2 matita_arithmetics_nat.nat (fun z => matita_arithmetics_nat.le x z) (fun z => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y (matita_arithmetics_nat.S z))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_inv_S1. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $matita_arithmetics_nat.nat$ and the function that maps $z$ to $matita_arithmetics_nat.le$ applied to $x$ and $z$ and the function that maps $z$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.S$ applied to $z$.",
    "output": "axiom le_inv_S1 (x y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S x) y)) : cic.Term cic.prop (matita_basics_logic.ex2 matita_arithmetics_nat.nat (λ z => matita_arithmetics_nat.le x z) (λ z => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y (matita_arithmetics_nat.S z)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_n_O_elim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $P$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "le_n_O_elim : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O) -> P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> __1 : cic.Term cic.prop (P matita_arithmetics_nat.O) -> cic.Term cic.prop (P n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_O_elim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $P$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "postulate le_n_O_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_n_O_elim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $P$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "Axiom le_n_O_elim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O), forall P : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __1 : cic.Term cic.prop (P matita_arithmetics_nat.O), cic.Term cic.prop (P n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_n_O_elim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $P$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "axiom le_n_O_elim (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) : cic.Term cic.prop (P n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "F2_ind_aux. For all elements $A1$ and $A2$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A1$ and $A2$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$.",
    "output": "f2_ind_aux : A1 : cic.Univ univs.Type0 -> A2 : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A1 -> __1 : cic.Term univs.Type0 A2 -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "F2_ind_aux. For all elements $A1$ and $A2$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A1$ and $A2$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$.",
    "output": "postulate f2_ind_aux : (A1 : cic.Univ univs.Type0) -> (A2 : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "F2_ind_aux. For all elements $A1$ and $A2$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A1$ and $A2$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$.",
    "output": "Axiom f2_ind_aux : forall A1 : cic.Univ univs.Type0, forall A2 : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2), forall __ : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a1 : cic.Term univs.Type0 A1, forall a2 : cic.Term univs.Type0 A2, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n), cic.Term cic.prop (P a1 a2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "F2_ind_aux. For all elements $A1$ and $A2$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A1$ and $A2$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$.",
    "output": "axiom f2_ind_aux (A1 A2 : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2)) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (a1 : cic.Term univs.Type0 A1) (a2 : cic.Term univs.Type0 A2) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) : cic.Term cic.prop (P a1 a2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then we can say that $__$ is greater than or equal to $__1$.",
    "output": "Geq : __ : Nat -> __1 : Nat -> Prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then we can say that $__$ is greater than or equal to $__1$.",
    "output": "postulate Geq : (_ : Nat) -> (__1 : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then we can say that $__$ is greater than or equal to $__1$.",
    "output": "Axiom Geq : forall x__ : nat, forall __1 : nat, Prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then we can say that $__$ is greater than or equal to $__1$.",
    "output": "axiom Geq (x__ __1 : Nat) : Prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "le_to_le_to_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate le_to_le_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "Axiom le_to_le_to_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "axiom le_to_le_to_eq (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_gen. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $i$ and $n$ to elements of $P$ of $i$, $P$ holds for $n$.",
    "output": "le_gen : P : (__ : Nat -> Prop) -> n : Nat -> __ : (i : Nat -> __ : Leq i n -> P i) -> P n ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_gen. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $i$ and $n$ to elements of $P$ of $i$, $P$ holds for $n$.",
    "output": "postulate le_gen : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Leq i n) -> P i) -> P n"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_gen. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $i$ and $n$ to elements of $P$ of $i$, $P$ holds for $n$.",
    "output": "Axiom le_gen : forall P : ((x__ : nat) -> Prop), forall n : nat, forall x__ : ((i : nat) -> (x__ : Leq i n) -> P i), P n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_gen. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $i$ and $n$ to elements of $P$ of $i$, $P$ holds for $n$.",
    "output": "axiom le_gen (P : (x__ : Nat) -> Prop) (n : Nat) (x__ : (i : Nat) -> (x__ : i ≤ n) -> P i) : P n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Commutative_plus. $commutative$ holds for $Nat$ and $plus$.",
    "output": "commutative_plus : commutative Nat plus ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_plus. $commutative$ holds for $Nat$ and $plus$.",
    "output": "postulate commutative_plus : commutative Nat plus"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Commutative_plus. $commutative$ holds for $Nat$ and $plus$.",
    "output": "Axiom commutative_plus : commutative nat plus ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Commutative_plus. $commutative$ holds for $Nat$ and $plus$.",
    "output": "axiom commutative_plus : commutative Nat plus"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Assoc_plus1. For all natural numbers $a$ and $b$ and $c$, the sum of $c$ and the sum of $b$ and $a$ is equal to the sum of the sum of $b$ and $c$ and $a$.",
    "output": "assoc_plus1 : a : Nat -> b : Nat -> c : Nat -> Eq (plus c (plus b a)) (plus (plus b c) a) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Assoc_plus1. For all natural numbers $a$ and $b$ and $c$, the sum of $c$ and the sum of $b$ and $a$ is equal to the sum of the sum of $b$ and $c$ and $a$.",
    "output": "postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Assoc_plus1. For all natural numbers $a$ and $b$ and $c$, the sum of $c$ and the sum of $b$ and $a$ is equal to the sum of the sum of $b$ and $c$ and $a$.",
    "output": "Axiom assoc_plus1 : forall a : nat, forall b : nat, forall c : nat, c + (b + a) = b + c + a ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Assoc_plus1. For all natural numbers $a$ and $b$ and $c$, the sum of $c$ and the sum of $b$ and $a$ is equal to the sum of the sum of $b$ and $c$ and $a$.",
    "output": "axiom assoc_plus1 (a b c : Nat) : c + (b + a) = b + c + a"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Minus_S_S. For all natural numbers $n$ and $m$, the difference of the sum of $n$ and $1$ and the sum of $m$ and $1$ is equal to the difference of $n$ and $m$.",
    "output": "minus_S_S : n : Nat -> m : Nat -> Eq (minus (plus n (nd 1)) (plus m (nd 1))) (minus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Minus_S_S. For all natural numbers $n$ and $m$, the difference of the sum of $n$ and $1$ and the sum of $m$ and $1$ is equal to the difference of $n$ and $m$.",
    "output": "postulate minus_S_S : (n : Nat) -> (m : Nat) -> Eq (minus (plus n 1) (plus m 1)) (minus n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Minus_S_S. For all natural numbers $n$ and $m$, the difference of the sum of $n$ and $1$ and the sum of $m$ and $1$ is equal to the difference of $n$ and $m$.",
    "output": "Axiom minus_S_S : forall n : nat, forall m : nat, n + 1 - (m + 1) = n - m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Minus_S_S. For all natural numbers $n$ and $m$, the difference of the sum of $n$ and $1$ and the sum of $m$ and $1$ is equal to the difference of $n$ and $m$.",
    "output": "axiom minus_S_S (n m : Nat) : n + 1 - (m + 1) = n - m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_plus_comm_23. For all natural numbers $x$ and $y$ and $z$, the sum of the sum of $x$ and $y$ and $z$ is equal to the sum of the sum of $x$ and $z$ and $y$.",
    "output": "plus_plus_comm_23 : x : Nat -> y : Nat -> z : Nat -> Eq (plus (plus x y) z) (plus (plus x z) y) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_plus_comm_23. For all natural numbers $x$ and $y$ and $z$, the sum of the sum of $x$ and $y$ and $z$ is equal to the sum of the sum of $x$ and $z$ and $y$.",
    "output": "postulate plus_plus_comm_23 : (x : Nat) -> (y : Nat) -> (z : Nat) -> Eq (plus (plus x y) z) (plus (plus x z) y)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Plus_plus_comm_23. For all natural numbers $x$ and $y$ and $z$, the sum of the sum of $x$ and $y$ and $z$ is equal to the sum of the sum of $x$ and $z$ and $y$.",
    "output": "Axiom plus_plus_comm_23 : forall x : nat, forall y : nat, forall z : nat, x + y + z = x + z + y ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Plus_plus_comm_23. For all natural numbers $x$ and $y$ and $z$, the sum of the sum of $x$ and $y$ and $z$ is equal to the sum of the sum of $x$ and $z$ and $y$.",
    "output": "axiom plus_plus_comm_23 (x y z : Nat) : x + y + z = x + z + y"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_not_zero. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $not_zero$ holds for $m$.",
    "output": "lt_to_not_zero : n : Nat -> m : Nat -> __ : Lt n m -> not_zero m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_not_zero. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $not_zero$ holds for $m$.",
    "output": "postulate lt_to_not_zero : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not_zero m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_to_not_zero. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $not_zero$ holds for $m$.",
    "output": "Axiom lt_to_not_zero : forall n : nat, forall m : nat, forall x__ : (n < m), not_zero m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_to_not_zero. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $not_zero$ holds for $m$.",
    "output": "axiom lt_to_not_zero (n m : Nat) (x__ : n < m) : not_zero m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_n_Sn. For all natural numbers $n$, $n$ is less than or equal to the sum of $n$ and $1$.",
    "output": "le_n_Sn : n : Nat -> Leq n (plus n (nd 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_Sn. For all natural numbers $n$, $n$ is less than or equal to the sum of $n$ and $1$.",
    "output": "postulate le_n_Sn : (n : Nat) -> Leq n (plus n 1)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_n_Sn. For all natural numbers $n$, $n$ is less than or equal to the sum of $n$ and $1$.",
    "output": "Axiom le_n_Sn : forall n : nat, Leq n (n + 1) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_n_Sn. For all natural numbers $n$, $n$ is less than or equal to the sum of $n$ and $1$.",
    "output": "axiom le_n_Sn (n : Nat) : n ≤ n + 1"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Leb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "leb : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Leb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "postulate leb : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Leb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "Axiom leb : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Leb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "axiom leb (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Leb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.leb$ applied to $n$ and $m$.",
    "output": "leb_elim : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (P matita_basics_bool.true)) -> __1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Leb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.leb$ applied to $n$ and $m$.",
    "output": "postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Leb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.leb$ applied to $n$ and $m$.",
    "output": "Axiom leb_elim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall __ : ((__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)), forall __1 : ((__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)), cic.Term cic.prop (P (matita_arithmetics_nat.leb n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Leb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.leb$ applied to $n$ and $m$.",
    "output": "axiom leb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_S_S_to_le. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than or equal to the sum of $m$ and $1$, then $n$ is less than or equal to $m$.",
    "output": "le_S_S_to_le : n : Nat -> m : Nat -> __ : Leq (plus n (nd 1)) (plus m (nd 1)) -> Leq n m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_S_S_to_le. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than or equal to the sum of $m$ and $1$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_S_S_to_le : (n : Nat) -> (m : Nat) -> (_ : Leq (plus n 1) (plus m 1)) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_S_S_to_le. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than or equal to the sum of $m$ and $1$, then $n$ is less than or equal to $m$.",
    "output": "Axiom le_S_S_to_le : forall n : nat, forall m : nat, forall x__ : Leq (n + 1) (m + 1), Leq n m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_S_S_to_le. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than or equal to the sum of $m$ and $1$, then $n$ is less than or equal to $m$.",
    "output": "axiom le_S_S_to_le (n m : Nat) (x__ : n + 1 ≤ m + 1) : n ≤ m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "lt_to_leb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "Axiom lt_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "axiom lt_to_leb_false (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Min. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "min : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Min. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Min. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom min : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Min. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom min (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Max. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "max : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Max. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate max : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Max. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom max : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Max. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom max (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Commutative_min. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.min$.",
    "output": "commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Commutative_min. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.min$.",
    "output": "postulate commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Commutative_min. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.min$.",
    "output": "Axiom commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Commutative_min. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.min$.",
    "output": "axiom commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_plus_to_le. For all natural numbers $a$ and $n$ and $m$, if the sum of $a$ and $n$ is less than or equal to the sum of $a$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "le_plus_to_le : a : Nat -> n : Nat -> m : Nat -> __ : Leq (plus a n) (plus a m) -> Leq n m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_to_le. For all natural numbers $a$ and $n$ and $m$, if the sum of $a$ and $n$ is less than or equal to the sum of $a$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_plus_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus a n) (plus a m)) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_plus_to_le. For all natural numbers $a$ and $n$ and $m$, if the sum of $a$ and $n$ is less than or equal to the sum of $a$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "Axiom le_plus_to_le : forall a : nat, forall n : nat, forall m : nat, forall x__ : Leq (a + n) (a + m), Leq n m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_plus_to_le. For all natural numbers $a$ and $n$ and $m$, if the sum of $a$ and $n$ is less than or equal to the sum of $a$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "axiom le_plus_to_le (a n m : Nat) (x__ : a + n ≤ a + m) : n ≤ m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_maxr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$.",
    "output": "le_maxr : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) -> cic.Term cic.prop (matita_arithmetics_nat.le m i) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_maxr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$.",
    "output": "postulate le_maxr : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)) -> cic.Term cic.prop (matita_arithmetics_nat.le m i)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_maxr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$.",
    "output": "Axiom le_maxr : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i), cic.Term cic.prop (matita_arithmetics_nat.le m i) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_maxr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$.",
    "output": "axiom le_maxr (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)) : cic.Term cic.prop (matita_arithmetics_nat.le m i)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "To_max. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.",
    "output": "to_max : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m i) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "To_max. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.",
    "output": "postulate to_max : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m i)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "To_max. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.",
    "output": "Axiom to_max : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m i), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "To_max. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.",
    "output": "axiom to_max (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m i)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "P_ord. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "p_ord : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate p_ord : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "P_ord. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom p_ord : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "P_ord. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom p_ord (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transitive_lt. $transitive$ holds for $Nat$ and $Lt$.",
    "output": "transitive_lt : transitive Nat Lt ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transitive_lt. $transitive$ holds for $Nat$ and $Lt$.",
    "output": "postulate transitive_lt : transitive Nat Lt"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Transitive_lt. $transitive$ holds for $Nat$ and $Lt$.",
    "output": "Axiom transitive_lt : transitive nat Lt ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Transitive_lt. $transitive$ holds for $Nat$ and $Lt$.",
    "output": "axiom transitive_lt : transitive Nat Lt"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_to_le_to_lt. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than $m$, then if $m$ is less than or equal to $p$, then $n$ is less than $p$.",
    "output": "lt_to_le_to_lt : n : Nat -> m : Nat -> p : Nat -> __ : Lt n m -> __1 : Leq m p -> Lt n p ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_to_le_to_lt. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than $m$, then if $m$ is less than or equal to $p$, then $n$ is less than $p$.",
    "output": "postulate lt_to_le_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt n m) -> (__1 : Leq m p) -> Lt n p"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_to_le_to_lt. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than $m$, then if $m$ is less than or equal to $p$, then $n$ is less than $p$.",
    "output": "Axiom lt_to_le_to_lt : forall n : nat, forall m : nat, forall p : nat, forall x__ : (n < m), forall __1 : Leq m p, n < p ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_to_le_to_lt. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than $m$, then if $m$ is less than or equal to $p$, then $n$ is less than $p$.",
    "output": "axiom lt_to_le_to_lt (n m p : Nat) (x__ : n < m) (__1 : m ≤ p) : n < p"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "P_ord_exp1. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.",
    "output": "p_ord_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_exp1. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.",
    "output": "postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "P_ord_exp1. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.",
    "output": "Axiom p_ord_exp1 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "P_ord_exp1. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.",
    "output": "axiom p_ord_exp1 (p n q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_S_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than the sum of $m$ and $1$, then $n$ is less than $m$.",
    "output": "lt_S_S_to_lt : n : Nat -> m : Nat -> __ : Lt (plus n (nd 1)) (plus m (nd 1)) -> Lt n m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_S_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than the sum of $m$ and $1$, then $n$ is less than $m$.",
    "output": "postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_S_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than the sum of $m$ and $1$, then $n$ is less than $m$.",
    "output": "Axiom lt_S_S_to_lt : forall n : nat, forall m : nat, forall x__ : (n + 1 < m + 1), n < m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_S_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than the sum of $m$ and $1$, then $n$ is less than $m$.",
    "output": "axiom lt_S_S_to_lt (n m : Nat) (x__ : n + 1 < m + 1) : n < m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ord_times. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.",
    "output": "ord_times : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_times. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.",
    "output": "postulate ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Ord_times. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.",
    "output": "Axiom ord_times : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Ord_times. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.",
    "output": "axiom ord_times (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_to_or_lt_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than $m$ or $n$ is equal to $m$.",
    "output": "le_to_or_lt_eq : n : Nat -> m : Nat -> __ : Leq n m -> or (Lt n m) (Eq n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_to_or_lt_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than $m$ or $n$ is equal to $m$.",
    "output": "postulate le_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> or (Lt n m) (Eq n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_to_or_lt_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than $m$ or $n$ is equal to $m$.",
    "output": "Axiom le_to_or_lt_eq : forall n : nat, forall m : nat, forall x__ : Leq n m, n < m \\/ n = m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_to_or_lt_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than $m$ or $n$ is equal to $m$.",
    "output": "axiom le_to_or_lt_eq (n m : Nat) (x__ : n ≤ m) : n < m ∨ n = m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mod_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.",
    "output": "mod_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mod_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.",
    "output": "postulate mod_p_ord_inv : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Mod_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.",
    "output": "Axiom mod_p_ord_inv : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Mod_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.",
    "output": "axiom mod_p_ord_inv (p m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "injn : __ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate injn : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Injn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom injn : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Injn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom injn (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Injn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "injn_Sn_n : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Injn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "postulate injn_Sn_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Injn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "Axiom injn_Sn_n : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n)), cic.Term cic.prop (matita_arithmetics_permutation.injn f n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Injn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "axiom injn_Sn_n (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_n_Sm_elim. For all natural numbers $n$ and $m$, if $n$ is less than or equal to the sum of $m$ and $1$, then for all propositions $P$, for all functions $__1$ from elements $__1$ of $Leq$ of the sum of $n$ and $1$ and the sum of $m$ and $1$ to elements of $P$, for all functions $__2$ from elements $__2$ of $Eq$ of $n$ and the sum of $m$ and $1$ to elements of $P$, $P$.",
    "output": "le_n_Sm_elim : n : Nat -> m : Nat -> __ : Leq n (plus m (nd 1)) -> P : Prop -> __1 : (__1 : Leq (plus n (nd 1)) (plus m (nd 1)) -> P) -> __2 : (__2 : Eq n (plus m (nd 1)) -> P) -> P ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_n_Sm_elim. For all natural numbers $n$ and $m$, if $n$ is less than or equal to the sum of $m$ and $1$, then for all propositions $P$, for all functions $__1$ from elements $__1$ of $Leq$ of the sum of $n$ and $1$ and the sum of $m$ and $1$ to elements of $P$, for all functions $__2$ from elements $__2$ of $Eq$ of $n$ and the sum of $m$ and $1$ to elements of $P$, $P$.",
    "output": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_n_Sm_elim. For all natural numbers $n$ and $m$, if $n$ is less than or equal to the sum of $m$ and $1$, then for all propositions $P$, for all functions $__1$ from elements $__1$ of $Leq$ of the sum of $n$ and $1$ and the sum of $m$ and $1$ to elements of $P$, for all functions $__2$ from elements $__2$ of $Eq$ of $n$ and the sum of $m$ and $1$ to elements of $P$, $P$.",
    "output": "Axiom le_n_Sm_elim : forall n : nat, forall m : nat, forall x__ : Leq n (m + 1), forall P : Prop, forall __1 : ((__1 : Leq (n + 1) (m + 1)) -> P), forall __2 : ((__2 : n = m + 1) -> P), P ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_n_Sm_elim. For all natural numbers $n$ and $m$, if $n$ is less than or equal to the sum of $m$ and $1$, then for all propositions $P$, for all functions $__1$ from elements $__1$ of $Leq$ of the sum of $n$ and $1$ and the sum of $m$ and $1$ to elements of $P$, for all functions $__2$ from elements $__2$ of $Eq$ of $n$ and the sum of $m$ and $1$ to elements of $P$, $P$.",
    "output": "axiom le_n_Sm_elim (n m : Nat) (x__ : n ≤ m + 1) (P : Prop) (__1 : (__1 : n + 1 ≤ m + 1) -> P) (__2 : (__2 : n = m + 1) -> P) : P"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "plus_minus_associative : x : Nat -> y : Nat -> z : Nat -> __ : Leq z y -> Eq (plus x (minus y z)) (minus (plus x y) z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (plus x (minus y z)) (minus (plus x y) z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "Axiom plus_minus_associative : forall x : nat, forall y : nat, forall z : nat, forall x__ : Leq z y, x + (y - z) = x + y - z ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "axiom plus_minus_associative (x y z : Nat) (x__ : z ≤ y) : x + (y - z) = x + y - z"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_minus_to_plus. For all natural numbers $n$ and $m$ and $p$, if the difference of $n$ and $m$ is less than or equal to $p$, then $n$ is less than or equal to the sum of $p$ and $m$.",
    "output": "le_minus_to_plus : n : Nat -> m : Nat -> p : Nat -> __ : Leq (minus n m) p -> Leq n (plus p m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_minus_to_plus. For all natural numbers $n$ and $m$ and $p$, if the difference of $n$ and $m$ is less than or equal to $p$, then $n$ is less than or equal to the sum of $p$ and $m$.",
    "output": "postulate le_minus_to_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq (minus n m) p) -> Leq n (plus p m)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_minus_to_plus. For all natural numbers $n$ and $m$ and $p$, if the difference of $n$ and $m$ is less than or equal to $p$, then $n$ is less than or equal to the sum of $p$ and $m$.",
    "output": "Axiom le_minus_to_plus : forall n : nat, forall m : nat, forall p : nat, forall x__ : Leq (n - m) p, Leq n (p + m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_minus_to_plus. For all natural numbers $n$ and $m$ and $p$, if the difference of $n$ and $m$ is less than or equal to $p$, then $n$ is less than or equal to the sum of $p$ and $m$.",
    "output": "axiom le_minus_to_plus (n m p : Nat) (x__ : n - m ≤ p) : n ≤ p + m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than or equal to $p$.",
    "output": "le_plus_to_minus : n : Nat -> m : Nat -> p : Nat -> __ : Leq n (plus p m) -> Leq (minus n m) p ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than or equal to $p$.",
    "output": "postulate le_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n (plus p m)) -> Leq (minus n m) p"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than or equal to $p$.",
    "output": "Axiom le_plus_to_minus : forall n : nat, forall m : nat, forall p : nat, forall x__ : Leq n (p + m), Leq (n - m) p ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than or equal to $p$.",
    "output": "axiom le_plus_to_minus (n m p : Nat) (x__ : n ≤ p + m) : n - m ≤ p"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_to_le. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, for all natural numbers $m$, $ex$ holds for $Nat$ and the function that maps $i$ to $Leq$ applied to $m$ and $f$ applied to $i$.",
    "output": "increasing_to_le : f : (__ : Nat -> Nat) -> __ : increasing f -> m : Nat -> ex Nat (i : Nat => Leq m (f i)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Increasing_to_le. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, for all natural numbers $m$, $ex$ holds for $Nat$ and the function that maps $i$ to $Leq$ applied to $m$ and $f$ applied to $i$.",
    "output": "postulate increasing_to_le : (f : (_ : Nat) -> Nat) -> (_ : increasing f) -> (m : Nat) -> ex Nat (\\ i : Nat -> Leq m (f i))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Increasing_to_le. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, for all natural numbers $m$, $ex$ holds for $Nat$ and the function that maps $i$ to $Leq$ applied to $m$ and $f$ applied to $i$.",
    "output": "Axiom increasing_to_le : forall f : ((x__ : nat) -> nat), forall x__ : increasing f, forall m : nat, ex nat (fun i => Leq m (f i)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Increasing_to_le. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, for all natural numbers $m$, $ex$ holds for $Nat$ and the function that maps $i$ to $Leq$ applied to $m$ and $f$ applied to $i$.",
    "output": "axiom increasing_to_le (f : (x__ : Nat) -> Nat) (x__ : increasing f) (m : Nat) : ex Nat (λ i => m ≤ f i)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Invert_permut. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "invert_permut : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Invert_permut. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate invert_permut : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Invert_permut. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom invert_permut : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Invert_permut. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom invert_permut (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_divides : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Univ return_sort) -> case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q)) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Match_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_divides : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort), forall case_quotient : ((q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))), forall z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Match_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_divides (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) (case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_to_eqb_true. For all natural numbers $n$ and $m$, if $n$ is equal to $m$, then $eqb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "eq_to_eqb_true : n : Nat -> m : Nat -> __ : Eq n m -> Eq (eqb n m) true ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_to_eqb_true. For all natural numbers $n$ and $m$, if $n$ is equal to $m$, then $eqb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "postulate eq_to_eqb_true : (n : Nat) -> (m : Nat) -> (_ : Eq n m) -> Eq (eqb n m) true"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_to_eqb_true. For all natural numbers $n$ and $m$, if $n$ is equal to $m$, then $eqb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "Axiom eq_to_eqb_true : forall n : nat, forall m : nat, forall x__ : (n = m), eqb n m = true ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_to_eqb_true. For all natural numbers $n$ and $m$, if $n$ is equal to $m$, then $eqb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "axiom eq_to_eqb_true (n m : Nat) (x__ : n = m) : eqb n m = true"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_times. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "divides_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_times. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "postulate divides_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Divides_times. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "Axiom divides_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.divides n p), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Divides_times. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "axiom divides_times (n m p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "eq_mod_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "Axiom eq_mod_to_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q)), cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "axiom eq_mod_to_divides (n m q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_15321. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_15321 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m) -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_15321. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_15321. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "Axiom let_clause_15321 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m), forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_15321. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_15321 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ord_rem_eq. For all natural numbers $n$ and $p$, $ord_rem$ applied to $n$ and $p$ is equal to $snd$ applied to $Nat$ and $Nat$ and $p_ord$ applied to $n$ and $p$.",
    "output": "ord_rem_eq : n : Nat -> p : Nat -> Eq (ord_rem n p) (snd Nat Nat (p_ord n p)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_rem_eq. For all natural numbers $n$ and $p$, $ord_rem$ applied to $n$ and $p$ is equal to $snd$ applied to $Nat$ and $Nat$ and $p_ord$ applied to $n$ and $p$.",
    "output": "postulate ord_rem_eq : (n : Nat) -> (p : Nat) -> Eq (ord_rem n p) (snd Nat Nat (p_ord n p))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Ord_rem_eq. For all natural numbers $n$ and $p$, $ord_rem$ applied to $n$ and $p$ is equal to $snd$ applied to $Nat$ and $Nat$ and $p_ord$ applied to $n$ and $p$.",
    "output": "Axiom ord_rem_eq : forall n : nat, forall p : nat, ord_rem n p = snd nat nat (p_ord n p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Ord_rem_eq. For all natural numbers $n$ and $p$, $ord_rem$ applied to $n$ and $p$ is equal to $snd$ applied to $Nat$ and $Nat$ and $p_ord$ applied to $n$ and $p$.",
    "output": "axiom ord_rem_eq (n p : Nat) : ord_rem n p = snd Nat Nat (p_ord n p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ord_exp. For all natural numbers $p$ and $m$, if $1$ is less than $p$, then $ord$ applied to the exponentiation of $p$ and $m$ and $p$ is equal to $m$.",
    "output": "ord_exp : p : Nat -> m : Nat -> __ : Lt (nd 1) p -> Eq (ord (pow p m) p) m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_exp. For all natural numbers $p$ and $m$, if $1$ is less than $p$, then $ord$ applied to the exponentiation of $p$ and $m$ and $p$ is equal to $m$.",
    "output": "postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Ord_exp. For all natural numbers $p$ and $m$, if $1$ is less than $p$, then $ord$ applied to the exponentiation of $p$ and $m$ and $p$ is equal to $m$.",
    "output": "Axiom ord_exp : forall p : nat, forall m : nat, forall x__ : (1 < p), ord (pow p m) p = m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Ord_exp. For all natural numbers $p$ and $m$, if $1$ is less than $p$, then $ord$ applied to the exponentiation of $p$ and $m$ and $p$ is equal to $m$.",
    "output": "axiom ord_exp (p m : Nat) (x__ : 1 < p) : ord (pow p m) p = m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_to_not_ord_O. For all natural numbers $p$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $p$ is divisible by $m$, then $ord$ applied to $m$ and $p$ is not equal to $0$.",
    "output": "divides_to_not_ord_O : p : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : divisible p m -> not (Eq (ord m p) 0) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_to_not_ord_O. For all natural numbers $p$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $p$ is divisible by $m$, then $ord$ applied to $m$ and $p$ is not equal to $0$.",
    "output": "postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : divisible p m) -> not (Eq (ord m p) 0)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Divides_to_not_ord_O. For all natural numbers $p$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $p$ is divisible by $m$, then $ord$ applied to $m$ and $p$ is not equal to $0$.",
    "output": "Axiom divides_to_not_ord_O : forall p : nat, forall m : nat, forall x__ : (0 < m), forall __1 : prime p, forall __2 : divisible p m, ~ (ord m p = 0) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Divides_to_not_ord_O. For all natural numbers $p$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $p$ is divisible by $m$, then $ord$ applied to $m$ and $p$ is not equal to $0$.",
    "output": "axiom divides_to_not_ord_O (p m : Nat) (x__ : 0 < m) (__1 : prime p) (__2 : divisible p m) : ¬ (ord m p = 0)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ord_ord_rem. For all natural numbers $p$ and $q$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $q$ is prime, then if $q$ is less than $p$, then $ord$ applied to $ord_rem$ applied to $m$ and $p$ and $q$ is equal to $ord$ applied to $m$ and $q$.",
    "output": "ord_ord_rem : p : Nat -> q : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : prime q -> __3 : Lt q p -> Eq (ord (ord_rem m p) q) (ord m q) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ord_ord_rem. For all natural numbers $p$ and $q$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $q$ is prime, then if $q$ is less than $p$, then $ord$ applied to $ord_rem$ applied to $m$ and $p$ and $q$ is equal to $ord$ applied to $m$ and $q$.",
    "output": "postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Ord_ord_rem. For all natural numbers $p$ and $q$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $q$ is prime, then if $q$ is less than $p$, then $ord$ applied to $ord_rem$ applied to $m$ and $p$ and $q$ is equal to $ord$ applied to $m$ and $q$.",
    "output": "Axiom ord_ord_rem : forall p : nat, forall q : nat, forall m : nat, forall x__ : (0 < m), forall __1 : prime p, forall __2 : prime q, forall __3 : (q < p), ord (ord_rem m p) q = ord m q ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Ord_ord_rem. For all natural numbers $p$ and $q$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $q$ is prime, then if $q$ is less than $p$, then $ord$ applied to $ord_rem$ applied to $m$ and $p$ and $q$ is equal to $ord$ applied to $m$ and $q$.",
    "output": "axiom ord_ord_rem (p q m : Nat) (x__ : 0 < m) (__1 : prime p) (__2 : prime q) (__3 : q < p) : ord (ord_rem m p) q = ord m q"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime, then if $0$ is less than $m$, then if $n$ is divisible by $m$, then $ord_rem$ applied to $m$ and $n$ is less than $m$.",
    "output": "lt_ord_rem : n : Nat -> m : Nat -> __ : prime n -> __1 : Lt 0 m -> __2 : divisible n m -> Lt (ord_rem m n) m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime, then if $0$ is less than $m$, then if $n$ is divisible by $m$, then $ord_rem$ applied to $m$ and $n$ is less than $m$.",
    "output": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime, then if $0$ is less than $m$, then if $n$ is divisible by $m$, then $ord_rem$ applied to $m$ and $n$ is less than $m$.",
    "output": "Axiom lt_ord_rem : forall n : nat, forall m : nat, forall x__ : prime n, forall __1 : (0 < m), forall __2 : divisible n m, ord_rem m n < m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime, then if $0$ is less than $m$, then if $n$ is divisible by $m$, then $ord_rem$ applied to $m$ and $n$ is less than $m$.",
    "output": "axiom lt_ord_rem (n m : Nat) (x__ : prime n) (__1 : 0 < m) (__2 : divisible n m) : ord_rem m n < m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "P_ord_inv. For all natural numbers $_p$ and $_m$ and $_x$, $Nat$.",
    "output": "p_ord_inv : _p : Nat -> _m : Nat -> _x : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "P_ord_inv. For all natural numbers $_p$ and $_m$ and $_x$, $Nat$.",
    "output": "postulate p_ord_inv : (_p : Nat) -> (_m : Nat) -> (_x : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "P_ord_inv. For all natural numbers $_p$ and $_m$ and $_x$, $Nat$.",
    "output": "Axiom p_ord_inv : forall _p : nat, forall _m : nat, forall _x : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "P_ord_inv. For all natural numbers $_p$ and $_m$ and $_x$, $Nat$.",
    "output": "axiom p_ord_inv (_p _m _x : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_prime_to_primeb_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$.",
    "output": "not_prime_to_primeb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_prime_to_primeb_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$.",
    "output": "postulate not_prime_to_primeb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_prime_to_primeb_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$.",
    "output": "Axiom not_prime_to_primeb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_prime_to_primeb_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$.",
    "output": "axiom not_prime_to_primeb_false (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Permut_S_to_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $m$, for all elements $__$ of $permut$ of $f$ and the sum of $m$ and $1$, if $f$ applied to the sum of $m$ and $1$ is equal to the sum of $m$ and $1$, then $permut$ holds for $f$ and $m$.",
    "output": "permut_S_to_permut : f : (__ : Nat -> Nat) -> m : Nat -> __ : permut f (plus m (nd 1)) -> __1 : Eq (f (plus m (nd 1))) (plus m (nd 1)) -> permut f m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Permut_S_to_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $m$, for all elements $__$ of $permut$ of $f$ and the sum of $m$ and $1$, if $f$ applied to the sum of $m$ and $1$ is equal to the sum of $m$ and $1$, then $permut$ holds for $f$ and $m$.",
    "output": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Permut_S_to_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $m$, for all elements $__$ of $permut$ of $f$ and the sum of $m$ and $1$, if $f$ applied to the sum of $m$ and $1$ is equal to the sum of $m$ and $1$, then $permut$ holds for $f$ and $m$.",
    "output": "Axiom permut_S_to_permut : forall f : ((x__ : nat) -> nat), forall m : nat, forall x__ : permut f (m + 1), forall __1 : (f (m + 1) = m + 1), permut f m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Permut_S_to_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $m$, for all elements $__$ of $permut$ of $f$ and the sum of $m$ and $1$, if $f$ applied to the sum of $m$ and $1$ is equal to the sum of $m$ and $1$, then $permut$ holds for $f$ and $m$.",
    "output": "axiom permut_S_to_permut (f : (x__ : Nat) -> Nat) (m : Nat) (x__ : permut f (m + 1)) (__1 : f (m + 1) = m + 1) : permut f m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "transpose : __ : Nat -> __1 : Nat -> __2 : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "postulate transpose : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "Axiom transpose : forall x__ : nat, forall __1 : nat, forall __2 : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "axiom transpose (x__ __1 __2 : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_upper_bound2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_upper_bound2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom let_upper_bound2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom let_upper_bound2 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_previous_prime6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "let_previous_prime6 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_previous_prime6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_previous_prime6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_previous_prime6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom let_previous_prime6 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m), forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_previous_prime6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom let_previous_prime6 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "invert_permut_f : f : (__ : Nat -> Nat) -> n : Nat -> m : Nat -> __ : Leq m n -> __1 : injn f n -> Eq (invert_permut n f (f m)) m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "Axiom invert_permut_f : forall f : ((x__ : nat) -> nat), forall n : nat, forall m : nat, forall x__ : Leq m n, forall __1 : injn f n, invert_permut n f (f m) = m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Invert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ is equal to $m$.",
    "output": "axiom invert_permut_f (f : (x__ : Nat) -> Nat) (n m : Nat) (x__ : m ≤ n) (__1 : injn f n) : invert_permut n f (f m) = m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "lt_nth_prime_to_not_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "Axiom lt_nth_prime_to_not_prime : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n))), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "axiom lt_nth_prime_to_not_prime (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1068. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $permf$ of $permut$ of $f$ and $n$, for all natural numbers $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then for all natural numbers $a$, if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.",
    "output": "let_clause_1068 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) i ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1068. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $permf$ of $permut$ of $f$ and $n$, for all natural numbers $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then for all natural numbers $a$, if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.",
    "output": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_1068. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $permf$ of $permut$ of $f$ and $n$, for all natural numbers $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then for all natural numbers $a$, if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.",
    "output": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_1068. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $permf$ of $permut$ of $f$ and $n$, for all natural numbers $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then for all natural numbers $a$, if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.",
    "output": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Divides_n_n. For all natural numbers $n$, $n$ is divisible by $n$.",
    "output": "divides_n_n : n : Nat -> divisible n n ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Divides_n_n. For all natural numbers $n$, $n$ is divisible by $n$.",
    "output": "postulate divides_n_n : (n : Nat) -> divisible n n"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Divides_n_n. For all natural numbers $n$, $n$ is divisible by $n$.",
    "output": "Axiom divides_n_n : forall n : nat, divisible n n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Divides_n_n. For all natural numbers $n$, $n$ is divisible by $n$.",
    "output": "axiom divides_n_n (n : Nat) : divisible n n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "Axiom let_clause_1033 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "axiom let_clause_1033 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "le_log2_sqrt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "postulate le_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "Axiom le_log2_sqrt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "axiom le_log2_sqrt (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dividesb_true_to_divides. For all natural numbers $n$ and $m$, if $dividesb$ applied to $n$ and $m$ is equal to $true$, then $n$ is divisible by $m$.",
    "output": "dividesb_true_to_divides : n : Nat -> m : Nat -> __ : Eq (dividesb n m) true -> divisible n m ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dividesb_true_to_divides. For all natural numbers $n$ and $m$, if $dividesb$ applied to $n$ and $m$ is equal to $true$, then $n$ is divisible by $m$.",
    "output": "postulate dividesb_true_to_divides : (n : Nat) -> (m : Nat) -> (_ : Eq (dividesb n m) true) -> divisible n m"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dividesb_true_to_divides. For all natural numbers $n$ and $m$, if $dividesb$ applied to $n$ and $m$ is equal to $true$, then $n$ is divisible by $m$.",
    "output": "Axiom dividesb_true_to_divides : forall n : nat, forall m : nat, forall x__ : (dividesb n m = true), divisible n m ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dividesb_true_to_divides. For all natural numbers $n$ and $m$, if $dividesb$ applied to $n$ and $m$ is equal to $true$, then $n$ is divisible by $m$.",
    "output": "axiom dividesb_true_to_divides (n m : Nat) (x__ : dividesb n m = true) : divisible n m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Dividesb_div_true. For all natural numbers $d$ and $n$, if $0$ is less than $n$, then if $dividesb$ applied to $d$ and $n$ is equal to $true$, then $dividesb$ applied to the quotient of $n$ and $d$ and $n$ is equal to $true$.",
    "output": "dividesb_div_true : d : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Eq (dividesb d n) true -> Eq (dividesb (div n d) n) true ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Dividesb_div_true. For all natural numbers $d$ and $n$, if $0$ is less than $n$, then if $dividesb$ applied to $d$ and $n$ is equal to $true$, then $dividesb$ applied to the quotient of $n$ and $d$ and $n$ is equal to $true$.",
    "output": "postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (dividesb d n) true) -> Eq (dividesb (div n d) n) true"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Dividesb_div_true. For all natural numbers $d$ and $n$, if $0$ is less than $n$, then if $dividesb$ applied to $d$ and $n$ is equal to $true$, then $dividesb$ applied to the quotient of $n$ and $d$ and $n$ is equal to $true$.",
    "output": "Axiom dividesb_div_true : forall d : nat, forall n : nat, forall x__ : (0 < n), forall __1 : (dividesb d n = true), dividesb (n / d) n = true ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Dividesb_div_true. For all natural numbers $d$ and $n$, if $0$ is less than $n$, then if $dividesb$ applied to $d$ and $n$ is equal to $true$, then $dividesb$ applied to the quotient of $n$ and $d$ and $n$ is equal to $true$.",
    "output": "axiom dividesb_div_true (d n : Nat) (x__ : 0 < n) (__1 : dividesb d n = true) : dividesb (n / d) n = true"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Bool_rect_Type0_body. For all functions $Q_$ from elements $_x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_true$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_344$.",
    "output": "bool_rect_Type0_body : Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type0) -> _H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false) -> x_344 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type0 (Q_ x_344) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Bool_rect_Type0_body. For all functions $Q_$ from elements $_x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_true$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_344$.",
    "output": "postulate bool_rect_Type0_body : (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) -> (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ x_344)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Bool_rect_Type0_body. For all functions $Q_$ from elements $_x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_true$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_344$.",
    "output": "Axiom bool_rect_Type0_body : forall Q_ : ((_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0), forall _H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false), forall x_344 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type0 (Q_ x_344) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Bool_rect_Type0_body. For all functions $Q_$ from elements $_x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_true$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_344$.",
    "output": "axiom bool_rect_Type0_body (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 (Q_ x_344)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_smallest_factor_to_not_divides. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $1$ is less than $i$, then if $i$ is less than $smallest_factor$ applied to $n$, then $i$ is not divisible by $n$.",
    "output": "lt_smallest_factor_to_not_divides : n : Nat -> i : Nat -> __ : Lt (nd 1) n -> __1 : Lt (nd 1) i -> __2 : Lt i (smallest_factor n) -> not (divisible i n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_smallest_factor_to_not_divides. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $1$ is less than $i$, then if $i$ is less than $smallest_factor$ applied to $n$, then $i$ is not divisible by $n$.",
    "output": "postulate lt_smallest_factor_to_not_divides : (n : Nat) -> (i : Nat) -> (_ : Lt 1 n) -> (__1 : Lt 1 i) -> (__2 : Lt i (smallest_factor n)) -> not (divisible i n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_smallest_factor_to_not_divides. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $1$ is less than $i$, then if $i$ is less than $smallest_factor$ applied to $n$, then $i$ is not divisible by $n$.",
    "output": "Axiom lt_smallest_factor_to_not_divides : forall n : nat, forall i : nat, forall x__ : (1 < n), forall __1 : (1 < i), forall __2 : (i < smallest_factor n), ~ divisible i n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_smallest_factor_to_not_divides. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $1$ is less than $i$, then if $i$ is less than $smallest_factor$ applied to $n$, then $i$ is not divisible by $n$.",
    "output": "axiom lt_smallest_factor_to_not_divides (n i : Nat) (x__ : 1 < n) (__1 : 1 < i) (__2 : i < smallest_factor n) : ¬ divisible i n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Primeb_false_to_not_prime. For all natural numbers $n$, if $primeb$ applied to $n$ is equal to absurdity, then $n$ is not prime.",
    "output": "primeb_false_to_not_prime : n : Nat -> __ : Eq (primeb n) false -> not (prime n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Primeb_false_to_not_prime. For all natural numbers $n$, if $primeb$ applied to $n$ is equal to absurdity, then $n$ is not prime.",
    "output": "postulate primeb_false_to_not_prime : (n : Nat) -> (_ : Eq (primeb n) false) -> not (prime n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Primeb_false_to_not_prime. For all natural numbers $n$, if $primeb$ applied to $n$ is equal to absurdity, then $n$ is not prime.",
    "output": "Axiom primeb_false_to_not_prime : forall n : nat, forall x__ : (primeb n = false), ~ prime n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Primeb_false_to_not_prime. For all natural numbers $n$, if $primeb$ applied to $n$ is equal to absurdity, then $n$ is not prime.",
    "output": "axiom primeb_false_to_not_prime (n : Nat) (x__ : primeb n = false) : ¬ prime n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_eq_true_false. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.true$ and $matita_basics_bool.false$.",
    "output": "not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_eq_true_false. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.true$ and $matita_basics_bool.false$.",
    "output": "postulate not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_eq_true_false. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.true$ and $matita_basics_bool.false$.",
    "output": "Axiom not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_eq_true_false. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.true$ and $matita_basics_bool.false$.",
    "output": "axiom not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eqnot_to_noteq. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.",
    "output": "eqnot_to_noteq : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eqnot_to_noteq. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.",
    "output": "postulate eqnot_to_noteq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eqnot_to_noteq. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.",
    "output": "Axiom eqnot_to_noteq : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2)), cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eqnot_to_noteq. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.",
    "output": "axiom eqnot_to_noteq (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Andb_true_r. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "andb_true_r : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Andb_true_r. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "postulate andb_true_r : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Andb_true_r. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "Axiom andb_true_r : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Andb_true_r. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "axiom andb_true_r (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Orb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.",
    "output": "orb_true_r1 : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Orb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.",
    "output": "postulate orb_true_r1 : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Orb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.",
    "output": "Axiom orb_true_r1 : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Orb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.",
    "output": "axiom orb_true_r1 (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Increasing_nth_prime. For all natural numbers $n$, $nth_prime$ applied to $n$ is less than $nth_prime$ applied to the sum of $n$ and $1$.",
    "output": "increasing_nth_prime : n : Nat -> Lt (nth_prime n) (nth_prime (plus n (nd 1))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Increasing_nth_prime. For all natural numbers $n$, $nth_prime$ applied to $n$ is less than $nth_prime$ applied to the sum of $n$ and $1$.",
    "output": "postulate increasing_nth_prime : (n : Nat) -> Lt (nth_prime n) (nth_prime (plus n 1))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Increasing_nth_prime. For all natural numbers $n$, $nth_prime$ applied to $n$ is less than $nth_prime$ applied to the sum of $n$ and $1$.",
    "output": "Axiom increasing_nth_prime : forall n : nat, nth_prime n < nth_prime (n + 1) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Increasing_nth_prime. For all natural numbers $n$, $nth_prime$ applied to $n$ is less than $nth_prime$ applied to the sum of $n$ and $1$.",
    "output": "axiom increasing_nth_prime (n : Nat) : nth_prime n < nth_prime (n + 1)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "List_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.",
    "output": "list_rect_Type3 : _A : cic.Univ univs.Type0 -> Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type3) -> _H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_733 : cic.Term univs.Type0 _A -> x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_735 : cic.Term univs.Type3 (Q_ x_732) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) -> x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type3 (Q_ x_731) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "List_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.",
    "output": "postulate list_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) -> (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) -> (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type3 (Q_ x_731)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "List_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.",
    "output": "Axiom list_rect_Type3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3), forall _H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))), forall x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type3 (Q_ x_731) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "List_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.",
    "output": "axiom list_rect_Type3 (_A : cic.Univ univs.Type0) (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type3 (Q_ x_731)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Let_upper_bound5. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "let_upper_bound5 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Let_upper_bound5. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "postulate let_upper_bound5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Let_upper_bound5. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "Axiom let_upper_bound5 : forall n : nat, forall m : nat, forall ltml : (nth_prime n < m), nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Let_upper_bound5. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "axiom let_upper_bound5 (n m : Nat) (ltml : nth_prime n < m) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Le_sigma. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "le_sigma : n : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> __ : (i : Nat -> __ : Lt i n -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> __1 : (i : Nat -> __1 : Lt i n -> __2 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n (i : Nat => p1 i) Nat 0 plus (i : Nat => g1 i)) (bigop n (i : Nat => p2 i) Nat 0 plus (i : Nat => g2 i)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Le_sigma. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Le_sigma. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "Axiom le_sigma : forall n : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall g1 : ((x__ : nat) -> nat), forall g2 : ((x__ : nat) -> nat), forall x__ : ((i : nat) -> (x__ : i < n) -> (__1 : p1 i = true) -> p2 i = true), forall __1 : ((i : nat) -> (__1 : i < n) -> (__2 : p1 i = true) -> Leq (g1 i) (g2 i)), Leq (bigop n (fun i => p1 i) nat 0 plus (fun i => g1 i)) (bigop n (fun i => p2 i) nat 0 plus (fun i => g2 i)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Le_sigma. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "axiom le_sigma (n : Nat) (p1 p2 : (x__ : Nat) -> bool) (g1 g2 : (x__ : Nat) -> Nat) (x__ : (i : Nat) -> (x__ : i < n) -> (__1 : p1 i = true) -> p2 i = true) (__1 : (i : Nat) -> (__1 : i < n) -> (__2 : p1 i = true) -> g1 i ≤ g2 i) : bigop n (λ i => p1 i) Nat 0 plus (λ i => g1 i) ≤ bigop n (λ i => p2 i) Nat 0 plus (λ i => g2 i)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Let $_n$ be a natural number. Then the square root of $_n$ is a natural number.",
    "output": "sqrt : _n : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Let $_n$ be a natural number. Then the square root of $_n$ is a natural number.",
    "output": "postulate sqrt : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Let $_n$ be a natural number. Then the square root of $_n$ is a natural number.",
    "output": "Axiom sqrt : forall _n : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Let $_n$ be a natural number. Then the square root of $_n$ is a natural number.",
    "output": "axiom sqrt (_n : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Cons_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.",
    "output": "cons_injective_r : A : cic.Univ univs.Type0 -> a1 : cic.Term univs.Type0 A -> a2 : cic.Term univs.Type0 A -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Cons_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.",
    "output": "postulate cons_injective_r : (A : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Cons_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.",
    "output": "Axiom cons_injective_r : forall A : cic.Univ univs.Type0, forall a1 : cic.Term univs.Type0 A, forall a2 : cic.Term univs.Type0 A, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Cons_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.",
    "output": "axiom cons_injective_r (A : cic.Univ univs.Type0) (a1 a2 : cic.Term univs.Type0 A) (l1 l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list B) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "postulate map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list B)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "Axiom map : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term univs.Type0 (matita_basics_lists_list.list B) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "axiom map (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term univs.Type0 (matita_basics_lists_list.list B)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lt_log2_sqrt. For all natural numbers $n$, if the exponentiation of $2$ and $6$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than the square root of $n$.",
    "output": "lt_log2_sqrt : n : Nat -> __ : Leq (pow (nd 2) (nd 6)) n -> Lt (log (nd 2) n) (sqrt n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lt_log2_sqrt. For all natural numbers $n$, if the exponentiation of $2$ and $6$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than the square root of $n$.",
    "output": "postulate lt_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 6) n) -> Lt (log 2 n) (sqrt n)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lt_log2_sqrt. For all natural numbers $n$, if the exponentiation of $2$ and $6$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than the square root of $n$.",
    "output": "Axiom lt_log2_sqrt : forall n : nat, forall x__ : Leq (pow 2 6) n, log 2 n < sqrt n ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lt_log2_sqrt. For all natural numbers $n$, if the exponentiation of $2$ and $6$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than the square root of $n$.",
    "output": "axiom lt_log2_sqrt (n : Nat) (x__ : pow 2 6 ≤ n) : log 2 n < sqrt n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Reverse_cons. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $l$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "reverse_cons : S : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 S -> l : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Reverse_cons. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $l$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "postulate reverse_cons : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Reverse_cons. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $l$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "Axiom reverse_cons : forall S : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 S, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Reverse_cons. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $l$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "axiom reverse_cons (S : cic.Univ univs.Type0) (a : cic.Term univs.Type0 S) (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Prop170. We can prove that for all natural numbers $x$, it is not the case that $x$ is even and $x$ is odd.",
    "output": "prop170 : Proof (forall Nat (x => not (and (even x) (odd x)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Prop170. We can prove that for all natural numbers $x$, it is not the case that $x$ is even and $x$ is odd.",
    "output": "postulate prop170 : all Nat (\\ x -> not (and (even x) (odd x)))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Prop170. We can prove that for all natural numbers $x$, it is not the case that $x$ is even and $x$ is odd.",
    "output": "Axiom prop170 : forall x : nat, ~ (even x /\\ odd x) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Prop170. We can prove that for all natural numbers $x$, it is not the case that $x$ is even and $x$ is odd.",
    "output": "axiom prop170 : ∀ x : Nat, ¬ (even x ∧ odd x)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "AssocUnion. For all sets $A$, $B$ and $C$, we can prove that the union of the union of $A$ and $B$ and $C$ is equal to the union of $A$ and the union of $B$ and $C$.",
    "output": "assocUnion : (A : Set) -> (B : Set) -> (C : Set) -> Proof (equalset (union (union A B) C) (union A (union B C))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "AssocUnion. For all sets $A$, $B$ and $C$, we can prove that the union of the union of $A$ and $B$ and $C$ is equal to the union of $A$ and the union of $B$ and $C$.",
    "output": "postulate assocUnion : (A : Set) -> (B : Set) -> (C : Set) -> equalset (union (union A B) C) (union A (union B C))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "AssocUnion. For all sets $A$, $B$ and $C$, we can prove that the union of the union of $A$ and $B$ and $C$ is equal to the union of $A$ and the union of $B$ and $C$.",
    "output": "Axiom assocUnion : forall A : Set, forall B : Set, forall C : Set, equalset (union (union A B) C) (union A (union B C)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "AssocUnion. For all sets $A$, $B$ and $C$, we can prove that the union of the union of $A$ and $B$ and $C$ is equal to the union of $A$ and the union of $B$ and $C$.",
    "output": "axiom assocUnion (A B C : Set) : equalset (union (union A B) C) (union A (union B C))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lenght_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "lenght_to_nil : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lenght_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate lenght_to_nil : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lenght_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "Axiom lenght_to_nil : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lenght_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "axiom lenght_to_nil (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Lists_length_split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $la$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $lb$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$.",
    "output": "lists_length_split : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (la : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.ex (matita_basics_lists_list.list A) (lb : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Lists_length_split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $la$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $lb$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$.",
    "output": "postulate lists_length_split : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ la : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ lb : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Lists_length_split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $la$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $lb$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$.",
    "output": "Axiom lists_length_split : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (fun la => matita_basics_logic.ex (matita_basics_lists_list.list A) (fun lb => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Lists_length_split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $la$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $lb$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$.",
    "output": "axiom lists_length_split (A : cic.Univ univs.Type0) (l1 l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (λ la => matita_basics_logic.ex (matita_basics_lists_list.list A) (λ lb => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb))))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Append_l2_injective. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "append_l2_injective : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2)) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Append_l2_injective. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "postulate append_l2_injective : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Append_l2_injective. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "Axiom append_l2_injective : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2)), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Append_l2_injective. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "axiom append_l2_injective (A : cic.Univ univs.Type0) (l1 l2 l3 l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "DominEmpty. For all sets $A$, we can prove that the intersection of $A$ and the empty set is equal to the empty set.",
    "output": "dominEmpty : (A : Set) -> Proof (equalset (intersection A emptyset) emptyset) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "DominEmpty. For all sets $A$, we can prove that the intersection of $A$ and the empty set is equal to the empty set.",
    "output": "postulate dominEmpty : (A : Set) -> equalset (intersection A emptyset) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "DominEmpty. For all sets $A$, we can prove that the intersection of $A$ and the empty set is equal to the empty set.",
    "output": "Axiom dominEmpty : forall A : Set, equalset (intersection A emptyset) emptyset ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "DominEmpty. For all sets $A$, we can prove that the intersection of $A$ and the empty set is equal to the empty set.",
    "output": "axiom dominEmpty (A : Set) : equalset (intersection A emptyset) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Mem_append_l2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "mem_append_l2 : A : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 A -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Mem_append_l2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "postulate mem_append_l2 : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2)) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Mem_append_l2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "Axiom mem_append_l2 : forall A : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2), cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Mem_append_l2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "axiom mem_append_l2 (A : cic.Univ univs.Type0) (a : cic.Term univs.Type0 A) (l1 l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2)) : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ComplEmpty. We can prove that the complement of the empty set is equal to the universal set.",
    "output": "complEmpty : Proof (equalset (complement emptyset) universeset) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ComplEmpty. We can prove that the complement of the empty set is equal to the universal set.",
    "output": "postulate complEmpty : equalset (complement emptyset) universeset"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "ComplEmpty. We can prove that the complement of the empty set is equal to the universal set.",
    "output": "Axiom complEmpty : equalset (complement emptyset) universeset ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "ComplEmpty. We can prove that the complement of the empty set is equal to the universal set.",
    "output": "axiom complEmpty : equalset (complement emptyset) universeset"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "ComplUniverse. We can prove that the complement of the universal set is equal to the empty set.",
    "output": "complUniverse : Proof (equalset (complement universeset) emptyset) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "ComplUniverse. We can prove that the complement of the universal set is equal to the empty set.",
    "output": "postulate complUniverse : equalset (complement universeset) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "ComplUniverse. We can prove that the complement of the universal set is equal to the empty set.",
    "output": "Axiom complUniverse : equalset (complement universeset) emptyset ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "ComplUniverse. We can prove that the complement of the universal set is equal to the empty set.",
    "output": "axiom complUniverse : equalset (complement universeset) emptyset"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Thm01. For all instances $m$ and $n$ of natural numbers, if we can prove that $n$ is not equal to $0$, then we can prove that the exponentiation of the quotient of $m$ and $n$ and $2$ is not equal to $2$.",
    "output": "Thm01 : (m : Elem Nat) -> (n : Elem Nat) -> Proof (Neq n 0) -> Proof (Neq (pow (div m n) 2) 2) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm01. For all instances $m$ and $n$ of natural numbers, if we can prove that $n$ is not equal to $0$, then we can prove that the exponentiation of the quotient of $m$ and $n$ and $2$ is not equal to $2$.",
    "output": "postulate Thm01 : (m : Nat) -> (n : Nat) -> Neq n 0 -> Neq (pow (div m n) 2) 2"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Thm01. For all instances $m$ and $n$ of natural numbers, if we can prove that $n$ is not equal to $0$, then we can prove that the exponentiation of the quotient of $m$ and $n$ and $2$ is not equal to $2$.",
    "output": "Axiom Thm01 : forall m : nat, forall n : nat, (Neq n 0 -> Neq (pow (m / n) 2) 2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Thm01. For all instances $m$ and $n$ of natural numbers, if we can prove that $n$ is not equal to $0$, then we can prove that the exponentiation of the quotient of $m$ and $n$ and $2$ is not equal to $2$.",
    "output": "axiom Thm01 (m n : Nat) (x : n ≠ 0) : pow (m / n) 2 ≠ 2"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is rational, if there exists an integer $p$, such that there exists an integer $q$, such that $q$ is not equal to $0$ and $x$ is equal to the quotient of $p$ and $q$.",
    "output": "def rational : Elem Real -> Prop := x => exists Int (p => exists Int (q => and (Neq q 0) (Eq x (div p q)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is rational, if there exists an integer $p$, such that there exists an integer $q$, such that $q$ is not equal to $0$ and $x$ is equal to the quotient of $p$ and $q$.",
    "output": "rational : Real -> Prop\nrational = \\ x -> exists Int (\\ p -> exists Int (\\ q -> and (Neq q 0) (Eq x (div p q))))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is rational, if there exists an integer $p$, such that there exists an integer $q$, such that $q$ is not equal to $0$ and $x$ is equal to the quotient of $p$ and $q$.",
    "output": "Definition rational (x : Real) : Prop := exists p : Int, exists q : Int, Neq q 0 /\\ x = p / q ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is rational, if there exists an integer $p$, such that there exists an integer $q$, such that $q$ is not equal to $0$ and $x$ is equal to the quotient of $p$ and $q$.",
    "output": "def rational (x : Real) : Prop := ∃ p : Int, ∃ q : Int, q ≠ 0 ∧ x = p / q"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is irrational, if $x$ is not rational.",
    "output": "def irrational : Elem Real -> Prop := x => not (rational x) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is irrational, if $x$ is not rational.",
    "output": "irrational : Real -> Prop\nirrational = \\ x -> not (rational x)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is irrational, if $x$ is not rational.",
    "output": "Definition irrational (x : Real) : Prop := ~ rational x ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Definition. Let $x$ be an instance of real numbers. Then $x$ is irrational, if $x$ is not rational.",
    "output": "def irrational (x : Real) : Prop := ¬ rational x"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Flatten. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "flatten : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Flatten. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate flatten : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Flatten. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "Axiom flatten : forall A : cic.Univ univs.Type0, forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A)), cic.Term univs.Type0 (matita_basics_lists_list.list A) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Flatten. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "axiom flatten (A : cic.Univ univs.Type0) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) : cic.Term univs.Type0 (matita_basics_lists_list.list A)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. Vectors are a basic type.",
    "output": "Vector : Set ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. Vectors are a basic type.",
    "output": "postulate Vector : Set"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. Vectors are a basic type.",
    "output": "Axiom Vector : Set ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. Vectors are a basic type.",
    "output": "axiom Vector : Set"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "All_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l1$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "All_append : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_lists_list.All A P l1) -> __1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2) -> cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "All_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l1$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "postulate All_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l1)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2)) -> cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "All_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l1$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "Axiom All_append : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.All A P l1), forall __1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2), cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "All_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l1$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "axiom All_append (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (l1 l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l1)) (__1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2)) : cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Axiom. The number \\(\\pi\\) is an instance of real numbers.",
    "output": "pi : Elem Real ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Axiom. The number \\(\\pi\\) is an instance of real numbers.",
    "output": "postulate pi : Real"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Axiom. The number \\(\\pi\\) is an instance of real numbers.",
    "output": "Axiom pi : Real ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Axiom. The number \\(\\pi\\) is an instance of real numbers.",
    "output": "axiom pi : Real"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Allr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Allr : A : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Allr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Allr : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Allr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom Allr : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Allr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom Allr (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Thm11. For all instances $n$ of natural numbers, we can prove that there exists a natural number $p$, such that $p$ is greater than or equal to $n$ and $p$ is prime.",
    "output": "thm11 : (n : Elem Nat) -> Proof (exists Nat (p => and (Geq p n) (prime p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Thm11. For all instances $n$ of natural numbers, we can prove that there exists a natural number $p$, such that $p$ is greater than or equal to $n$ and $p$ is prime.",
    "output": "postulate thm11 : (n : Nat) -> exists Nat (\\ p -> and (Geq p n) (prime p))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Thm11. For all instances $n$ of natural numbers, we can prove that there exists a natural number $p$, such that $p$ is greater than or equal to $n$ and $p$ is prime.",
    "output": "Axiom thm11 : forall n : nat, exists p : nat, Geq p n /\\ prime p ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Thm11. For all instances $n$ of natural numbers, we can prove that there exists a natural number $p$, such that $p$ is greater than or equal to $n$ and $p$ is prime.",
    "output": "axiom thm11 (n : Nat) : ∃ p : Nat, p ≥ n ∧ prime p"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ return_sort) -> case_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Match_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort), forall case_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Match_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_781$.",
    "output": "Aop_ind : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_781) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_781$.",
    "output": "postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_781)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_781$.",
    "output": "Axiom Aop_ind : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_781) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_781$.",
    "output": "axiom Aop_ind (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_781)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "Aop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type4 (Q_ x_783) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_783)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "Axiom Aop_rect_Type4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type4 (Q_ x_783) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "axiom Aop_rect_Type4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type4 (Q_ x_783)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_789$.",
    "output": "Aop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type2 (Q_ x_789) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_789$.",
    "output": "postulate Aop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_789)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_789$.",
    "output": "Axiom Aop_rect_Type2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type2 (Q_ x_789) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_789$.",
    "output": "axiom Aop_rect_Type2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type2 (Q_ x_789)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "Aop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_803) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "postulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "Axiom Aop_rect_CProp1 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_803) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "axiom Aop_rect_CProp1 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_803)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Aop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $a2$ and $a$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $x0$ applied to $b$ and $c$ and $x0$ applied to $x0$ applied to $a$ and $b$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z51$ to $P$ and $y$ and $x$.",
    "output": "Aop_discr : a1 : cic.Univ univs.Type0 -> a2 : cic.Term univs.Type0 a1 -> x : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y) -> cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) => cic.univ univs.Type2) (t0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => t1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) => t2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) => t3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) => matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) => cic.univ univs.Type2) (u0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => u1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a2 a) a)) => u2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a a2) a)) => u3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a (u0 b c)) (u0 (u0 a b) c))) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t0 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : cic.Term cic.prop ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t0 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : cic.Term cic.prop ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) => P))))) (_z51 : (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) u0) -> e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) -> e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) -> _e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t0 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : cic.Term cic.prop ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Aop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $a2$ and $a$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $x0$ applied to $b$ and $c$ and $x0$ applied to $x0$ applied to $a$ and $b$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z51$ to $P$ and $y$ and $x$.",
    "output": "postulate Aop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> cic.univ univs.Type2) (\\ t0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ t1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) -> \\ t2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) -> \\ t3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) -> matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> cic.univ univs.Type2) (\\ u0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ u1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a2 a) a)) -> \\ u2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a a2) a)) -> \\ u3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a (u0 b c)) (u0 (u0 a b) c))) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) (\\ e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (\\ e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (\\ _e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) -> P))))) (\\ _z51 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) u0)) -> (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1)) -> (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2)) -> (_e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x0) -> \\ x1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0) x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (\\ x0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x0) -> \\ x1 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) -> \\ p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) -> \\ x2 : cic.Term cic.prop ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (\\ x01 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : cic.Term cic.prop ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) -> \\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> cic.lift cic.prop univs.Type0 ((\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) -> cic.lift cic.prop univs.Type0 ((\\ x01 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x01) -> \\ x11 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) -> \\ p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) -> \\ x21 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) -> \\ p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1))) t0 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (\\ x02 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x02) -> \\ x12 : cic.Term cic.prop ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) -> \\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__1 : cic.Term univs.Type0 a1) -> (__2 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) -> cic.lift cic.prop univs.Type0 ((\\ x00 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x00) -> \\ x10 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) -> \\ p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 (\\ x_19 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x011 : ((__2 : cic.Term univs.Type0 a1) -> (__3 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __2 : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __3 : cic.Term univs.Type0 a1 -> a1)))) t0 x011) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) -> cic.prod univs.Type0 cic.prop a1 (\\ a : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ b : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 cic.prop a1 (\\ c : cic.Term univs.Type0 a1 -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Aop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $a2$ and $a$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $x0$ applied to $b$ and $c$ and $x0$ applied to $x0$ applied to $a$ and $b$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z51$ to $P$ and $y$ and $x$.",
    "output": "Axiom Aop_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Term univs.Type0 a1, forall x : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2), forall y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y), cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => fun t2 => fun t3 => matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => fun u2 => fun u3 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1))) t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((fun x0 => fun p0 => cic.prod univs.Type0 cic.prop a1 (fun a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1)))) t0 (fun x_19 => fun _x_20 => cic.lift cic.prop univs.Type0 ((fun x0 => fun p0 => cic.prod univs.Type0 cic.prop a1 (fun a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) (fun e1 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((fun x0 => fun p0 => fun x1 => fun p1 => cic.prod univs.Type0 cic.prop a1 (fun a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1))) t0 (fun x0 => fun __ => cic.lift cic.prop univs.Type0 ((fun x01 => fun p0 => cic.prod univs.Type0 cic.prop a1 (fun a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (fun x0 => fun p0 => fun x1 => fun __ => cic.lift cic.prop univs.Type0 ((fun x01 => fun p01 => fun x11 => fun p1 => cic.prod univs.Type0 cic.prop a1 (fun a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (fun e2 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((fun x0 => fun p0 => fun x1 => fun p1 => fun x2 => fun p2 => cic.prod univs.Type0 cic.prop a1 (fun a => cic.prod univs.Type0 cic.prop a1 (fun b => cic.prod univs.Type0 cic.prop a1 (fun c => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1))) t0 (fun x0 => fun __ => cic.lift cic.prop univs.Type0 ((fun x01 => fun p0 => cic.prod univs.Type0 cic.prop a1 (fun a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (fun x0 => fun p0 => fun x1 => fun __ => cic.lift cic.prop univs.Type0 ((fun x01 => fun p01 => fun x11 => fun p1 => cic.prod univs.Type0 cic.prop a1 (fun a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (fun x0 => fun p0 => fun x1 => fun p1 => fun x2 => fun __ => cic.lift cic.prop univs.Type0 ((fun x01 => fun p01 => fun x11 => fun p11 => fun x21 => fun p2 => cic.prod univs.Type0 cic.prop a1 (fun a => cic.prod univs.Type0 cic.prop a1 (fun b => cic.prod univs.Type0 cic.prop a1 (fun c => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (fun _e3 => P))))) (fun _z51 => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Aop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $a2$ and $a$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $x0$ applied to $b$ and $c$ and $x0$ applied to $x0$ applied to $a$ and $b$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z51$ to $P$ and $y$ and $x$.",
    "output": "axiom Aop_discr (a1 : cic.Univ univs.Type0) (a2 : cic.Term univs.Type0 a1) (x y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => λ t2 => λ t3 => matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => λ u2 => λ u3 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (λ __ => cic.prod univs.Type0 univs.Type0 a1 (λ __1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (λ __ => cic.prod univs.Type0 univs.Type0 a1 (λ __1 => a1))) t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((λ x0 => λ p0 => cic.prod univs.Type0 cic.prop a1 (λ a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (λ __ => cic.prod univs.Type0 univs.Type0 a1 (λ __1 => a1)))) t0 (λ x_19 => λ _x_20 => cic.lift cic.prop univs.Type0 ((λ x0 => λ p0 => cic.prod univs.Type0 cic.prop a1 (λ a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) (λ e1 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((λ x0 => λ p0 => λ x1 => λ p1 => cic.prod univs.Type0 cic.prop a1 (λ a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (λ __ => cic.prod univs.Type0 univs.Type0 a1 (λ __1 => a1))) t0 (λ x0 => λ __ => cic.lift cic.prop univs.Type0 ((λ x01 => λ p0 => cic.prod univs.Type0 cic.prop a1 (λ a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (λ x0 => λ p0 => λ x1 => λ __ => cic.lift cic.prop univs.Type0 ((λ x01 => λ p01 => λ x11 => λ p1 => cic.prod univs.Type0 cic.prop a1 (λ a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (λ e2 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((λ x0 => λ p0 => λ x1 => λ p1 => λ x2 => λ p2 => cic.prod univs.Type0 cic.prop a1 (λ a => cic.prod univs.Type0 cic.prop a1 (λ b => cic.prod univs.Type0 cic.prop a1 (λ c => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (λ __ => cic.prod univs.Type0 univs.Type0 a1 (λ __1 => a1))) t0 (λ x0 => λ __ => cic.lift cic.prop univs.Type0 ((λ x01 => λ p0 => cic.prod univs.Type0 cic.prop a1 (λ a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (λ x0 => λ p0 => λ x1 => λ __ => cic.lift cic.prop univs.Type0 ((λ x01 => λ p01 => λ x11 => λ p1 => cic.prod univs.Type0 cic.prop a1 (λ a => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (λ x0 => λ p0 => λ x1 => λ p1 => λ x2 => λ __ => cic.lift cic.prop univs.Type0 ((λ x01 => λ p01 => λ x11 => λ p11 => λ x21 => λ p2 => cic.prod univs.Type0 cic.prop a1 (λ a => cic.prod univs.Type0 cic.prop a1 (λ b => cic.prod univs.Type0 cic.prop a1 (λ c => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (λ _e3 => P))))) (λ _z51 => P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_eq : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> __ : cic.Term univs.Type2 A -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_eq : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (__ : cic.Term univs.Type2 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Filter_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_eq : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall __ : cic.Term univs.Type2 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.eq A _x __), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Filter_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_eq (A : cic.Univ univs.Type2) (_x __ : cic.Term univs.Type2 A) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "eq_rect_Type0_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_19 : cic.Term univs.Type2 A -> _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Univ univs.Type0) -> _H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) -> x_19 : cic.Term univs.Type2 A -> x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Term univs.Type0 (Q_ x_19 x_20) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "postulate eq_rect_Type0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "Axiom eq_rect_Type0_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0), forall _H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)), forall x_19 : cic.Term univs.Type2 A, forall x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19), cic.Term univs.Type0 (Q_ x_19 x_20) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "axiom eq_rect_Type0_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) (x_19 : cic.Term univs.Type2 A) (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) : cic.Term univs.Type0 (Q_ x_19 x_20)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "eq_rect_CProp4 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_22 : cic.Term univs.Type2 A -> _x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_22 : cic.Term univs.Type2 A -> x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) -> cic.Term cic.prop (Q_ x_22 x_23) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "postulate eq_rect_CProp4 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_22 : cic.Term univs.Type2 A) -> (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Term cic.prop (Q_ x_22 x_23)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "Axiom eq_rect_CProp4 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_22 : cic.Term univs.Type2 A, forall x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22), cic.Term cic.prop (Q_ x_22 x_23) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "axiom eq_rect_CProp4 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_22 : cic.Term univs.Type2 A) (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) : cic.Term cic.prop (Q_ x_22 x_23)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_31$ and $x_32$.",
    "output": "eq_rect_CProp2_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_31 : cic.Term univs.Type2 A -> _x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_31 : cic.Term univs.Type2 A -> x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Term cic.prop (Q_ x_31 x_32) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_31$ and $x_32$.",
    "output": "postulate eq_rect_CProp2_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_31 : cic.Term univs.Type2 A) -> (x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Term cic.prop (Q_ x_31 x_32)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_31$ and $x_32$.",
    "output": "Axiom eq_rect_CProp2_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_31 : cic.Term univs.Type2 A, forall x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31), cic.Term cic.prop (Q_ x_31 x_32) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_31$ and $x_32$.",
    "output": "axiom eq_rect_CProp2_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_31 : cic.Term univs.Type2 A) (x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) : cic.Term cic.prop (Q_ x_31 x_32)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_34$ and $x_35$.",
    "output": "eq_rect_CProp1 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_34 : cic.Term univs.Type2 A -> _x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_34 : cic.Term univs.Type2 A -> x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) -> cic.Term cic.prop (Q_ x_34 x_35) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_34$ and $x_35$.",
    "output": "postulate eq_rect_CProp1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_34 : cic.Term univs.Type2 A) -> (_x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_34 : cic.Term univs.Type2 A) -> (x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Term cic.prop (Q_ x_34 x_35)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_34$ and $x_35$.",
    "output": "Axiom eq_rect_CProp1 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_34 : cic.Term univs.Type2 A) -> (_x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_34 : cic.Term univs.Type2 A, forall x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34), cic.Term cic.prop (Q_ x_34 x_35) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_34$ and $x_35$.",
    "output": "axiom eq_rect_CProp1 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_34 : cic.Term univs.Type2 A) -> (_x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_34 : cic.Term univs.Type2 A) (x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) : cic.Term cic.prop (Q_ x_34 x_35)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Eq_rect_Type0_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $x$ and $p$.",
    "output": "eq_rect_Type0_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ univs.Type0) -> __ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term univs.Type0 (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Eq_rect_Type0_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $x$ and $p$.",
    "output": "postulate eq_rect_Type0_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type0 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Eq_rect_Type0_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $x$ and $p$.",
    "output": "Axiom eq_rect_Type0_r : forall A : cic.Univ univs.Type2, forall a : cic.Term univs.Type2 A, forall P : ((x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0), forall __ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a)), forall x : cic.Term univs.Type2 A, forall p : cic.Term cic.prop (matita_basics_logic.eq A x a), cic.Term univs.Type0 (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Eq_rect_Type0_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $x$ and $p$.",
    "output": "axiom eq_rect_Type0_r (A : cic.Univ univs.Type2) (a : cic.Term univs.Type2 A) (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) (x : cic.Term univs.Type2 A) (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) : cic.Term univs.Type0 (P x p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Filter_True. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_True : return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop matita_basics_logic.True -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop matita_basics_logic.True -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop matita_basics_logic.True -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Filter_True. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Filter_True. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_True : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop matita_basics_logic.True, cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Filter_True. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_True (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop matita_basics_logic.True) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "True_rect_Type4 : Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type4) -> _H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I) -> x_42 : cic.Term cic.prop matita_basics_logic.True -> cic.Term univs.Type4 (Q_ x_42) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "postulate True_rect_Type4 : (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) -> (x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type4 (Q_ x_42)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "Axiom True_rect_Type4 : forall Q_ : ((_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4), forall _H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I), forall x_42 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type4 (Q_ x_42) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "axiom True_rect_Type4 (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) (x_42 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type4 (Q_ x_42)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "True_rect_CProp3. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "True_rect_CProp3 : Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_58 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_58) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "True_rect_CProp3. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "postulate True_rect_CProp3 : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "True_rect_CProp3. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "Axiom True_rect_CProp3 : forall Q_ : ((_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop), forall _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I), forall x_58 : cic.Term cic.prop matita_basics_logic.True, cic.Term cic.prop (Q_ x_58) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "True_rect_CProp3. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "axiom True_rect_CProp3 (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_58 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_58)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "False_rect_Type0. For all functions $Q_$ from elements $_x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_72$.",
    "output": "False_rect_Type0 : Q_ : (_x_72 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type0) -> x_72 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type0 (Q_ x_72) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_Type0. For all functions $Q_$ from elements $_x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_72$.",
    "output": "postulate False_rect_Type0 : (Q_ : (_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0) -> (x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ x_72)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "False_rect_Type0. For all functions $Q_$ from elements $_x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_72$.",
    "output": "Axiom False_rect_Type0 : forall Q_ : ((_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0), forall x_72 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type0 (Q_ x_72) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "False_rect_Type0. For all functions $Q_$ from elements $_x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_72$.",
    "output": "axiom False_rect_Type0 (Q_ : (_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0) (x_72 : cic.Term cic.prop matita_basics_logic.False) : cic.Term univs.Type0 (Q_ x_72)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "False_rect_CProp1. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "False_rect_CProp1 : Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_77) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp1. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "postulate False_rect_CProp1 : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "False_rect_CProp1. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "Axiom False_rect_CProp1 : forall Q_ : ((_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_77 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_77) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "False_rect_CProp1. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "axiom False_rect_CProp1 (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_77 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_77)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "False_rect_CProp1_body. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "False_rect_CProp1_body : Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_77) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp1_body. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "postulate False_rect_CProp1_body : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "False_rect_CProp1_body. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "Axiom False_rect_CProp1_body : forall Q_ : ((_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_77 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_77) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "False_rect_CProp1_body. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "axiom False_rect_CProp1_body (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_77 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_77)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "False_rect_CProp0_body. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.",
    "output": "False_rect_CProp0_body : Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_78 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_78) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "False_rect_CProp0_body. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.",
    "output": "postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "False_rect_CProp0_body. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.",
    "output": "Axiom False_rect_CProp0_body : forall Q_ : ((_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_78 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_78) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "False_rect_CProp0_body. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.",
    "output": "axiom False_rect_CProp0_body (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_78 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_78)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Not : _A : cic.Univ cic.prop -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Not : (_A : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom Not : forall _A : cic.Univ cic.prop, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom Not (_A : cic.Univ cic.prop) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Nmk. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.",
    "output": "nmk : A : cic.Univ cic.prop -> __ : (__ : cic.Term cic.prop A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Nmk. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.",
    "output": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Nmk. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.",
    "output": "Axiom nmk : forall A : cic.Univ cic.prop, forall __ : ((__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False), cic.Term cic.prop (matita_basics_logic.Not A) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Nmk. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.",
    "output": "axiom nmk (A : cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (matita_basics_logic.Not A)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_Not : _A : cic.Univ cic.prop -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ return_sort) -> case_nmk : (__ : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_Not : forall _A : cic.Univ cic.prop, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort), forall case_nmk : ((__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))), forall z : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_Not (_A : cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) (z : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "Not_rect_CProp3 : _A : cic.Univ cic.prop -> Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_107 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_106) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "Axiom Not_rect_CProp3 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))), forall x_106 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_106) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "axiom Not_rect_CProp3 (_A : cic.Univ cic.prop) (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term cic.prop (Q_ x_106)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Not_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z275$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z276$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_92$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_92$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Not_inv_rect_Type2 : x1 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) -> P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1) -> cic.Univ univs.Type2) -> _H1 : (x_92 : (__ : cic.Term cic.prop x1 -> cic.Term cic.prop matita_basics_logic.False) -> _z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92)) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Not_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z275$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z276$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_92$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_92$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "postulate Not_inv_rect_Type2 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) -> (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Not_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z275$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z276$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_92$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_92$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Axiom Not_inv_rect_Type2 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2), forall _H1 : ((x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Not_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z275$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z276$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_92$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_92$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "axiom Not_inv_rect_Type2 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "And_ind : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_120 : cic.Term cic.prop _A -> x_119 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) -> x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_118) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "postulate And_ind : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) -> (x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_118)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "And_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "Axiom And_ind : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))), forall x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_118) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "And_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "axiom And_ind (_A _B : cic.Univ cic.prop) (Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) (x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_118)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "And_rect_CProp4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_148 : cic.Term cic.prop _A -> x_147 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_146) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "postulate And_rect_CProp4 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_146)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "Axiom And_rect_CProp4 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))), forall x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_146) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "axiom And_rect_CProp4 (_A _B : cic.Univ cic.prop) (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_146)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "And_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "And_inv_rect_CProp1 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_164 : cic.Term cic.prop x1 -> x_163 : cic.Term cic.prop x2 -> _z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "And_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp1 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "And_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom And_inv_rect_CProp1 : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2), forall P : ((_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "And_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom And_inv_rect_CProp1 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Match_ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_ex2 : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ return_sort) -> case_ex2_intro : (x : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (_P x) -> __1 : cic.Term cic.prop (_Q x) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))) -> z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Match_ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (case_ex2_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Match_ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_ex2 : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort), forall case_ex2_intro : ((x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))), forall z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Match_ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_ex2 (A : cic.Univ univs.Type0) (_P _Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) (case_ex2_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))) (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Ex2_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "ex2_ind : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ cic.prop) -> _H_ex2_intro : (x : cic.Term univs.Type0 A -> x_276 : cic.Term cic.prop (_P x) -> x_275 : cic.Term cic.prop (_Q x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term cic.prop (Q_ x_274) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Ex2_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "postulate ex2_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) -> (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term cic.prop (Q_ x_274)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Ex2_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "Axiom ex2_ind : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop), forall _H_ex2_intro : ((x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))), forall x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term cic.prop (Q_ x_274) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Ex2_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "axiom ex2_ind (A : cic.Univ univs.Type0) (_P _Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) : cic.Term cic.prop (Q_ x_274)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Iff_or_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $C$ and $A$ and $matita_basics_logic.Or$ applied to $C$ and $B$.",
    "output": "iff_or_l : A : cic.Univ cic.prop -> B : cic.Univ cic.prop -> C : cic.Univ cic.prop -> __ : cic.Term cic.prop (matita_basics_logic.iff A B) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Iff_or_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $C$ and $A$ and $matita_basics_logic.Or$ applied to $C$ and $B$.",
    "output": "postulate iff_or_l : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B))"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Iff_or_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $C$ and $A$ and $matita_basics_logic.Or$ applied to $C$ and $B$.",
    "output": "Axiom iff_or_l : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall C : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.iff A B), cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Iff_or_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $C$ and $A$ and $matita_basics_logic.Or$ applied to $C$ and $B$.",
    "output": "axiom iff_or_l (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "StreicherK. For all elements $T$ of $cic.Univ$ of $univs.Type2$, for all elements $t$ of $cic.Term$ of $univs.Type2$ and $T$, for all functions $P$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.refl$ applied to $T$ and $t$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $p$.",
    "output": "streicherK : T : cic.Univ univs.Type2 -> t : cic.Term univs.Type2 T -> P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)) -> p : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Term univs.Type2 (P p) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "StreicherK. For all elements $T$ of $cic.Univ$ of $univs.Type2$, for all elements $t$ of $cic.Term$ of $univs.Type2$ and $T$, for all functions $P$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.refl$ applied to $T$ and $t$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $p$.",
    "output": "postulate streicherK : (T : cic.Univ univs.Type2) -> (t : cic.Term univs.Type2 T) -> (P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t))) -> (p : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Term univs.Type2 (P p)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "StreicherK. For all elements $T$ of $cic.Univ$ of $univs.Type2$, for all elements $t$ of $cic.Term$ of $univs.Type2$ and $T$, for all functions $P$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.refl$ applied to $T$ and $t$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $p$.",
    "output": "Axiom streicherK : forall T : cic.Univ univs.Type2, forall t : cic.Term univs.Type2 T, forall P : ((__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2), forall __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)), forall p : cic.Term cic.prop (matita_basics_logic.eq T t t), cic.Term univs.Type2 (P p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "StreicherK. For all elements $T$ of $cic.Univ$ of $univs.Type2$, for all elements $t$ of $cic.Term$ of $univs.Type2$ and $T$, for all functions $P$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.refl$ applied to $T$ and $t$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $p$.",
    "output": "axiom streicherK (T : cic.Univ univs.Type2) (t : cic.Term univs.Type2 T) (P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2) (__ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t))) (p : cic.Term cic.prop (matita_basics_logic.eq T t t)) : cic.Term univs.Type2 (P p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Predicate. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "predicate : __ : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Predicate. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate predicate : (__ : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Predicate. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom predicate : forall __ : cic.Univ univs.Type0, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Predicate. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom predicate (__ : cic.Univ univs.Type0) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Reflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "reflexive : A : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Reflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate reflexive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Reflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom reflexive : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Reflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom reflexive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Inv. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "inv : A : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _a : cic.Term univs.Type0 A -> _b : cic.Term univs.Type0 A -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Inv. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate inv : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Inv. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom inv : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall _a : cic.Term univs.Type0 A, forall _b : cic.Term univs.Type0 A, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Inv. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom inv (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) (_a _b : cic.Term univs.Type0 A) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sub_reflexive. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $T$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $T$ and $R$ and $R$.",
    "output": "sub_reflexive : T : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation T) -> cic.Term cic.prop (matita_basics_relations.subR T R R) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sub_reflexive. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $T$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $T$ and $R$ and $R$.",
    "output": "postulate sub_reflexive : (T : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation T)) -> cic.Term cic.prop (matita_basics_relations.subR T R R)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sub_reflexive. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $T$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $T$ and $R$ and $R$.",
    "output": "Axiom sub_reflexive : forall T : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation T), cic.Term cic.prop (matita_basics_relations.subR T R R) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sub_reflexive. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $T$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $T$ and $R$ and $R$.",
    "output": "axiom sub_reflexive (T : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation T)) : cic.Term cic.prop (matita_basics_relations.subR T R R)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "distributive : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _g : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom distributive : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A), forall _g : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom distributive (A : cic.Univ univs.Type0) (_f _g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Distributive2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "distributive2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _g : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Distributive2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_g : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Distributive2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom distributive2 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B), forall _g : ((__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Distributive2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom distributive2 (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (_g : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_ind_body. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "void_ind_body : Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_482 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_482) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_ind_body. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "postulate void_ind_body : (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_482)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Void_ind_body. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "Axiom void_ind_body : forall Q_ : ((_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_482 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_482) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Void_ind_body. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "axiom void_ind_body (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_482 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_482)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_rect_Type3. For all functions $Q_$ from elements $_x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_485$.",
    "output": "void_rect_Type3 : Q_ : (_x_485 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type3) -> x_485 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type3 (Q_ x_485) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_rect_Type3. For all functions $Q_$ from elements $_x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_485$.",
    "output": "postulate void_rect_Type3 : (Q_ : (_x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type3) -> (x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type3 (Q_ x_485)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Void_rect_Type3. For all functions $Q_$ from elements $_x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_485$.",
    "output": "Axiom void_rect_Type3 : forall Q_ : ((_x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type3), forall x_485 : cic.Term univs.Type0 matita_basics_types.void, cic.Term univs.Type3 (Q_ x_485) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Void_rect_Type3. For all functions $Q_$ from elements $_x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_485$.",
    "output": "axiom void_rect_Type3 (Q_ : (_x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type3) (x_485 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term univs.Type3 (Q_ x_485)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Void_rect_CProp0_body. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.",
    "output": "void_rect_CProp0_body : Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_494 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_494) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Void_rect_CProp0_body. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.",
    "output": "postulate void_rect_CProp0_body : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Void_rect_CProp0_body. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.",
    "output": "Axiom void_rect_CProp0_body : forall Q_ : ((_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_494 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_494) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Void_rect_CProp0_body. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.",
    "output": "axiom void_rect_CProp0_body (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_494 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_494)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit. $cic.Univ$ holds for $univs.Type0$.",
    "output": "unit : cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit. $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate unit : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Unit. $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom unit : cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Unit. $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom unit : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_rect_Type5_body. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "unit_rect_Type5_body : Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type5) -> _H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it) -> x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type5 (Q_ x_499) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_rect_Type5_body. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "postulate unit_rect_Type5_body : (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) -> (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) -> (x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type5 (Q_ x_499)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Unit_rect_Type5_body. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "Axiom unit_rect_Type5_body : forall Q_ : ((_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5), forall _H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it), forall x_499 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term univs.Type5 (Q_ x_499) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Unit_rect_Type5_body. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "axiom unit_rect_Type5_body (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) (x_499 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type5 (Q_ x_499)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Unit_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z930$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z931$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "unit_inv_rect_Type1 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type1) -> _H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Unit_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z930$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z931$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Unit_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z930$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z931$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom unit_inv_rect_Type1 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1), forall _H1 : ((_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Unit_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z930$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z931$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "axiom unit_inv_rect_Type1 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "Sum_rect_Type5 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type5) -> _H_inl : (x_532 : cic.Term univs.Type0 _A -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> _H_inr : (x_533 : cic.Term univs.Type0 _B -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type5 (Q_ x_531) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sum_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "Axiom Sum_rect_Type5 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5), forall _H_inl : ((x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))), forall _H_inr : ((x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))), forall x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type5 (Q_ x_531) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sum_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "axiom Sum_rect_Type5 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type5 (Q_ x_531)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "Sum_rect_Type5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type5) -> _H_inl : (x_532 : cic.Term univs.Type0 _A -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> _H_inr : (x_533 : cic.Term univs.Type0 _B -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type5 (Q_ x_531) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "postulate Sum_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sum_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "Axiom Sum_rect_Type5_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5), forall _H_inl : ((x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))), forall _H_inr : ((x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))), forall x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type5 (Q_ x_531) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sum_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "axiom Sum_rect_Type5_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type5 (Q_ x_531)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.",
    "output": "Sum_rect_Type3 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type3) -> _H_inl : (x_537 : cic.Term univs.Type0 _A -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> _H_inr : (x_538 : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type3 (Q_ x_536) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.",
    "output": "postulate Sum_rect_Type3 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sum_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.",
    "output": "Axiom Sum_rect_Type3 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3), forall _H_inl : ((x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))), forall _H_inr : ((x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))), forall x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type3 (Q_ x_536) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sum_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.",
    "output": "axiom Sum_rect_Type3 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type3 (Q_ x_536)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "Sum_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_562 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> _H_inr : (x_563 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_561) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "Axiom Sum_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop), forall _H_inl : ((x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))), forall _H_inr : ((x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))), forall x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term cic.prop (Q_ x_561) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "axiom Sum_rect_CProp5_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_561)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Sum_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z33$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a2$ and $matita_basics_logic.R0$ applied to $a2$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z34$ to $P$ and $y$ and $x$.",
    "output": "Sum_discr : a1 : cic.Univ univs.Type0 -> a2 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 a1 => matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) => P)) (_z33 : (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.Term univs.Type1 P) => P))) (u0 : cic.Term univs.Type0 a2 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) y) (t0 : cic.Term univs.Type0 a2 => matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) (u0 : cic.Term univs.Type0 a2 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) => P)) (_z34 : (_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Sum_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z33$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a2$ and $matita_basics_logic.R0$ applied to $a2$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z34$ to $P$ and $y$ and $x$.",
    "output": "postulate Sum_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ _e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> P)) (\\ _z33 : ((_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> cic.Term univs.Type1 P) -> P))) (\\ u0 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> P)) y) (\\ t0 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> P)) (\\ u0 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) (\\ _e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) -> P)) (\\ _z34 : ((_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Sum_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z33$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a2$ and $matita_basics_logic.R0$ applied to $a2$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z34$ to $P$ and $y$ and $x$.",
    "output": "Axiom Sum_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun _e0 => P)) (fun _z33 => P))) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) y) (fun t0 => matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) (fun _e0 => P)) (fun _z34 => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Sum_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z33$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a2$ and $matita_basics_logic.R0$ applied to $a2$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z34$ to $P$ and $y$ and $x$.",
    "output": "axiom Sum_discr (a1 a2 : cic.Univ univs.Type0) (x y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ _e0 => P)) (λ _z33 => P))) (λ u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => P)) y) (λ t0 => matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => P)) (λ u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) (λ _e0 => P)) (λ _z34 => P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti.",
    "input": "Option_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.",
    "output": "option_rect_CProp5_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_619 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) -> x_618 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_618) ."
  },
  {
    "instruction": "Translate the following English statement into Agda.",
    "input": "Option_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.",
    "output": "postulate option_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) -> (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_618)"
  },
  {
    "instruction": "Translate the following English statement into Coq.",
    "input": "Option_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.",
    "output": "Axiom option_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))), forall x_618 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_618) ."
  },
  {
    "instruction": "Translate the following English statement into Lean.",
    "input": "Option_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.",
    "output": "axiom option_rect_CProp5_body (_A : cic.Univ univs.Type0) (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_618)"
  }
]