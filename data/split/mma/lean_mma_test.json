[
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If two functions fâ‚ and fâ‚‚ are eventually equal at a filter lâ‚, and if function fâ‚ tends from filter lâ‚ to filter lâ‚‚, then function fâ‚‚ also tends from filter lâ‚ to filter lâ‚‚.",
    "output": "theorem Tendsto.congr' {fâ‚ fâ‚‚ : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} (hl : fâ‚ =á¶ [lâ‚] fâ‚‚)\n    (h : Tendsto fâ‚ lâ‚ lâ‚‚) : Tendsto fâ‚‚ lâ‚ lâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' and any list 'l' of elements of the same type as 'a', the count of 'a' in the list that results from erasing 'a' from 'l' is equal to the count of 'a' in 'l' minus one.",
    "output": "theorem count_erase_self (a : Î±) (l : List Î±) : count a (List.erase l a) = count a l - 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of type 'Î±' and any function 'u' that maps from a finite set of size 'm' to 'Î±', the tail of a vector created by prepending 'x' to 'u' is equal to 'u'.",
    "output": "theorem tail_cons (x : Î±) (u : Fin m â†’ Î±) : vecTail (vecCons x u) = u :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a polynomial g is monic, then the root of g is integral over the ring R.",
    "output": "theorem isIntegral_root' (hg : g.Monic) : IsIntegral R (root g) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If b is less than or equal to c, then the natural sum of a and b is less than or equal to the natural sum of a and c.",
    "output": "theorem nadd_le_nadd_left (h : b â‰¤ c) (a) : a â™¯ b â‰¤ a â™¯ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any unit 'u' in a ring 'R' and any natural number 'n', the coefficient of the term of degree 'n' in the power series expansion of the inverse of 'u' subtracted from 1 is equal to 1 divided by 'u' raised to the power of 'n + 1'.",
    "output": "theorem coeff_invUnitsSub (u : RË£) (n : â„•) : coeff R n (invUnitsSub u) = 1 /â‚š u ^ (n + 1) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A hyperreal number 'x' is infinitely positive if and only if for all real numbers 'r', 'r' is less than 'x'.",
    "output": "theorem infinitePos_def {x : â„*} : InfinitePos x â†” âˆ€ r : â„, â†‘r < x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The non-equal locus of the sum of two functions 'f' and 'g' with respect to 'f' is equal to the support of 'g'.",
    "output": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a scalar multiplication operation on a set R and M, and a continuous constant scalar multiplication on R and M, given a scalar r from R, a continuous function f from Î² to M, and a continuous function g from Î± to Î², the composition of the scalar multiplication of r and f with g is equal to the scalar multiplication of r with the composition of f and g.",
    "output": "theorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : C(Î², M)) (g : C(Î±, Î²)) :\n    (r â€¢ f).comp g = r â€¢ f.comp g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any relation 'r' on a set 'Î±' that is well-ordered (denoted by 'wo'), the order type of the well-ordered set 'âŸ¨Î±, r, woâŸ©' is equal to the order type of the relation 'r'.",
    "output": "theorem type_def (r) [wo : IsWellOrder Î± r] : (âŸ¦âŸ¨Î±, r, woâŸ©âŸ§ : Ordinal) = type r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any uniform space Î² and any function f from Î² to Î± that is uniformly continuous, for any natural number n, the function that maps x to the nth power of f(x) is also uniformly continuous.",
    "output": "theorem UniformContinuous.pow_const [UniformSpace Î²] {f : Î² â†’ Î±} (hf : UniformContinuous f) :\n    âˆ€ n : â„•, UniformContinuous fun x => f x ^ n"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any functions `n` mapping from Î³ to Î´, `m'` mapping from Î² to Î±' to Î´, and `n'` mapping from Î± to Î±', if for all `a` and `b`, `n` applied to `m` of `a` and `b` equals `m'` of `b` applied to `n'` of `a`, then mapping `n` over the result of applying the binary function `m` to `f` and `g` equals applying the binary function `m'` to `g` and the result of mapping `n'` over `f`.",
    "output": "theorem map_mapâ‚‚_antidistrib_right {n : Î³ â†’ Î´} {m' : Î² â†’ Î±' â†’ Î´} {n' : Î± â†’ Î±'}\n    (h_antidistrib : âˆ€ a b, n (m a b) = m' b (n' a)) : (mapâ‚‚ m f g).map n = mapâ‚‚ m' g (f.map n') :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The arctangent of a real number x is equal to the arcsine of the ratio of x to the square root of the sum of 1 and the square of x.",
    "output": "theorem arctan_eq_arcsin (x : â„) : arctan x = arcsin (x / sqrt (1 + x ^ 2)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the function that adds a constant 'a' to a variable 'x', when applied to the closed interval from 'b' to 'c', is equal to the closed interval from 'a + b' to 'a + c'.",
    "output": "theorem image_const_add_Icc : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list 'l' of any type 'Î±', given that 'l' is not an empty list, the cycle of 'l' is equal to 'l' appended to the cycle of 'l'.",
    "output": "theorem cycle_eq : âˆ€ (l : List Î±) (h : l â‰  []), cycle l h = l ++â‚› cycle l h"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object 'n' in 'M' and any object 'X' in 'C', the application of the map of 'F.obj n' to 'F.Îµ.app X' is equal to the composition of the application of 'F.map (Î»_ n).inv' to 'X' and the inverse application of 'F.Î¼Iso (ğŸ™_ M) n' to 'X'.",
    "output": "theorem obj_Îµ_app (n : M) (X : C) :\n    (F.obj n).map (F.Îµ.app X) = (F.map (Î»_ n).inv).app X â‰« (F.Î¼Iso (ğŸ™_ M) n).inv.app X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' is an element of the neighborhood of 'x', then 'x' has a unique differential within the set 's'.",
    "output": "theorem uniqueDiffWithinAt_of_mem_nhds (h : s âˆˆ ğ“ x) : UniqueDiffWithinAt ğ•œ s x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a monovariant function pair f and g, the product of the sum of f(i) and the sum of g(i) is less than or equal to the product of the cardinality of the index set and the sum of the product of f(i) and g(i).",
    "output": "theorem Monovary.sum_mul_sum_le_card_mul_sum (hfg : Monovary f g) :\n    ((âˆ‘ i, f i) * âˆ‘ i, g i) â‰¤ Fintype.card Î¹ * âˆ‘ i, f i * g i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î± and Î², where Î± is finite, and any two sets s and t (one from each type), if the cardinality of Î± is equal to the cardinality of Î², and the cardinality of set s is equal to the cardinality of set t, then the cardinality of the complement of set s in Î± is equal to the cardinality of the complement of set t in Î².",
    "output": "theorem mk_compl_eq_mk_compl_finite {Î± Î² : Type u} [Finite Î±] {s : Set Î±} {t : Set Î²}\n    (h1 : (#Î±) = (#Î²)) (h : (#s) = (#t)) : (#(sá¶œ : Set Î±)) = (#(tá¶œ : Set Î²)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is monotone on a set 's', then the composition of 'f' and the value function of a subtype is also monotone when mapping from 's' to 'Î²'.",
    "output": "theorem _root_.MonotoneOn.monotone (h : MonotoneOn f s) :\n    Monotone (f âˆ˜ Subtype.val : s â†’ Î²) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two complex numbers x and y, the complex power function of x and y is equal to x raised to the power of y.",
    "output": "theorem cpow_eq_pow (x y : â„‚) : cpow x y = x ^ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' of type Î± and a set 't' of type Î² are both measurable sets, then the Cartesian product of 's' and 't' is also a measurable set.",
    "output": "theorem MeasurableSet.prod {s : Set Î±} {t : Set Î²} (hs : MeasurableSet s)\n    (ht : MeasurableSet t) : MeasurableSet (s Ã—Ë¢ t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number 'x' and any positive number 'Îµ', there exists a rational number 'q' such that the absolute difference between 'x' and 'q' is less than 'Îµ'.",
    "output": "theorem exists_rat_near (x : Î±) (Îµ0 : 0 < Îµ) : âˆƒ q : â„š, |x - q| < Îµ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'f' is in the Lp space of measurable functions from 'Î±' to 'E' with respect to measure 'Î¼' if and only if the pth power of the norm of 'f' with respect to measure 'Î¼' is less than infinity.",
    "output": "theorem mem_Lp_iff_snorm_lt_top {f : Î± â†’â‚˜[Î¼] E} : f âˆˆ Lp E p Î¼ â†” snorm f p Î¼ < âˆ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The successor of one in the finite set of size n+2 is equal to two.",
    "output": "theorem succ_one_eq_two' : Fin.succ (1 : Fin (n + 2)) = 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given relation R on elements of type Î², a list of elements of type Î±, and a function from Î± to a list of Î², the list formed by binding the function over the list has the pairwise property with respect to R if and only if two conditions are met: firstly, for every element in the original list, the list produced by applying the function to that element has the pairwise property with respect to R; and secondly, for every pair of elements in the original list, for every pair of elements in the lists produced by applying the function to those elements, the relation R holds.",
    "output": "theorem pairwise_bind {R : Î² â†’ Î² â†’ Prop} {l : List Î±} {f : Î± â†’ List Î²} :\n    List.Pairwise R (l.bind f) â†”\n      (âˆ€ a âˆˆ l, Pairwise R (f a)) âˆ§ Pairwise (fun aâ‚ aâ‚‚ => âˆ€ x âˆˆ f aâ‚, âˆ€ y âˆˆ f aâ‚‚, R x y) l :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two sets 's' and 't' in a monoid 'Î±' that also forms a star semigroup, the star of the product of 's' and 't' is equal to the product of the star of 't' and the star of 's'.",
    "output": "theorem star_mul [Monoid Î±] [StarSemigroup Î±] (s t : Set Î±) : (s * t)â‹† = tâ‹† * sâ‹† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of all pairs of elements (p) from a set Î±, where the first element of the pair is less than the second, is an open set.",
    "output": "theorem isOpen_lt_prod : IsOpen { p : Î± Ã— Î± | p.1 < p.2 } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'n is less than the predecessor of m' if and only if 'the successor of n is less than m'.",
    "output": "theorem lt_pred_iff : n < pred m â†” succ n < m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'x' and 'y' are not in the same cycle of permutation 'f', then applying the cycle of 'f' at 'x' to 'y' results in 'y'.",
    "output": "theorem cycleOf_apply_of_not_sameCycle : Â¬SameCycle f x y â†’ cycleOf f x y = y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a sequence of natural numbers 'u' and an initial sequence 'init' of order 'E.order', if 'u' is a solution of the linear recurrence 'E' and 'u' equals 'init' for all 'n' in the order of 'E', then for all natural numbers 'n', 'u' at 'n' equals the solution of 'E' made with 'init' at 'n'.",
    "output": "theorem eq_mk_of_is_sol_of_eq_init {u : â„• â†’ Î±} {init : Fin E.order â†’ Î±} (h : E.IsSolution u)\n    (heq : âˆ€ n : Fin E.order, u n = init n) : âˆ€ n, u n = E.mkSol init n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'f' from 'M' to 'Mâ‚‚' over the scalar field 'S', the same map 'f' considered over a larger scalar field 'R' is still the same map when considered as a function from 'M' to 'Mâ‚‚'.",
    "output": "theorem coe_restrictScalars (f : M â†’â‚—[S] Mâ‚‚) : ((f : M â†’â‚—[R] Mâ‚‚) : M â†’ Mâ‚‚) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two vertices 'u' and 'v' in a graph 'G' that are adjacent, concatenating an empty list with the adjacency of 'u' and 'v' is equivalent to adding the adjacency of 'u' and 'v' to the start of an empty list.",
    "output": "theorem concat_nil {u v : V} (h : G.Adj u v) : nil.concat h = cons h nil :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bijective function 'f' from 'Î±' to 'Î²', the preimage of a set 's' under 'f' is equal to another set 't' if and only if 's' is equal to the image of 't' under 'f'.",
    "output": "theorem preimage_eq_iff_eq_image {f : Î± â†’ Î²} (hf : Bijective f) {s t} : f â»Â¹' s = t â†” s = f '' t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any commutative monoid 'M', any natural number 'n', any element 'i' of the finite set of size 'n', and any function 'v' from the finite set of size 'n+1' to 'M', the product of the function 'v' over all elements 'j' in the strict upper half of 'i.succ' is equal to the product of the function 'v' over all elements 'j' in the strict upper half of 'i', where each 'j' is incremented by one.",
    "output": "theorem prod_Ioi_succ {M : Type _} [CommMonoid M] {n : â„•} (i : Fin n) (v : Fin n.succ â†’ M) :\n    (âˆ j in Ioi i.succ, v j) = âˆ j in Ioi i, v j.succ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a sequence of functions `f'` is uniformly Cauchy on filters `l` and `l'`, then the sequence of functions obtained by multiplying `f'` by the constant function `1` is also uniformly Cauchy on the same filters.",
    "output": "theorem UniformCauchySeqOnFilter.one_smulRight {l' : Filter ğ•œ}\n    (hf' : UniformCauchySeqOnFilter f' l l') :\n    UniformCauchySeqOnFilter (fun n => fun z => (1 : ğ•œ â†’L[ğ•œ] ğ•œ).smulRight (f' n z)) l l' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The absolute value of the difference between the norms of two elements 'a' and 'b' is less than or equal to the norm of the ratio of 'a' to 'b'.",
    "output": "theorem abs_norm_sub_norm_le' (a b : E) : |â€–aâ€– - â€–bâ€–| â‰¤ â€–a / bâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an alternating map 'f' from a module 'M' to a module 'N' over a ring 'R' indexed by 'Î¹', and a linear map 'g' from a module 'Mâ‚‚' to 'M', the application of the composition of 'f' with the linear map 'g' is equal to the composition of 'f' with the double composition of 'g'.",
    "output": "theorem coe_compLinearMap (f : AlternatingMap R M N Î¹) (g : Mâ‚‚ â†’â‚—[R] M) :\n    â‡‘(f.compLinearMap g) = f âˆ˜ (Â· âˆ˜ Â·) g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is not equal to zero, then the degree of the polynomial constant a is zero.",
    "output": "theorem degree_C (ha : a â‰  0) : degree (C a) = (0 : WithBot â„•) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ordinal number 'o' and any element 'a' from the successor of 'o', 'a' is less than or equal to the enumeration of 'o' with respect to the successor of 'o', where the enumeration is defined by the order relation '<'. This is proven by rewriting the type of 'o' as less than its successor.",
    "output": "theorem le_enum_succ {o : Ordinal} (a : (succ o).out.Î±) :\n    a â‰¤\n      @enum (succ o).out.Î± (Â· < Â·) _ o\n        (by\n          rw [type_lt]\n          exact lt_succ o) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is not equal to zero, then the function that maps x to its inverse has a derivative at x, which is equal to the negative of the inverse of the square of x, scaled by 1.",
    "output": "theorem hasFDerivAt_inv (x_ne_zero : x â‰  0) :\n    HasFDerivAt (fun x => xâ»Â¹) (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (-(x ^ 2)â»Â¹) : ğ•œ â†’L[ğ•œ] ğ•œ) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two integers 'a' and 'b', the absolute value of 'a' is less than the absolute value of 'b' if and only if the square of 'a' is less than the square of 'b'.",
    "output": "theorem natAbs_lt_iff_sq_lt {a b : â„¤} : a.natAbs < b.natAbs â†” a ^ 2 < b ^ 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given topological space R and a topological ring R with an ideal J, J is adic if and only if for every natural number n, the set of elements in the nth power of J is open, and for every set s in the neighborhood of 0 in R, there exists a natural number n such that the set of elements in the nth power of J is a subset of s.",
    "output": "theorem isAdic_iff [top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} :\n    IsAdic J â†”\n      (âˆ€ n : â„•, IsOpen ((J ^ n : Ideal R) : Set R)) âˆ§\n        âˆ€ s âˆˆ ğ“ (0 : R), âˆƒ n : â„•, ((J ^ n : Ideal R) : Set R) âŠ† s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from an index set 'Î¹' to the closed subsets of a topological space 'Î±', and a finite set 's' of indices, the underlying set of the intersection (infimum) of the closed subsets indexed by 's' is equal to the intersection of the sets obtained by applying the function 'f' to each element of 's'.",
    "output": "theorem coe_finset_inf (f : Î¹ â†’ Closeds Î±) (s : Finset Î¹) :\n    (â†‘(s.inf f) : Set Î±) = s.inf ((â†‘) âˆ˜ f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite set 's' of any type 'Î±', the cardinality of 's' is equal to the cardinality of the finite set 's'.",
    "output": "theorem Fintype.card_coe (s : Finset Î±) [Fintype s] : Fintype.card s = s.card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of 'a' and 'b' is in the half-open interval from 'c' to 'd' if and only if 'a' is in the half-open interval from 'c - b' to 'd - b'.",
    "output": "theorem add_mem_Ico_iff_left : a + b âˆˆ Set.Ico c d â†” a âˆˆ Set.Ico (c - b) (d - b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a centroid homomorphism 'f' of a type 'Î±', the conversion of 'f' to an additive monoid homomorphism is equal to 'f' itself.",
    "output": "theorem toAddMonoidHom_eq_coe (f : CentroidHom Î±) : f.toAddMonoidHom = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 's' of set 'S', the algebraic mapping of 's' from 'S' to the trivial square zero extension of 'R' and 'M' is equal to the inclusion of the left (inl) of the algebraic mapping of 's' from 'S' to 'R'.",
    "output": "theorem algebraMap_eq_inl' (s : S) : algebraMap S (tsze R M) s = inl (algebraMap S R s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three types Î±, Î², Î³ that are primcodable, and any three properties p, q, r of type Î±, Î², Î³ respectively, if property p is one-one reducible to property q, and property q is one-one reducible to property r, then property p is one-one reducible to property r. This is a statement of transitivity for one-one reducibility.",
    "output": "theorem OneOneReducible.trans {Î± Î² Î³} [Primcodable Î±] [Primcodable Î²] [Primcodable Î³] {p : Î± â†’ Prop}\n    {q : Î² â†’ Prop} {r : Î³ â†’ Prop} : p â‰¤â‚ q â†’ q â‰¤â‚ r â†’ p â‰¤â‚ r"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a particular element 'a' does not belong to a given set 's', then the intersection of set 's' and the set containing only 'a' is an empty set.",
    "output": "theorem inter_singleton_of_not_mem {a : Î±} {s : Finset Î±} (h : a âˆ‰ s) : s âˆ© {a} = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The negative of x is an element of p if and only if x is an element of p.",
    "output": "theorem neg_mem_iff : -x âˆˆ p â†” x âˆˆ p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'f' from 'E' to 'F' that is differentiable on a set 's', and for all 'y', the derivative of 'f' within the set 's' at 'x' and 'y' is 'n' times continuously differentiable on 's', then 'f' is '(n + 1)' times continuously differentiable on 's'. Here, 'ğ•œ' is the field over which the function is defined and 'E' and 'F' are finite-dimensional vector spaces over 'ğ•œ'.",
    "output": "theorem contDiffOn_succ_of_fderiv_apply [FiniteDimensional ğ•œ E] {n : â„•} {f : E â†’ F} {s : Set E}\n    (hf : DifferentiableOn ğ•œ f s) (h : âˆ€ y, ContDiffOn ğ•œ n (fun x => fderivWithin ğ•œ f s x y) s) :\n    ContDiffOn ğ•œ (n + 1 : â„•) f s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The homomorphism of the quotient of the integer power of a homomorphism, when the homomorphism is the identity on A, is equal to the identity homomorphism.",
    "output": "theorem homQuotientZPowOfHom_id : homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The range of the representation function of a basis 'b' (which maps from the module 'M' to the function space of 'Î¹' with coefficients in the ring 'R') is equal to the set of all finitely supported functions from 'Î¹' to 'R' that are supported everywhere (i.e., on the universal set).",
    "output": "theorem repr_range : LinearMap.range (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) = Finsupp.supported R R univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If polynomial q is not equal to zero and the trailing degree of polynomial p is less than or equal to the trailing degree of polynomial q, then the natural number trailing degree of polynomial p is less than or equal to the natural number trailing degree of polynomial q.",
    "output": "theorem natTrailingDegree_le_natTrailingDegree {hq : q â‰  0}\n    (hpq : p.trailingDegree â‰¤ q.trailingDegree) : p.natTrailingDegree â‰¤ q.natTrailingDegree :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a sequence of functions 'fs' and a function 'f' that are dominated by an integrable function 'bound', and each function in the sequence 'fs' is almost everywhere strongly measurable, then if for almost every 'a', the sequence 'fs' converges to 'f' at 'a', the limit of the sequence of the set function applied to 'fs' is the set function applied to 'f'. This is under the condition that 'T' is a dominated finite measure additive function.",
    "output": "theorem tendsto_setToFun_of_dominated_convergence (hT : DominatedFinMeasAdditive Î¼ T C)\n    {fs : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„)\n    (fs_measurable : âˆ€ n, AEStronglyMeasurable (fs n) Î¼) (bound_integrable : Integrable bound Î¼)\n    (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => fs n a) atTop (ğ“ (f a))) :\n    Tendsto (fun n => setToFun Î¼ T hT (fs n)) atTop (ğ“ <| setToFun Î¼ T hT f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If y and z are coprime and x divides y, then x and z are also coprime.",
    "output": "theorem IsCoprime.of_isCoprime_of_dvd_left (h : IsCoprime y z) (hdvd : x âˆ£ y) : IsCoprime x z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nonzero polynomial 'p' over a finite field 'Fq', the cardinality of the power of the degree of 'p' is equal to the cardinality of 'Fq' raised to the natural degree of 'p'.",
    "output": "theorem cardPowDegree_nonzero (p : Fq[X]) (hp : p â‰  0) :\n    cardPowDegree p = (Fintype.card Fq : â„¤) ^ p.natDegree :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any interval 's' of any type 'Î±', the length of 's' is always greater than or equal to zero.",
    "output": "theorem length_nonneg : âˆ€ s : Interval Î±, 0 â‰¤ s.length"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'y' has a finite order and for every prime number 'p' that divides the order of 'x', 'p' times the order of 'x' also divides the order of 'y', then the order of the product of 'x' and 'y' is equal to the order of 'y'.",
    "output": "theorem orderOf_mul_eq_right_of_forall_prime_mul_dvd (hy : IsOfFinOrder y)\n    (hdvd : âˆ€ p : â„•, p.Prime â†’ p âˆ£ orderOf x â†’ p * orderOf x âˆ£ orderOf y) :\n    orderOf (x * y) = orderOf y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers k and l, and any Lie ideals I and J of a Lie algebra L over a ring R, if the k-th derived series of I and the l-th derived series of J are both the zero ideal (denoted by âŠ¥), then the (k + l)-th derived series of the sum of I and J is also the zero ideal.",
    "output": "theorem derivedSeries_add_eq_bot {k l : â„•} {I J : LieIdeal R L} (hI : derivedSeries R I k = âŠ¥)\n    (hJ : derivedSeries R J l = âŠ¥) : derivedSeries R (I + J) (k + l) = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type 'q.P.A' and any function 'f' from 'q.P.B a' to 'q.P.W', the fixed point of the function 'mk' applied to the abstraction of the pair consisting of 'a' and the function that maps 'x' to the equivalence class of 'f x', is equal to the equivalence class of the pair consisting of 'a' and 'f'.",
    "output": "theorem Fix.ind_aux (a : q.P.A) (f : q.P.B a â†’ q.P.W) :\n    Fix.mk (abs âŸ¨a, fun x => âŸ¦f xâŸ§âŸ©) = âŸ¦âŸ¨a, fâŸ©âŸ§ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for all elements 'x' in a certain set 'l', the function 'f' applied to 'x' is nonnegative (i.e., greater than or equal to zero), and if the function 'g' tends to infinity as 'x' tends to infinity in 'l', then the function that adds the results of 'f' and 'g' also tends to infinity as 'x' tends to infinity in 'l'.",
    "output": "theorem tendsto_atTop_add_nonneg_left' (hf : âˆ€á¶  x in l, 0 â‰¤ f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If N is a normal subgroup of a group G and the order of N is coprime to the index of N in G, then there exists a subgroup H of G such that N and H are complementary.",
    "output": "theorem exists_right_complement'_of_coprime {N : Subgroup G} [N.Normal]\n    (hN : Nat.coprime (Nat.card N) N.index) : âˆƒ H : Subgroup G, IsComplement' N H :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 'i' that is measurable, and another set 'j' that is also measurable, the restriction of the vector 'v' to the set 'i' applied to 'j' is equal to the vector 'v' applied to the intersection of 'j' and 'i'.",
    "output": "theorem restrict_apply {i : Set Î±} (hi : MeasurableSet i) {j : Set Î±} (hj : MeasurableSet j) :\n    v.restrict i j = v (j âˆ© i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sine of two times pi is equal to zero.",
    "output": "theorem sin_two_pi : sin (2 * Ï€) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an affine equivalence 'e' between two points 'Pâ‚' and 'Pâ‚‚' in a field 'k', and for any two points 'a' and 'b' in 'Pâ‚' and any scalar 'c' in 'k', applying 'e' to the line map of 'a', 'b', and 'c' is equivalent to the line map of 'e a', 'e b', and 'c'.",
    "output": "theorem apply_lineMap (e : Pâ‚ â‰ƒáµƒ[k] Pâ‚‚) (a b : Pâ‚) (c : k) :\n    e (AffineMap.lineMap a b c) = AffineMap.lineMap (e a) (e b) c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have an algebra A over B, and if A has a finite presentation over R and B has a finite presentation over A, then B also has a finite presentation over R. This is under the condition that R, A, and B form a scalar tower.",
    "output": "theorem trans [Algebra A B] [IsScalarTower R A B] (hfpA : FinitePresentation R A)\n    (hfpB : FinitePresentation A B) : FinitePresentation R B :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given point 'x' and a set 's' such that 's' is in the neighborhood of 'x', and another set 't', the difference of 's' and 't' is in the neighborhood of 'x' within the complement of 't'.",
    "output": "theorem diff_mem_nhdsWithin_compl {x : Î±} {s : Set Î±} (hs : s âˆˆ ğ“ x) (t : Set Î±) :\n    s \\ t âˆˆ ğ“[tá¶œ] x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types K and L, given that K and L are fields, R is a domain, R is a Dedekind domain, there are algebra structures between R and K, and between S and L, K and L are fraction rings of R and S respectively, there are algebra structures between K and L, and between R and L, R, S, and L form a scalar tower, as do R, K, and L, R and S form a Noetherian ring, S is an integral closure of R in L, and p is a maximal ideal of R that is not the zero ideal, the sum over all prime ideals P in the factorization of the ideal p in S, of the product of the ramification index and the inertia degree of P with respect to the ring homomorphism from R to S, is equal to the field extension degree of K over L.",
    "output": "theorem sum_ramification_inertia (K L : Type _) [Field K] [Field L] [IsDomain R]\n    [IsDedekindDomain R] [Algebra R K] [IsFractionRing R K] [Algebra S L] [IsFractionRing S L]\n    [Algebra K L] [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] [IsNoetherian R S]\n    [IsIntegralClosure S R L] [p.IsMaximal] (hp0 : p â‰  âŠ¥) :\n    (âˆ‘ P in (factors (map (algebraMap R S) p)).toFinset,\n        ramificationIdx (algebraMap R S) p P * inertiaDeg (algebraMap R S) p P) =\n      finrank K L :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given Lie Submodule 'N'', the Lie bracket of the top Lie Ideal and 'N' is less than or equal to 'N'' if and only if 'N' is less than or equal to the normalizer of 'N''.",
    "output": "theorem top_lie_le_iff_le_normalizer (N' : LieSubmodule R L M) :\n    â…(âŠ¤ : LieIdeal R L), Nâ† â‰¤ N' â†” N â‰¤ N'.normalizer :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The Cramer's map for a matrix A is a linear map in the field of scalars Î±.",
    "output": "theorem cramer_is_linear : IsLinearMap Î± (cramerMap A) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index 'i' in a set 'Î¹', if every 'Î± i' is nonempty and the filter 'f i' is not the smallest filter (NeBot), then the coproduct filter of 'f' is also not the smallest filter.",
    "output": "theorem NeBot.coprodáµ¢ [âˆ€ i, Nonempty (Î± i)] {i : Î¹} (h : NeBot (f i)) : NeBot (Filter.coprodáµ¢ f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'l' is an exponential comparison filter, 'a' is a complex number, and 'b' is a real number less than zero, then the function that maps 'z' to the exponential of 'b' times 'z' is little-o of the function that maps 'z' to 'z' raised to the power of 'a' at the limit 'l'. This means that the growth rate of the exponential function is significantly smaller than the growth rate of the power function as 'z' approaches the limit 'l'.",
    "output": "theorem isLittleO_exp_cpow (hl : IsExpCmpFilter l) (a : â„‚) {b : â„} (hb : b < 0) :\n    (fun z => exp (b * z)) =o[l] fun z => z ^ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two algebraic equivalences, the first one from Aâ‚ to Aâ‚‚ and the second one from Aâ‚‚ to Aâ‚ƒ, the composition of the first equivalence followed by the second one is equal to the transitive application of the first equivalence to the second one.",
    "output": "theorem coe_trans (eâ‚ : Aâ‚ â‰ƒâ‚[R] Aâ‚‚) (eâ‚‚ : Aâ‚‚ â‰ƒâ‚[R] Aâ‚ƒ) : â‡‘(eâ‚.trans eâ‚‚) = eâ‚‚ âˆ˜ eâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The second projection of a pullback cone, derived from a left isomorphism of morphisms f and g, is equal to the identity morphism.",
    "output": "theorem pullbackConeOfLeftIso_snd : (pullbackConeOfLeftIso f g).snd = ğŸ™ _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is monotone and tends to zero as it approaches infinity, and if the norm of the sum of a sequence 'z' up to any given point 'n' is less than or equal to a constant 'b', then the sequence defined by the sum of the product of 'f' and 'z' up to the point 'n+1' is a Cauchy sequence.",
    "output": "theorem Monotone.cauchySeq_series_mul_of_tendsto_zero_of_bounded (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (ğ“ 0)) (hgb : âˆ€ n, â€–âˆ‘ i in range n, z iâ€– â‰¤ b) :\n    CauchySeq fun n â†¦ âˆ‘ i in range (n + 1), f i â€¢ z i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of the set of elements that do not satisfy the predicate 'p', applying the equivalence relation 'ep.subtypeCongr en' to 'a' is the same as applying the equivalence relation 'en' to 'a'.",
    "output": "theorem Perm.subtypeCongr.right_apply_subtype (a : { a // Â¬p a }) : ep.subtypeCongr en a = en a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two multisets 's' and 't', if 's' does not contain any duplicate elements, then the intersection of 's' and 't' (where duplicates are not allowed) also does not contain any duplicate elements.",
    "output": "theorem Nodup.ndinter {s : Multiset Î±} (t : Multiset Î±) : Nodup s â†’ Nodup (ndinter s t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two multiplicative characters Ï‡ and Ï‡' from a ring R to another ring R', Ï‡ is equal to Ï‡' if and only if for all units a in R, the value of Ï‡ at a is equal to the value of Ï‡' at a.",
    "output": "theorem ext_iff {Ï‡ Ï‡' : MulChar R R'} : Ï‡ = Ï‡' â†” âˆ€ a : RË£, Ï‡ a = Ï‡' a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers 'n' and 'k', if 'n' is not less than the square of 'k', then the difference between the square root of 'n' and 'k' is less than the difference between the square root of 'n' plus 2 and 'k'.",
    "output": "theorem minFac_lemma (n k : â„•) (h : Â¬n < k * k) : sqrt n - k < sqrt n + 2 - k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The application of the norm group norm to a normed group E is equal to the norm.",
    "output": "theorem coe_normGroupNorm : â‡‘(normGroupNorm E) = norm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'f' from 'Î±' to non-negative extended real numbers is continuous if and only if the function 'f' is continuous when considered as a function from 'Î±' to extended real numbers.",
    "output": "theorem continuous_coe_ennreal_iff {f : Î± â†’ â„â‰¥0âˆ} :\n    (Continuous fun a => (f a : EReal)) â†” Continuous f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± that is finite, any type Î² that has a decidable equality, any function from Î± to Î², any element k of Î², and any property p of Î² that is decidable, if k is in the image of the function applied to all elements of Î± and k does not satisfy the property p, then the image of the function applied to all elements of Î± that satisfy the property p is a proper subset of the image of the function applied to all elements of Î±.",
    "output": "theorem image_subtype_univ_ssubset_image_univ [Fintype Î±] [DecidableEq Î²] (k : Î²) (b : Î± â†’ Î²)\n    (hk : k âˆˆ Finset.image b univ) (p : Î² â†’ Prop) [DecidablePred p] (hp : Â¬p k) :\n    image (fun i : { a // p (b a) } => b â†‘i) univ âŠ‚ image b univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 'c' of linear maps from 'E' to 'F', if 'c' is directed on the relation 'less than or equal to', and 'l' is a linear map in 'c', then for any 'x' in the domain of 'l', the supremum of 'c' applied to 'x' (with 'x' satisfying the condition that it is less than or equal to the supremum of 'c') is equal to 'l' applied to 'x'.",
    "output": "theorem sSup_apply {c : Set (E â†’â‚—.[R] F)} (hc : DirectedOn (Â· â‰¤ Â·) c) {l : E â†’â‚—.[R] F}\n    (hl : l âˆˆ c) (x : l.domain) :\n    (LinearPMap.sSup c hc) âŸ¨x, (LinearPMap.le_sSup hc hl).1 x.2âŸ© = l x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The difference of 'a' and 'b' equals zero if and only if 'a' is less than or equal to 'b'.",
    "output": "theorem tsub_eq_zero_iff_le : a - b = 0 â†” a â‰¤ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The matrix representation of the identity linear map, when both the domain and codomain are the same vector space vâ‚, is the identity matrix.",
    "output": "theorem LinearMap.toMatrix_one : LinearMap.toMatrix vâ‚ vâ‚ 1 = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' and any element 'y' from set 'S', the mapping of 'f.mk' 'x' 'y' by 'f.map' 'hy' 'k' is equal to 'k.mk' of 'g' 'x' and the ordered pair consisting of 'g' 'y' and 'hy' 'y'.",
    "output": "theorem map_mk' (x) (y : S) : f.map hy k (f.mk' x y) = k.mk' (g x) âŸ¨g y, hy yâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is not equal to zero, then there exists a natural number n such that the inverse of 2 to the power of n is less than a.",
    "output": "theorem exists_inv_two_pow_lt (ha : a â‰  0) : âˆƒ n : â„•, 2â»Â¹ ^ n < a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any elements 'r' from ring 'R' and 's' from ring 'S', the application of the universal homomorphism to the quotient of 'r' and 's' is equal to the product of the image of 'r' under 'f' and the inverse of the image of 's' under 'fS' in the unit group of 'T'.",
    "output": "theorem universalHom_apply {r : R} {s : S} :\n    universalHom f fS hf (r /â‚’ s) = f r * ((fS s)â»Â¹ : Units T) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a ring Î± and a function f from Î± to Î±, given integers na, nb, nc and natural numbers da, db, dc, k, if f is the addition function, a is a rational number with numerator na and denominator da, b is a rational number with numerator nb and denominator db, the sum of the product of na and db and the product of nb and da is equal to the product of k and nc, and the product of da and db is equal to the product of k and dc, then the result of applying the function f to a and b is a rational number with numerator nc and denominator dc.",
    "output": "theorem isRat_add {Î±} [Ring Î±] {f : Î± â†’ Î± â†’ Î±} {a b : Î±} {na nb nc : â„¤} {da db dc k : â„•} :\n    f = HAdd.hAdd â†’ IsRat a na da â†’ IsRat b nb db â†’\n    Int.add (Int.mul na db) (Int.mul nb da) = Int.mul k nc â†’\n    Nat.mul da db = Nat.mul k dc â†’\n    IsRat (f a b) nc dc :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any complex number 'z' and any natural number 'n', the absolute value of 'z' raised to the power of 'n' is equal to the absolute value of 'z' raised to the power of 'n'.",
    "output": "theorem abs_pow (z : â„‚) (n : â„•) : Complex.abs (z ^ n) = Complex.abs z ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' in a topological group 'G' that is equipped with a right multiplication operation, the inverse of the right multiplication by 'x' is the same as the right multiplication by the inverse of 'x'.",
    "output": "theorem mulRight_symm [IsometricSMul Gáµáµ’áµ– G] (x : G) : (mulRight x).symm = mulRight xâ»Â¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' from set A and a polynomial 'p' from the ring of polynomials over R, the application of the function 'toFunLinear' on the tensor product of 'a' and 'p' is equal to the application of the function 'toFunBilinear' on 'a' and 'p'.",
    "output": "theorem toFunLinear_tmul_apply (a : A) (p : R[X]) :\n    toFunLinear R A (a âŠ—â‚œ[R] p) = toFunBilinear R A a p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a nonempty set 's' of ideals of a ring 'Î±', and 's' is a chain (meaning for any two elements in 's', one is less than or equal to the other), and every element 'p' in 's' is a prime ideal, then the infimum of 's' is also a prime ideal.",
    "output": "theorem sInf_isPrime_of_isChain {s : Set (Ideal Î±)} (hs : s.Nonempty) (hs' : IsChain (Â· â‰¤ Â·) s)\n    (H : âˆ€ p âˆˆ s, Ideal.IsPrime p) : (sInf s).IsPrime :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two continuous affine maps 'f' and 'g' from 'P' to 'Q' over a ring 'R', if for every 'x' in 'P', 'f' at 'x' equals 'g' at 'x', then 'f' equals 'g'.",
    "output": "theorem ext {f g : P â†’A[R] Q} (h : âˆ€ x, f x = g x) : f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two star subalgebras Sâ‚ and Sâ‚‚ of a ring R and an algebra B, and a star algebra homomorphism f from A to B, if Sâ‚ is a subset of or equal to Sâ‚‚, then the preimage of Sâ‚ under f is a subset of or equal to the preimage of Sâ‚‚ under f.",
    "output": "theorem comap_mono {Sâ‚ Sâ‚‚ : StarSubalgebra R B} {f : A â†’â‹†â‚[R] B} :\n    Sâ‚ â‰¤ Sâ‚‚ â†’ Sâ‚.comap f â‰¤ Sâ‚‚.comap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a symmetrized element 'a' of type 'Î±', 'a' being unequal to the unsymmetrized version of 1 is equivalent to 'a' being unequal to the symmetrized version of 1.",
    "output": "theorem unsym_ne_one_iff [One Î±] (a : Î±Ë¢Ê¸áµ) : unsym a â‰  (1 : Î±) â†” a â‰  (1 : Î±Ë¢Ê¸áµ) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two positive natural numbers 'm' and 'n', and any natural numbers 'k' and 'l', if 'm' and 'n' are coprime, then 'm' to the power of 'k' is also coprime with 'n' to the power of 'l'.",
    "output": "theorem Coprime.pow {m n : â„•+} (k l : â„•) (h : m.Coprime n) : (m ^ k).coprime (n ^ l) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function coeFn is injective when applied to homotopies between two paths pâ‚€ and pâ‚ in the topological space X. This means that if two homotopies produce the same output when coeFn is applied to them, then those two homotopies must have been the same to begin with.",
    "output": "theorem coeFn_injective : @Function.Injective (Homotopy pâ‚€ pâ‚) (I Ã— I â†’ X) (â‡‘) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If set s and set t in the topological space Î± are open, then their intersection is also an open set in Î±.",
    "output": "theorem IsOpen.inter (s t : Set Î±) : IsOpen Î± s â†’ IsOpen Î± t â†’ IsOpen Î± (s âˆ© t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a type Î¹ with a linear order, a filter 'f' on a set Î±, a filter 'g' on a set Î², a function 's' from Î¹ to the set of subsets of Î±, and a function 't' from Î¹ to the set of subsets of Î², and if 'f' has an antitone basis 's' and 'g' has an antitone basis 't', then the product filter of 'f' and 'g' has an antitone basis that is the product of the functions 's' and 't'.",
    "output": "theorem HasAntitoneBasis.prod {Î¹ : Type _} [LinearOrder Î¹] {f : Filter Î±} {g : Filter Î²}\n    {s : Î¹ â†’ Set Î±} {t : Î¹ â†’ Set Î²} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\n    HasAntitoneBasis (f Ã—Ë¢ g) fun n => s n Ã—Ë¢ t n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any multisets 's' and 't' and any element 'a', 's' with 'a' added is equal to 't' if and only if 'a' is an element of 't' and 's' is equal to 't' with 'a' removed.",
    "output": "theorem add_singleton_eq_iff {s t : Multiset Î±} {a : Î±} : s + {a} = t â†” a âˆˆ t âˆ§ s = t.erase a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a pullback 'p' of functions 'f' and 'g', the first component of the homomorphism of 'p' under the isomorphism 'pullbackIsoPullback f g' is equal to the first component of the pullback 'p' mapped to 'X' by 'pullback.fst'.",
    "output": "theorem pullbackIsoPullback_hom_fst (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X Ã— Y).fst = (pullback.fst : _ âŸ¶ X) p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given element 's' from the set 'Ïƒ' and any given element 'a' from the set 'R', the product of the constant 'a' and the variable 's' is equal to a monomial with 's' as the variable, '1' as the exponent, and 'a' as the coefficient.",
    "output": "theorem C_mul_X_eq_monomial {s : Ïƒ} {a : R} : C a * X s = monomial (Finsupp.single s 1) a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a covariant class Î± with respect to multiplication and less than or equal to relation, and another covariant class Î± with respect to the swapped multiplication and strictly less than relation, if a is less than b and c is less than d, then the product of a and c is less than the product of b and d.",
    "output": "theorem Right.mul_lt_mul [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]\n    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)] {a b c d : Î±}\n    (hâ‚ : a < b) (hâ‚‚ : c < d) :\n    a * c < b * d :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± that has a uniform space structure and is a complete space, the entire set of Î± is complete.",
    "output": "theorem complete_univ {Î± : Type u} [UniformSpace Î±] [CompleteSpace Î±] :\n    IsComplete (univ : Set Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list 'l' of elements of type 'Î±', if the reverse of 'l' is equal to 'l' itself, then 'l' is a palindrome.",
    "output": "theorem of_reverse_eq {l : List Î±} : reverse l = l â†’ Palindrome l :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' from 'Î±' to 'Î²' is not absolutely measurable with respect to a measure 'Î¼', then the measure of the image of 'f' under 'Î¼' is zero.",
    "output": "theorem map_of_not_aemeasurable {f : Î± â†’ Î²} {Î¼ : Measure Î±} (hf : Â¬AEMeasurable f Î¼) :\n    Î¼.map f = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' that takes a natural number and an element of type Î± and returns an element of type Î² in a monadic context, a starting natural number 'start', an element 'a' of type Î±, and a list 'as' of elements of type Î±, the specification of mapping 'f' over the indices and elements of the list starting from 'start' and consisting of 'a' followed by 'as' is equivalent to applying 'f' to 'start' and 'a', and then prepending this to the result of recursively applying the same mapping operation to the rest of the list, starting from the next index.",
    "output": "theorem mapIdxMAuxSpec_cons {Î± Î²} (f : â„• â†’ Î± â†’ m Î²) (start : â„•) (a : Î±) (as : List Î±) :\n    mapIdxMAuxSpec f start (a :: as) = cons <$> f start a <*> mapIdxMAuxSpec f (start + 1) as :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The absolute value of negative one raised to any natural number power is equal to one.",
    "output": "theorem abs_neg_one_pow (n : â„•) : |(-1 : R) ^ n| = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type 'Î±' and any list 'l' of type 'Î±', the encoding of the list that results from prepending 'a' to 'l' is equal to the successor of the pair of the encoding of 'a' and the encoding of 'l'.",
    "output": "theorem encode_list_cons (a : Î±) (l : List Î±) :\n    encode (a :: l) = succ (pair (encode a) (encode l)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î¹' to 'E' that is linearly independent, the norm of the Gram-Schmidt normalized function at 'n' is equal to 1.",
    "output": "theorem gramSchmidtNormed_unit_length {f : Î¹ â†’ E} (n : Î¹) (hâ‚€ : LinearIndependent ğ•œ f) :\n    â€–gramSchmidtNormed ğ•œ f nâ€– = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an isometry function 'h' from set Î± to set Î², and for any set 's' in Î², the extended metric diameter of the preimage of 's' under 'h' is equal to the extended metric diameter of 's'.",
    "output": "theorem ediam_preimage (h : Î± â‰ƒáµ¢ Î²) (s : Set Î²) : EMetric.diam (h â»Â¹' s) = EMetric.diam s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bijective function 'f', the inverse of 'f' (obtained through 'bijInv') is a right inverse of 'f'. This means that if you apply 'f' to an element and then apply the inverse, you get the original element back.",
    "output": "theorem rightInverse_bijInv (f_bij : Bijective f) : RightInverse (bijInv f_bij) f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product map of functions f and g is equal to the product of the composition of function f with the first element of the ordered pair (R, S) and the composition of function g with the second element of the ordered pair (R, S).",
    "output": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Set 's' is less than set 't' if and only if set 's' is a proper subset of set 't'.",
    "output": "theorem lt_iff_ssubset : s < t â†” s âŠ‚ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two filters 'f' and 'g' of types 'Î±' and 'Î²' respectively, the product of 'f' and 'g' is equal to the sequence of 'g' mapped by the product constructor 'Prod.mk' on 'f'.",
    "output": "theorem prod_eq {f : Filter Î±} {g : Filter Î²} : f Ã—Ë¢ g = (f.map Prod.mk).seq g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three types Yâ‚, Yâ‚‚, and Yâ‚ƒ, and any two functions g from Yâ‚‚ to Yâ‚ƒ and f from Yâ‚ to Yâ‚‚, the composition of the map of g and the map of f is equal to the map of the composition of g and f.",
    "output": "theorem map_comp {Yâ‚ Yâ‚‚ Yâ‚ƒ : Type _} (g : Yâ‚‚ â†’ Yâ‚ƒ) (f : Yâ‚ â†’ Yâ‚‚) :\n    @map X _ _ _ g âˆ˜ map f = map (g âˆ˜ f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given pseudometric space 'm' over a set 'Î±' with a uniform space 'U', if the uniformity of 'U' is equal to the uniformity of the pseudometric space converted to a uniform space, then replacing the uniformity of 'm' with 'H' (where 'H' is the condition that the uniformities are equal) results in the original pseudometric space 'm'.",
    "output": "theorem PseudoMetricSpace.replaceUniformity_eq {Î±} [U : UniformSpace Î±] (m : PseudoMetricSpace Î±)\n    (H : ğ“¤[U] = ğ“¤[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any property 'C' of an element 'x' in the ring of polynomials adjoined by a root 'f', if the property 'C' holds for all polynomials 'p' in the ring 'R[X]', then the property 'C' also holds for the element 'x'.",
    "output": "theorem induction_on {C : AdjoinRoot f â†’ Prop} (x : AdjoinRoot f) (ih : âˆ€ p : R[X], C (mk f p)) :\n    C x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two linear maps Ï† and Ïˆ from the direct sum of a family of modules M indexed by i to a module N over a ring R, if for every index i and element x in M, the value of Ï† applied to the singleton of i and x equals the value of Ïˆ applied to the same singleton, then Ï† and Ïˆ are equal.",
    "output": "theorem lhom_ext â¦ƒÏ† Ïˆ : (Î â‚€ i, M i) â†’â‚—[R] Nâ¦„ (h : âˆ€ i x, Ï† (single i x) = Ïˆ (single i x)) : Ï† = Ïˆ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' has a strict Frechet derivative at a point 'a', then the local inverse of 'f' at 'a' also has a strict Frechet derivative at the point 'f(a)', with the derivative being the inverse of the derivative of 'f'.",
    "output": "theorem to_localInverse (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    HasStrictFDerivAt (hf.localInverse f f' a) (f'.symm : F â†’L[ğ•œ] E) (f a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the function pair (f, g) is anti-variant on a set s, then the function pair (g, f) is also anti-variant on the same set s.",
    "output": "theorem AntivaryOn.symm (h : AntivaryOn f g s) : AntivaryOn g f s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A completion of a set Î± is nonempty if and only if the set Î± itself is nonempty.",
    "output": "theorem nonempty_completion_iff : Nonempty (Completion Î±) â†” Nonempty Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'l' and three functions 'f', 'g', and 'h' that map from 'Î±' to 'Î²', if 'f' is eventually equal to 'g' at 'l' and 'g' is eventually equal to 'h' at 'l', then 'f' is eventually equal to 'h' at 'l'. This is a transitivity property for eventual equality.",
    "output": "theorem EventuallyEq.trans {l : Filter Î±} {f g h : Î± â†’ Î²} (Hâ‚ : f =á¶ [l] g) (Hâ‚‚ : g =á¶ [l] h) :\n    f =á¶ [l] h :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given order-isomorphism 'f' between two relations 'r' and 's', the function obtained by converting 'f' to a relation-embedding and then treating it as a function from 'Î±' to 'Î²' is the same as the original order-isomorphism 'f'.",
    "output": "theorem coe_toRelEmbedding (f : r â‰ƒr s) : (f.toRelEmbedding : Î± â†’ Î²) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the inner product of vectors x and y equals zero, then the angle between vector x and the vector resulting from subtracting y from x is equal to the inverse cosine of the ratio of the norm of x to the norm of the vector resulting from subtracting y from x.",
    "output": "theorem angle_sub_eq_arccos_of_inner_eq_zero {x y : V} (h : âŸªx, yâŸ« = 0) :\n    angle x (x - y) = Real.arccos (â€–xâ€– / â€–x - yâ€–) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any submonoid 's' of 'M' and any submonoid 't' of 'N', the set of the product of 's' and 't' is equal to the Cartesian product of the set of 's' and the set of 't'.",
    "output": "theorem coe_prod (s : Submonoid M) (t : Submonoid N) :\n    (s.prod t : Set (M Ã— N)) = (s : Set M) Ã—Ë¢ (t : Set N) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a left inverse function 'f'' on function 'f' over set 's', and set 'sâ‚' is a subset of 's', then 'f'' is also a left inverse function on 'f' over set 'sâ‚'. This is a property of function monotonicity.",
    "output": "theorem LeftInvOn.mono (hf : LeftInvOn f' f s) (ht : sâ‚ âŠ† s) : LeftInvOn f' f sâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' is null measurable with respect to a measure 'Î¼', then the fundamental interior of the set 's' with respect to a group 'G' is also null measurable with respect to the same measure 'Î¼'.",
    "output": "theorem NullMeasurableSet.fundamentalInterior (hs : NullMeasurableSet s Î¼) :\n    NullMeasurableSet (fundamentalInterior G s) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function 'f' from the direct sum over 'i' of 'Î² i', the function 'Ïˆ' applied to 'f' is equal to the function 'toAddMonoid' applied to the composition of 'Ïˆ' and 'of Î² i' for each 'i', and then applied to 'f'. This uniqueness property holds in the context of additive monoids.",
    "output": "theorem toAddMonoid.unique (f : â¨ i, Î² i) : Ïˆ f = toAddMonoid (fun i => Ïˆ.comp (of Î² i)) f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The constant coefficient of the Witt subtraction function at a given natural number 'n' is equal to zero.",
    "output": "theorem constantCoeff_wittSub (n : â„•) : constantCoeff (wittSub p n) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three multisets s, t, and u, the sum of s and t is less than or equal to the sum of s and u if and only if t is less than or equal to u.",
    "output": "theorem add_le_add_iff_left' {s t u : Multiset Î±} : s + t â‰¤ s + u â†” t â‰¤ u :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a convex set 's' in a topological vector space 'E', if 'x' is in the closure of 's' and 'y' is in the interior of 's', then for any non-negative scalar 'a' and positive scalar 'b' such that 'a + b = 1', the convex combination 'a â€¢ x + b â€¢ y' is in the interior of 's'.",
    "output": "theorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex ğ•œ s) {x y : E}\n    (hx : x âˆˆ closure s) (hy : y âˆˆ interior s) {a b : ğ•œ} (ha : 0 â‰¤ a) (hb : 0 < b)\n    (hab : a + b = 1) : a â€¢ x + b â€¢ y âˆˆ interior s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have two functions 'f' mapping from Î± to Î² and 'g' mapping from Î³ to Î±, and if 'f' is continuous at the greatest lower bound of the range of 'g' and 'f' is an antitone function (a function that preserves the order in the opposite direction), and the range of 'g' has a lower bound, then the value of 'f' at the greatest lower bound of the range of 'g' is equal to the least upper bound of the range of 'f' composed with 'g'.",
    "output": "theorem Antitone.map_ciInf_of_continuousAt {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : ContinuousAt f (â¨… i, g i))\n    (Af : Antitone f) (H : BddBelow (range g)) : f (â¨… i, g i) = â¨† i, f (g i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a complex-valued function 'f', a complex number 'c', and real numbers 'R' and 'C' where 'R' is positive, if the function 'f' is continuous on the sphere with center 'c' and radius 'R', and the norm of 'f' at any point 'z' on the sphere is less than or equal to 'C', and there exists a point 'z' on the sphere where the norm of 'f' is less than 'C', then the norm of the contour integral of 'f' over the circle with center 'c' and radius 'R' is less than 2 times pi times 'R' times 'C'.",
    "output": "theorem norm_integral_lt_of_norm_le_const_of_lt {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R)\n    (hc : ContinuousOn f (sphere c R)) (hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C)\n    (hlt : âˆƒ z âˆˆ sphere c R, â€–f zâ€– < C) : â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of an antisymmetric relation (Â· âŠ† Â·) on a set Î±, if a is a subset of b and a is not equal to b, then a is a proper subset of b.",
    "output": "theorem ssubset_of_subset_of_ne [IsAntisymm Î± (Â· âŠ† Â·)] (hâ‚ : a âŠ† b) (hâ‚‚ : a â‰  b) : a âŠ‚ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The intersection over a set S union the intersection over a set T is equal to the intersection of the union of each pair of sets in the Cartesian product of S and T. Here, each pair of sets is a member of the Cartesian product of S and T, and is a pair of sets of elements of type Î±.",
    "output": "theorem sInter_union_sInter {S T : Set (Set Î±)} :\n    â‹‚â‚€ S âˆª â‹‚â‚€ T = â‹‚ p âˆˆ S Ã—Ë¢ T, (p : Set Î± Ã— Set Î±).1 âˆª p.2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The coefficient of the zeroth term in a multivariate polynomial (with variables Ïƒ and coefficients in the ring R) that equals one, is one.",
    "output": "theorem coeff_zero_one : coeff 0 (1 : MvPolynomial Ïƒ R) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given elements 'a' from set Î“ and 'r' from set R, the singleton of 'a' and 'r' equals zero if and only if 'r' equals zero.",
    "output": "theorem single_eq_zero_iff {a : Î“} {r : R} : single a r = 0 â†” r = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functors G from category C to category D, and F from category D to category E, whiskering on the right with the identity natural transformation on G and functor F is equal to the identity natural transformation on the composition of functors G and F.",
    "output": "theorem whiskerRight_id' {G : C â¥¤ D} (F : D â¥¤ E) : whiskerRight (ğŸ™ G) F = ğŸ™ (G.comp F) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any complex number z, the absolute value of the ratio of its imaginary part to its absolute value is less than or equal to one.",
    "output": "theorem abs_im_div_abs_le_one (z : â„‚) : |z.im / Complex.abs z| â‰¤ 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three objects 'a', 'b', and 'c' in a bicategory 'B', any path 'p' from 'a' to 'b', and any two morphisms 'f' and 'g' from 'b' to 'c' with a 2-morphism 'Î·' from 'f' to 'g', the left whiskering of the map of the preinclusion of 'B' with respect to the pair 'p' and 'Î·', followed by the homomorphism of the normalization isomorphism of 'p' and 'g', is equal to the homomorphism of the normalization isomorphism of 'p' and 'f', followed by the second map of the preinclusion of 'B' with respect to the homomorphism from the equality to the homomorphism (which is determined by the extension of the discrete category with respect to the congruence of the normalization auxiliary function of 'p' and 'Î·').",
    "output": "theorem normalize_naturality {a b c : B} (p : Path a b) {f g : Hom b c} (Î· : f âŸ¶ g) :\n    (preinclusion B).map âŸ¨pâŸ© â— Î· â‰« (normalizeIso p g).hom =\n      (normalizeIso p f).hom â‰«\n        (preinclusion B).mapâ‚‚ (eqToHom (Discrete.ext _ _ (normalizeAux_congr p Î·))) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is less than 'b', then 'b' is the greatest element in the interval that is open on 'a' and closed on 'b'.",
    "output": "theorem isGreatest_Ioc (h : a < b) : IsGreatest (Ioc a b) b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any nonempty set n, the determinant of a zero matrix of size n by n with elements from set R is zero.",
    "output": "theorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A module M over a ring R is Artinian if and only if the relation \"less than\" on the set of submodules of M is well-founded.",
    "output": "theorem isArtinian_iff_wellFounded :\n    IsArtinian R M â†” WellFounded ((Â· < Â·) : Submodule R M â†’ Submodule R M â†’ Prop) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a unit 'a' in ring 'R', 'a' is a multiplication-regular element in the monoid 'M'.",
    "output": "theorem Units.isSMulRegular (a : RË£) : IsSMulRegular M (a : R) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any finite type Î¹, any ordered ring R, and any module Máµ¢ over R for each i, and any quadratic form Q on each Máµ¢, the function pi applied to Q is nonnegative for all x if and only if Q is nonnegative for all i and x.",
    "output": "theorem nonneg_pi_iff [Fintype Î¹] {R} [OrderedRing R] [âˆ€ i, Module R (Máµ¢ i)]\n    {Q : âˆ€ i, QuadraticForm R (Máµ¢ i)} : (âˆ€ x, 0 â‰¤ pi Q x) â†” âˆ€ i x, 0 â‰¤ Q i x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a homeomorphism 'h' from a topological space 'Î±' to another topological space 'Î²', and a set 's' in 'Î²', the preimage of the interior of 's' under 'h' is equal to the interior of the preimage of 's' under 'h'.",
    "output": "theorem preimage_interior (h : Î± â‰ƒâ‚œ Î²) (s : Set Î²) : h â»Â¹' interior s = interior (h â»Â¹' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'f' and 'g' from type 'Î±' to type 'Î²', if 'f' is equal to 'g', and for any element 'a' of type 'Î±', the congruence of 'h' (which is the equality of 'f' and 'g') and the reflexivity of 'a' is equal to the congruence function of 'h' and 'a'.",
    "output": "theorem congr_refl_right {f g : Î± â†’ Î²} (h : f = g) (a : Î±) :\n    congr h (Eq.refl a) = congr_fun h a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given a field ğ•œ with characteristic zero, a ring R, an additive commutative group M, and the algebraic, module, and scalar tower structures between them, along with the topological structures on R and M and the continuity of scalar multiplication, if we have an element x of the twisted square zero extension of R by M such that the scalar multiplication of the opposite of the first component of x and the second component of x equals the scalar multiplication of the first component of x and the second component of x, and if the sum of the exponential series of the first component of x converges to e, then the sum of the exponential series of x converges to the sum of e and the scalar multiplication of e and the second component of x.",
    "output": "theorem hasSum_expSeries_of_smul_comm [Field ğ•œ] [CharZero ğ•œ] [Ring R] [AddCommGroup M] [Algebra ğ•œ R]\n    [Module R M] [Module Ráµáµ’áµ– M] [SMulCommClass R Ráµáµ’áµ– M] [Module ğ•œ M] [IsScalarTower ğ•œ R M]\n    [IsScalarTower ğ•œ Ráµáµ’áµ– M] [TopologicalRing R] [TopologicalAddGroup M] [ContinuousSMul R M]\n    [ContinuousSMul Ráµáµ’áµ– M] (x : tsze R M) (hx : MulOpposite.op x.fst â€¢ x.snd = x.fst â€¢ x.snd)\n    {e : R} (h : HasSum (fun n => expSeries ğ•œ R n fun _ => x.fst) e) :\n    HasSum (fun n => expSeries ğ•œ (tsze R M) n fun _ => x) (inl e + inr (e â€¢ x.snd)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'f' is less than or equal to 'g' if and only if for all 'i' in the support of 'f', the value of 'f' at 'i' is less than or equal to the value of 'g' at 'i'.",
    "output": "theorem le_iff : f â‰¤ g â†” âˆ€ i âˆˆ f.support, f i â‰¤ g i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three types X, Y, and Z, the composition of a morphism from X to Y and a morphism from Y to Z is equal to the function composition of the second morphism after the first.",
    "output": "theorem types_comp {X Y Z : Type u} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : f â‰« g = g âˆ˜ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of a subset 'S' and any natural number 'n', the coercion of 'x' to the power of 'n' into a superset 'A' is equal to the coercion of 'x' into 'A' raised to the power of 'n'.",
    "output": "theorem coe_pow (x : S) (n : â„•) : (â†‘(x ^ n) : A) = (x : A) ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a matrix A is Hermitian, then any submatrix of A, obtained by a function f from m to n, is also Hermitian.",
    "output": "theorem IsHermitian.submatrix {A : Matrix n n Î±} (h : A.IsHermitian) (f : m â†’ n) :\n    (A.submatrix f f).IsHermitian :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given point 'x' in set 'X', the set of indices 'i' for which the function 'f' applied to 'i' and 'x' is not equal to zero, is finite.",
    "output": "theorem point_finite (x : X) : { i | f i x â‰  0 }.Finite :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given natural number 'p', a function 'f' from 'Ïƒ' to multivariate polynomials over 'Ï„' and 'R', and a multivariate polynomial 'Ï†' over 'Ïƒ' and 'R', expanding 'p' times the result of binding 'f' to 'Ï†' is equal to binding the function that maps 'i' to the result of expanding 'p' times 'f(i)' to 'Ï†'.",
    "output": "theorem expand_bindâ‚ (p : â„•) (f : Ïƒ â†’ MvPolynomial Ï„ R) (Ï† : MvPolynomial Ïƒ R) :\n    expand p (bindâ‚ f Ï†) = bindâ‚ (fun i â†¦ expand p (f i)) Ï† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the set of elements 'a' that satisfy the property 'p' is closed, then the function that maps each subtype 'p' to an element in 'Î±' is a closed embedding.",
    "output": "theorem closedEmbedding_subtype_val (h : IsClosed { a | p a }) :\n    ClosedEmbedding ((â†‘) : Subtype p â†’ Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' that takes a pair of elements from sets 'Î±' and 'Î²' and maps to a set 'Î³', and for any elements 'x' from 'Î±' and 'y' from 'Î²', applying the curried version of 'f' to 'x' and 'y' is the same as applying 'f' to the pair '(x, y)'.",
    "output": "theorem curry_apply {Î± Î² Î³} (f : Î± Ã— Î² â†’ Î³) (x : Î±) (y : Î²) : curry f x y = f (x, y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is strictly decreasing (StrictAnti f) and 'a' is the minimum value of the function (IsMin (f a)), then 'a' is the maximum value of the input (IsMax a).",
    "output": "theorem StrictAnti.isMax_of_apply (hf : StrictAnti f) (ha : IsMin (f a)) : IsMax a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two objects A and B in a category C that has binary coproducts, given a binary cofan c and assuming that c is a colimit, the morphism 'inr' of the cofan c is a monomorphism.",
    "output": "theorem binaryCofan_inr {A B : C} [MonoCoprod C] (c : BinaryCofan A B) (hc : IsColimit c) :\n    Mono c.inr :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of the product of a constant and a sequence (for each term in the sequence) is equal to the product of the constant and the sum of the sequence.",
    "output": "theorem tsum_mul_left : (âˆ‘' i, a * f i) = a * âˆ‘' i, f i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three objects X, Y, Z and their isomorphic counterparts Xâ‚, Yâ‚, Zâ‚ in a category C, and for any morphisms f from X to Y and g from Y to Z, the composition of the morphisms f and g, when congruent with the isomorphisms Î± and Î³, is equal to the composition of the morphisms f congruent with the isomorphisms Î± and Î², and g congruent with the isomorphisms Î² and Î³.",
    "output": "theorem homCongr_comp {X Y Z Xâ‚ Yâ‚ Zâ‚ : C} (Î± : X â‰… Xâ‚) (Î² : Y â‰… Yâ‚) (Î³ : Z â‰… Zâ‚) (f : X âŸ¶ Y)\n    (g : Y âŸ¶ Z) : Î±.homCongr Î³ (f â‰« g) = Î±.homCongr Î² f â‰« Î².homCongr Î³ g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"X\" is not a unit in the ring of polynomials over \"R\".",
    "output": "theorem not_isUnit_X : Â¬IsUnit (X : R[X]) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A point 'a' is in the interior of a set 's' if and only if the set 's' is in the neighborhood of the point 'a'.",
    "output": "theorem mem_interior_iff_mem_nhds {s : Set Î±} {a : Î±} : a âˆˆ interior s â†” s âˆˆ ğ“ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any multiset 't' and any two functions 'fâ‚' and 'fâ‚‚' from 'Î¹' to the set of 'Î±', if for every element 'i' in 't', the image of 'i' under 'fâ‚' is a subset of the image of 'i' under 'fâ‚‚', then the product of the multiset 't' mapped by 'fâ‚' is a subset of the product of the multiset 't' mapped by 'fâ‚‚'.",
    "output": "theorem multiset_prod_subset_multiset_prod (t : Multiset Î¹) (fâ‚ fâ‚‚ : Î¹ â†’ Set Î±)\n    (hf : âˆ€ i âˆˆ t, fâ‚ i âŠ† fâ‚‚ i) : (t.map fâ‚).prod âŠ† (t.map fâ‚‚).prod :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' is an open map, then for any set 's' in the neighborhood of 'x', the image of 's' under 'f' is in the neighborhood of 'f(x)'.",
    "output": "theorem image_mem_nhds (hf : IsOpenMap f) {x : Î±} {s : Set Î±} (hx : s âˆˆ ğ“ x) : f '' s âˆˆ ğ“ (f x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of a nonempty interval of any type Î±, when set to 1, equals 1.",
    "output": "theorem toProd_one : (1 : NonemptyInterval Î±).toProd = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a multiset 's' of functions from 'Î±' to 'M', and every function in 's' is strongly measurable, then the function that maps 'x' to the product of the multiset 's' mapped with the function 'f' from 'Î±' to 'M' at 'x', is also strongly measurable.",
    "output": "theorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (Î± â†’ M))\n    (hs : âˆ€ f âˆˆ s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : Î± â†’ M => f x).prod :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is nonempty if and only if there exists an element 'x' that belongs to the set 's'.",
    "output": "theorem nonempty_def : s.Nonempty â†” âˆƒ x, x âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'F' and a constant 'c' from the field 'ğ•œ', if 'q' is greater than 0, then the seminorm of 'c' times 'f' with respect to 'q' and measure 'Î¼' is equal to the absolute value of 'c' times the seminorm of 'f' with respect to 'q' and measure 'Î¼'.",
    "output": "theorem snorm'_const_smul {f : Î± â†’ F} (c : ğ•œ) (hq_pos : 0 < q) :\n    snorm' (c â€¢ f) q Î¼ = â€–câ€–â‚Š â€¢ snorm' f q Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a submultiplicative action 'p' of a ring 'R' on a module 'M', and a set 's' of elements from 'M' such that 's' is equal to the underlying set of 'p', the copy of 'p' with set 's' and proof 'hs' is equal to 'p'.",
    "output": "theorem copy_eq (p : SubMulAction R M) (s : Set M) (hs : s = â†‘p) : p.copy s hs = p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of all points x, for which the property p holds eventually in the neighborhood of x, is an open set.",
    "output": "theorem isOpen_setOf_eventually_nhds {p : Î± â†’ Prop} : IsOpen { x | âˆ€á¶  y in ğ“ x, p y } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type 'Î±' that is empty, and for any binary relation 'r' on 'Î±', 'r' is well-founded.",
    "output": "theorem wellFounded_of_isEmpty {Î±} [IsEmpty Î±] (r : Î± â†’ Î± â†’ Prop) : WellFounded r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types ğ’œ and â„¬, given that they are both categories and preadditive, and given a functor F from ğ’œ to â„¬ that is additive, and objects A, B, C in ğ’œ, and morphisms f from A to B and g from B to C that form a split sequence, then the sequence formed by the images of f and g under the functor F is also a split sequence.",
    "output": "theorem Split.map {ğ’œ â„¬ : Type _} [Category ğ’œ] [Preadditive ğ’œ] [Category â„¬] [Preadditive â„¬]\n    (F : ğ’œ â¥¤ â„¬) [Functor.Additive F] {A B C : ğ’œ} {f : A âŸ¶ B} {g : B âŸ¶ C} (h : Split f g) :\n    Split (F.map f) (F.map g) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cotangent of I is a singleton if and only if I is an idempotent element.",
    "output": "theorem cotangent_subsingleton_iff : Subsingleton I.Cotangent â†” IsIdempotentElem I :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a list of permutations, if every permutation in the list is a swap, then the sign of the product of the list is equal to negative one raised to the power of the length of the list.",
    "output": "theorem sign_prod_list_swap {l : List (Perm Î±)} (hl : âˆ€ g âˆˆ l, IsSwap g) :\n    sign l.prod = (-1) ^ l.length :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given element 'a' of type 'Î±', the cardinality (or size) of the set of elements less than 'a' is equal to the cardinality of the set of elements less than or equal to 'a' minus one.",
    "output": "theorem card_Iio_eq_card_Iic_sub_one (a : Î±) : (Iio a).card = (Iic a).card - 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nontrivial field B, given a polynomial p over A, if p is irreducible, the algebraic evaluation of p at x equals zero, and p is monic, then p is equal to the minimal polynomial of x over A.",
    "output": "theorem eq_of_irreducible_of_monic [Nontrivial B] {p : A[X]} (hp1 : Irreducible p)\n    (hp2 : Polynomial.aeval x p = 0) (hp3 : p.Monic) : p = minpoly A x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bilinear map 'f' from 'Mâ‚—' to 'Nâ‚—' to 'Pâ‚—', and two linear maps 'g' from 'Qâ‚—' to 'Mâ‚—' and 'g'' from 'Qâ‚—'' to 'Nâ‚—', for any elements 'x' in 'Qâ‚—' and 'y' in 'Qâ‚—'', the application of the composition of 'f' with 'g' and 'g'' to 'x' and 'y' is equal to the application of 'f' to the images of 'x' and 'y' under 'g' and 'g'' respectively.",
    "output": "theorem complâ‚â‚‚_apply (f : Mâ‚— â†’â‚—[R] Nâ‚— â†’â‚—[R] Pâ‚—) (g : Qâ‚— â†’â‚—[R] Mâ‚—) (g' : Qâ‚—' â†’â‚—[R] Nâ‚—) (x : Qâ‚—)\n    (y : Qâ‚—') : f.complâ‚â‚‚ g g' x y = f (g x) (g' y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two real numbers 'a' and 'b' where 'a' is less than 'b', the cardinality of the open interval between 'a' and 'b' is equal to the cardinality of the continuum.",
    "output": "theorem mk_Ioo_real {a b : â„} (h : a < b) : (#Ioo a b) = ğ”  :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If I and J are ideals of a ring A and they are coprime (their supremum is the whole ring), then their infimum is equal to their product.",
    "output": "theorem inf_eq_mul_of_coprime {I J : Ideal A} (coprime : I âŠ” J = âŠ¤) : I âŠ“ J = I * J :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every index 'i', 'f i' is an upper set, then the union over all 'i' of 'f i' is also an upper set.",
    "output": "theorem isUpperSet_iUnion {f : Î¹ â†’ Set Î±} (hf : âˆ€ i, IsUpperSet (f i)) : IsUpperSet (â‹ƒ i, f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any positive compact subset 'K' of a group 'G' and any set 'V' in 'G' such that the interior of 'V' is nonempty, the index of 'K' in 'V' is greater than zero.",
    "output": "theorem index_pos (K : PositiveCompacts G) {V : Set G} (hV : (interior V).Nonempty) :\n    0 < index (K : Set G) V :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nonzero element 'x' from a normed vector space 'E' and any scalar 'c' from the field 'ğ•œ', the coordinate of the scaled vector 'c' times 'x' in the direction of 'x' is equal to 'c'.",
    "output": "theorem coord_toSpanNonzeroSingleton {x : E} (h : x â‰  0) (c : ğ•œ) :\n    coord ğ•œ x h (toSpanNonzeroSingleton ğ•œ x h c) = c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of 'a' and 'b' equals the maximum possible value if and only if either 'a' or 'b' equals the maximum possible value.",
    "output": "theorem add_eq_top : a + b = âŠ¤ â†” a = âŠ¤ âˆ¨ b = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a spectral map 'f' from Î² to Î³ and a spectral map 'g' from Î± to Î², the composition of 'f' and 'g' as a continuous map from Î± to Î³ is equal to the composition of 'f' as a continuous map from Î² to Î³ and 'g'.",
    "output": "theorem coe_comp_continuousMap' (f : SpectralMap Î² Î³) (g : SpectralMap Î± Î²) :\n    (f.comp g : ContinuousMap Î± Î³) = (f : ContinuousMap Î² Î³).comp g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given algebra homomorphism 'f' from algebra 'A' to algebra 'B', there exists a Galois connection between the map of 'f' and the comap of 'f'.",
    "output": "theorem gc_map_comap (f : A â†’â‚[R] B) : GaloisConnection (map f) (comap f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The right value of 'x' being 'none' is equivalent to 'x' being a left value.",
    "output": "theorem getRight_eq_none_iff : x.getRight = none â†” x.isLeft :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any multivariate polynomial 'p' over a ring 'R' and a variable 's' from a set 'Ïƒ', the coefficient of the term in 'p' multiplied by the variable 's' (represented by 'X s * p') with a monomial 'm' incremented by one in the 's' dimension (represented by 'Finsupp.single s 1 + m') is equal to the coefficient of the term in 'p' with the monomial 'm'.",
    "output": "theorem coeff_X_mul (m) (s : Ïƒ) (p : MvPolynomial Ïƒ R) :\n    coeff (Finsupp.single s 1 + m) (X s * p) = coeff m p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'g' mapping from 'M' to 'N' such that 'g' of 1 equals 1, and another function 'f' mapping from 'Î±' to 'M', the multiplicative support of the composition of 'g' and 'f' is a subset of the multiplicative support of 'f'.",
    "output": "theorem mulSupport_comp_subset {g : M â†’ N} (hg : g 1 = 1) (f : Î± â†’ M) :\n    mulSupport (g âˆ˜ f) âŠ† mulSupport f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²', a constant 'c', and an element 'a' of 'Î±', lifting the function 'f' over the equivalence class of 'a' (denoted by 'mk a') is equal to the function 'f' applied to 'a'.",
    "output": "theorem lift_mk (f : Î± â†’ Î²) (c) (a : Î±) : lift f c (mk a) = f a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The bottom element of the finset (finite set) of any type Î± is equal to the empty set.",
    "output": "theorem bot_eq_empty : (âŠ¥ : Finset Î±) = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'a' belongs to the filtered list 'l' (filtered by some property 'p'), then 'a' also belongs to the original list 'l'.",
    "output": "theorem mem_of_mem_filter {a : Î±} {l} (h : a âˆˆ filter p l) : a âˆˆ l :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three integers a, b, and c, if they satisfy Fermat's 4-dimensional equation, then c cannot be equal to zero.",
    "output": "theorem ne_zero {a b c : â„¤} (h : Fermat42 a b c) : c â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A natural number 'n' equals one if and only if there does not exist a prime number 'p' that divides 'n'.",
    "output": "theorem eq_one_iff_not_exists_prime_dvd {n : â„•} : n = 1 â†” âˆ€ p : â„•, p.Prime â†’ Â¬p âˆ£ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "11 divides a natural number 'n' if and only if 11, as an integer, divides the alternating sum of the digits of 'n' when 'n' is expressed in base 10.",
    "output": "theorem eleven_dvd_iff :\n    11 âˆ£ n â†” (11 : â„¤) âˆ£ ((digits 10 n).map fun n : â„• => (n : â„¤)).alternatingSum :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A hyperreal number 'x' is infinitely negative if and only if 'x' is less than any real number 'r'.",
    "output": "theorem infiniteNeg_def {x : â„*} : InfiniteNeg x â†” âˆ€ r : â„, x < r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a local homeomorphism 'e' from type Î± to Î², given a set 's' of type Î² and an element 'x' from the source of 'e', the mapping of 'e' on the neighborhood within the preimage of 's' at 'x' is equal to the neighborhood within 's' at the image of 'x' under 'e'.",
    "output": "theorem map_nhdsWithin_preimage_eq (e : LocalHomeomorph Î± Î²) {x} (hx : x âˆˆ e.source) (s : Set Î²) :\n    map e (ğ“[e â»Â¹' s] x) = ğ“[s] e x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The denominator of 1, when considered as an element of the set NumDenSameDeg ğ’œ x, is equal to 1 in the algebra A.",
    "output": "theorem den_one : ((1 : NumDenSameDeg ğ’œ x).den : A) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any types 'Î²' and 'Î³', any element 'x' of type 'Î³', any natural number 'n', and any type vector 'Î±' of length 'n', the type vector constant function applied to 'x' and the appended type vector of 'Î±' and 'Î²' is equal to the function that appends the type vector constant function applied to 'x' and 'Î±' with the function that maps any element to 'x'.",
    "output": "theorem const_append1 {Î² Î³} (x : Î³) {n} (Î± : TypeVec n) :\n    TypeVec.const x (Î± ::: Î²) = appendFun (TypeVec.const x Î±) fun _ => x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a polynomial 'p' and a real number 'a', the root multiplicity of 'a' in 'p' is equal to the multiplicity of 'X - C a' in 'p'. However, if 'p' equals zero, then the root multiplicity is also zero. This is guaranteed by the condition that the multiplicity of 'X - C a' in 'p' is finite.",
    "output": "theorem rootMultiplicity_eq_multiplicity (p : R[X]) (a : R) :\n    rootMultiplicity a p =\n      if h0 : p = 0 then 0 else (multiplicity (X - C a) p).get (multiplicity_X_sub_C_finite a h0) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given matrices M and N, where M is a matrix of size m by n and N is a matrix of size n by l, both with elements from a non-unital semiring that is also a star ring, the conjugate transpose of the product of M and N is equal to the product of the conjugate transpose of N and the conjugate transpose of M.",
    "output": "theorem conjTranspose_mul [Fintype n] [NonUnitalSemiring Î±] [StarRing Î±] (M : Matrix m n Î±)\n    (N : Matrix n l Î±) : (M â¬ N)á´´ = Ná´´ â¬ Má´´ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of a Boolean algebra, if a set 's' is an antichain with respect to the less than or equal to relation, then the complement of 's' is also an antichain with respect to the same relation.",
    "output": "theorem image_compl [BooleanAlgebra Î±] (hs : IsAntichain (Â· â‰¤ Â·) s) :\n    IsAntichain (Â· â‰¤ Â·) (compl '' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The derivative of a monomial with coefficient 'a' and degree 'n' is equal to a monomial with degree 'n - 1' and coefficient 'a * n'.",
    "output": "theorem derivative_monomial (a : R) (n : â„•) :\n    derivative (monomial n a) = monomial (n - 1) (a * n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The difference of two rational functions 'f' and 'g' over a field 'F', when considered as a Laurent series over 'F', is equal to the difference of 'f' and 'g'.",
    "output": "theorem coe_sub : ((f - g : RatFunc F) : LaurentSeries F) = f - g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object 'n' in 'M' and any object 'X' in 'C', the composition of the map of 'F.obj n' applied to 'F.Îµ.app X', the application of 'F.Î¼ (ğŸ™_ M) n' to 'X', and the application of 'F.map (Î»_ n).hom' to 'X' is equal to the identity.",
    "output": "theorem left_unitality_app (n : M) (X : C) :\n    (F.obj n).map (F.Îµ.app X) â‰« (F.Î¼ (ğŸ™_ M) n).app X â‰« (F.map (Î»_ n).hom).app X = ğŸ™ _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' of type 'Î±' and an option 'o' of type 'Î±', 'a' is in the finite set derived from 'o' if and only if 'a' is in 'o'.",
    "output": "theorem mem_toFinset {a : Î±} {o : Option Î±} : a âˆˆ o.toFinset â†” a âˆˆ o :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of a function over a finite set is equal to the supremum of the function over that set if and only if for all distinct elements in the set, the multisets generated by the function on these elements are disjoint.",
    "output": "theorem finset_sum_eq_sup_iff_disjoint {Î² : Type _} {i : Finset Î²} {f : Î² â†’ Multiset Î±} :\n    i.sum f = i.sup f â†”\n      âˆ€ (x) (_ : x âˆˆ i) (y) (_ : y âˆˆ i), x â‰  y â†’ Multiset.Disjoint (f x) (f y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer 'n' and any natural numbers 'k' and 'p', if 'p' is a prime number and 'p' divides 'n' raised to the power of 'k', then 'p' also divides 'n'.",
    "output": "theorem Int.Prime.dvd_pow' {n : â„¤} {k p : â„•} (hp : Nat.Prime p) (h : (p : â„¤) âˆ£ n ^ k) :\n    (p : â„¤) âˆ£ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the co-domain of a function mapped by another function is not the least element (or bottom element), then the original function's co-domain is also not the least element.",
    "output": "theorem neBot_of_comap (h : (comap m g).NeBot) : g.NeBot :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-zero element 'a' of 'A', the inverse of the image of 'a' under the function 'Ïƒ' is equal to the image of the inverse of 'a' under the function 'Ïƒ'.",
    "output": "theorem map_inv (a : AË£) : (Ïƒ (a : A))â»Â¹ = Ïƒ (â†‘aâ»Â¹ : A) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The square of the norm of zero in field K is equal to zero.",
    "output": "theorem normSq_zero : normSq (0 : K) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 't' is a pushout cocone of 'f' and 'g', and 't' is a colimit, then if 'f' is an epimorphism, 't.inr' is also an epimorphism.",
    "output": "theorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] :\n    Epi t.inr :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of two numbers is odd if and only if both numbers are odd.",
    "output": "theorem odd_mul : Odd (m * n) â†” Odd m âˆ§ Odd n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a type Î±, which is a commutative group and a linear order, and for which the multiplication operation is covariant with the less than or equal to relation, the fraction a divided by b is less than or equal to the fraction b divided by a if and only if a is less than or equal to b.",
    "output": "theorem div_le_div_flip {Î± : Type _} [CommGroup Î±] [LinearOrder Î±]\n    [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] {a b : Î±} : a / b â‰¤ b / a â†” a â‰¤ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Applying the function 'toOuterMeasure' to a singleton set containing an element 'a' is equal to applying the function 'p' to the element 'a'.",
    "output": "theorem toOuterMeasure_apply_singleton (a : Î±) : p.toOuterMeasure {a} = p a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given property 'p' of an element 'Î±', and a given set 's' of elements 'x' that satisfy the property 'p', if an element 'a' does not satisfy the property 'p', then 'a' is not an element of the set 's' after it has been mapped using the subtype embedding.",
    "output": "theorem not_mem_map_subtype_of_not_property {p : Î± â†’ Prop} (s : Finset { x // p x }) {a : Î±}\n    (h : Â¬p a) : a âˆ‰ s.map (Embedding.subtype _) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f has a strict derivative f' at a point x, and a function g has a strict derivative g' at the same point x, then the function that is the difference of f and g has a strict derivative equal to the difference of f' and g' at the point x.",
    "output": "theorem HasStrictDerivAt.sub (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x) :\n    HasStrictDerivAt (fun x => f x - g x) (f' - g') x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any functor P from the opposite of category C to category D, the plus map of the identity morphism of P is equal to the identity morphism of the plus construction.",
    "output": "theorem plusMap_id (P : Cáµ’áµ– â¥¤ D) : J.plusMap (ğŸ™ P) = ğŸ™ _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The morphism from the first kernel fork of a binary bicone 'c' is equal to the right inclusion of 'c'.",
    "output": "theorem BinaryBicone.fstKernelFork_Î¹ : (BinaryBicone.fstKernelFork c).Î¹ = c.inr :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The closure of the set of all elements x in K such that the valuation of x is less than Î³ (where Î³ is a nonzero element of Î“â‚€), when these elements are mapped to the completion of K, is equal to the set of all elements x in the completion of K such that the extension of the valuation to the completion of K applied to x is less than Î³.",
    "output": "theorem closure_coe_completion_v_lt {Î³ : Î“â‚€Ë£} :\n    closure ((â†‘) '' { x : K | v x < (Î³ : Î“â‚€) }) =\n    { x : hat K | extensionValuation x < (Î³ : Î“â‚€) } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number 'r' and any positive integer 'k', the Hasse derivative of the constant polynomial 'r' at 'k' is equal to zero.",
    "output": "theorem hasseDeriv_C (r : R) (hk : 0 < k) : hasseDeriv k (C r) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of vectors in a vector space 'V' over a field 'K', if 's' is finite, then the dimension of the span of 's' (i.e., the smallest subspace containing all vectors in 's') is less than or equal to the number of elements in 's'.",
    "output": "theorem finrank_span_le_card (s : Set V) [Fintype s] : finrank K (span K s) â‰¤ s.toFinset.card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function that maps prime numbers to positive natural numbers is injective. This means that different prime numbers will always map to different positive natural numbers.",
    "output": "theorem coe_pnat_injective : Function.Injective ((â†‘) : Nat.Primes â†’ â„•+) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î± and Î² that have a zero element, given a function 'f' from Î± to Î² such that 'f' of zero equals zero, and a function 'd' from 'n' to Î±, the map of the function 'f' over the diagonal of 'd' equals the diagonal of the function 'm' mapped to 'f' of 'd' of 'm'.",
    "output": "theorem diagonal_map [Zero Î±] [Zero Î²] {f : Î± â†’ Î²} (h : f 0 = 0) {d : n â†’ Î±} :\n    (diagonal d).map f = diagonal fun m => f (d m) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The auxiliary function for reparameterizing the transitive association is equal to zero when the input is zero.",
    "output": "theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given a topological space F and a topological add group F, for any type Î¹, any property p of Î¹, and any function b from Î¹ to the set of F, if the neighborhood filter of 0 in F has a basis determined by p and b, then the neighborhood filter of the 0 function in the space of continuous linear maps from E to F also has a basis. This basis is determined by a function that takes a set of E and an element of Î¹ and returns whether the set is Von Neumann bounded and the property p holds for the element of Î¹, and a function that takes a set of E and an element of Î¹ and returns the set of continuous linear maps from E to F such that for every element in the set of E, the image of the element under the map is in the set determined by applying b to the element of Î¹.",
    "output": "theorem hasBasis_nhds_zero_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n    {Î¹ : Type _} {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set F} (h : (ğ“ 0 : Filter F).HasBasis p b) :\n    (ğ“ (0 : E â†’SL[Ïƒ] F)).HasBasis (fun Si : Set E Ã— Î¹ => Bornology.IsVonNBounded ğ•œâ‚ Si.1 âˆ§ p Si.2)\n      fun Si => { f : E â†’SL[Ïƒ] F | âˆ€ x âˆˆ Si.1, f x âˆˆ b Si.2 } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the primorial of 'n' is greater than zero.",
    "output": "theorem primorial_pos (n : â„•) : 0 < n# :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any Witt vector 'x' over a ring 'R' and any natural number 'n', the coefficient of 'n' in the negation of 'x' is equal to the polynomial evaluation of the 'n'th Witt negation polynomial at the coefficients of 'x'.",
    "output": "theorem neg_coeff (x : ğ• R) (n : â„•) : (-x).coeff n = peval (wittNeg p n) ![x.coeff] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type K, if K is a field, and there is an algebra A over K, and A is a fraction ring of K, then A is a Dedekind domain if and only if the following conditions are met: A is a Noetherian ring, the dimension of A is less than or equal to one, and for every element x in K that is integral over A, there exists an element y such that the algebraic mapping of y from A to K equals x.",
    "output": "theorem isDedekindDomain_iff (K : Type _) [Field K] [Algebra A K] [IsFractionRing A K] :\n    IsDedekindDomain A â†”\n      IsNoetherianRing A âˆ§\n        DimensionLEOne A âˆ§ âˆ€ {x : K}, IsIntegral A x â†’ âˆƒ y, algebraMap A K y = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ordered ring Î± that is nontrivial, the function that casts an integer x to Î± is strictly monotonically increasing.",
    "output": "theorem cast_strictMono [OrderedRing Î±] [Nontrivial Î±] : StrictMono (fun x : â„¤ => (x : Î±)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is a maximum, then 'a' is a predecessor limit.",
    "output": "theorem _root_.IsMax.isPredLimit : IsMax a â†’ IsPredLimit a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given partial equivalence 'f' between 'm' and 'n', and for any 'i' and 'j', the application of 'f' to the matrix at position 'i', 'j' is equal to 1 if 'j' is in the image of 'f' at 'i', otherwise it is 0. This is under the conditions that 'n' is decidable equal, and 'Î±' is a type with defined zero and one.",
    "output": "theorem toMatrix_apply [DecidableEq n] [Zero Î±] [One Î±] (f : m â‰ƒ. n) (i j) :\n    toMatrix f i j = if j âˆˆ f i then (1 : Î±) else 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'g' mapping from 'Î²' to 'F', if 'f' is a measurable embedding, then the p-seminorm of 'g' with respect to the measure obtained by mapping 'f' over 'Î¼' is equal to the p-seminorm of the composition of 'g' and 'f' with respect to 'Î¼'.",
    "output": "theorem _root_.MeasurableEmbedding.snorm_map_measure {g : Î² â†’ F} (hf : MeasurableEmbedding f) :\n    snorm g p (Measure.map f Î¼) = snorm (g âˆ˜ f) p Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' is a function from Î² to Î± in a topological space Î², and 'f' is inducing, then for any set 's' in Î± that is separable, the preimage of 's' under 'f' is also separable.",
    "output": "theorem _root_.Inducing.isSeparable_preimage {f : Î² â†’ Î±} [TopologicalSpace Î²]\n    (hf : Inducing f) {s : Set Î±} (hs : IsSeparable s) : IsSeparable (f â»Â¹' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given complex number 'c' with norm greater than 1, and a real number 'R' such that the norm of 'c' is less than 'R', if the field 'E' over the complex numbers is not finite-dimensional, and 's' is a finite set of elements from 'E', then there exists an element 'x' from 'E' such that the norm of 'x' is less than or equal to 'R' and for all elements 'y' in the set 's', the norm of the difference between 'y' and 'x' is greater than or equal to 1.",
    "output": "theorem exists_norm_le_le_norm_sub_of_finset {c : ğ•œ} (hc : 1 < â€–câ€–) {R : â„} (hR : â€–câ€– < R)\n    (h : Â¬FiniteDimensional ğ•œ E) (s : Finset E) : âˆƒ x : E, â€–xâ€– â‰¤ R âˆ§ âˆ€ y âˆˆ s, 1 â‰¤ â€–y - xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' that maps elements of type Î± to type Î², and a list 'xs' of type Î±, the list obtained by first applying the function 'f' to each element of 'xs' and then converting the result to a list is the same as the list obtained by first converting 'xs' to a list and then applying the function 'f' to each element of the list.",
    "output": "theorem toList_map (f : Î± â†’ Î²) (xs : t Î±) : toList (f <$> xs) = f <$> toList xs :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If y is less than x, the difference between x and y is divisible by 2, and x is not divisible by 2, then for any natural number n greater than 0 that is even, the 2-adic valuation of the difference between x to the power of n and y to the power of n plus 1 is equal to the sum of the 2-adic valuation of the sum of x and y, the 2-adic valuation of the difference between x and y, and the 2-adic valuation of n.",
    "output": "theorem pow_two_sub_pow (hyx : y < x) (hxy : 2 âˆ£ x - y) (hx : Â¬2 âˆ£ x) {n : â„•} (hn : 0 < n)\n    (hneven : Even n) :\n    padicValNat 2 (x ^ n - y ^ n) + 1 =\n      padicValNat 2 (x + y) + padicValNat 2 (x - y) + padicValNat 2 n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A filter 'g' is less than or equal to the product of filters 'f' if and only if for all 'i', the function 'eval i' tends towards 'f i' under the filter 'g'.",
    "output": "theorem le_pi {g : Filter (âˆ€ i, Î± i)} : g â‰¤ pi f â†” âˆ€ i, Tendsto (eval i) g (f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' in the lexicographical order of the function from 'Î±' to 'N', and for any 'i' in 'Î±', if for all 'j' less than 'i', the lexicographical order of 'a' at 'j' is equal to the lexicographical order of 'b' at 'j', and the lexicographical order of 'a' at 'i' is less than the lexicographical order of 'b' at 'i', then 'a' is less than 'b'.",
    "output": "theorem lt_of_forall_lt_of_lt (a b : Lex (Î± â†’â‚€ N)) (i : Î±) :\n    (âˆ€ j < i, ofLex a j = ofLex b j) â†’ ofLex a i < ofLex b i â†’ a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an algebraic equivalence 'e' between two algebraic structures 'Aâ‚' and 'Aâ‚‚' over a ring 'R', the inverse of 'e' is a left inverse of 'e'. This means that applying the inverse of 'e' to the result of 'e' will return the original input.",
    "output": "theorem leftInverse_symm (e : Aâ‚ â‰ƒâ‚[R] Aâ‚‚) : Function.LeftInverse e.symm e :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given commutative group with zero 'Î²', a finite set 's', and a function 'f' from 'Î±' to 'Î²', if we create a unit from the product of the function 'f' applied to each element in 's', it is equal to the product of the units created from each element in 's' (where each unit is created from the function 'f' applied to an element in 's'). The function 'h' is used to handle the case where the product of the function 'f' applied to each element in 's' is zero.",
    "output": "theorem Units.mk0_prod [CommGroupWithZero Î²] (s : Finset Î±) (f : Î± â†’ Î²) (h) :\n    Units.mk0 (âˆ b in s, f b) h =\n      âˆ b in s.attach, Units.mk0 (f b) fun hh => h (Finset.prod_eq_zero b.2 hh) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'e' is right order continuous.",
    "output": "theorem rightOrdContinuous : RightOrdContinuous e :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given limit \"t\" in category theory, and for any object \"W\" in category \"C\" with a morphism \"m\" from \"W\" to the point of \"t\", \"m\" is equal to the lift of \"h\" (where \"h\" is a limit of \"t\") with \"W\" as the point and the application of \"m\" followed by the application of the projection of \"t\" as the projection.",
    "output": "theorem hom_lift (h : IsLimit t) {W : C} (m : W âŸ¶ t.pt) :\n    m = h.lift { pt := W, Ï€ := { app := fun b => m â‰« t.Ï€.app b } } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If ğ’¢ is a coseparating set in a category C and â„‹ is a set in C that contains ğ’¢, then â„‹ is also a coseparating set in C.",
    "output": "theorem IsCoseparating.mono {ğ’¢ : Set C} (hğ’¢ : IsCoseparating ğ’¢) {â„‹ : Set C} (hğ’¢â„‹ : ğ’¢ âŠ† â„‹) :\n    IsCoseparating â„‹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function v from real numbers to a vector space E, and a non-negative real number K such that for every real number t, v is Lipschitz continuous with constant K at t. If we have two functions f and g from real numbers to E, and two real numbers a and b such that f is continuous on the closed interval from a to b, and for every t in the open interval from a to b, the derivative of f at t within the closed interval from t to infinity is v(t, f(t)). If g is also continuous on the closed interval from a to b, and for every t in the open interval from a to b, the derivative of g at t within the closed interval from t to infinity is v(t, g(t)), and if f(a) equals g(a), then for every t in the closed interval from a to b, f(t) equals g(t). This theorem is essentially stating the uniqueness of solutions to ordinary differential equations under certain conditions.",
    "output": "theorem ODE_solution_unique {v : â„ â†’ E â†’ E} {K : â„â‰¥0} (hv : âˆ€ t, LipschitzWith K (v t))\n    {f g : â„ â†’ E} {a b : â„} (hf : ContinuousOn f (Icc a b))\n    (hf' : âˆ€ t âˆˆ Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t) (hg : ContinuousOn g (Icc a b))\n    (hg' : âˆ€ t âˆˆ Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t) (ha : f a = g a) :\n    âˆ€ t âˆˆ Icc a b, f t = g t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is continuously differentiable 'n' times over the real numbers, then the function that applies the hyperbolic sine to 'f' is also continuously differentiable 'n' times over the real numbers.",
    "output": "theorem ContDiff.sinh {n} (h : ContDiff â„ n f) : ContDiff â„ n fun x => Real.sinh (f x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite sets s and t, the ratio of the number of intersecting edges between s and t to the product of the number of elements in s and t is equal to the edge density between s and t in the graph G.",
    "output": "theorem card_interedges_div_card (s t : Finset Î±) :\n    ((G.interedges s t).card : â„š) / (s.card * t.card) = G.edgeDensity s t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of the relational coimage of relation 'r' and the relational coimage of relation 's' is equal to the relational coimage of the composition of relation 'r' and relation 's'.",
    "output": "theorem rcomap_compose (r : Rel Î± Î²) (s : Rel Î² Î³) : rcomap r âˆ˜ rcomap s = rcomap (r.comp s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The non-negative distance between points x and y is less than or equal to the sum of the non-negative distance from z to x and the non-negative distance from z to y. This is a version of the triangle inequality for non-negative distances.",
    "output": "theorem nndist_triangle_left (x y z : Î±) : nndist x y â‰¤ nndist z x + nndist z y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î³ that is a monoid, and any function f from M to Î³ that is a monoid homomorphism, the range of f is a submonoid.",
    "output": "theorem Range.isSubmonoid {Î³ : Type _} [Monoid Î³] {f : M â†’ Î³} (hf : IsMonoidHom f) :\n    IsSubmonoid (Set.range f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of a constant 'a' and a variable 'X' is equal to a monomial of degree 1 with coefficient 'a'.",
    "output": "theorem C_mul_X_eq_monomial : C a * X = monomial 1 a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers 'n' and 'k', if 'k' is less than or equal to 'n', then the binomial coefficient of 'n' and 'k' (denoted as \"choose n k\") is greater than zero.",
    "output": "theorem choose_pos : âˆ€ {n k}, k â‰¤ n â†’ 0 < choose n k"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"a is equivalent to 0 modulo n if and only if n divides a\".",
    "output": "theorem modEq_zero_iff_dvd : a â‰¡ 0 [ZMOD n] â†” n âˆ£ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f is antitone (non-increasing) on the interval from xâ‚€ to xâ‚€ + a, then the sum of the function values at each point in the range a, offset by xâ‚€ and incremented by 1, is less than or equal to the integral of the function over the interval from xâ‚€ to xâ‚€ + a.",
    "output": "theorem AntitoneOn.sum_le_integral (hf : AntitoneOn f (Icc xâ‚€ (xâ‚€ + a))) :\n    (âˆ‘ i in Finset.range a, f (xâ‚€ + (i + 1 : â„•))) â‰¤ âˆ« x in xâ‚€..xâ‚€ + a, f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any polynomial 'p' and any real number 'r', the evaluation of the product of 'p' and the difference between 'X' and the constant 'r' at 'r' is equal to zero.",
    "output": "theorem eval_mul_X_sub_C {p : R[X]} (r : R) : (p * (X - C r)).eval r = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object 'X' and a function 'f' from 'X' to the object 'F.Obj X', and for any element 'xâ‚€' of 'X', the corecursion of 'f' at 'xâ‚€' in 'M' is equal to the creation in 'M' of the functor application of the corecursion of 'f' to 'f' at 'xâ‚€'.",
    "output": "theorem corec_def {X} (f : X â†’ F.Obj X) (xâ‚€ : X) : M.corec f xâ‚€ = M.mk (M.corec f <$> f xâ‚€) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An element 'a' is in the list 'l' if and only if there exists a number 'n' and a proof 'h' that the 'n'-th element of the list 'l', considering 'h', is equal to 'a'.",
    "output": "theorem mem_iff_nthLe {a} {l : List Î±} : a âˆˆ l â†” âˆƒ n h, nthLe l n h = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given group homomorphism 'f' from group 'G' to group 'N' and a subgroup 'H' of 'G', the image of 'H' under 'f' is equal to the range of 'f' if and only if 'H' and the kernel of 'f' are codisjoint.",
    "output": "theorem map_eq_range_iff {f : G â†’* N} {H : Subgroup G} : H.map f = f.range â†” Codisjoint H f.ker :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of a continuous open map 'f' from 'Î±' to 'Î²' with the identity continuous open map on 'Î±' is equal to 'f'.",
    "output": "theorem comp_id (f : Î± â†’CO Î²) : f.comp (ContinuousOpenMap.id Î±) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set S of intermediate fields between fields F and E, the set of elements in the greatest lower bound (infimum) of S is equal to the greatest lower bound of the set of elements in each intermediate field in S.",
    "output": "theorem coe_sInf (S : Set (IntermediateField F E)) : (â†‘(sInf S) : Set E) =\n    sInf ((fun (x : IntermediateField F E) => (x : Set E)) '' S) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If p is not equal to infinity, then the function that maps a simple function in Lp space to the Lp space itself is a dense embedding.",
    "output": "theorem denseEmbedding (hp_ne_top : p â‰  âˆ) :\n    DenseEmbedding ((â†‘) : Lp.simpleFunc E p Î¼ â†’ Lp E p Î¼) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given equivalence 'f' between two types 'Î±' and 'Î±'', and a function 'l' from 'Î±' to 'R', the total function of the equivalent domain mapping of 'f' and 'l' is equal to the total function of 'Î±' and 'R' with the composition of 'v'' and 'f' applied to 'l'.",
    "output": "theorem total_equivMapDomain (f : Î± â‰ƒ Î±') (l : Î± â†’â‚€ R) :\n    (Finsupp.total Î±' M' R v') (equivMapDomain f l) = (Finsupp.total Î± M' R (v' âˆ˜ f)) l :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements x, y, and z in a normed lattice, the norm of the supremum of x and z minus the supremum of y and z is less than or equal to the norm of x minus y.",
    "output": "theorem norm_sup_sub_sup_le_norm (x y z : Î±) : â€–x âŠ” z - y âŠ” zâ€– â‰¤ â€–x - yâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' from the multiplier algebra of a star algebra 'A' over a field 'ğ•œ', the second component of the product of 'a' and 'b' is equal to the product of the second component of 'b' and the second component of 'a'.",
    "output": "theorem mul_snd (a b : ğ“œ(ğ•œ, A)) : (a * b).snd = b.snd * a.snd :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the function f is interval integrable over the intervals [a, b], [c, d], and [a, c] with respect to a measure Î¼, then the difference between the integral of f from a to b and the integral of f from c to d is equal to the difference between the integral of f from a to c and the integral of f from b to d.",
    "output": "theorem integral_interval_sub_interval_comm (hab : IntervalIntegrable f Î¼ a b)\n    (hcd : IntervalIntegrable f Î¼ c d) (hac : IntervalIntegrable f Î¼ a c) :\n    ((âˆ« x in a..b, f x âˆ‚Î¼) - âˆ« x in c..d, f x âˆ‚Î¼) =\n      (âˆ« x in a..c, f x âˆ‚Î¼) - âˆ« x in b..d, f x âˆ‚Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given addition monoid M, a monoid R, and a distributive multiplication action of R on M, and for a function f from Î± to Î², a scalar r from R, and a function v from Î² to M, if the function f is injective on the preimage of the support of v and the preimage of the support of the scalar multiplication of r and v, then the comapDomain of f and the scalar multiplication of r and v is equal to the scalar multiplication of r and the comapDomain of f and v.",
    "output": "theorem comapDomain_smul [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : Î± â†’ Î²} (r : R)\n    (v : Î² â†’â‚€ M) (hfv : Set.InjOn f (f â»Â¹' â†‘v.support))\n    (hfrv : Set.InjOn f (f â»Â¹' â†‘(r â€¢ v).support) :=\n      hfv.mono <| Set.preimage_mono <| Finset.coe_subset.mpr support_smul) :\n    comapDomain f (r â€¢ v) hfrv = r â€¢ comapDomain f v hfv :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two subgroups H and K of a group G, if H is a subset of K, then the composition of the subtype of K and the inclusion of H in K is equal to the subtype of H.",
    "output": "theorem subtype_comp_inclusion {H K : Subgroup G} (hH : H â‰¤ K) :\n    K.subtype.comp (inclusion hH) = H.subtype :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of any type 'Î±', and for another set 't' of the same type 'Î±' where '1' of type 'Î±' is an element of 't', 's' is a subset of the product of 's' and 't'.",
    "output": "theorem subset_mul_left (s : Set Î±) {t : Set Î±} (ht : (1 : Î±) âˆˆ t) : s âŠ† s * t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function f is almost everywhere measurable with respect to the measure restricted to the union of sets s and t if and only if the function f is almost everywhere measurable with respect to the measure restricted to set s and the function f is almost everywhere measurable with respect to the measure restricted to set t.",
    "output": "theorem _root_.aemeasurable_union_iff {s t : Set Î±} :\n    AEMeasurable f (Î¼.restrict (s âˆª t)) â†”\n      AEMeasurable f (Î¼.restrict s) âˆ§ AEMeasurable f (Î¼.restrict t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' from a field extension 'E', the field obtained by adjoining 'x' to the field obtained by adjoining a set 'S' to a field 'F' is the same as the field obtained by adjoining 'x' to the set 'S' and then adjoining this to the field 'F'.",
    "output": "theorem adjoin_insert_adjoin (x : E) :\n    adjoin F (insert x (adjoin F S : Set E)) = adjoin F (insert x S) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any polynomial 'x' over a field 'K', the function 'ofFractionRing' applied to the algebraic mapping of 'x' into the fraction ring of polynomials over 'K' is equal to the algebraic mapping of 'x'.",
    "output": "theorem ofFractionRing_algebraMap (x : K[X]) :\n    ofFractionRing (algebraMap _ (FractionRing K[X]) x) = algebraMap _ _ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any additive monoid with one element 'R' and any natural numbers 'm' and 'n', the cast of the sum of 'm' and 'n' to 'R' is equal to the sum of 'm' and 'n'.",
    "output": "theorem cast_add [AddMonoidWithOne R] (m n : â„•) : ((m + n : â„•) : R) = m + n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Taking elements from the right of an empty list, regardless of the number of elements specified, will result in an empty list.",
    "output": "theorem rtake_nil : rtake ([] : List Î±) n = [] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is greater than or equal to 1 and b is also greater than or equal to 1, then the product of a and b is greater than or equal to 1.",
    "output": "theorem one_le_mul_of_one_le_of_one_le (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : (1 : Î±) â‰¤ a * b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite numbers 'i' and 'j' within a certain range 'n', if the values of 'i' and 'j' are not equal, then 'i' and 'j' themselves are not equal.",
    "output": "theorem ne_of_vne {i j : Fin n} (h : i.val â‰  j.val) : i â‰  j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is a unit, then the multiplication of 'a' and 'b' being equal to the multiplication of 'a' and 'c' implies that 'b' is equal to 'c'. This is known as the left cancellation law in multiplication.",
    "output": "theorem mul_left_cancel (h : IsUnit a) : a * b = a * c â†’ b = c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' which is non-negative almost everywhere with respect to measure 'Î¼' and is interval integrable over the interval from 'a' to 'b', the integral of 'f' over this interval is positive if and only if 'a' is less than 'b' and the measure of the intersection of the support of 'f' and the interval (a, b] is positive.",
    "output": "theorem integral_pos_iff_support_of_nonneg_ae (hf : 0 â‰¤áµ[Î¼] f) (hfi : IntervalIntegrable f Î¼ a b) :\n    (0 < âˆ« x in a..b, f x âˆ‚Î¼) â†” a < b âˆ§ 0 < Î¼ (support f âˆ© Ioc a b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The transition from the inverse of a local homeomorphism 'e' to 'e' itself is equivalent to the local homeomorphism of the target set of 'e', given that the target set is open.",
    "output": "theorem trans_symm_self : e.symm.trans e â‰ˆ LocalHomeomorph.ofSet e.target e.open_target :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a constant 'c' is not equal to zero, then the function that multiplies 'c' with the output of function 'f' for each input 'x' in set 's' is continuous if and only if the function 'f' is continuous on set 's'.",
    "output": "theorem continuousOn_const_smul_iffâ‚€ (hc : c â‰  0) :\n    ContinuousOn (fun x => c â€¢ f x) s â†” ContinuousOn f s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type M that is a monoid, and any unit 'u' and element 'a' of M, 'a' is a unit if and only if the product of 'u' and 'a' is a unit.",
    "output": "theorem Units.isUnit_units_mul {M : Type _} [Monoid M] (u : MË£) (a : M) :\n    IsUnit (â†‘u * a) â†” IsUnit a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'g' and 'h' that map sets of elements of type Î± to sets of elements of type Î² and sets of elements of type Î² to sets of elements of type Î³ respectively, if 'g' and 'h' are monotone, then lifting 'f' by 'g' and then lifting the result by 'h' is the same as lifting 'f' by the function that applies 'h' to the result of applying 'g' to a set.",
    "output": "theorem lift'_lift'_assoc {g : Set Î± â†’ Set Î²} {h : Set Î² â†’ Set Î³} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift' h = f.lift' fun s => h (g s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any additive group with one element R, the integer coefficient of one in the arithmetic function from integers to R is equal to one.",
    "output": "theorem intCoe_one [AddGroupWithOne R] : ((1 : ArithmeticFunction â„¤) :\n    ArithmeticFunction R) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real numbers 'x' and 'p', given that 'x' is not equal to zero or 'p' is greater than or equal to 1, the derivative at 'x' of the function 'x' to the power of 'p' is 'p' times 'x' to the power of 'p - 1'.",
    "output": "theorem hasDerivAt_rpow_const {x p : â„} (h : x â‰  0 âˆ¨ 1 â‰¤ p) :\n    HasDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a ring homomorphism 'h' from a commutative semiring 'R' to another commutative semiring 'S', a function 'f' from a type 'Î±' to a type 'M' with zero, and a function 'g' from 'Î±' and 'M' to 'R', the image of the product of 'f' and 'g' under 'h' is equal to the product of 'f' and the image of 'g' under 'h'.",
    "output": "theorem RingHom.map_finsupp_prod [Zero M] [CommSemiring R] [CommSemiring S] (h : R â†’+* S)\n    (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ R) : h (f.prod g) = f.prod fun a b => h (g a b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given equivalence between two sets m and l (denoted as eâ‚˜), and another equivalence between two sets n and o (denoted as eâ‚™), and a matrix M with dimensions m by n with elements of type Î±, the reindexing of matrix M using the equivalences eâ‚˜ and eâ‚™ is equal to the submatrix of M obtained by applying the inverse of the equivalences eâ‚˜ and eâ‚™.",
    "output": "theorem reindex_apply (eâ‚˜ : m â‰ƒ l) (eâ‚™ : n â‰ƒ o) (M : Matrix m n Î±) :\n    reindex eâ‚˜ eâ‚™ M = M.submatrix eâ‚˜.symm eâ‚™.symm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The dot product of vector v and the negation of vector w is equal to the negation of the dot product of vector v and vector w.",
    "output": "theorem dotProduct_neg : v â¬áµ¥ -w = -(v â¬áµ¥ w) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function that takes an element from subgroup H to group G, defined by the subtype of H, is equal to the function that takes an element from H to G, defined by the coercion function.",
    "output": "theorem coeSubtype : (SubgroupClass.subtype H : H â†’ G) = ((â†‘) : H â†’ G) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If set t is almost everywhere equal to the empty set with respect to measure Î¼, then the union of sets s and t is almost everywhere equal to set s with respect to the same measure Î¼.",
    "output": "theorem union_ae_eq_left_of_ae_eq_empty (h : t =áµ[Î¼] (âˆ… : Set Î±)) : (s âˆª t : Set Î±) =áµ[Î¼] s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponential function applied to the left injection of a real number in the direct sum of real numbers and some normed space is equal to the left injection of the exponential function applied to the real number.",
    "output": "theorem exp_inl (x : R) : exp ğ•œ (inl x : tsze R M) = inl (exp ğ•œ x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse of the extended chart at a point 'x' in a smooth manifold with corners 'I' is continuous at the image of 'x' under the extended chart.",
    "output": "theorem continuousAt_extChartAt_symm : ContinuousAt (extChartAt I x).symm ((extChartAt I x) x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The operation that assigns to each element its opposite is surjective. This means that for every element in the set, there is at least one element in the original set that maps to it under this operation.",
    "output": "theorem op_surjective : Surjective (op : Î± â†’ Î±áµáµ’áµ–) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "1 is less than the non-negative real part of p.",
    "output": "theorem one_lt_nnreal : 1 < Real.toNNReal p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a partial equivalence between type Î± and type Î² represented by 'f', then the composition of 'f' with the bottom partial equivalence (which represents no equivalence) between type Î² and type Î³ is also the bottom partial equivalence.",
    "output": "theorem trans_bot (f : Î± â‰ƒ. Î²) : f.trans (âŠ¥ : Î² â‰ƒ. Î³) = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index set Î¹, any weighting function w from Î¹ to a field k, any point function p from Î¹ to a space P, and any index i in Î¹, the weighted difference of points from the set s with i removed, using the point function p and the weight function w, with respect to the point p(i), is equal to the weighted difference of points from the set s, using the point function p and the weight function w, with respect to the point p(i). This holds if Î¹ has decidable equality.",
    "output": "theorem weightedVSubOfPoint_erase [DecidableEq Î¹] (w : Î¹ â†’ k) (p : Î¹ â†’ P) (i : Î¹) :\n    (s.erase i).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ring homomorphism class F from ring R to ring S, and any function f from F, for all natural numbers n, applying the function f to n (considered as an element of ring R) equals n.",
    "output": "theorem map_natCast [RingHomClass F R S] (f : F) : âˆ€ n : â„•, f (n : R) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the series of f and g are both summable, and the series of the product of f and g (where f and g are functions of the elements from the sets Î¹ and Îº respectively) is also summable, then the sum of the series of f times the sum of the series of g is equal to the sum of the series of the product of f and g.",
    "output": "theorem tsum_mul_tsum (hf : Summable f) (hg : Summable g)\n    (hfg : Summable fun x : Î¹ Ã— Îº => f x.1 * g x.2) :\n    ((âˆ‘' x, f x) * âˆ‘' y, g y) = âˆ‘' z : Î¹ Ã— Îº, f z.1 * g z.2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cardinality of the multiset obtained by binding a function 'f' to a multiset 's' is equal to the sum of the multiset obtained by mapping the composition of the cardinality function and 'f' over 's'.",
    "output": "theorem card_bind : card (s.bind f) = (s.map (card âˆ˜ f)).sum :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' in set 'Î±', 'l a' is the greatest lower bound of the set of all 'b' such that 'a' is less than or equal to 'u b'.",
    "output": "theorem isGLB_l {a : Î±} : IsGLB { b | a â‰¤ u b } (l a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 's' mapping from a pair of index sets 'Î¹' and 'Î¹'' to a set of 'Î±', the union over 'j' of the intersection over 'i' of 's i j' is a subset of the intersection over 'i' of the union over 'j' of 's i j'.",
    "output": "theorem iUnion_iInter_subset {s : Î¹ â†’ Î¹' â†’ Set Î±} : (â‹ƒ j, â‹‚ i, s i j) âŠ† â‹‚ i, â‹ƒ j, s i j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of group theory, for a finite group G, the exponent of G is equal to the maximum order of any element in G. This maximum order is guaranteed to be at least 1.",
    "output": "theorem exponent_eq_max'_orderOf [Fintype G] :\n    exponent G = ((@Finset.univ G _).image orderOf).max' âŸ¨1, by simpâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite dimensional field 'K' and vector space 'V', the application of the map evaluation equivalence on a subspace 'W' of 'V' is equal to the mapping of the subspace 'W' with the evaluation of 'K' and 'V'.",
    "output": "theorem mapEvalEquiv_apply [FiniteDimensional K V] (W : Subspace K V) :\n    mapEvalEquiv K V W = W.map (eval K V) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The interval from 'a' to 'b' is equal to the interval from 'a' (interpreted as a natural number) to 'b', which is then finalized to 'n'.",
    "output": "theorem Ioc_eq_finset_subtype : Ioc a b = (Ioc (a : â„•) b).fin n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of set 'M' and any natural number 'n', the first element of the application of 'of' function on 'I', 'M', and 'x' at 'n' is equal to the application of 'mkQ' function on '_' and 'x'.",
    "output": "theorem of_apply (x : M) (n : â„•) : (of I M x).1 n = mkQ _ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' from set 'E', there exists a unique 'v' from the integer span of the set range 'b', such that the vector addition of 'v' and 'x' belongs to the fundamental domain of 'b'. This theorem is applicable under the condition that 'Î¹' is finite.",
    "output": "theorem exist_unique_vadd_mem_fundamentalDomain [Finite Î¹] (x : E) :\n    âˆƒ! v : span â„¤ (Set.range b), v +áµ¥ x âˆˆ fundamentalDomain b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The norm of 'x' when converted to an additive form in the set E is equal to the norm of 'x'.",
    "output": "theorem norm_toAdd (x) : â€–(toAdd x : E)â€– = â€–xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' in set 'M' and given subrings 'S' and 'T' of ring 'R', the scalar multiplication of 'a' and 'S' is less than or equal to the scalar multiplication of 'a' and 'T' if and only if 'S' is less than or equal to 'T'.",
    "output": "theorem pointwise_smul_le_pointwise_smul_iff {a : M} {S T : Subring R} : a â€¢ S â‰¤ a â€¢ T â†” S â‰¤ T :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' mapped by a function 'f' is nonempty if and only if the set 's' itself is nonempty.",
    "output": "theorem map_nonempty : (s.map f).Nonempty â†” s.Nonempty :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î±â‚ and Î±â‚‚, given a bijective function 'e' between them, an element 'i' of type Î±â‚, and a module 'm', the domain of the linear congruence of 'e' applied to the single function of 'i' and 'm' is equal to the single function of 'e' applied to 'i' and 'm'.",
    "output": "theorem domLCongr_single {Î±â‚ : Type _} {Î±â‚‚ : Type _} (e : Î±â‚ â‰ƒ Î±â‚‚) (i : Î±â‚) (m : M) :\n    (Finsupp.domLCongr e : _ â‰ƒâ‚—[R] _) (Finsupp.single i m) = Finsupp.single (e i) m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The singleton set containing only the number one in the submodule of R and A is equal to the span of R and 1.",
    "output": "theorem one_eq_span_one_set : (1 : Submodule R A) = span R 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f is analytic at a point x and function g is also analytic at the same point x, then the sum of functions f and g is also analytic at point x.",
    "output": "theorem AnalyticAt.add (hf : AnalyticAt ğ•œ f x) (hg : AnalyticAt ğ•œ g x) : AnalyticAt ğ•œ (f + g) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± and any finite set s of type Î±, the cardinality of s is equal to the cardinality of the set obtained by applying the cardinality function to s.",
    "output": "theorem mk_coe_finset {Î± : Type u} {s : Finset Î±} : (#s) = â†‘(Finset.card s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for all points 'x' in a topological space 'X', the stalk functor mapping of 'f' (a morphism from sheaf 'F' to sheaf 'G') is a monomorphism, then 'f' itself is a monomorphism.",
    "output": "theorem mono_of_stalk_mono {F G : Sheaf C X} (f : F âŸ¶ G) [âˆ€ x, Mono <| (stalkFunctor C x).map f.1] :\n    Mono f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any equivalence relation 'e' from 'r' to 'r', applying 'e' to the inverse of 'e' applied to any element 'x' will yield 'x' itself.",
    "output": "theorem apply_inv_self (e : r â‰ƒr r) (x) : e (eâ»Â¹ x) = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' is in the neighborhood of a point 'a', then 's' is also in the neighborhood within a set 't' of the point 'a'.",
    "output": "theorem mem_nhdsWithin_of_mem_nhds {s t : Set Î±} {a : Î±} (h : s âˆˆ ğ“ a) : s âˆˆ ğ“[t] a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given equivalence 'e' between two index sets 'Î¹' and 'Î¹â‚‚', and a function 'f' that maps each index to a module 'M', the tensor product of 'f' reindexed by 'e' is equal to the tensor product of 'f' composed with the inverse of 'e'.",
    "output": "theorem reindex_tprod (e : Î¹ â‰ƒ Î¹â‚‚) (f : âˆ€ _, M) :\n    reindex R M e (tprod R f) = tprod R fun i â†¦ f (e.symm i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The ceiling function, which maps any real number to the smallest integer greater than or equal to it, is monotone. This means that if a real number x is less than or equal to another real number y, then the ceiling of x is also less than or equal to the ceiling of y.",
    "output": "theorem ceil_mono : Monotone (ceil : Î± â†’ â„¤) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The natural degree of twice a polynomial 'a' is less than or equal to the natural degree of the polynomial 'a' itself.",
    "output": "theorem natDegree_bit0 (a : R[X]) : (bit0 a).natDegree â‰¤ a.natDegree :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a matrix M with a nonzero determinant, and a vector v such that when we multiply M by v we get the zero vector, then v must be the zero vector.",
    "output": "theorem eq_zero_of_mulVec_eq_zero [DecidableEq m] {M : Matrix m m A} (hM : M.det â‰  0) {v : m â†’ A}\n    (hv : M.mulVec v = 0) : v = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two sets 's' and 't' that are both bounded below and nonempty, the greatest lower bound (infimum) of the union of 's' and 't' is equal to the intersection of the greatest lower bound of 's' and the greatest lower bound of 't'.",
    "output": "theorem csInf_union (hs : BddBelow s) (sne : s.Nonempty) (ht : BddBelow t) (tne : t.Nonempty) :\n    sInf (s âˆª t) = sInf s âŠ“ sInf t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given monoid 'G', a multiplication action of 'G' on a semiring 'ğ”¸', and a continuous constant scalar multiplication of 'G' on 'ğ”¸', for any element 'g' of 'G' and any element 'x' of 'ğ”¸', the exponential of the scalar multiplication of 'g' and 'x' is equal to the scalar multiplication of 'g' and the exponential of 'x'.",
    "output": "theorem exp_smul {G} [Monoid G] [MulSemiringAction G ğ”¸] [ContinuousConstSMul G ğ”¸] (g : G) (x : ğ”¸) :\n    exp ğ•‚ (g â€¢ x) = g â€¢ exp ğ•‚ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nontrivial set 's', the first element chosen from 's' is not equal to the second element chosen from 's'.",
    "output": "theorem Nontrivial.choose_fst_ne_choose_snd (hs : s.Nontrivial) :\n    hs.choose.fst â‰  hs.choose.snd :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a Freiman homomorphism of class F from a set A to a set Î² of size n, given a function f of type F, and two multisets s and t of elements from Î±, if every element of s and t is in A, both s and t have the same cardinality n, and the product of elements in s is equal to the product of elements in t, then the product of the elements in the multiset obtained by mapping f over s is equal to the product of the elements in the multiset obtained by mapping f over t.",
    "output": "theorem map_prod_eq_map_prod [FreimanHomClass F A Î² n] (f : F) {s t : Multiset Î±}\n    (hsA : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ x âˆˆ A) (htA : âˆ€ â¦ƒxâ¦„, x âˆˆ t â†’ x âˆˆ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n)\n    (h : s.prod = t.prod) : (s.map f).prod = (t.map f).prod :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the supremum of sets s and t is nonempty, then set t is nonempty.",
    "output": "theorem Nonempty.of_sups_right : (s âŠ» t).Nonempty â†’ t.Nonempty :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite partitions P and Q of a set a, the parts of the intersection of P and Q are equal to the image of the Cartesian product of the parts of P and Q under the function that maps each pair to their intersection, with the bottom element removed.",
    "output": "theorem parts_inf (P Q : Finpartition a) :\n    (P âŠ“ Q).parts = ((P.parts Ã—Ë¢ Q.parts).image fun bc : Î± Ã— Î± â†¦ bc.1 âŠ“ bc.2).erase âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any types Î± and Î², and any element b of type Î², the function that takes an element a of type Î± and pairs it with b to form a product of type Î± Ã— Î² is injective. In other words, if two pairs (a, b) and (a', b) are equal, then a must be equal to a'.",
    "output": "theorem mk.inj_right {Î± Î² : Type _} (b : Î²) :\n    Function.Injective (fun a â†¦ Prod.mk a b : Î± â†’ Î± Ã— Î²) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object 'x' in 'X' and any 'U', the object 'U' remains unchanged when mapped with the identity on 'X'.",
    "output": "theorem map_id_obj (x : X) (U) : (map (ğŸ™ X) x).obj U = U :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given submonoid 's' of 'M' and an element 'x' of 'M', 'x' is in the subsemigroup of 's' if and only if 'x' is in 's'.",
    "output": "theorem mem_toSubsemigroup {s : Submonoid M} {x : M} : x âˆˆ s.toSubsemigroup â†” x âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given commutative semiring R and a semiring A with an algebra structure over R, if we have two algebra homomorphisms f and g from the dual numbers over R to A, and if these two homomorphisms map the dual number Îµ to the same element in A, then these two homomorphisms are equal.",
    "output": "theorem algHom_ext {A} [CommSemiring R] [Semiring A] [Algebra R A] â¦ƒf g : R[Îµ] â†’â‚[R] Aâ¦„\n    (h : f Îµ = g Îµ) : f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' and any multiset 's', if 'a' is an element of 's', then the cardinality (or size) of 's' after erasing 'a', plus one, is equal to the original cardinality of 's'.",
    "output": "theorem card_erase_add_one {a : Î±} {s : Multiset Î±} : a âˆˆ s â†’ card (s.erase a) + 1 = card s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The domain function, when applied to the fields R, E, and F, is strictly monotonic. This means that if we have two elements and the first is less than the second, then the image of the first under the domain function is less than the image of the second.",
    "output": "theorem domain_mono : StrictMono (@domain R _ E _ _ F _ _) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²', given the conditions 'hâ‚', 'hâ‚‚', and 'hâ‚ƒ', the function 'f' with the conditions 'hâ‚', 'hâ‚‚', and 'hâ‚ƒ' as a multiplicative homomorphism from 'Î±' to 'Î²' is equivalent to the function 'f' with the condition 'hâ‚' as a monoid homomorphism from 'Î±' to 'Î²'.",
    "output": "theorem coe_mulHom_mk (f : Î± â†’ Î²) (hâ‚ hâ‚‚ hâ‚ƒ) :\n    ((âŸ¨âŸ¨f, hâ‚âŸ©, hâ‚‚, hâ‚ƒâŸ© : Î± â†’â‚™+* Î²) : Î± â†’â‚™* Î²) = âŸ¨f, hâ‚âŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The preimage of the boolean indicator function of set s for the value false is equal to the complement of set s.",
    "output": "theorem preimage_boolIndicator_false : s.boolIndicator â»Â¹' {false} = sá¶œ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is an element of the source of e, then applying the inverse of the local homeomorphism e to the pair consisting of the projection of x and the second component of e at x, gives us back x.",
    "output": "theorem symm_apply_mk_proj (ex : x âˆˆ e.source) : e.toLocalHomeomorph.symm (proj x, (e x).2) = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' and any elements 'x' and 'a' of an additive commutative monoid 'Î±', the term of 'n', 'x', and 'a' is equal to 'n' times 'x' plus 'a'.",
    "output": "theorem term_eq [AddCommMonoid Î±] (n : â„•) (x a : Î±) : term n x a = n â€¢ x + a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two computations 'câ‚' and 'câ‚‚' of type Î±, if 'câ‚' is equivalent to 'câ‚‚', then the promise of 'câ‚' leading to a result 'a' is equivalent to the promise of 'câ‚‚' leading to the same result 'a'.",
    "output": "theorem promises_congr {câ‚ câ‚‚ : Computation Î±} (h : câ‚ ~ câ‚‚) (a) : câ‚ ~> a â†” câ‚‚ ~> a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any scalar 'r' and any two points 'pâ‚' and 'pâ‚‚', the line map from 'pâ‚' to 'pâ‚‚' at 'r' is included in the line spanned by 'pâ‚' and 'pâ‚‚'.",
    "output": "theorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (pâ‚ pâ‚‚ : P) :\n    AffineMap.lineMap pâ‚ pâ‚‚ r âˆˆ line[k, pâ‚, pâ‚‚] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' is a group homomorphism from group 'G' to group 'H', and 's' is a subgroup of 'G', then the image of 's' under 'f' is a subgroup of 'H'.",
    "output": "theorem image_subgroup {f : G â†’ H} (hf : IsGroupHom f) {s : Set G} (hs : IsSubgroup s) :\n    IsSubgroup (f '' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list of elements of an arbitrary type and a natural number that is less than or equal to the length of the list, taking the first 'n' elements of the reversed list is the same as dropping the first 'length of the list minus n' elements from the original list and then reversing it.",
    "output": "theorem reverse_take {Î±} {xs : List Î±} (n : â„•) (h : n â‰¤ xs.length) :\n    xs.reverse.take n = (xs.drop (xs.length - n)).reverse :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number 'a' and any natural number 'n', the absolute value of 'a' raised to the power of 'n' is equal to the absolute value of 'a' raised to the power of 'n'.",
    "output": "theorem pow_abs (a : R) (n : â„•) : |a| ^ n = |a ^ n| :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The norm of the product of a variable 'x' and its conjugate is equal to the product of the norm of 'x' and the norm of 'x'.",
    "output": "theorem norm_self_mul_star {x : E} : â€–x * xâ‹†â€– = â€–xâ€– * â€–xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Mapping the identity multiplicative homomorphism on a set Î± is equivalent to the identity monoid homomorphism on the set Î± with an additional element.",
    "output": "theorem map_id : map (MulHom.id Î±) = MonoidHom.id (WithOne Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"a commutes with the inverse of u if and only if a commutes with u\".",
    "output": "theorem units_inv_right_iff : Commute a â†‘uâ»Â¹ â†” Commute a u :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'ofNat' for the product of two natural numbers is equal to the 'unpair' function.",
    "output": "theorem prod_nat_ofNat : ofNat (â„• Ã— â„•) = unpair :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any objects X' and Y' in category C and any morphism g from X' to Y' that has a kernel, if the functor G maps g and preserves the limit of the parallel pair (g, 0), then for any morphisms p from X to X' and q from Y to Y' such that the composition of f and q equals the composition of p and g, the composition of the kernel map of G.map f and G.map g with G.map p and G.map q (where the equality is proven by rewriting the composition using the functor G) and the inverse of the isomorphism that preserves the kernel of G is equal to the composition of the inverse of the isomorphism that preserves the kernel of G and the G.map of the kernel map of f and g with p and q.",
    "output": "theorem kernel_map_comp_preserves_kernel_iso_inv {X' Y' : C} (g : X' âŸ¶ Y') [HasKernel g]\n    [HasKernel (G.map g)] [PreservesLimit (parallelPair g 0) G] (p : X âŸ¶ X') (q : Y âŸ¶ Y')\n    (hpq : f â‰« q = p â‰« g) :\n    kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [â† G.map_comp, hpq, G.map_comp]) â‰«\n        (PreservesKernel.iso G _).inv =\n      (PreservesKernel.iso G _).inv â‰« G.map (kernel.map f g p q hpq) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If m and n are odd numbers, then the difference between m and n is an even number.",
    "output": "theorem Odd.sub_odd (hm : Odd m) (hn : Odd n) : Even (m - n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all natural numbers n and p, if p is a prime number, then p divides the factorial of n if and only if p is less than or equal to n.",
    "output": "theorem Prime.dvd_factorial : âˆ€ {n p : â„•} (_ : Prime p), p âˆ£ n ! â†” p â‰¤ n"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'd' of type Î± and two elements 'x' and 'y' of type WithBot Î±, the function 'unbot'' applied to 'd' and 'x' equals the function 'unbot'' applied to 'd' and 'y' if and only if 'x' equals 'y' or 'x' equals 'd' and 'y' equals bottom or 'x' equals bottom and 'y' equals 'd'.",
    "output": "theorem unbot'_eq_unbot'_iff {d : Î±} {x y : WithBot Î±} :\n    unbot' d x = unbot' d y â†” x = y âˆ¨ x = d âˆ§ y = âŠ¥ âˆ¨ x = âŠ¥ âˆ§ y = d :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given natural number 'n' which is greater than 0, and any two elements 'a' and 'x' of a ring 'R', 'x' is a member of the nth roots of 'a' if and only if 'x' raised to the power 'n' equals 'a'.",
    "output": "theorem mem_nthRoots {n : â„•} (hn : 0 < n) {a x : R} : x âˆˆ nthRoots n a â†” x ^ n = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a finite configuration of points P and lines L, for any given point p, the count of lines through that point is equal to the order of the configuration plus one.",
    "output": "theorem lineCount_eq [Finite P] [Finite L] (p : P) : lineCount L p = order P L + 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the theorem, assuming that R is an integral domain and x is a non-zero element of R, the product of an ideal I and the principal ideal generated by x equals the product of another ideal J and the principal ideal generated by x if and only if I equals J.",
    "output": "theorem span_singleton_mul_left_inj [IsDomain R] {x : R} (hx : x â‰  0) :\n    I * span {x} = J * span {x} â†” I = J :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' in the field 'F' is star-convex with respect to a linear map 'f' from 'E' to 'F' at a point 'f(x)', then the preimage of the set 's' under the function 'f' is star-convex at the point 'x' in the field 'ğ•œ'.",
    "output": "theorem StarConvex.linear_preimage {s : Set F} (f : E â†’â‚—[ğ•œ] F) (hs : StarConvex ğ•œ (f x) s) :\n    StarConvex ğ•œ x (s.preimage f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any finite type Î¹ and an affine basis b of Î¹ in real numbers and V, the centroid of the universal set with respect to real numbers and b is in the interior of the convex hull of the range of b with respect to real numbers.",
    "output": "theorem AffineBasis.centroid_mem_interior_convexHull {Î¹} [Fintype Î¹] (b : AffineBasis Î¹ â„ V) :\n    Finset.univ.centroid â„ b âˆˆ interior (convexHull â„ (range b)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If J is an element of Ï€, then the distortion of J is less than or equal to the distortion of Ï€.",
    "output": "theorem distortion_le_of_mem (h : J âˆˆ Ï€) : J.distortion â‰¤ Ï€.distortion :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a semilattice structure of type Î³, a set is bounded below by the union of sets s and t if and only if both set s and set t are bounded below.",
    "output": "theorem bddBelow_union [SemilatticeInf Î³] {s t : Set Î³} :\n    BddBelow (s âˆª t) â†” BddBelow s âˆ§ BddBelow t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A vector 'v' is in the vector span of the set range of a function 'p' if and only if there exists a finite set 's' and a function 'w' such that the sum of 'w i' for all 'i' in 's' equals zero, and 'v' equals the weighted difference of 's' with respect to 'p' and 'w'.",
    "output": "theorem mem_vectorSpan_iff_eq_weightedVSub {v : V} {p : Î¹ â†’ P} :\n    v âˆˆ vectorSpan k (Set.range p) â†”\n      âˆƒ (s : Finset Î¹) (w : Î¹ â†’ k) (_ : (âˆ‘ i in s, w i) = 0), v = s.weightedVSub p w :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The bounded limit superior of a function 'f' for a sequence 'u' where the property 'p' or 'q' holds is equal to the supremum of the bounded limit superior of 'f' for 'u' where 'p' holds and the bounded limit superior of 'f' for 'u' where 'q' holds.",
    "output": "theorem blimsup_or_eq_sup : (blimsup u f fun x => p x âˆ¨ q x) = blimsup u f p âŠ” blimsup u f q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of elements of type 'M' and an element 'x' of type 'M', given the conditions 'h_one' and 'h_mul', 'x' is an element of the submonoid created from 's' with 'h_mul' and 'h_one' if and only if 'x' is an element of 's'.",
    "output": "theorem mem_mk {s : Set M} {x : M} (h_one) (h_mul) : x âˆˆ mk âŸ¨s, h_mulâŸ© h_one â†” x âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'lowerClosure', which maps a set of elements of type Î± to a lower set of Î±, is monotone. This means that if one set is a subset of another, the lower closure of the first set is also a subset of the lower closure of the second set.",
    "output": "theorem lowerClosure_mono : Monotone (lowerClosure : Set Î± â†’ LowerSet Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a relation 'r' on a set 'Î²', given that 'r' is transitive, and a function 'f' from natural numbers to 'Î²', and a natural number 'a', if for all natural numbers 'n' greater than or equal to 'a', 'r' holds between 'f(n)' and 'f(n+1)', then for any two natural numbers 'b' and 'c' such that 'b' is greater than or equal to 'a' and 'c' is strictly greater than 'b', 'r' holds between 'f(b)' and 'f(c)'.",
    "output": "theorem Nat.rel_of_forall_rel_succ_of_le_of_lt (r : Î² â†’ Î² â†’ Prop) [IsTrans Î² r] {f : â„• â†’ Î²} {a : â„•}\n    (h : âˆ€ n, a â‰¤ n â†’ r (f n) (f (n + 1))) â¦ƒb c : â„•â¦„ (hab : a â‰¤ b) (hbc : b < c) :\n    r (f b) (f c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'polarCoord.symm' has a FrÃ©chet derivative at a point 'p' in the real plane. The derivative is given by the continuous linear map corresponding to the matrix with entries 'cos p.2', '-p.1 * sin p.2', 'sin p.2', and 'p.1 * cos p.2'.",
    "output": "theorem hasFDerivAt_polarCoord_symm (p : â„ Ã— â„) :\n    HasFDerivAt polarCoord.symm\n      (LinearMap.toContinuousLinearMap (Matrix.toLin (Basis.finTwoProd â„) (Basis.finTwoProd â„)\n        !![cos p.2, -p.1 * sin p.2; sin p.2, p.1 * cos p.2])) p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' that maps from type Î± to type Î², a term 't' of type Î±, and a list 'ts' of type Î±, mapping 'f' over the list of permutations of 't' and 'ts' is equal to the list of permutations of 'f t' and the list obtained by mapping 'f' over 'ts'.",
    "output": "theorem map_map_permutations'Aux (f : Î± â†’ Î²) (t : Î±) (ts : List Î±) :\n    map (map f) (permutations'Aux t ts) = permutations'Aux (f t) (map f ts) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a positive number y, the square root of x equals y if and only if the square of y equals x.",
    "output": "theorem sqrt_eq_iff_mul_self_eq_of_pos (h : 0 < y) : sqrt x = y â†” y * y = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any set 's' of any type 'Î±', 's' is countable if and only if the cardinality of 's' is less than aleph one.",
    "output": "theorem countable_iff_lt_aleph_one {Î± : Type _} (s : Set Î±) : s.Countable â†” (#s) < aleph 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'f' from 'Î±' to the dual of 'Î²' is antitone on a set 's' if and only if the function 'f' is monotone on the set 's'.",
    "output": "theorem antitoneOn_toDual_comp_iff : AntitoneOn (toDual âˆ˜ f : Î± â†’ Î²áµ’áµˆ) s â†” MonotoneOn f s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given box I, there exists a sequence of boxes J indexed by natural numbers, such that for every natural number n, the closed interval of the box J at index n is a subset of the open interval of box I. Furthermore, the lower bound of the sequence of boxes J tends to the lower bound of box I, and the upper bound of the sequence of boxes J tends to the upper bound of box I.",
    "output": "theorem exists_seq_mono_tendsto (I : Box Î¹) :\n    âˆƒ J : â„• â†’o Box Î¹,\n      (âˆ€ n, Box.Icc (J n) âŠ† Box.Ioo I) âˆ§\n        Tendsto (lower âˆ˜ J) atTop (ğ“ I.lower) âˆ§ Tendsto (upper âˆ˜ J) atTop (ğ“ I.upper) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If Î± is a preconnected space and i is a dense inducing function, then Î² is also a preconnected space.",
    "output": "theorem preconnectedSpace [PreconnectedSpace Î±] (di : DenseInducing i) :\n    PreconnectedSpace Î² :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is congruent to b modulo p, then a minus c is congruent to b minus c modulo p.",
    "output": "theorem sub_right (c : Î±) (h : a â‰¡ b [PMOD p]) : a - c â‰¡ b - c [PMOD p] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a pair 'p' from the product of two sets 'Î±' and 'Î²', and an element 'c' from set 'E', the power of 'p' to 'c' is equal to the pair formed by the power of the first element of 'p' to 'c' and the power of the second element of 'p' to 'c'.",
    "output": "theorem pow_def (p : Î± Ã— Î²) (c : E) : p ^ c = (p.1 ^ c, p.2 ^ c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function `f` composed with a continuous linear equivalence `e` is continuously differentiable within a set `s` at the point `e.symm x` if and only if the function `f` itself is continuously differentiable within the set `s` at the point `x`. Here, `ğ•œ` is the field over which the functions are defined and `n` is the order of differentiation.",
    "output": "theorem ContinuousLinearEquiv.contDiffWithinAt_comp_iff (e : G â‰ƒL[ğ•œ] E) :\n    ContDiffWithinAt ğ•œ n (f âˆ˜ e) (e â»Â¹' s) (e.symm x) â†” ContDiffWithinAt ğ•œ n f s x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of type 'A', getting the constant from the object created by making 'x' a constant of type 'n' and 'A' is equal to 'x'.",
    "output": "theorem const.get_mk (x : A) : const.get (const.mk n x : (const n A).Obj Î±) = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The ring R is of finite type over itself.",
    "output": "theorem self : FiniteType R R :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"0\" is a strictly multiplicative regular element in the algebraic structure M over the ring R if and only if M is a subsingleton.",
    "output": "theorem zero_iff_subsingleton : IsSMulRegular M (0 : R) â†” Subsingleton M :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the norm of the difference between the (n + 1)th term and the nth term of the Newton sequence is equal to the ratio of the norm of the evaluation of the function 'F' at the nth term of the Newton sequence to the norm of the evaluation of the derivative of the function 'F' at the nth term of the Newton sequence.",
    "output": "theorem newton_seq_norm_eq (n : â„•) :\n    â€–newton_seq (n + 1) - newton_seq nâ€– =\n    â€–F.eval (newton_seq n)â€– / â€–F.derivative.eval (newton_seq n)â€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'c' has a strict derivative 'c'' at a point 'x', and a function 'd' has a strict derivative 'd'' at the same point 'x', then the composition of the function 'c' with the function 'd' also has a strict derivative at the point 'x'. This derivative is the sum of the composition of 'c'' with 'd' at 'x' and the composition of 'c' at 'x' with 'd''.",
    "output": "theorem HasStrictDerivAt.clm_comp (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'a' belongs to set 's' and an element 'b' belongs to set 't', then the scalar multiplication of 'a' and 'b' belongs to the scalar multiplication of sets 's' and 't'.",
    "output": "theorem smul_mem_smul : a âˆˆ s â†’ b âˆˆ t â†’ a â€¢ b âˆˆ s â€¢ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a natural number 'n' is less than or equal to the ramification index of a function 'f', a prime 'p', and a prime ideal 'P', then the map of 'f' and 'p' is less than or equal to 'P' raised to the power of 'n'.",
    "output": "theorem le_pow_of_le_ramificationIdx {n : â„•} (hn : n â‰¤ ramificationIdx f p P) :\n    map f p â‰¤ P ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If two local equivalences 'e' and 'e'' are equivalent, then the restrictions of 'e' and 'e'' to a set 's' are also equivalent.",
    "output": "theorem EqOnSource.restr {e e' : LocalEquiv Î± Î²} (he : e â‰ˆ e') (s : Set Î±) :\n    e.restr s â‰ˆ e'.restr s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'g' is integrable with respect to the measure 'Î¼' mapped by a function 'f' if and only if the composition of 'g' and 'f' is integrable with respect to the measure 'Î¼'.",
    "output": "theorem integrable_map_equiv (f : Î± â‰ƒáµ Î´) (g : Î´ â†’ Î²) :\n    Integrable g (Measure.map f Î¼) â†” Integrable (g âˆ˜ f) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is the complement of 'b', then 'a' is equal to the negation of 'b'.",
    "output": "theorem IsCompl.eq_hnot (h : IsCompl a b) : a = ï¿¢b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a ring R, if x is nilpotent, then its negation (-x) is also nilpotent.",
    "output": "theorem IsNilpotent.neg [Ring R] (h : IsNilpotent x) : IsNilpotent (-x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'a' belongs to the intersection of two finite sets 'sâ‚' and 'sâ‚‚', then 'a' belongs to the set 'sâ‚‚'.",
    "output": "theorem mem_of_mem_inter_right {a : Î±} {sâ‚ sâ‚‚ : Finset Î±} (h : a âˆˆ sâ‚ âˆ© sâ‚‚) : a âˆˆ sâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'a' is equivalent to 'b' modulo 'p' if and only if the interval from 'a' to 'b' modulo 'p', where 'p' is positive, is equal to 'a' plus 'p'.",
    "output": "theorem modEq_iff_toIocMod_eq_right : a â‰¡ b [PMOD p] â†” toIocMod hp a b = a + p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If I and J are primary ideals in a ring R, and if the radical of I is equal to the radical of J, then the intersection of I and J is also a primary ideal.",
    "output": "theorem isPrimary_inf {I J : Ideal R} (hi : IsPrimary I) (hj : IsPrimary J)\n    (hij : radical I = radical J) : IsPrimary (I âŠ“ J) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two additive commutative monoids M and N, and a function 'f' from Î± to the monoid homomorphisms from M to N, and any element 'a' of Î±, the composition of the liftAddHom function (with respect to Î±, M, and N) applied to 'f' and the singleAddHom function applied to 'a' is equal to the function 'f' applied to 'a'.",
    "output": "theorem liftAddHom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : Î± â†’ M â†’+ N) (a : Î±) :\n    ((liftAddHom (Î± := Î±) (M := M) (N := N)) f).comp (singleAddHom a) = f a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a property P lifts within a set s at a point x for a function g, and if the set s is in the neighborhood of x, then the property P lifts at the point x for the function g.",
    "output": "theorem liftPropAt_of_liftPropWithinAt (h : LiftPropWithinAt P g s x) (hs : s âˆˆ ğ“ x) :\n    LiftPropAt P g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A number x is in the closed interval between a and b if and only if x is greater than or equal to a and less than or equal to b.",
    "output": "theorem mem_Icc : x âˆˆ Icc a b â†” a â‰¤ x âˆ§ x â‰¤ b :="
  },
  {
    "instruction": "1. For all h where h is less than the length of list l, R applies to a and the nth element of list l where n is 0.",
    "input": "A chain R exists from a to list l if and only if the following two conditions are met:",
    "output": "theorem chain_iff_nthLe {R} {a : Î±} {l : List Î±} : Chain R a l â†”\n        (âˆ€ h : 0 < length l, R a (nthLe l 0 h)) âˆ§\n          âˆ€ (i) (h : i < length l - 1),\n            R (nthLe l i (lt_of_lt_pred h)) (nthLe l (i + 1) (lt_pred_iff.mp h)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' in set 'S', 'x' being equal to zero in set 'A' is equivalent to 'x' being zero in set 'S'.",
    "output": "theorem coe_eq_zero {x : S} : (x : A) = 0 â†” x = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions, one from Î² to Î³ and another from Î± to Î², the composition of the two functions after mapping over Sym2 is equal to the composition of the mapping of each function over Sym2.",
    "output": "theorem map_comp {g : Î² â†’ Î³} {f : Î± â†’ Î²} : Sym2.map (g âˆ˜ f) = Sym2.map g âˆ˜ Sym2.map f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The imaginary part of the negation of a quaternion 'a' is equal to the negation of the imaginary part of 'a'.",
    "output": "theorem neg_imI : (-a).imI = -a.imI :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any summable family (s, t) of elements in the set of real numbers (R) indexed by a set (Î±) and ordered by a set (Î“), the sum of the summable families at a particular index (a) is equal to the sum of the individual summable families at that same index.",
    "output": "theorem add_apply {s t : SummableFamily Î“ R Î±} {a : Î±} : (s + t) a = s a + t a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer 'n' and any type 'Î±' that can be cast to an integer, casting 'n' to 'Î±' using the 'ofDual' function will result in 'n'.",
    "output": "theorem ofDual_intCast [IntCast Î±] (n : â„¤) : (ofDual n : Î±) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of a uniform space F and a uniform add group F, for a given set ğ”– of sets of E, the topological space derived from the strong uniformity of Ïƒ, F, and ğ”– is equal to the strong topology of Ïƒ, F, and ğ”–.",
    "output": "theorem strongUniformity_topology_eq [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    (strongUniformity Ïƒ F ğ”–).toTopologicalSpace = strongTopology Ïƒ F ğ”– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero scalar 's', 's' times 'x' is an element of 'p' if and only if 'x' is an element of 'p'.",
    "output": "theorem smul_mem_iff (s0 : s â‰  0) : s â€¢ x âˆˆ p â†” x âˆˆ p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The real number r, when converted to a non-negative extended real number, equals 1 if and only if r itself equals 1.",
    "output": "theorem coe_eq_one : (â†‘r : â„â‰¥0âˆ) = 1 â†” r = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' from the ring 'R', the valuation of the negative of 'x' is equal to the valuation of 'x'.",
    "output": "theorem map_neg (x : R) : v (-x) = v x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The spectrum of a continuous function 'f' from a topological space 'X' to a field 'ğ•œ' is equal to the set of all possible values of 'f'.",
    "output": "theorem spectrum_eq_range (f : C(X, ğ•œ)) : spectrum ğ•œ f = Set.range f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The equivalence class of the negation of an element 'x' in the quotient space 'M / p' is equal to the negation of the equivalence class of 'x' in the same quotient space.",
    "output": "theorem mk_neg : (mk (-x) : M â§¸ p) = -(mk x : M â§¸ p) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The successor of the negative of the successor of a natural number n is equal to the negative of n.",
    "output": "theorem succ_neg_nat_succ (n : â„•) : succ (-Nat.succ n) = -n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'toSubmonoid', which maps from a subgroup of G to a submonoid of G, is injective. This means that if two subgroups are mapped to the same submonoid by this function, then those two subgroups were originally the same. The proof of this theorem is not shown here.",
    "output": "theorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G â†’ Submonoid G) :=\n  -- fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'x' is a fixed point of a function 'e', then 'x' is also a fixed point of the inverse function of 'e'.",
    "output": "theorem equiv_symm (h : IsFixedPt e x) : IsFixedPt e.symm x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any nonempty directed set Î¹, given a morphism F from the direct limit of a system (G, f) to a ring P, and any element x, the value of F at x is equal to the lift of the system (G, f) to P, composed with F, evaluated at x. This holds true for all i and j in Î¹ such that i is less than or equal to j, and for all elements x, where the function of f is simplified.",
    "output": "theorem lift_unique [Nonempty Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)] (F : DirectLimit G f â†’+* P) (x) :\n    F x = lift G f P (fun i => F.comp <| of G f i) (fun i j hij x => by simp [of_f]) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' and any element 'a'' with a corresponding value 'b'' of type Î², and any associative list 's', 'a' is in the list resulting from inserting 'a'' and 'b'' into 's' if and only if 'a' is equal to 'a'' or 'a' is in 's'.",
    "output": "theorem mem_insert {a a'} {b' : Î² a'} (s : AList Î²) : a âˆˆ insert a' b' s â†” a = a' âˆ¨ a âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given ring homomorphism 'f' from ring 'R' to ring 'S' and a polynomial 'p' with coefficients in 'R', the evaluation of the mapped polynomial at 1 is equal to the mapping of the evaluation of the original polynomial at 1.",
    "output": "theorem eval_one_map (f : R â†’+* S) (p : R[X]) : (p.map f).eval 1 = f (p.eval 1) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the finite rank of a module V over a field K is equal to one, then the order of the submodule of V over a semiring A is simple. This is under the conditions that A is a semiring, V is a module over A, there is a scalar multiplication operation between K and A, and K, A, V form a scalar tower.",
    "output": "theorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A]\n    [IsScalarTower K A V] (h : finrank K V = 1) : IsSimpleOrder (Submodule A V) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The application of the identity algebra homomorphism on a ring R and an algebra A is equal to the identity function.",
    "output": "theorem coe_id : â‡‘(AlgHom.id R A) = id :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any nonempty index set, the intersection of a set with the intersection over all sets indexed by the index set is equal to the intersection over all sets of the intersection of the set with each set indexed by the index set.",
    "output": "theorem inter_iInter [Nonempty Î¹] (s : Set Î²) (t : Î¹ â†’ Set Î²) : (s âˆ© â‹‚ i, t i) = â‹‚ i, s âˆ© t i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a countable index set Î² and a function f from Î² to the set of subsets of Î±, if every pair of sets in the image of f is disjoint and each set in the image of f is measurable, then the countable union of the sets in the image of f is also measurable.",
    "output": "theorem has_iUnion {Î²} [Countable Î²] {f : Î² â†’ Set Î±} (hd : Pairwise (Disjoint on f))\n    (h : âˆ€ i, d.Has (f i)) : d.Has (â‹ƒ i, f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for a functor 'F' from category 'C' to category 'D', every object 'X' in 'C' is mapped to a zero object in 'D', then the functor 'F' itself is a zero functor.",
    "output": "theorem Functor.isZero (F : C â¥¤ D) (hF : âˆ€ X, IsZero (F.obj X)) : IsZero F :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a topological space Î², which is also a complete lattice and an order-closed topology with zero, and a measurable space that is an open measurable space, given a function i from natural numbers to Î², a function f from Î± to Î², and an element a of Î±, if f is measurable and zero in Î² is the bottom element, then the supremum over n of the application of the approximated function i to f at n and a is equal to the supremum over k of i at k, given that i at k is less than or equal to f at a.",
    "output": "theorem iSup_approx_apply [TopologicalSpace Î²] [CompleteLattice Î²] [OrderClosedTopology Î²] [Zero Î²]\n    [MeasurableSpace Î²] [OpensMeasurableSpace Î²] (i : â„• â†’ Î²) (f : Î± â†’ Î²) (a : Î±) (hf : Measurable f)\n    (h_zero : (0 : Î²) = âŠ¥) : (â¨† n, (approx i f n : Î± â†’â‚› Î²) a) = â¨† (k) (_ : i k â‰¤ f a), i k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is upper semicontinuous at a point 'x' within a set 's', and if another set 't' is a subset of 's', then the function 'f' is also upper semicontinuous at the point 'x' within the set 't'.",
    "output": "theorem UpperSemicontinuousWithinAt.mono (h : UpperSemicontinuousWithinAt f s x) (hst : t âŠ† s) :\n    UpperSemicontinuousWithinAt f t x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The range function is monotone.",
    "output": "theorem range_mono : Monotone range :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functions 'f' and 'g' from 'Î±' to 'Î²' and a point 'a' in 'Î±', if 'f' is eventually equal to 'g' in the neighborhood of 'a', then for all points 'y' in the neighborhood of 'a', 'f' is eventually equal to 'g' in the neighborhood of 'y'.",
    "output": "theorem Filter.EventuallyEq.eventuallyEq_nhds {f g : Î± â†’ Î²} {a : Î±} (h : f =á¶ [ğ“ a] g) :\n    âˆ€á¶  y in ğ“ a, f =á¶ [ğ“ y] g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given relation 'r' on some type 'Î±' and any multiset 's' of quotients of 'r', there exists a multiset 't' of type 'Î±' such that 's' is equal to the multiset obtained by mapping the function 'Quot.mk r' over 't'.",
    "output": "theorem exists_multiset_eq_map_quot_mk {r : Î± â†’ Î± â†’ Prop} (s : Multiset (Quot r)) :\n    âˆƒ t : Multiset Î±, s = t.map (Quot.mk r) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-unital non-associative semiring Î±, a matrix A with dimensions Fin l by Fin m, and a vector v of dimension Fin m, the right multiplication of the matrix A by the vector v is equal to the multiplication of the matrix A by the vector v.",
    "output": "theorem mulVecáµ£_eq [NonUnitalNonAssocSemiring Î±] (A : Matrix (Fin l) (Fin m) Î±) (v : Fin m â†’ Î±) :\n    mulVecáµ£ A v = A.mulVec v :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for all indices 'i' and 'hi', the function 'f' is monotone, then the function 'nfpBFamily' parameterized by 'o' and 'f' is also monotone.",
    "output": "theorem nfpBFamily_monotone (hf : âˆ€ i hi, Monotone (f i hi)) : Monotone (nfpBFamily.{u, v} o f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any nonempty interval 's' of type 'Î±', the corresponding set 's' of type 'Î±' is also nonempty.",
    "output": "theorem coe_nonempty (s : NonemptyInterval Î±) : (s : Set Î±).Nonempty :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is measurable in the supremum of a collection of measurable spaces (indexed by 'Î¹' and mapped by 'm') if and only if 's' is generated by the collection of sets that are measurable in some measurable space in the collection.",
    "output": "theorem measurableSet_iSup {Î¹} {m : Î¹ â†’ MeasurableSpace Î±} {s : Set Î±} :\n    MeasurableSet[iSup m] s â†” GenerateMeasurable { s : Set Î± | âˆƒ i, MeasurableSet[m i] s } s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'f' from a module 'M' to itself, if 'f' is a projection on 'm', then the kernel of the codomain restriction of 'f' is equal to the kernel of 'f'.",
    "output": "theorem codRestrict_ker {f : M â†’â‚—[S] M} (h : IsProj m f) : ker h.codRestrict = ker f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the first element of a pair (x) is equal to the first element of another pair (y), then the pairs x and y are equal.",
    "output": "theorem eq_of_fst_eq_fst (h : (x : Î± Ã— Î±).fst = (y : Î± Ã— Î±).fst) : x = y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a contravariant class of type Î±, if 'a' is not the bottom element and 'a + b' is less than or equal to 'a + c', then 'b' is less than or equal to 'c'.",
    "output": "theorem le_of_add_le_add_left [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (ha : a â‰  âŠ¥)\n    (h : a + b â‰¤ a + c) : b â‰¤ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'b' is equivalent to 'a', then 'a' is equivalent to 'b'.",
    "output": "theorem bihimp_bihimp_cancel_right : b â‡” a â‡” a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function g from real numbers to a normed space F, and a real number R that is not equal to zero, the function g is integrable if and only if the function that maps x to g(x/R) is integrable.",
    "output": "theorem integrable_comp_div_iff (g : â„ â†’ F) {R : â„} (hR : R â‰  0) :\n    (Integrable fun x => g (x / R)) â†” Integrable g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is the greatest lower bound of a set 's' and 'Îµ' is a positive number, then there exists a number 'b' in the set 's' such that 'b' is greater than or equal to 'a' and less than 'a + Îµ'.",
    "output": "theorem IsGLB.exists_between_self_add (h : IsGLB s a) (hÎµ : 0 < Îµ) : âˆƒ b âˆˆ s, a â‰¤ b âˆ§ b < a + Îµ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The functor Î“ from some category to C is equal to the composition of the functor forgetToPresheafedSpace.op and the functor PresheafedSpace.Î“.",
    "output": "theorem Î“_def : (Î“ : _ â¥¤ C) = forgetToPresheafedSpace.op â‹™ PresheafedSpace.Î“ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the product of two filters 'f' and 'g' is not the bottom filter, then 'f' is not the bottom filter.",
    "output": "theorem NeBot.of_mul_left : (f * g).NeBot â†’ f.NeBot :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given point 'y' in the set 'E' and any real number 'Îµ', the open ball centered at 'y' with radius 'Îµ' is equal to the set of all points 'x' such that the norm of 'x' divided by 'y' is less than 'Îµ'.",
    "output": "theorem ball_eq' (y : E) (Îµ : â„) : ball y Îµ = { x | â€–x / yâ€– < Îµ } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Applying the zero derivation (from a ring R to an A-module M) to any element (a) of A results in the zero element of M.",
    "output": "theorem zero_apply (a : A) : (0 : Derivation R A M) a = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have two types J and K, both of which are categories, and two functors F and G from J and K respectively to a category C, and if the cones over F are isomorphic to the cones over G, then if F has a limit, G also has a limit.",
    "output": "theorem HasLimit.ofConesIso {J K : Type uâ‚} [Category.{vâ‚} J] [Category.{vâ‚‚} K] (F : J â¥¤ C)\n    (G : K â¥¤ C) (h : F.cones â‰… G.cones) [HasLimit F] : HasLimit G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An element 'x' belongs to the kernel of the cotangent map of 'I' if and only if this element, considered as an element of 'R', belongs to the square of 'I'.",
    "output": "theorem mem_toCotangent_ker {x : I} : x âˆˆ LinearMap.ker I.toCotangent â†” (x : R) âˆˆ I ^ 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type S, which is a commutative ring and a local ring, and a given ring homomorphism f from R to S, f is a local ring homomorphism if and only if the preimage of the closed point of S under the map f is equal to the closed point of R.",
    "output": "theorem isLocalRingHom_iff_comap_closedPoint {S : Type v} [CommRing S] [LocalRing S] (f : R â†’+* S) :\n    IsLocalRingHom f â†” PrimeSpectrum.comap f (closedPoint S) = closedPoint R :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse of the fraction formed by two integers 'a' and 'b' is equal to the fraction formed by 'b' and 'a'.",
    "output": "theorem inv_def' {a b : â„¤} : (a /. b)â»Â¹ = b /. a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two topological spaces X and Y that are isomorphic, and for presheaves â„± on Y and ğ’¢ on X, if there is a morphism from â„± to the pushforward of ğ’¢ along the isomorphism, then the application of the pushforward of the isomorphism and the morphism to an open set U in X is equal to the composition of the application of the morphism to the image of U under the inverse of the isomorphism and the mapping of ğ’¢ to the homomorphism induced by the equality of the preimage of the preimage of the open set under the isomorphism and the open set itself.",
    "output": "theorem pushforwardToOfIso_app {X Y : TopCat} (Hâ‚ : X â‰… Y) {â„± : Y.Presheaf C} {ğ’¢ : X.Presheaf C}\n    (Hâ‚‚ : â„± âŸ¶ Hâ‚.hom _* ğ’¢) (U : (Opens X)áµ’áµ–) :\n    (pushforwardToOfIso Hâ‚ Hâ‚‚).app U =\n      Hâ‚‚.app (op ((Opens.map Hâ‚.inv).obj (unop U))) â‰«\n        ğ’¢.map (eqToHom (by simp [Opens.map, Set.preimage_preimage])) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given ideal J of a ring P, where J is prime, and a given ring homomorphism f from ring R to P, the complement of the prime ideal I is less than or equal to the complement of the prime ideal J under the map f if and only if the preimage of J under f is less than or equal to I.",
    "output": "theorem le_comap_primeCompl_iff {J : Ideal P} [hJ : J.IsPrime] {f : R â†’+* P} :\n    I.primeCompl â‰¤ J.primeCompl.comap f â†” J.comap f â‰¤ I :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given value 'x' in a preordered set 'Î±' with no maximum order, the set of all elements greater than or equal to some value (atTop) is disjoint from the set of all elements less than or equal to 'x' (ğ“Ÿ (Iic x)).",
    "output": "theorem disjoint_atTop_principal_Iic [Preorder Î±] [NoMaxOrder Î±] (x : Î±) :\n    Disjoint atTop (ğ“Ÿ (Iic x)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is less than or equal to 'b', then the union of the set of all numbers less than 'a' and the set of all numbers between 'a' and 'b' (inclusive) is equal to the set of all numbers less than or equal to 'b'.",
    "output": "theorem Iio_union_Icc_eq_Iic (h : a â‰¤ b) : Iio a âˆª Icc a b = Iic b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' of a set 'Î±' and any integer 'm', the function 'toIocMod' applied to the sum of 'a' and the scalar product of 'm' and 'p' and 'b' is equal to the sum of the function 'toIocMod' applied to 'a' and 'b' and the scalar product of 'm' and 'p'.",
    "output": "theorem toIocMod_add_zsmul' (a b : Î±) (m : â„¤) :\n    toIocMod hp (a + m â€¢ p) b = toIocMod hp a b + m â€¢ p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a surjective function 'f' from group G to group H, if N is the kernel of 'f' and N is a torsion group, then group H is a torsion group if and only if group G is a torsion group.",
    "output": "theorem IsTorsion.quotient_iff {f : G â†’* H} (hf : Function.Surjective f) (hN : N = f.ker)\n    (tN : IsTorsion N) : IsTorsion H â†” IsTorsion G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a NoMaxOrder (an ordered set where no maximum element exists), the set of all elements greater than a given element 'a' is connected.",
    "output": "theorem isConnected_Ioi [NoMaxOrder Î±] : IsConnected (Ioi a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a category 'C' that has equalizers, given a set 'ğ’¢' in 'C', if 'ğ’¢' is a detecting set, then 'ğ’¢' is also a separating set.",
    "output": "theorem IsDetecting.isSeparating [HasEqualizers C] {ğ’¢ : Set C} (hğ’¢ : IsDetecting ğ’¢) :\n    IsSeparating ğ’¢ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î± and Î², given that Î± is infinite, the cardinality of the sum of Î± and Î² is equal to the maximum of the cardinalities of Î± and Î².",
    "output": "theorem add_mk_eq_max {Î± Î² : Type _} [Infinite Î±] : (#Î±) + (#Î²) = max (#Î±) (#Î²) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two ring homomorphisms 'f' and 'g' from a ring 'R' to a ring 'S', and a set 's' of elements from 'R', if 'f' and 'g' are equal on the set 's', then 'f' and 'g' are also equal on the closure of the set 's'.",
    "output": "theorem eqOn_sclosure {f g : R â†’+* S} {s : Set R} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three points p1, p2, and p3, where p1 is not equal to p2 and p3 is not equal to p2, the distance from p1 to p3 is equal to the sum of the distance from p1 to p2 and the distance from p3 to p2 if and only if the unoriented angle between p1, p2, and p3 is equal to pi.",
    "output": "theorem dist_eq_add_dist_iff_angle_eq_pi {p1 p2 p3 : P} (hp1p2 : p1 â‰  p2) (hp3p2 : p3 â‰  p2) :\n    dist p1 p3 = dist p1 p2 + dist p3 p2 â†” âˆ  p1 p2 p3 = Ï€ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type G that forms a group, given two group actions fâ‚ and fâ‚‚ from G to CircleDeg1Lift (a type of group action on the circle), if for all elements g in G the translation number of fâ‚ g equals the translation number of fâ‚‚ g, then there exists a semiconjugacy F from CircleDeg1Lift such that for all elements g in G, F semiconjugates fâ‚ g to fâ‚‚ g.",
    "output": "theorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type _} [Group G]\n    (fâ‚ fâ‚‚ : G â†’* CircleDeg1Lift) (h : âˆ€ g, Ï„ (fâ‚ g) = Ï„ (fâ‚‚ g)) :\n    âˆƒ F : CircleDeg1Lift, âˆ€ g, Semiconj F (fâ‚ g) (fâ‚‚ g) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' mapping from a set 'Î¹' to a set 'Î±', and a set 's' of 'Î¹' that is finite, if every element 'b' in 's' maps to a null measurable set under 'f' with respect to a measure 'Î¼', then the intersection of all these mapped sets is also a null measurable set with respect to the same measure 'Î¼'.",
    "output": "theorem _root_.Set.Finite.nullMeasurableSet_biInter {f : Î¹ â†’ Set Î±} {s : Set Î¹} (hs : s.Finite)\n    (h : âˆ€ b âˆˆ s, NullMeasurableSet (f b) Î¼) : NullMeasurableSet (â‹‚ b âˆˆ s, f b) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all elements x in the union of list 1 and list 2, the property p holds if and only if for all elements x in list 1, the property p holds and for all elements x in list 2, the property p holds.",
    "output": "theorem forall_mem_union : (âˆ€ x âˆˆ lâ‚ âˆª lâ‚‚, p x) â†” (âˆ€ x âˆˆ lâ‚, p x) âˆ§ âˆ€ x âˆˆ lâ‚‚, p x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the set of elements greater than 'a' under the embedding of a subtype 'p' is equal to the set of elements greater than 'a' in the finset 'Î±'.",
    "output": "theorem map_subtype_embedding_Ioi : (Ioi a).map (Embedding.subtype p) = (Ioi a : Finset Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measure Î¼, a function f that is measurable, another function g, and a set s that is measurable, if for almost every x in the restriction of Î¼ to s, f(x) is less than infinity, then the integral over s of g with respect to the measure with density f is equal to the integral over s of the product of f and g with respect to Î¼.",
    "output": "theorem set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable (Î¼ : Measure Î±) {f : Î± â†’ â„â‰¥0âˆ}\n    (f_meas : Measurable f) (g : Î± â†’ â„â‰¥0âˆ) {s : Set Î±} (hs : MeasurableSet s)\n    (hf : âˆ€áµ x âˆ‚Î¼.restrict s, f x < âˆ) :\n    (âˆ«â» a in s, g a âˆ‚Î¼.withDensity f) = âˆ«â» a in s, (f * g) a âˆ‚Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given number 'n', the function that converts a vector to a list (Vector.toList) is computable.",
    "output": "theorem vector_toList {n} : Computable (@Vector.toList Î± n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given index set Î¹, if we have a family of submodules V of an inner product space E over a field ğ•œ, such that this family is orthogonal (meaning that the inner product of any two distinct submodules is zero), and the closure of the union of all submodules in the family is a complete set, then the direct sum of the submodules is an internal direct sum if and only if the orthogonal complement of the closure of the union of all submodules is the zero subspace.",
    "output": "theorem OrthogonalFamily.isInternal_iff_of_isComplete [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}\n    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢)\n    (hc : IsComplete (â†‘(iSup V) : Set E)) : DirectSum.IsInternal V â†” (iSup V)á—® = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given types R and A, where R is a commutative semiring and A is a semiring with an algebra structure over R, the bottom element of the subalgebra of R in A, when converted to a submodule, is finitely generated.",
    "output": "theorem _root_.Subalgebra.fg_bot_toSubmodule {R A : Type _} [CommSemiring R] [Semiring A]\n    [Algebra R A] : (âŠ¥ : Subalgebra R A).toSubmodule.FG :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a property 'p' pertaining to a set of elements of type 'Î±', if 's' is a subsingleton set (a set with at most one element), and if the property 'p' holds for the empty set and for any set containing exactly one element, then the property 'p' also holds for the set 's'.",
    "output": "theorem Subsingleton.induction_on {p : Set Î± â†’ Prop} (hs : s.Subsingleton) (he : p âˆ…)\n    (hâ‚ : âˆ€ x, p {x}) : p s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the rank of a module V over a field K is zero, then the finite dimension (finrank) of V over K is also zero. This is under the condition that V is finite-dimensional over K.",
    "output": "theorem finrank_eq_zero_of_rank_eq_zero [FiniteDimensional K V] (h : Module.rank K V = 0) :\n    finrank K V = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number N and any element Î³ of the group Gamma0 N, Î³ is an element of the group Gamma1' N if and only if the Gamma0Map of N applied to Î³ equals 1.",
    "output": "theorem Gamma1_mem' (N : â„•) (Î³ : Gamma0 N) : Î³ âˆˆ Gamma1' N â†” (Gamma0Map N) Î³ = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from the lp space with infinity norm, and a natural number 'n', the nth power of the function 'f' is equal to the function 'f' raised to the nth power.",
    "output": "theorem infty_coeFn_pow (f : lp B âˆ) (n : â„•) : â‡‘(f ^ n) = (â‡‘f) ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two vertices 'v' and 'w' in a graph 'G', the set of common neighbors of 'v' and 'w' is the same as the set of common neighbors of 'w' and 'v'. In other words, the common neighbors of two vertices in a graph are symmetric with respect to the vertices.",
    "output": "theorem commonNeighbors_symm (v w : V) : G.commonNeighbors v w = G.commonNeighbors w v :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A module 'm' is in the supremum of a chain of submodules 'a' indexed by natural numbers if and only if there exists a natural number 'k' such that 'm' is in the submodule 'a' at index 'k'.",
    "output": "theorem mem_iSup_of_chain (a : â„• â†’o Submodule R M) (m : M) : (m âˆˆ â¨† k, a k) â†” âˆƒ k, m âˆˆ a k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of subsets of a type 'Î±', given a topological space 't' and a second countable topology on 'Î±', if 't' is generated from 's', then the Borel Ïƒ-algebra on 'Î±' is also generated from 's'.",
    "output": "theorem borel_eq_generateFrom_of_subbasis {s : Set (Set Î±)} [t : TopologicalSpace Î±]\n    [SecondCountableTopology Î±] (hs : t = .generateFrom s) : borel Î± = .generateFrom s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any set s in a normed space E, and any non-negative real numbers Îµ and Î´, the Îµ-thickening of the Î´-thickening of s is equal to the (Îµ + Î´)-thickening of s.",
    "output": "theorem cthickening_cthickening (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (s : Set E) :\n    cthickening Îµ (cthickening Î´ s) = cthickening (Îµ + Î´) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of type 'Î±' that is not a member of set 's', and for any finite set 't' of type 'Î±', the set difference of 's' and the set obtained by inserting 'x' into 't' is equal to the set difference of 's' and 't'.",
    "output": "theorem sdiff_insert_of_not_mem {x : Î±} (h : x âˆ‰ s) (t : Finset Î±) : s \\ insert x t = s \\ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A property 'p' holds eventually for all elements 'x' in the supremum (or join) of two filters 'f' and 'g' if and only if the property 'p' holds eventually for all elements 'x' in both filters 'f' and 'g'.",
    "output": "theorem eventually_sup {p : Î± â†’ Prop} {f g : Filter Î±} :\n    (âˆ€á¶  x in f âŠ” g, p x) â†” (âˆ€á¶  x in f, p x) âˆ§ âˆ€á¶  x in g, p x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number x and for any two real numbers y and z, if z divides y, then the result of multiplying x with y and then dividing by z is equal to the result of multiplying x with the result of dividing y by z.",
    "output": "theorem mul_div_assoc (x : R) {y z : R} (h : z âˆ£ y) : x * y / z = x * (y / z) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The map of a prime number 'p' through a function 'f' is less than or equal to the prime number 'P' raised to the power of the ramification index of the function 'f' at 'p' and 'P'.",
    "output": "theorem le_pow_ramificationIdx : map f p â‰¤ P ^ ramificationIdx f p P :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type D that is a category and preadditive, and any functor F from C to D that is additive, the composition of the alternating face map complex of C and the map of the homological complex by F is equal to the composition of the whiskering of the simplicial object from C to D by F and the alternating face map complex of D.",
    "output": "theorem map_alternatingFaceMapComplex {D : Type _} [Category D] [Preadditive D] (F : C â¥¤ D)\n    [F.Additive] :\n    alternatingFaceMapComplex C â‹™ F.mapHomologicalComplex _ =\n      (SimplicialObject.whiskering C D).obj F â‹™ alternatingFaceMapComplex D :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two affine isometries 'f' and 'g' from 'P' to 'Pâ‚‚', if for every 'x', 'f' at 'x' equals 'g' at 'x', then 'f' equals 'g'.",
    "output": "theorem ext {f g : P â†’áµƒâ±[ğ•œ] Pâ‚‚} (h : âˆ€ x, f x = g x) : f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'f' from some type 'Î±' to natural numbers, a function 'g' from 'Î±' to some type 'Ïƒ', and a function 'h' from 'Î±' and natural numbers to 'Ïƒ', and if all these functions are computable, then the function that takes an element of type 'Î±' and applies the natural number cases on the result of 'f' applied to that element, with 'g' and 'h' as the case functions, is also computable.",
    "output": "theorem nat_casesOn {f : Î± â†’ â„•} {g : Î± â†’ Ïƒ} {h : Î± â†’ â„• â†’ Ïƒ} (hf : Computable f) (hg : Computable g)\n    (hh : Computableâ‚‚ h) :\n    Computable fun a => Nat.casesOn (motive := fun _ => Ïƒ) (f a) (g a) (h a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'x is inseparable from y' if and only if for every open set 's' in the topological space 'X', 'x' is in 's' if and only if 'y' is in 's'.",
    "output": "theorem inseparable_iff_forall_open : (x ~áµ¢ y) â†” âˆ€ s : Set X, IsOpen s â†’ (x âˆˆ s â†” y âˆˆ s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function from Î± to Î² and any filter on Î±, the filter on Î± is less than or equal to the preimage of the top filter under the function.",
    "output": "theorem le_comap_top (f : Î± â†’ Î²) (l : Filter Î±) : l â‰¤ comap f âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a commutative monoid Î² and a function f from the finite set of 3 elements to Î², the product of the function values over all elements in the set is equal to the product of the function values at 0, 1, and 2.",
    "output": "theorem prod_univ_three [CommMonoid Î²] (f : Fin 3 â†’ Î²) : (âˆ i, f i) = f 0 * f 1 * f 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any operation 'op' on types 'Î±' and 'Î²', if 'op' is a symmetric operation, then the flipped operation is equal to the original operation.",
    "output": "theorem IsSymmOp.flip_eq {Î± Î²} (op) [IsSymmOp Î± Î² op] : flip op = op :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a nonempty set 's' in a field 'k' of characteristic zero with a finite type 'Î¹', then the sum of the centroid weights indicators of 's' over all 'i' equals one.",
    "output": "theorem sum_centroidWeightsIndicator_eq_one_of_nonempty [CharZero k] [Fintype Î¹] (h : s.Nonempty) :\n    (âˆ‘ i, s.centroidWeightsIndicator k i) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' in group 'G', the inverse of 'a' in 'G' is equal to the inverse of 'a' in quotient group 'Q'.",
    "output": "theorem mk_inv (a : G) : ((aâ»Â¹ : G) : Q ) = (a : Q)â»Â¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î¹ that is finite, and any basis b of a module M over a ring R, the range of the evaluation map in the dual space of M is the entire dual space.",
    "output": "theorem eval_range {Î¹ : Type _} [Finite Î¹] (b : Basis Î¹ R M) :\n    LinearMap.range (Dual.eval R M) = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any indexed set of subsets of E (denoted by s), if the set s is directed under the subset relation and each subset in s is convex, then the union of all subsets in s is also convex.",
    "output": "theorem Directed.convex_iUnion {Î¹ : Sort _} {s : Î¹ â†’ Set E} (hdir : Directed (Â· âŠ† Â·) s)\n    (hc : âˆ€ â¦ƒi : Î¹â¦„, Convex ğ•œ (s i)) : Convex ğ•œ (â‹ƒ i, s i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 't' is open, then the left division of another set 's' by 't' is also open.",
    "output": "theorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the value of one divided by ('n' plus one) is greater than zero.",
    "output": "theorem one_div_pos_of_nat {n : â„•} : 0 < 1 / ((n : Î±) + 1) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In an additive zero class with a preorder and a covariant class, for any two elements x and y such that both are greater than or equal to zero, the sum of x and y (with the proof that their sum is nonnegative) is equal to the sum of the elements x and y themselves.",
    "output": "theorem mk_add_mk [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] {x y : Î±}\n    (hx : 0 â‰¤ x) (hy : 0 â‰¤ y) :\n    (âŸ¨x, hxâŸ© : { x : Î± // 0 â‰¤ x }) + âŸ¨y, hyâŸ© = âŸ¨x + y, add_nonneg hx hyâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function F from the symmetric square of a type Î± to a type Î², and for any two elements aâ‚ and aâ‚‚ of type Î±, the application of the inverse lift of F to aâ‚ and aâ‚‚ is equal to the application of F to the unordered pair of aâ‚ and aâ‚‚.",
    "output": "theorem coe_lift_symm_apply (F : Sym2 Î± â†’ Î²) (aâ‚ aâ‚‚ : Î±) :\n    (lift.symm F : Î± â†’ Î± â†’ Î²) aâ‚ aâ‚‚ = F âŸ¦(aâ‚, aâ‚‚)âŸ§ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The norm of the equivalent real product of a complex number z is less than or equal to the absolute value of z.",
    "output": "theorem equivRealProd_apply_le (z : â„‚) : â€–equivRealProd zâ€– â‰¤ abs z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a property 'p' that applies to multisets of type 'Î±', and a multiset 's' of the same type, if the property 'p' holds for the empty multiset, and if for any element 'a' and any multiset 's', the property 'p' holds for all multisets 't' that are less than or equal to 's', then the property 'p' also holds for the multiset 's'. This is a form of strong induction on multisets.",
    "output": "theorem case_strongInductionOn {p : Multiset Î± â†’ Prop} (s : Multiset Î±) (hâ‚€ : p 0)\n    (hâ‚ : âˆ€ a s, (âˆ€ t â‰¤ s, p t) â†’ p (a ::â‚˜ s)) : p s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A singleton set (containing only one element) is a subset of set 's' if and only if that one element is an element of set 's'.",
    "output": "theorem one_subset : (1 : Finset Î±) âŠ† s â†” (1 : Î±) âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the function that negates each element in the set of all elements greater than or equal to a certain value 'a', is equal to the set of all elements less than or equal to the negation of 'a'.",
    "output": "theorem image_neg_Ici : Neg.neg '' Ici a = Iic (-a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of a parallelepiped under a linear transformation is a parallelepiped. Specifically, if 'f' is a linear transformation from 'E' to 'F', and 'v' is a function that maps from an index set 'Î¹' to 'E', then the image of the parallelepiped defined by 'v' under 'f' is the same as the parallelepiped defined by the composition of 'f' and 'v'.",
    "output": "theorem image_parallelepiped (f : E â†’â‚—[â„] F) (v : Î¹ â†’ E) :\n    f '' parallelepiped v = parallelepiped (f âˆ˜ v) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number x, if x is greater than or equal to 0 and less than or equal to 1, then x is less than or equal to the sine of (Ï€/2 times x).",
    "output": "theorem le_sin_mul {x : â„} (hx : 0 â‰¤ x) (hx' : x â‰¤ 1) : x â‰¤ sin (Ï€ / 2 * x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type 'Î±', any function 'g' from 'F Î±' to 'Î±', any 'a' in 'q.P.A', and any function 'f' from 'q.P.B a' to 'q.P.W', the recursive function 'recF' applied to 'g' and the pair 'âŸ¨a, fâŸ©' is equal to 'g' applied to the absolute value of the functor 'recF g' mapped over the pair 'âŸ¨a, fâŸ©'.",
    "output": "theorem recF_eq' {Î± : Type _} (g : F Î± â†’ Î±) (a : q.P.A) (f : q.P.B a â†’ q.P.W) :\n    recF g âŸ¨a, fâŸ© = g (abs (recF g <$> âŸ¨a, fâŸ©)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of elements in field 'K' and a subfield 't' of 'K', the closure of 's' is less than or equal to 't' if and only if 's' is a subset of 't'.",
    "output": "theorem closure_le {s : Set K} {t : Subfield K} : closure s â‰¤ t â†” s âŠ† t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given Baer module 'h' over a ring 'R' and a quotient ring 'Q', and for any element 'y' of a module 'N' and an element 'r' of the ring 'R' such that 'r' times 'y' is in the domain of the extension of the maximum ideal 'i' by a function 'f', the extension of the ideal 'i' to the Baer module 'h' by the function 'f' at the elements 'y' and 'r' is equal to the linear map to the extension of the maximum ideal 'i' by the function 'f' at the pair consisting of 'r' times 'y' and the fact that 'r' times 'y' is in the domain of the extension.",
    "output": "theorem ExtensionOfMaxAdjoin.extendIdealTo_eq (h : Module.Baer R Q) {y : N} (r : R)\n    (hr : r â€¢ y âˆˆ (extensionOfMax i f).domain) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r =\n    (extensionOfMax i f).toLinearPMap âŸ¨r â€¢ y, hrâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If you have four continuous functions A, B, C, and D, each mapping from a set X to matrices of real numbers of different dimensions, then the function that maps each element of X to the block matrix formed by the matrices A(x), B(x), C(x), and D(x) is also continuous.",
    "output": "theorem Continuous.matrix_fromBlocks {A : X â†’ Matrix n l R} {B : X â†’ Matrix n m R}\n    {C : X â†’ Matrix p l R} {D : X â†’ Matrix p m R} (hA : Continuous A) (hB : Continuous B)\n    (hC : Continuous C) (hD : Continuous D) :\n    Continuous fun x => Matrix.fromBlocks (A x) (B x) (C x) (D x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of all integers from 'a' inclusive to 'b' exclusive is a subset of the set of all integers less than or equal to 'b'.",
    "output": "theorem Ico_subset_Iic_self : Ico a b âŠ† Iic b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The reflection of an algebraic equivalence between Aâ‚ and itself is equal to the identity algebraic homomorphism from R to Aâ‚.",
    "output": "theorem refl_toAlgHom : â†‘(refl : Aâ‚ â‰ƒâ‚[R] Aâ‚) = AlgHom.id R Aâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a topological space Gâ‚€ with a T1 space structure, given two functions f and g from a set Î± to Gâ‚€, a filter l on Î±, and two elements x and y in Gâ‚€ such that the function g tends towards y under the filter l and y is not equal to zero, the function that maps each element n in Î± to the product of f(n) and g(n) tends towards x*y under the filter l if and only if the function f tends towards x under the filter l.",
    "output": "theorem Filter.tendsto_mul_iff_of_ne_zero [T1Space Gâ‚€] {f g : Î± â†’ Gâ‚€} {l : Filter Î±} {x y : Gâ‚€}\n    (hg : Tendsto g l (ğ“ y)) (hy : y â‰  0) :\n    Tendsto (fun n => f n * g n) l (ğ“ <| x * y) â†” Tendsto f l (ğ“ x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'removeNth', which removes the 'i'-th element from a vector of length 'n + 1', is continuous.",
    "output": "theorem continuous_removeNth {n : â„•} {i : Fin (n + 1)} :\n    Continuous (removeNth i : Vector Î± (n + 1) â†’ Vector Î± n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a list L of transvection structures, the product of the matrices corresponding to the elements in L, when multiplied by the product of the matrices corresponding to the inverse of the elements in the reversed list L, equals the identity matrix.",
    "output": "theorem prod_mul_reverse_inv_prod (L : List (TransvectionStruct n R)) :\n    (L.map toMatrix).prod â¬ (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).prod = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The imaginary part function is an open map.",
    "output": "theorem isOpenMap_im : IsOpenMap im :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type R, which is a complete linear order, and a function f from Î¹ to R, if the supremum of f(i) over all i is not in the range of f, then the union of the intervals closed below by f(i) for all i is equal to the interval open above by the supremum of f(i) over all i.",
    "output": "theorem iUnion_Iic_eq_Iio_iSup {R : Type _} [CompleteLinearOrder R] {f : Î¹ â†’ R}\n    (no_greatest_elem : (â¨† i, f i) âˆ‰ range f) : (â‹ƒ i : Î¹, Iic (f i)) = Iio (â¨† i, f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If r is not equal to zero, then the single-valued function of a and r is not equal to zero.",
    "output": "theorem single_ne_zero (h : r â‰  0) : single a r â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "There exists a member 'y' in the target of 'e' such that property 'p' holds for 'y' if and only if there exists a member 'x' in the source of 'e' such that property 'p' holds for the application of 'e' to 'x'.",
    "output": "theorem exists_mem_target {p : Î² â†’ Prop} : (âˆƒ y âˆˆ e.target, p y) â†” âˆƒ x âˆˆ e.source, p (e x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f is continuous, function g is continuous, and for all x, either f(x) is not equal to zero or g(x) is greater than zero, then the function that maps x to f(x) raised to the power of g(x) is also continuous.",
    "output": "theorem Continuous.rpow (hf : Continuous f) (hg : Continuous g) (h : âˆ€ x, f x â‰  0 âˆ¨ 0 < g x) :\n    Continuous fun x => f x ^ g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from structure 'M' to structure 'N' in the language 'L', the mapping of 'f' is monotone.",
    "output": "theorem monotone_map {f : M â†’[L] N} : Monotone (map f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any path 'p' from point 'a' to point 'b', and for any point 'c' with a path 'q' from 'b' to 'c', the list of the composite path from 'a' to 'c' is equal to the concatenation of the list of path 'q' and the list of path 'p'.",
    "output": "theorem toList_comp (p : Path a b) : âˆ€ {c} (q : Path b c), (p.comp q).toList = q.toList ++ p.toList"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The topological support of the derivative of a function f is a subset of the topological support of the function f itself.",
    "output": "theorem tsupport_fderiv_subset : tsupport (fderiv ğ•œ f) âŠ† tsupport f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is the least element in set 's' and 'b' is also the least element in set 's', then 'a' and 'b' must be equal.",
    "output": "theorem IsLeast.unique (Ha : IsLeast s a) (Hb : IsLeast s b) : a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'm' from set M and any element 'r' from set R, the right identity of the tensor product of 'm' and 'r' is equal to 'r' scaled by 'm'.",
    "output": "theorem rid_tmul (m : M) (r : R) : (TensorProduct.rid R M) (m âŠ—â‚œ r) = r â€¢ m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If Î¼ is left-invariant under multiplication, then the function that takes a pair of elements from group G and divides the first by the second is quasi-measure-preserving with respect to the product measure of Î¼ and Î½, and Î¼ itself.",
    "output": "theorem quasiMeasurePreserving_div [IsMulLeftInvariant Î¼] :\n    QuasiMeasurePreserving (fun p : G Ã— G => p.1 / p.2) (Î¼.prod Î½) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If I and J are submodules of a ring R over a field P, and if both I and J are fractional ideals of a multiplicative set S, then the supremum (or join) of I and J is also a fractional ideal of S.",
    "output": "theorem _root_.IsFractional.sup {I J : Submodule R P} :\n    IsFractional S I â†’ IsFractional S J â†’ IsFractional S (I âŠ” J)"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 't' of type Î± and an element 'x' of type Î±, given that the neighborhood of 'x' is countably generated, if 'x' is the greatest lower bound of 't' and 't' is nonempty, then there exists a sequence 'u' of elements of type Î± such that 'u' is antitone (i.e., it is a decreasing sequence), 'x' is less than or equal to every element of 'u', 'u' tends to 'x' as it approaches infinity, and every element of 'u' belongs to 't'.",
    "output": "theorem IsGLB.exists_seq_antitone_tendsto {t : Set Î±} {x : Î±} [IsCountablyGenerated (ğ“ x)]\n    (htx : IsGLB t x) (ht : t.Nonempty) :\n    âˆƒ u : â„• â†’ Î±, Antitone u âˆ§ (âˆ€ n, x â‰¤ u n) âˆ§ Tendsto u atTop (ğ“ x) âˆ§ âˆ€ n, u n âˆˆ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A space is locally connected if and only if for every point and for every neighborhood of that point, there exists a subset of the neighborhood that is open, contains the point, and is connected.",
    "output": "theorem locallyConnectedSpace_iff_open_connected_subsets :\n    LocallyConnectedSpace Î± â†”\n      âˆ€ x, âˆ€ U âˆˆ ğ“ x, âˆƒ V : Set Î±, V âŠ† U âˆ§ IsOpen V âˆ§ x âˆˆ V âˆ§ IsConnected V :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function F tends towards the product of p and the principal filter of s, converging to c if and only if F tends uniformly on the function that maps every element to c, with respect to p and s.",
    "output": "theorem tendsto_prod_principal_iff {c : Î²} :\n    Tendsto (â†¿F) (p Ã—Ë¢ ğ“Ÿ s) (ğ“ c) â†” TendstoUniformlyOn F (fun _ => c) p s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list of Sigma types, the function 'dlookup' applied to an element 'a' and the list is 'Some' if and only if 'a' is in the keys of the list.",
    "output": "theorem dlookup_isSome {a : Î±} : âˆ€ {l : List (Sigma Î²)}, (dlookup a l).isSome â†” a âˆˆ l.keys"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Applying the functor of the Karoubi chain complex equivalence to Nâ‚‚ is equivalent to embedding the Karoubi functor category into the opposite Simplex category, then applying Nâ‚, the functor of the Karoubi chain complex equivalence to the Karoubi category, and finally applying the inverse of the equivalence between the Karoubi and Karoubi categories to the homological complex functor.",
    "output": "theorem compatibility_Nâ‚‚_Nâ‚_karoubi :\n    Nâ‚‚ â‹™ (karoubiChainComplexEquivalence C â„•).functor =\n      karoubiFunctorCategoryEmbedding SimplexCategoryáµ’áµ– C â‹™\n        Nâ‚ â‹™ (karoubiChainComplexEquivalence (Karoubi C) â„•).functor â‹™\n            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' from 'Î±' to 'Î²' is an embedding, then 'f' is continuous.",
    "output": "theorem Embedding.continuous {f : Î± â†’ Î²} (hf : Embedding f) : Continuous f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two additive commutative group categories G and H, the application of the projection map of the cone of the binary product limit cone to the left walking pair equals the first additive monoid homomorphism from G to H.",
    "output": "theorem binaryProductLimitCone_cone_Ï€_app_left (G H : AddCommGroupCat.{u}) :\n    (binaryProductLimitCone G H).cone.Ï€.app âŸ¨WalkingPair.leftâŸ© = AddMonoidHom.fst G H :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a type vector 'Î±' of length 0 and a function 'ps' from 'Î±' to a repeated 0-length vector of propositions, the subtype value of 'ps' is equal to the nil function.",
    "output": "theorem subtypeVal_nil {Î± : TypeVec.{u} 0} (ps : Î± âŸ¹ Â«repeatÂ» 0 Prop) :\n    TypeVec.subtypeVal ps = nilFun :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-negative real number x and any non-negative real number y greater than 1, there will eventually be a natural number n such that x to the power of 1/n is less than or equal to y. This will hold true for all sufficiently large n.",
    "output": "theorem eventually_pow_one_div_le (x : â„â‰¥0) {y : â„â‰¥0} (hy : 1 < y) :\n    âˆ€á¶  n : â„• in atTop, x ^ (1 / n : â„) â‰¤ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers m and n, and any elements x and y of a field K, if the Frobenius endomorphism of K raised to the power of p to the m applied to x equals y, then the equivalence class generated by the pair (n, x) in the perfect closure of K with respect to p is equal to the equivalence class generated by the pair (m + n, y).",
    "output": "theorem R.sound (m n : â„•) (x y : K) (H : (frobenius K p^[m]) x = y) :\n    mk K p (n, x) = mk K p (m + n, y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is less than or equal to 'c', then 'a' is less than or equal to the maximum of 'b' and 'c'.",
    "output": "theorem le_max_of_le_right : a â‰¤ c â†’ a â‰¤ max b c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two linear maps 'f' and 'g' from a module 'M' to another module 'Mâ‚‚', the sum of 'f' and 'g' applied to an element 'x' from 'M' is equal to the sum of 'f' applied to 'x' and 'g' applied to 'x'.",
    "output": "theorem add_apply (f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (x : M) : (f + g) x = f x + g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of the lift function and the 'of' function applied to 'f' (which is a function from Î± to M) is equal to 'f'.",
    "output": "theorem lift_comp_of (f : Î± â†’ M) : lift f âˆ˜ of = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If set s and set t are both G-delta sets, then the union of set s and set t is also a G-delta set.",
    "output": "theorem IsGÎ´.union {s t : Set Î±} (hs : IsGÎ´ s) (ht : IsGÎ´ t) : IsGÎ´ (s âˆª t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given module W over a field K, with W being an additive commutative group, and a natural number n that is not equal to zero, if the rank of module V over K is equal to n times the rank of module W over K, then module V is finite-dimensional over K if and only if module W is finite-dimensional over K.",
    "output": "theorem finiteDimensional_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module K W] {n : â„•}\n    (hn : n â‰  0) (hVW : Module.rank K V = n â€¢ Module.rank K W) :\n    FiniteDimensional K V â†” FiniteDimensional K W :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given elements 'a' of type Î± and 'b' of type Î²(a), and for any given associative lists 'sâ‚' and 'sâ‚‚' of type AList Î², if the entries of 'sâ‚' are permutations of the entries of 'sâ‚‚', then the entries of the list resulting from replacing 'a' with 'b' in 'sâ‚' are also permutations of the entries of the list resulting from replacing 'a' with 'b' in 'sâ‚‚'.",
    "output": "theorem perm_replace {a : Î±} {b : Î² a} {sâ‚ sâ‚‚ : AList Î²} :\n    sâ‚.entries ~ sâ‚‚.entries â†’ (replace a b sâ‚).entries ~ (replace a b sâ‚‚).entries :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a semiring S and a ring homomorphism f from R to S, and if polynomial p is monic, then the polynomial obtained by mapping p through f is also monic.",
    "output": "theorem Monic.map [Semiring S] (f : R â†’+* S) (hp : Monic p) : Monic (p.map f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The length of a composition 'c' is less than the number of boundaries in 'c'.",
    "output": "theorem length_lt_card_boundaries : c.length < c.boundaries.card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' in a semilattice structure 'Î±', the set 's' is bounded above if and only if the intersection of 's' and the set of all elements 'b' such that 'a' is not less than or equal to 'b' is also bounded above.",
    "output": "theorem bounded_ge_inter_not_ge [SemilatticeInf Î±] (a : Î±) :\n    Bounded (Â· â‰¥ Â·) (s âˆ© { b | Â¬a â‰¤ b }) â†” Bounded (Â· â‰¥ Â·) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a property 'p' that applies to a function 'f' (which is a finite direct sum of the functions 'Î² i' indexed by 'i'), if 'p' holds for the zero function and if 'p' holds for any function 'f' where 'f i' is zero, 'b' is non-zero, and 'p' holds for 'f', then 'p' also holds for the function that is the sum of the function 'f' and the function that is 'b' at index 'i' and zero elsewhere. This is a form of mathematical induction over the elements of the direct sum.",
    "output": "theorem induction {p : (Î â‚€ i, Î² i) â†’ Prop} (f : Î â‚€ i, Î² i) (h0 : p 0)\n    (ha : âˆ€ (i b) (f : Î â‚€ i, Î² i), f i = 0 â†’ b â‰  0 â†’ p f â†’ p (single i b + f)) : p f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types G and H that are both subtraction-negative-zero monoids, and for any function f from G to H that maps 0 to 0, if for all x and y in G, f of (x - y) equals f of x minus f of y, then for any two functions vâ‚ and vâ‚‚ from a type Î± to G, the mapRange of f and hf on (vâ‚ - vâ‚‚) equals the mapRange of f and hf on vâ‚ minus the mapRange of f and hf on vâ‚‚. Here, mapRange is a function that applies f to the range of a function and hf is the proof that f maps 0 to 0.",
    "output": "theorem mapRange_sub [SubNegZeroMonoid G] [SubNegZeroMonoid H] {f : G â†’ H} {hf : f 0 = 0}\n    (hf' : âˆ€ x y, f (x - y) = f x - f y) (vâ‚ vâ‚‚ : Î± â†’â‚€ G) :\n    mapRange f hf (vâ‚ - vâ‚‚) = mapRange f hf vâ‚ - mapRange f hf vâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of sequences in 'E' that is closed, and for a sequence 'x' not in 's', if the longest prefix of 'x' in 's' is less than a natural number 'n', then 's' and the 'n'-cylinder of 'x' are disjoint.",
    "output": "theorem disjoint_cylinder_of_longestPrefix_lt {s : Set (âˆ€ n, E n)} (hs : IsClosed s) {x : âˆ€ n, E n}\n    (hx : x âˆ‰ s) {n : â„•} (hn : longestPrefix x s < n) : Disjoint s (cylinder x n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The kernel of a function 'f' when considered as a submodule of 'R' and 'M' is equal to the kernel of the linear map from 'M' to 'N' under 'f'.",
    "output": "theorem ker_coeSubmodule : (f.ker : Submodule R M) = LinearMap.ker (f : M â†’â‚—[R] N) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a multiset 't' of polynomials, if the product of the leading coefficients of each polynomial in 't' is not zero, then the natural degree of the product of 't' is equal to the sum of the natural degrees of each polynomial in 't'.",
    "output": "theorem natDegree_multiset_prod' (h : (t.map fun f => leadingCoeff f).prod â‰  0) :\n    t.prod.natDegree = (t.map fun f => natDegree f).sum :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The relation of the bottom element in the setoid of any type Î± is equivalent to the equality relation.",
    "output": "theorem bot_def : (âŠ¥ : Setoid Î±).Rel = (Â· = Â·) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and c in a Heyting algebra, the difference of the supremum of a and b and c is equal to the supremum of the difference of a and c and the difference of b and c.",
    "output": "theorem sup_sdiff_distrib (a b c : Î±) : (a âŠ” b) \\ c = a \\ c âŠ” b \\ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is an equivalence between two categories C and D, and if category C is well-powered, then category D is also well-powered.",
    "output": "theorem wellPowered_of_equiv (e : C â‰Œ D) [WellPowered C] : WellPowered D :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements x, y, and z from a module Mâ‚, the bilinear form Bâ‚ of x and the difference of y and z is equal to the difference of the bilinear form Bâ‚ of x and y and the bilinear form Bâ‚ of x and z.",
    "output": "theorem sub_right (x y z : Mâ‚) : Bâ‚ x (y - z) = Bâ‚ x y - Bâ‚ x z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given list and any element, the last element of the list obtained by appending the given element to the end of the given list is the given element itself.",
    "output": "theorem getLast_append_singleton {a : Î±} (l : List Î±) :\n    getLast (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real numbers x and y, if the sine of x equals y and x is in the closed interval from negative half pi to half pi, then the arcsine of y equals x.",
    "output": "theorem arcsin_eq_of_sin_eq {x y : â„} (hâ‚ : sin x = y) (hâ‚‚ : x âˆˆ Icc (-(Ï€ / 2)) (Ï€ / 2)) :\n    arcsin y = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of a topological space Î², which has a supremum operation and is continuous with respect to this operation, given a filter l and two functions f and g from Î¹ to Î², and two elements x and y in Î², if f tends to x along l and g tends to y along l, then the function that maps each element i of Î¹ to the supremum of f(i) and g(i) tends to the supremum of x and y along l.",
    "output": "theorem Filter.Tendsto.sup_right_nhds {Î¹ Î²} [TopologicalSpace Î²] [Sup Î²] [ContinuousSup Î²]\n    {l : Filter Î¹} {f g : Î¹ â†’ Î²} {x y : Î²} (hf : Tendsto f l (ğ“ x)) (hg : Tendsto g l (ğ“ y)) :\n    Tendsto (fun i => f i âŠ” g i) l (ğ“ (x âŠ” y)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î¹, any relation r on Î¹, given that Î¹ with relation r is a well-ordered set, any ordinal number o, and if the order type of r is o, and any function f from a set of elements less than o to Î±, the range of the function 'familyOfBFamily' applied to r, ho, and f is equal to the range of the function brange applied to o and f.",
    "output": "theorem range_familyOfBFamily' {Î¹ : Type u} (r : Î¹ â†’ Î¹ â†’ Prop) [IsWellOrder Î¹ r] {o}\n    (ho : type r = o) (f : âˆ€ a < o, Î±) : range (familyOfBFamily' r ho f) = brange o f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The division of a number represented as \"bit1 n\" by a number represented as \"bit0 m\" is equal to the division of n by m.",
    "output": "theorem bit1_div_bit0 : bit1 n / bit0 m = n / m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function obtained by filtering 'f' according to predicate 'p' is equivalent to the indicator function of the set of elements satisfying 'p' in 'f'.",
    "output": "theorem filter_eq_indicator : â‡‘(f.filter p) = Set.indicator { x | p x } f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-negative real number 'a' and a natural number 'n', the ceiling of the sum of 'a' and 'n' is equal to the sum of the ceiling of 'a' and 'n'.",
    "output": "theorem ceil_add_nat (ha : 0 â‰¤ a) (n : â„•) : âŒˆa + nâŒ‰â‚Š = âŒˆaâŒ‰â‚Š + n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' and any two elements 'i' and 'j' of the finite set of size 'n+1', if 'j' is less than 'i', then the cycle range of 'i' and 'j' is equal to 'j + 1'.",
    "output": "theorem cycleRange_of_lt {n : â„•} {i j : Fin n.succ} (h : j < i) : cycleRange i j = j + 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The distance between two points x and y in a metric space Î³ is greater than zero if and only if x is not equal to y.",
    "output": "theorem dist_pos {x y : Î³} : 0 < dist x y â†” x â‰  y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any finite set 's' of elements of type 'Î²' and any function 'f' from 'Î²' to 'Î±' (where 'Î±' is a type with a generalized Boolean algebra structure), and any element 'a' of type 'Î±', the supremum (greatest element) of the set obtained by applying the function 'f' to each element of 's' and then subtracting 'a', is equal to the result of subtracting 'a' from the supremum of the set obtained by applying 'f' to each element of 's'.",
    "output": "theorem sup_sdiff_right {Î± Î² : Type _} [GeneralizedBooleanAlgebra Î±] (s : Finset Î²) (f : Î² â†’ Î±)\n    (a : Î±) : (s.sup fun b => f b \\ a) = s.sup f \\ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of any type 'Î±', if 's' is finite, then the off-diagonal of 's' is also finite.",
    "output": "theorem Finite.offDiag {s : Set Î±} (hs : s.Finite) : s.offDiag.Finite :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite set 's' and a function 'f' from 's' to a ring 'R', the square of the sum of the function values over the set 's' is equal to the sum of the squares of the function values over the set 's'.",
    "output": "theorem sum_mul_self (s : Finset Î¹) (f : Î¹ â†’ R) :\n    ((âˆ‘ i in s, f i) * âˆ‘ i in s, f i) = âˆ‘ i in s, f i * f i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is an open embedding 'f' and 'F' is a sheaf, then the composition of the functor associated with the open map 'f' and 'F' is also a sheaf.",
    "output": "theorem TopCat.Presheaf.isSheaf_of_openEmbedding (h : OpenEmbedding f) (hF : F.IsSheaf) :\n    IsSheaf (h.isOpenMap.functor.op â‹™ F) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The outer measure of Î¼â‚ is less than or equal to the outer measure of Î¼â‚‚ if and only if Î¼â‚ is less than or equal to Î¼â‚‚.",
    "output": "theorem toOuterMeasure_le : Î¼â‚.toOuterMeasure â‰¤ Î¼â‚‚.toOuterMeasure â†” Î¼â‚ â‰¤ Î¼â‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is integrable with respect to a measure 'Î¼', then the function that multiplies 'f' by a constant 'c' is also integrable with respect to the same measure 'Î¼'.",
    "output": "theorem Integrable.mul_const {f : Î± â†’ ğ•œ} (h : Integrable f Î¼) (c : ğ•œ) :\n    Integrable (fun x => f x * c) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The coercion of 'none' from the Option type to the Part type in the context of any type Î±, is equal to 'none'.",
    "output": "theorem coe_none : (@Option.none Î± : Part Î±) = none :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î±, if Î± is unique and has an identity element (one), then the default element of Î± is equal to the identity element.",
    "output": "theorem unique_one {Î± : Type _} [Unique Î±] [One Î±] : default = (1 : Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The multiplication homomorphism obtained from the top equivalence is equal to the subtype of the top subsemigroup M in the multiplication membership class.",
    "output": "theorem topEquiv_toMulHom :\n    (topEquiv : _ â‰ƒ* M).toMulHom = MulMemClass.subtype (âŠ¤ : Subsemigroup M) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' is nonempty and is bounded above, then the supremum of 's' is the least upper bound of 's'.",
    "output": "theorem isLUB_csSup (ne : s.Nonempty) (H : BddAbove s) : IsLUB s (sSup s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given monoid homomorphism 'f' from 'M' to 'N', and given subsemigroups 'S' of 'M' and 'T' of 'N', the image of 'S' under 'f' is a subset of 'T' if and only if 'S' is a subset of the preimage of 'T' under 'f'.",
    "output": "theorem map_le_iff_le_comap {f : M â†’â‚™* N} {S : Subsemigroup M} {T : Subsemigroup N} :\n    S.map f â‰¤ T â†” S â‰¤ T.comap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real numbers x, y, and z, if x and y are coprime, then x and the sum of y and the product of z and x are also coprime.",
    "output": "theorem add_mul_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + z * x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The coefficient of the zeroth term in the polynomial P is equal to the discriminant of P.",
    "output": "theorem coeff_eq_d : P.toPoly.coeff 0 = P.d :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two additive homomorphisms 'f' and 'g' from the free module over a set 'Î±' to an additive group 'N', if 'f' and 'g' agree on all singletons, then 'f' and 'g' are equal. This is under the condition that 'N' is an additive group with a zero element.",
    "output": "theorem addHom_ext [AddZeroClass N] â¦ƒf g : (Î± â†’â‚€ M) â†’+ Nâ¦„\n    (H : âˆ€ x y, f (single x y) = g (single x y)) : f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The lower bounds of the singleton set containing 'a' are equivalent to the set of all elements less than or equal to 'a'.",
    "output": "theorem lowerBounds_singleton : lowerBounds {a} = Iic a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a surjective function 'f' from 'Î¹' to 'Î¹â‚‚', and a function 'g' from 'Î¹â‚‚' to a set of 'Î±', the intersection over 'x' of 'g' applied to 'f(x)' is equal to the intersection over 'y' of 'g(y)'.",
    "output": "theorem iInter_comp {f : Î¹ â†’ Î¹â‚‚} (hf : Surjective f) (g : Î¹â‚‚ â†’ Set Î±) : (â‹‚ x, g (f x)) = â‹‚ y, g y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a group G, and given elements a, b, c of G, the product of b and a is not equal to the product of c and a if and only if b is not equal to c.",
    "output": "theorem mul_ne_mul_left (a : G) {b c : G} : b * a â‰  c * a â†” b â‰  c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any complex number z in the unit disc, the square of its norm is less than 1.",
    "output": "theorem normSq_lt_one (z : ğ”») : normSq z < 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'g' of group 'G' and a subgroup 'H' of 'G', the set of integer powers of 'g' is a subset of 'H' if and only if 'g' is an element of 'H'.",
    "output": "theorem zpowers_le {g : G} {H : Subgroup G} : zpowers g â‰¤ H â†” g âˆˆ H :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The \"inl\" (inclusion from the left) of a pushout cocone of two functions f and g is equal to the ring homomorphism of the inclusion on the left in the tensor product of the algebras associated with f and g.",
    "output": "theorem pushoutCocone_inl :\n    (pushoutCocone f g).inl = by\n      letI := f.toAlgebra\n      letI := g.toAlgebra\n      exact Algebra.TensorProduct.includeLeft.toRingHom :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î±, for any natural number n, and for any list l of type Î±, the length of the sublists of l of length n is equal to \"length of l choose n\", where \"choose\" refers to the binomial coefficient.",
    "output": "theorem length_sublistsLen {Î± : Type _} :\n    âˆ€ (n) (l : List Î±), length (sublistsLen n l) = Nat.choose (length l) n"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The conversion of list 'l' to a finite set is equal to the conversion of list 'l'' to a finite set if and only if the deduplicated version of list 'l' is a permutation of the deduplicated version of list 'l''.",
    "output": "theorem toFinset_eq_iff_perm_dedup : l.toFinset = l'.toFinset â†” l.dedup ~ l'.dedup :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measure space Î¼, if the measure of the set containing only the element 'a' is zero and the measure of the set containing only the element 'b' is zero, then the half-open interval from 'a' to 'b' (including 'a' but excluding 'b') is almost everywhere equal to the half-open interval from 'a' to 'b' (excluding 'a' but including 'b') with respect to the measure Î¼.",
    "output": "theorem Ico_ae_eq_Ioc' (ha : Î¼ {a} = 0) (hb : Î¼ {b} = 0) : Ico a b =áµ[Î¼] Ioc a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any group filter basis B of a group G, the neighborhood of the element 1 in B is equal to the filter basis of B.",
    "output": "theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f has a derivative at a point x, then the function that applies the arctan function to f has a derivative at the same point x. The derivative is given by the formula 1 / (1 + f(x)^2) times the derivative of f at x.",
    "output": "theorem HasDerivAt.arctan (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun x => arctan (f x)) (1 / (1 + f x ^ 2) * f') x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given linear map 'Ï†' from the tensor product of a family of modules 's i' over a ring 'R' to a module 'E', if this linear map composed with the multilinear map 'PiTensorProduct.tprod R' equals 'Ï†', then 'Ï†' is uniquely determined by the lift of 'Ï†'.",
    "output": "theorem lift.unique' {Ï†' : (â¨‚[R] i, s i) â†’â‚—[R] E}\n    (H : Ï†'.compMultilinearMap (PiTensorProduct.tprod R) = Ï†) : Ï†' = lift Ï† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all indices 'i', given a Generalized Heyting Algebra on the function 'Ï€ i', for any two functions 'a' and 'b' that map an index to 'Ï€ i', the bi-implication of 'a' and 'b' is equivalent to the function that maps each index 'i' to the bi-implication of 'a i' and 'b i'.",
    "output": "theorem bihimp_def [âˆ€ i, GeneralizedHeytingAlgebra (Ï€ i)] (a b : âˆ€ i, Ï€ i) :\n    a â‡” b = fun i => a i â‡” b i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is the least element in set 't', then 'f(a)' is the greatest element in the image of 't' under the function 'f'.",
    "output": "theorem map_isLeast : IsLeast t a â†’ IsGreatest (f '' t) (f a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any quaternion 'q' with real numbers 'R' and complex numbers 'câ‚' and 'câ‚‚', the representation of 'q' in the basis 'basisOneIJK' is equal to the list consisting of the real part of 'q', the coefficient of 'i' in 'q', the coefficient of 'j' in 'q', and the coefficient of 'k' in 'q'.",
    "output": "theorem coe_basisOneIJK_repr (q : â„[R,câ‚,câ‚‚]) :\n    â‡‘((basisOneIJK câ‚ câ‚‚).repr q) = ![q.re, q.imI, q.imJ, q.imK] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Two algebra homomorphisms Ï†â‚ and Ï†â‚‚ from algebra A to algebra B over a ring R are equal if and only if they are equal for all elements x in algebra A.",
    "output": "theorem ext_iff {Ï†â‚ Ï†â‚‚ : A â†’â‚[R] B} : Ï†â‚ = Ï†â‚‚ â†” âˆ€ x, Ï†â‚ x = Ï†â‚‚ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' in the skew-adjoint of 'R', and any element 'z' in 'R', the product of the conjugate of 'z', 'x', and 'z' is also in the skew-adjoint of 'R'.",
    "output": "theorem conjugate' {x : R} (hx : x âˆˆ skewAdjoint R) (z : R) : star z * x * z âˆˆ skewAdjoint R :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' in the ring 'R' that is self-adjoint, and for any other element 'z' in the same ring, the product of 'z', 'x', and the conjugate of 'z' is also self-adjoint.",
    "output": "theorem conjugate {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (z * x * star z) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index 'i' and any two elements 'bâ‚' and 'bâ‚‚' of the set 'Î² i', the non-negative distance between the inverse images of 'bâ‚' and 'bâ‚‚' under the equivalence 'PiLp.equiv p Î²' is equal to the non-negative distance between 'bâ‚' and 'bâ‚‚'.",
    "output": "theorem nndist_equiv_symm_single_same (i : Î¹) (bâ‚ bâ‚‚ : Î² i) :\n    nndist ((PiLp.equiv p Î²).symm (Pi.single i bâ‚)) ((PiLp.equiv p Î²).symm (Pi.single i bâ‚‚)) =\n      nndist bâ‚ bâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ideal I in the product ring of R and S, I is equal to the product of the ideal in R mapped by the first ring homomorphism and the ideal in S mapped by the second ring homomorphism.",
    "output": "theorem ideal_prod_eq (I : Ideal (R Ã— S)) :\n    I = Ideal.prod (map (RingHom.fst R S) I : Ideal R) (map (RingHom.snd R S) I) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a real-valued function 'f' is differentiable and its derivative at any point 'x' is less than or equal to zero, then the function 'f' is antitone. An antitone function is one that decreases or remains constant as its input increases.",
    "output": "theorem antitone_of_deriv_nonpos {f : â„ â†’ â„} (hf : Differentiable â„ f) (hf' : âˆ€ x, deriv f x â‰¤ 0) :\n    Antitone f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The list of cycles generated from a list 'l' is equal to the list of cyclic permutations of 'l'.",
    "output": "theorem lists_coe (l : List Î±) : lists (l : Cycle Î±) = â†‘l.cyclicPermutations :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î¹'' and any finite type Î¹', given a function b'' from Î¹'' to M, the product of the matrix representation of b with respect to b' and the matrix representation of b' with respect to b'' is equal to the matrix representation of b with respect to b''.",
    "output": "theorem Basis.toMatrix_mul_toMatrix {Î¹'' : Type _} [Fintype Î¹'] (b'' : Î¹'' â†’ M) :\n    b.toMatrix b' â¬ b'.toMatrix b'' = b.toMatrix b'' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of all elements greater than zero in the finite set of natural numbers up to n (where n is a successor) is equal to the universal set mapped by the successor embedding function.",
    "output": "theorem Ioi_zero_eq_map : Ioi (0 : Fin n.succ) = univ.map (Fin.succEmbedding _).toEmbedding :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'f' and 'g' defined on a set 's' and any two functions 'f'' and 'g'' defined on the same set, and a function 'h' that takes three arguments - an element from the set, the result of applying 'f' or 'g' to that element, and the result of applying 'f'' or 'g'' to that element - the result of applying 'h' to an element 'x' from the set, the result of applying the piecewise function of 'f' and 'g' to 'x', and the result of applying the piecewise function of 'f'' and 'g'' to 'x', is equal to the result of applying the piecewise function of 'h' applied to 'x', 'f' applied to 'x', and 'f'' applied to 'x' if 'x' is in 's', or 'h' applied to 'x', 'g' applied to 'x', and 'g'' applied to 'x' if 'x' is not in 's'.",
    "output": "theorem apply_piecewiseâ‚‚ {Î´' Î´'' : Î± â†’ Sort _} (f' g' : âˆ€ i, Î´' i) (h : âˆ€ i, Î´ i â†’ Î´' i â†’ Î´'' i)\n    {x : Î±} :\n    h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' of type 'Î±' and a sequence 's', the operation of converting the sequence obtained by prepending 'a' to 's' into a list is equivalent to the operation of prepending 'a' to the list obtained by converting 's' into a list.",
    "output": "theorem toList_cons (a : Î±) (s) : toList (cons a s) = (List.cons a <$> toList s).think :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a polynomial 'p' over a ring 'R' is separable, then the roots of 'p' do not have any duplicates.",
    "output": "theorem nodup_roots {p : R[X]} (hsep : Separable p) : p.roots.Nodup :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number 'a', the sum of 'a' and 'a' divided by 2 is equal to 'a'.",
    "output": "theorem half_add_self (a : R) : (a + a) / 2 = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have two dominated finite measures additive, T and T', with the same measure Î¼ and constants C and C', and if T equals T', then for any function f from Î± to E, the setToFun of Î¼, T, hT, and f equals the setToFun of Î¼, T', hT', and f.",
    "output": "theorem setToFun_congr_left (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT' : DominatedFinMeasAdditive Î¼ T' C') (h : T = T') (f : Î± â†’ E) :\n    setToFun Î¼ T hT f = setToFun Î¼ T' hT' f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a monoid with zero homomorphism 'f' from a multiplicative monoid with zero 'M' to another multiplicative monoid with zero 'N', the composition of 'f' with the identity homomorphism on 'M' is equal to 'f' itself.",
    "output": "theorem MonoidWithZeroHom.comp_id [MulZeroOneClass M] [MulZeroOneClass N] (f : M â†’*â‚€ N) :\n  f.comp (MonoidWithZeroHom.id M) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a semiring R, an additive commutative monoid M, and a module M over R, then if N is a submodule of M and M is Noetherian over R, then N is also Noetherian over R.",
    "output": "theorem isNoetherian_of_submodule_of_noetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M]\n    (N : Submodule R M) (h : IsNoetherian R M) : IsNoetherian R N :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "X is codisjoint with the implication from x to y.",
    "output": "theorem codisjoint_himp_self_right : Codisjoint x (x â‡¨ y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and c of a set Î±, and any two sets s and t of ordered pairs of elements from Î±, if the ordered pair (a, c) is in set s and the ordered pair (c, b) is in set t, then the ordered pair (a, b) is in the composite of sets s and t.",
    "output": "theorem prod_mk_mem_compRel {a b c : Î±} {s t : Set (Î± Ã— Î±)} (hâ‚ : (a, c) âˆˆ s) (hâ‚‚ : (c, b) âˆˆ t) :\n    (a, b) âˆˆ s â—‹ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a contravariant class of type Î±, if b is additively left cancellable, a - b is additively left cancellable, b is less than or equal to a, and c is less than or equal to a, then a - b is less than a - c if and only if c is less than b.",
    "output": "theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass Î± Î± (Â· + Â·) (Â· < Â·)]\n    (hb : AddLECancellable b) (hab : AddLECancellable (a - b)) (hâ‚ : b â‰¤ a) (hâ‚‚ : c â‰¤ a) :\n    a - b < a - c â†” c < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of the singleton set containing element 'a' and the singleton set containing element 'b' is equal to the singleton set containing the product of 'a' and 'b'.",
    "output": "theorem singleton_mul_singleton (a b : Î±) : ({a} : Finset Î±) * {b} = {a * b} :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers q and n, the composition of the function (P q).f n with itself is equal to the function (P q).f n. This implies that the function (P q).f n is idempotent.",
    "output": "theorem P_f_idem (q n : â„•) : ((P q).f n : X _[n] âŸ¶ _) â‰« (P q).f n = (P q).f n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given tree 't', order 'o', and element 'x' of type Î±, if 't' is bounded by 'o' and 'x', then all elements in 't' are less than 'x'.",
    "output": "theorem Bounded.mem_lt : âˆ€ {t o} {x : Î±}, Bounded t o x â†’ All (Â· < x) t"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' from the set 'M', the application of the reflexive property of 'L' on 'M' to 'x' equals 'x' itself.",
    "output": "theorem refl_apply (x : M) : refl L M x = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of type Î± and any function 'u' from the finite set of size 0 to Î±, for all 'i' in the finite set of size 1, the value of the vector constructed from 'x' and 'u' at index 'i' is equal to 'x'.",
    "output": "theorem cons_val_fin_one (x : Î±) (u : Fin 0 â†’ Î±) : âˆ€ (i : Fin 1), vecCons x u i = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer 'd' and any square root of 'd' denoted as 'a', the norm of 'a' is equal to 1 if and only if 'a' is a member of the unitary group of the square root of 'd'.",
    "output": "theorem norm_eq_one_iff_mem_unitary {d : â„¤} {a : â„¤âˆšd} : a.norm = 1 â†” a âˆˆ unitary (â„¤âˆšd) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given Young Diagram 'Î¼', a natural number 'j', and a pair of natural numbers 'c', 'c' is in the 'j'-th column of 'Î¼' if and only if 'c' is in 'Î¼' and the second element of 'c' is equal to 'j'.",
    "output": "theorem mem_col_iff {Î¼ : YoungDiagram} {j : â„•} {c : â„• Ã— â„•} : c âˆˆ Î¼.col j â†” c âˆˆ Î¼ âˆ§ c.snd = j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have an algebra A over a ring S, and M is a submonoid of A, and S is a localization of M, then if M is less than or equal to the non-zero divisors of A, S is a domain.",
    "output": "theorem isDomain_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M â‰¤ nonZeroDivisors A) : IsDomain S :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'g' mapping from 'Î¹' to 'Î±', if for every 'i' there exists an 'i' such that 'f i' is less than or equal to 'g i', then the infimum (greatest lower bound) of 'f' is less than or equal to the infimum of 'g'.",
    "output": "theorem iInf_mono' {g : Î¹' â†’ Î±} (h : âˆ€ i', âˆƒ i, f i â‰¤ g i') : iInf f â‰¤ iInf g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a finite type Î¹ and a function p from Î¹ to a point P such that p is affine independent, and if the cardinality of the finite type Î¹ is n + 1, then the finite rank of the vector span of the set range of p is n.",
    "output": "theorem AffineIndependent.finrank_vectorSpan [Fintype Î¹] {p : Î¹ â†’ P} (hi : AffineIndependent k p)\n    {n : â„•} (hc : Fintype.card Î¹ = n + 1) : finrank k (vectorSpan k (Set.range p)) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two sets 's' and 't' of a ring 'R', if 's' is a subset of 't', then the centralizer of 't' is less than or equal to the centralizer of 's'.",
    "output": "theorem centralizer_le (s t : Set R) (h : s âŠ† t) : centralizer t â‰¤ centralizer s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a list 'l' forms a chain with relation 'R' and another list 'lâ‚' is a prefix of 'l', then 'lâ‚' also forms a chain with relation 'R'.",
    "output": "theorem Chain'.infix (h : Chain' R l) (h' : lâ‚ <:+: l) : Chain' R lâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The application of the first projection function on the product of two mathematical structures M and N is equal to the first element of the product.",
    "output": "theorem coe_fst : â‡‘(fst M N) = Prod.fst :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'u' from real numbers to 'E' is monotone, then 'u' is interval integrable between any two real numbers 'a' and 'b'.",
    "output": "theorem Monotone.intervalIntegrable {u : â„ â†’ E} {a b : â„} (hu : Monotone u) :\n    IntervalIntegrable u Î¼ a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'mab' mapping from type Î± to Î² and 'mba' mapping from type Î² to Î±, and any two filters 'f' of type Î± and 'g' of type Î², if the composition of 'mab' and 'mba' is eventually equal to the identity function at filter 'g', and if 'mba' tends to 'f' at 'g', then 'g' is less than or equal to the map of 'mab' at 'f'.",
    "output": "theorem le_map_of_right_inverse {mab : Î± â†’ Î²} {mba : Î² â†’ Î±} {f : Filter Î±} {g : Filter Î²}\n    (hâ‚ : mab âˆ˜ mba =á¶ [g] id) (hâ‚‚ : Tendsto mba g f) : g â‰¤ map mab f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"there does not exist an x such that s of x is true\" is equivalent to \"for all x, s of x is not true\".",
    "output": "theorem not_exists_eq : (Â¬ âˆƒ x, s x) = (âˆ€ x, Â¬ s x) :="
  },
  {
    "instruction": "",
    "input": "In the context of a linearly ordered field ğ•œ, a topological space E, an additive commutative monoid E, and a module ğ•œ E, for any set s of E, if s is a closed set and strictly convex in ğ•œ, then the frontier of s has the property of AddSalemSpencer.",
    "output": "theorem addSalemSpencer_frontier [LinearOrderedField ğ•œ] [TopologicalSpace E] [AddCommMonoid E]\n    [Module ğ•œ E] {s : Set E} (hsâ‚€ : IsClosed s) (hsâ‚ : StrictConvex ğ•œ s) :\n    AddSalemSpencer (frontier s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is equivalent to b modulo n, and c is equivalent to d modulo n, then the sum of a and c is equivalent to the sum of b and d modulo n.",
    "output": "theorem add (hâ‚ : a â‰¡ b [MOD n]) (hâ‚‚ : c â‰¡ d [MOD n]) : a + c â‰¡ b + d [MOD n] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The uniformity of a metric space Î³ is equal to the infimum of the principal set of pairs of points in Î³, where the extended distance between each pair of points is less than some positive number Îµ.",
    "output": "theorem uniformity_edist : ğ“¤ Î³ = â¨… Îµ > 0, ğ“Ÿ { p : Î³ Ã— Î³ | edist p.1 p.2 < Îµ } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set ğ’¢ in the opposite category of C, ğ’¢ is codetecting if and only if ğ’¢ is detecting.",
    "output": "theorem isCodetecting_unop_iff {ğ’¢ : Set Cáµ’áµ–} : IsCodetecting ğ’¢.unop â†” IsDetecting ğ’¢ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any infinite ring R, the cardinality of the set of quaternions over R is equal to the cardinality of R itself.",
    "output": "theorem mk_quaternion_of_infinite [Infinite R] : (#â„[R]) = (#R) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any types Î±, Î², and Î³, and any element c of type Î³, applying the symmetric of the sum association function to the right element of the right sum (inr (inr c)) results in the right element of the sum (inr c).",
    "output": "theorem sumAssoc_symm_apply_inr_inr {Î± Î² Î³} (c) : (sumAssoc Î± Î² Î³).symm (inr (inr c)) = inr c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The bottom subalgebra of A over R is finitely generated.",
    "output": "theorem fg_bot : (âŠ¥ : Subalgebra R A).FG :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The intersection of the set of elements that satisfy a property 'p' and a set 's' is equal to the set of elements in 's' that satisfy the property 'p'.",
    "output": "theorem setOf_inter_eq_sep (p : Î± â†’ Prop) (s : Set Î±) : {a | p a} âˆ© s = {a âˆˆ s | p a} :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three non-negative real numbers a, b, and c, the product of a and the supremum (the least upper bound) of b and c is equal to the supremum of the product of a and b and the product of a and c.",
    "output": "theorem mul_sup (a b c : â„â‰¥0) : a * (b âŠ” c) = a * b âŠ” a * c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the natural degree of polynomial p is less than or equal to the natural degree of polynomial q, and the natural degree of polynomial q is greater than 0, then the natural degree of the polynomial obtained by cancelling the leading terms of p and q is less than the natural degree of polynomial q.",
    "output": "theorem natDegree_cancelLeads_lt_of_natDegree_le_natDegree (h : p.natDegree â‰¤ q.natDegree)\n    (hq : 0 < q.natDegree) : (p.cancelLeads q).natDegree < q.natDegree :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The distance from point x to point w is less than or equal to the sum of the distance from x to y, the distance from y to z, and the distance from z to w. This is a generalization of the triangle inequality in the context of metric spaces.",
    "output": "theorem dist_triangle4 (x y z w : Î±) : dist x w â‰¤ dist x y + dist y z + dist z w :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given measure 'Î¼' on a set 'Î±', which is a probability measure, the measure derived from a probability mass function 'p' is equal to 'Î¼' if and only if 'p' is equal to the probability mass function derived from 'Î¼'.",
    "output": "theorem toMeasure_eq_iff_eq_toPmf (Î¼ : Measure Î±) [IsProbabilityMeasure Î¼] :\n    p.toMeasure = Î¼ â†” p = Î¼.toPmf :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list of elements of type Î±, the property of the list being a chain under a relation R is equivalent to the property of the list having pairwise relations under R, given that the relation R is transitive over Î±.",
    "output": "theorem chain'_iff_pairwise [IsTrans Î± R] : âˆ€ {l : List Î±}, Chain' R l â†” Pairwise R l"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function 'f' from a field 'F', if the kernel of 'f' is a trivial subspace (i.e., it only contains the zero vector), then the image of a subspace 'p' under 'f' is a subset of the image of another subspace 'p'' under 'f' if and only if 'p' is a subset of 'p''.",
    "output": "theorem map_le_map_iff' {f : F} (hf : ker f = âŠ¥) {p p'} : map f p â‰¤ map f p' â†” p â‰¤ p' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any finite set 's', the sum of the cardinality of 's' and the cardinality of the complement of 's' is equal to the cardinality of the set of all natural numbers.",
    "output": "theorem ncard_add_ncard_compl (s : Set Î±) (hs : s.Finite := by toFinite_tac)\n    (hsc : sá¶œ.Finite := by toFinite_tac) : s.ncard + sá¶œ.ncard = Nat.card Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The range of a piecewise function, defined by functions f and g over a set s, is equal to the union of the image of f over set s and the image of g over the complement of set s.",
    "output": "theorem range_piecewise (f g : Î± â†’ Î²) : range (s.piecewise f g) = f '' s âˆª g '' sá¶œ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given measure Î¼ on a set Î², where Î¼ is a locally finite measure, and a measurable set s, almost everywhere with respect to Î¼, the function that maps a positive real number r to the ratio of the measure of the intersection of s and the closed ball centered at x with radius r to the measure of the closed ball centered at x with radius r, tends to the indicator function of s at x as r tends to 0 from the right.",
    "output": "theorem ae_tendsto_measure_inter_div_of_measurableSet (Î¼ : Measure Î²) [IsLocallyFiniteMeasure Î¼]\n    {s : Set Î²} (hs : MeasurableSet s) :\n    âˆ€áµ x âˆ‚Î¼,\n      Tendsto (fun r => Î¼ (s âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0)\n        (ğ“ (s.indicator 1 x)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two lists 'l' and 'l'' and a natural number 'n', the rotation of list 'l' by 'n' positions is equal to list 'l'' if and only if list 'l' is equal to the rotation of list 'l'' by the difference of the length of 'l'' and the remainder of 'n' divided by the length of 'l''.",
    "output": "theorem rotate_eq_iff {l l' : List Î±} {n : â„•} :\n    l.rotate n = l' â†” l = l'.rotate (l'.length - n % l'.length) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two real-valued functions f and g, with their derivatives f' and g', if for every x in the closed interval from a to b, f has a derivative at x equal to f'(x), and g has a derivative at f(x) equal to g'(f(x)), and if f' is continuous on the closed interval from a to b, and g' is continuous, then the integral from a to b of the composition of g' and f, multiplied by f', is equal to the difference of the composition of g and f at b and the composition of g and f at a.",
    "output": "theorem integral_deriv_comp_mul_deriv {f f' g g' : â„ â†’ â„}\n    (hf : âˆ€ x âˆˆ uIcc a b, HasDerivAt f (f' x) x)\n    (hg : âˆ€ x âˆˆ uIcc a b, HasDerivAt g (g' (f x)) (f x)) (hf' : ContinuousOn f' (uIcc a b))\n    (hg' : Continuous g') : (âˆ« x in a..b, (g' âˆ˜ f) x * f' x) = (g âˆ˜ f) b - (g âˆ˜ f) a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'l' on a type 'Î±', a function 'f' from 'Î±' to a group 'G', and an element 'x' of 'G', if 'f' tends towards 'x' with respect to the filter 'l', then for any integer 'z', the function that maps 'x' to the 'z'-th power of 'f(x)' also tends towards the 'z'-th power of 'x' with respect to the filter 'l'.",
    "output": "theorem Filter.Tendsto.zpow {Î±} {l : Filter Î±} {f : Î± â†’ G} {x : G} (hf : Tendsto f l (ğ“ x))\n    (z : â„¤) : Tendsto (fun x => f x ^ z) l (ğ“ (x ^ z)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b', the product of the quotient of 'a' and the quotient of 'b' in the ring quotient 'r' is equal to the quotient of the product of 'a' and 'b'.",
    "output": "theorem mul_quot {a b} : (âŸ¨Quot.mk _ aâŸ© * âŸ¨Quot.mk _ bâŸ© : RingQuot r) = âŸ¨Quot.mk _ (a * b)âŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', rotating an empty list 'n' times results in an empty list.",
    "output": "theorem rotate'_nil (n : â„•) : ([] : List Î±).rotate' n = [] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given polynomial 'p', if 'p' is monic (which means the leading coefficient is 1), then the coefficient of 'p' at its natural degree is 1.",
    "output": "theorem Monic.coeff_natDegree {p : R[X]} (hp : p.Monic) : p.coeff p.natDegree = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If set sâ‚ is a subset of set sâ‚‚ and set tâ‚ is a subset of set tâ‚‚, then the disjoint sum of sâ‚ and tâ‚ is a subset of the disjoint sum of sâ‚‚ and tâ‚‚.",
    "output": "theorem disjSum_mono (hs : sâ‚ âŠ† sâ‚‚) (ht : tâ‚ âŠ† tâ‚‚) : sâ‚.disjSum tâ‚ âŠ† sâ‚‚.disjSum tâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'Î¼' from a pair of natural numbers to a natural number, and this function is a covariant class with respect to the swap operation and the less than or equal to relation, and if 'f' is an antitone function, then for any natural number 'm', the function that maps 'n' to 'f' of 'Î¼' of 'n' and 'm' is also an antitone function.",
    "output": "theorem Antitone.covariant_of_const' {Î¼ : N â†’ N â†’ N} [CovariantClass N N (swap Î¼) (Â· â‰¤ Â·)]\n    (hf : Antitone f) (m : N) : Antitone fun n â†¦ f (Î¼ n m) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a relation 'r' between elements of type 'Î²' and a function 'f' from type 'Î±' to 'Î²', the condition of 'pairwise' (meaning that every pair of distinct elements satisfies the relation 'r') for the function 'f' applied to elements of a subset 's' is equivalent to the condition of 'pairwise' for the function 'f' applied to the elements of the set 's'.",
    "output": "theorem pairwise_subtype_iff_pairwise_finset' (r : Î² â†’ Î² â†’ Prop) (f : Î± â†’ Î²) :\n    Pairwise (r on fun x : s => f x) â†” (s : Set Î±).Pairwise (r on f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The bounded limit inferior (bliminf) of a function 'u' with respect to a filter 'f' for the condition 'p x or q x' is equal to the greatest lower bound (infimum) of the bliminf of 'u' with respect to 'f' for the condition 'p' and the bliminf of 'u' with respect to 'f' for the condition 'q'.",
    "output": "theorem bliminf_or_eq_inf : (bliminf u f fun x => p x âˆ¨ q x) = bliminf u f p âŠ“ bliminf u f q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any matrix 'x' with finite dimensions 'm' and 'n', 'x' can be expressed as the sum of standard basis matrices, where each standard basis matrix is scaled by the corresponding element in 'x'.",
    "output": "theorem matrix_eq_sum_std_basis [Fintype m] [Fintype n] (x : Matrix m n Î±) :\n    x = âˆ‘ i : m, âˆ‘ j : n, stdBasisMatrix i j (x i j) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given basis 'l' with properties 'p' and sets 's', for any element 'x' of type Î±, 'x' is in every set 't' in 'l' if and only if for every 'i', if 'p i' holds, then 'x' is in 's i'.",
    "output": "theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : Î±} :\n    (âˆ€ t âˆˆ l, x âˆˆ t) â†” âˆ€ i, p i â†’ x âˆˆ s i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Subtracting any number from the lowest possible number results in the lowest possible number.",
    "output": "theorem bot_sub : âŠ¥ - t = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' and a set 's' of elements of type Î±, if 's' is in the neighborhood within 'a' (inclusive), then there exists an element 'b' less than or equal to 'a', such that the closed interval from 'b' to 'a' is in the neighborhood within 'a' (inclusive) and this closed interval is a subset of 's'.",
    "output": "theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Iic {a : Î±} {s : Set Î±} (hs : s âˆˆ ğ“[â‰¤] a) :\n    âˆƒ b â‰¤ a, Icc b a âˆˆ ğ“[â‰¤] a âˆ§ Icc b a âŠ† s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any multiplication operation on a set Î±, and any two elements 'a' and 'b' from the lexicographic order of Î±, the lexicographic order of the product of 'a' and 'b' is equal to the product of the lexicographic orders of 'a' and 'b'.",
    "output": "theorem ofLex_mul [Mul Î±] (a b : Lex Î±) : ofLex (a * b) = ofLex a * ofLex b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of the opposites of a sequence of elements (f x) is equal to the opposite of the sum of the sequence.",
    "output": "theorem tsum_op : (âˆ‘' x, MulOpposite.op (f x)) = MulOpposite.op (âˆ‘' x, f x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given convex set 's' in a topological vector space 'E' over a field 'ğ•œ', if every pair of distinct points in the boundary of 's' can be connected by a line segment that lies in the interior of 's', then 's' is strictly convex.",
    "output": "theorem Convex.strictConvex' {s : Set E} (hs : Convex ğ•œ s)\n    (h : (s \\ interior s).Pairwise fun x y => âˆƒ c : ğ•œ, lineMap x y c âˆˆ interior s) :\n    StrictConvex ğ•œ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any elements 'm' from set M, 'n' from set N, and 'p' from set P, the inverse of the tensor product association of 'm', 'n', and 'p' is equal to the tensor product of 'm', 'n', and 'p' in that order.",
    "output": "theorem assoc_symm_tmul (m : M) (n : N) (p : P) :\n    (TensorProduct.assoc R M N P).symm (m âŠ—â‚œ (n âŠ—â‚œ p)) = m âŠ—â‚œ n âŠ—â‚œ p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a complex-valued function 'f', a complex number 'c' and 'w', and a real number 'R', the integral of the function ((z - w)â»Â¹ â€¢ (z - w) â€¢ f z) over the circle centered at 'c' with radius 'R' is equal to the integral of the function 'f' over the same circle.",
    "output": "theorem integral_sub_inv_smul_sub_smul (f : â„‚ â†’ E) (c w : â„‚) (R : â„) :\n    (âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ (z - w) â€¢ f z) = âˆ® z in C(c, R), f z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The limit inferior (liminf) of a function that always returns the top element of a set, under any filter, is the top element of the set.",
    "output": "theorem liminf_const_top {f : Filter Î²} : liminf (fun _ : Î² => (âŠ¤ : Î±)) f = (âŠ¤ : Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any composition 'c' of a number 'n', the length of 'c' when converted to a composition set is equal to the original length of 'c'.",
    "output": "theorem Composition.toCompositionAsSet_length (c : Composition n) :\n    c.toCompositionAsSet.length = c.length :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a real number 'r' which is greater than 0 and less than 1, the neighborhood of a point 'x' has a basis that is a function of the natural number 'n', where the function is the closed ball centered at 'x' with radius 'r' to the power of 'n'.",
    "output": "theorem nhds_basis_closedBall_pow {r : â„} (h0 : 0 < r) (h1 : r < 1) :\n    (ğ“ x).HasBasis (fun _ => True) fun n : â„• => closedBall x (r ^ n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'x' is an irrational number and 'q' is a rational number that is not equal to zero, then the result of dividing 'q' by 'x' is also an irrational number.",
    "output": "theorem rat_div (h : Irrational x) {q : â„š} (hq : q â‰  0) : Irrational (q / x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of the factor through the image of a morphism 'f' and the inverse of the isomorphism from the coimage of 'f' to its image is equal to the projection onto the cokernel.",
    "output": "theorem factorThruImage_comp_coimageIsoImage'_inv :\n    factorThruImage f â‰« (coimageIsoImage' f).inv = cokernel.Ï€ _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A linear order Î± is nontrivial if and only if there exist elements x and y in Î± such that x is less than y.",
    "output": "theorem nontrivial_iff_lt [LinearOrder Î±] : Nontrivial Î± â†” âˆƒ x y : Î±, x < y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given order isomorphism 'e' between two ordered sets 'Î±' and 'Î²', 'e' is a surjective function. This means that for every element in the set 'Î²', there is at least one corresponding element in the set 'Î±' under the function 'e'.",
    "output": "theorem surjective (e : Î± â‰ƒo Î²) : Function.Surjective e :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'g' is asymptotically dominated by a function 'f' at a limit point 'l' and 'c' is a non-zero real number, then the function 'f' is also asymptotically dominated by the function 'c * g' at the same limit point 'l'.",
    "output": "theorem IsLittleO.const_mul_right' {g : Î± â†’ R} {c : R} (hc : IsUnit c) (h : f =o[l] g) :\n    f =o[l] fun x => c * g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a multiplicative character Ï‡ from a ring R to another ring R', the inverse of Ï‡ multiplied by Ï‡ equals 1.",
    "output": "theorem inv_mul (Ï‡ : MulChar R R') : Ï‡â»Â¹ * Ï‡ = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the successor of 'n' doubled is equal to the successor of the successor of 'n' doubled.",
    "output": "theorem bit0_succ_eq (n : â„•) : bit0 (succ n) = succ (succ (bit0 n)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of vertices of the infimum of a function from an index set to subgraphs is equal to the intersection of the set of vertices of each subgraph in the function.",
    "output": "theorem verts_iInf {f : Î¹ â†’ G.Subgraph} : (â¨… i, f i).verts = â‹‚ i, (f i).verts :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A number 'a' raised to an odd power 'n' is greater than zero if and only if the number 'a' itself is greater than zero.",
    "output": "theorem zpow_bit1_pos_iff : 0 < a ^ bit1 n â†” 0 < a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a square (sq) is an isomorphism, then the composition of the left side of the square with the homomorphism (g.hom) and the inverse of the right side of the square equals the homomorphism of f.",
    "output": "theorem left_hom_inv_right [IsIso sq] : sq.left â‰« g.hom â‰« inv sq.right = f.hom :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of ring theory, given an algebraic pushout structure (denoted by H) of rings R, S, R', and S', and given two algebra morphisms f from S to A and g from R' to A, for any element x in R', the result of applying the pushout description function (Algebra.pushoutDesc) to S', f, g, H, and the result of applying the algebra map to R' and S' on x, is equal to the result of applying g on x. This holds for any type A that is a semiring and an algebra over R.",
    "output": "theorem Algebra.pushoutDesc_right [H : Algebra.IsPushout R S R' S'] {A : Type _} [Semiring A]\n    [Algebra R A] (f : S â†’â‚[R] A) (g : R' â†’â‚[R] A) (H) (x : R') :\n    Algebra.pushoutDesc S' f g H (algebraMap R' S' x) = g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'Ï€' from 'Î±' to 'Î²', a set 's' of 'Î²', a set 't' of 'Î±', and an element 'a' of 'Î±' such that 'a' is an element of 't', 't' is open, and 's' is in the neighborhood of 'Ï€(a)' in the coinduced topology, the preimage of 's' under 'Ï€' is in the neighborhood of 'a'.",
    "output": "theorem preimage_nhds_within_coinduced {Ï€ : Î± â†’ Î²} {s : Set Î²} {t : Set Î±} {a : Î±} (h : a âˆˆ t)\n    (ht : IsOpen t)\n    (hs : s âˆˆ @nhds Î² (.coinduced (fun x : t => Ï€ x) inferInstance) (Ï€ a)) :\n    Ï€ â»Â¹' s âˆˆ ğ“ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functors F and G from a category J to a category C, and a natural transformation Î± from F to G, the lax limit of the map Î± is equal to the limit of the map Î±.",
    "output": "theorem limLax_map {F G : J â¥¤ C} (Î± : F âŸ¶ G) : limLax.map Î± = lim.map Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a measurable function 'f' and a constant 'c' from a measurable multiplication set 'M', then the function that multiplies 'c' with the output of 'f' for any input 'x' is also measurable.",
    "output": "theorem Measurable.const_mul [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => c * f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a surjective ring homomorphism Ï„â‚â‚‚, given a linear map f from M to Mâ‚‚ and a proof h, the range of the quotient lift of f with respect to h is equal to the range of f.",
    "output": "theorem range_liftQ [RingHomSurjective Ï„â‚â‚‚] (f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) (h) :\n    range (p.liftQ f h) = range f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The complement of set 's' is less than or equal to the complement of set 't' if and only if set 's' is less than or equal to set 't'.",
    "output": "theorem compl_le_compl : s.compl â‰¤ t.compl â†” s â‰¤ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is bounded below and above if and only if there exist two elements 'a' and 'b' such that 's' is a subset of the closed interval from 'a' to 'b'.",
    "output": "theorem bddBelow_bddAbove_iff_subset_Icc : BddBelow s âˆ§ BddAbove s â†” âˆƒ a b, s âŠ† Icc a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 's', the greatest common divisor of 0 and 's' is 0.",
    "output": "theorem gcdA_zero_left {s : â„•} : gcdA 0 s = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two multiplicative structures M and N, if there exists a multiplicative equivalence between M and N, then an element x in M maps to 1 in N if and only if x is 1 in M.",
    "output": "theorem map_eq_one_iff {M N} [MulOneClass M] [MulOneClass N] (h : M â‰ƒ* N) {x : M} :\n  h x = 1 â†” x = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given category with limits of shape J, and two objects i and j in category K, and a functor F from J to K to C, and a morphism f from i to j, the composition of the map of the limit of F with f and the homomorphism of the limit object isomorphic to the limit composed with the evaluation is equal to the composition of the homomorphism of the limit object isomorphic to the limit composed with the evaluation and the limit map of the left whiskered functor with the map of the evaluation with f.",
    "output": "theorem limit_map_limitObjIsoLimitCompEvaluation_hom [HasLimitsOfShape J C] {i j : K}\n    (F : J â¥¤ K â¥¤ C) (f : i âŸ¶ j) : (limit F).map f â‰« (limitObjIsoLimitCompEvaluation _ _).hom =\n    (limitObjIsoLimitCompEvaluation _ _).hom â‰« limMap (whiskerLeft _ ((evaluation _ _).map f)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is less than or equal to 'b', then the difference between the closed interval from 'a' to 'b' and the open interval from 'a' to 'b' is the set containing 'a' and 'b'.",
    "output": "theorem Icc_diff_Ioo_self (h : a â‰¤ b) : Icc a b \\ Ioo a b = {a, b} :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of all elements 'x' from set 'A' that are algebraic over 'R' is countable.",
    "output": "theorem countable : Set.Countable { x : A | IsAlgebraic R x } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Zero is less than a if and only if a is not equal to zero.",
    "output": "theorem zero_lt_iff : 0 < a â†” a â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The norm of the Fourier integral of a function f with respect to a multiplicative function e, a measure Î¼, a linear map L, and a point w, is less than or equal to the integral of the norm of the function f with respect to the measure Î¼.",
    "output": "theorem norm_fourierIntegral_le_integral_norm (e : Multiplicative ğ•œ â†’* ğ•Š) (Î¼ : Measure V)\n    (L : V â†’â‚—[ğ•œ] W â†’â‚—[ğ•œ] ğ•œ) (f : V â†’ E) (w : W) :\n    â€–fourierIntegral e Î¼ L f wâ€– â‰¤ âˆ« v : V, â€–f vâ€– âˆ‚Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The identity element (1) in the submonoid S' is equal to the pair consisting of the identity element and the proof that the identity element is in the submonoid S'.",
    "output": "theorem one_def : (1 : S') = âŸ¨1, OneMemClass.one_mem S'âŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number p that is greater than or equal to 1, and for any two non-negative real numbers a and b, the pth power of a plus the pth power of b, all raised to the power of 1/p, is less than or equal to the sum of a and b.",
    "output": "theorem rpow_add_rpow_le_add {p : â„} (a b : â„â‰¥0) (hp1 : 1 â‰¤ p) :\n    (a ^ p + b ^ p) ^ (1 / p) â‰¤ a + b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'e' is continuous on the set 's'.",
    "output": "theorem continuousOn {s} : ContinuousOn e s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any linear ordered semiring Î± and any positive numbers m and n, casting m to Î± is less than n if and only if m is less than n.",
    "output": "theorem cast_lt [LinearOrderedSemiring Î±] {m n : PosNum} : (m : Î±) < n â†” m < n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A monic polynomial p of degree 2 is not irreducible if and only if there exist coefficients câ‚ and câ‚‚ such that the zeroth coefficient of p equals the product of câ‚ and câ‚‚, and the first coefficient of p equals the sum of câ‚ and câ‚‚.",
    "output": "theorem Monic.not_irreducible_iff_exists_add_mul_eq_coeff (hm : p.Monic) (hnd : p.natDegree = 2) :\n    Â¬Irreducible p â†” âˆƒ câ‚ câ‚‚, p.coeff 0 = câ‚ * câ‚‚ âˆ§ p.coeff 1 = câ‚ + câ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'a' is the maximum value in the dual order if and only if 'a' is the minimum value in the original order.",
    "output": "theorem isMax_toDual_iff : IsMax (toDual a) â†” IsMin a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear isometric equivalence 'f' from 'E' to 'F', and for submodules 'U' and 'V' of 'F', the preimage of 'U' under 'f' is orthogonal to the preimage of 'V' under 'f' if and only if 'U' is orthogonal to 'V'.",
    "output": "theorem IsOrtho.comap_iff (f : E â‰ƒâ‚—áµ¢[ğ•œ] F) {U V : Submodule ğ•œ F} : U.comap f âŸ‚ V.comap f â†” U âŸ‚ V :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The complement of a set 's' equals the universal set if and only if the set 's' is empty.",
    "output": "theorem compl_univ_iff {s : Set Î±} : sá¶œ = univ â†” s = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and c in a set Î±, the associative property holds for the operation \"infimum\" (denoted by âŠ“). In other words, taking the infimum of a and b first and then taking the infimum with c gives the same result as taking the infimum of b and c first and then taking the infimum with a.",
    "output": "theorem inf_assoc (a b c : Î±) : a âŠ“ b âŠ“ c = a âŠ“ (b âŠ“ c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any sequence of propositions 'p' indexed by natural numbers, any sequence of sets 's' also indexed by natural numbers, and any sequence of real numbers 'r' indexed by natural numbers, if the sequence 'r' tends to 0 at the top and for almost all 'i' in the top, if 'p i' is true then 'r i' is greater than 0, then the boundary limit superior of the sequence of c-thickenings of the sets 's' by 'r' at the top for 'p' is almost everywhere equal to the boundary limit superior of the sequence of thickenings of the sets 's' by 'r' at the top for 'p' with respect to measure 'Î¼'.",
    "output": "theorem blimsup_cthickening_ae_eq_blimsup_thickening {p : â„• â†’ Prop} {s : â„• â†’ Set Î±} {r : â„• â†’ â„}\n    (hr : Tendsto r atTop (ğ“ 0)) (hr' : âˆ€á¶  i in atTop, p i â†’ 0 < r i) :\n    (blimsup (fun i => cthickening (r i) (s i)) atTop p : Set Î±) =áµ[Î¼]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a simple function 'f' from set 'Î±' to 'E' with respect to measure 'Î¼', applying the function 'setToL1S' with zero as the linear map from set 'Î±' to 'E' to 'F' over the reals, results in zero.",
    "output": "theorem setToL1S_zero_left (f : Î± â†’â‚â‚›[Î¼] E) : setToL1S (0 : Set Î± â†’ E â†’L[â„] F) f = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a surjective ring homomorphism Ï„â‚â‚‚ and a function f from field F, the map of the preimage (comap) of a submodule q under function f is equal to the intersection of the range of function f and the submodule q.",
    "output": "theorem _root_.Submodule.map_comap_eq [RingHomSurjective Ï„â‚â‚‚] (f : F) (q : Submodule Râ‚‚ Mâ‚‚) :\n    map f (comap f q) = range f âŠ“ q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function that takes an input 'x' and produces a pair consisting of the outputs of two functions 'f' and 'g' (i.e., (f x, g x)) is continuous if and only if both 'f' and 'g' are continuous.",
    "output": "theorem continuous_prod_mk {f : Î± â†’ Î²} {g : Î± â†’ Î³} :\n    (Continuous fun x => (f x, g x)) â†” Continuous f âˆ§ Continuous g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f commutes with function g, then for any natural numbers m and n, the m-th iteration of function f commutes with the n-th iteration of function g.",
    "output": "theorem iterate_iterate (h : Commute f g) (m n : â„•) : Commute (f^[m]) (g^[n]) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î¹, a continuous linear map 'f' from Mâ‚ to Mâ‚‚, a finite set 's' of type Î¹, and a function 'g' from Î¹ to Mâ‚, the map of the sum of the function 'g' over the set 's' is equal to the sum of the map of the function 'g' over the set 's'.",
    "output": "theorem map_sum {Î¹ : Type _} (f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚) (s : Finset Î¹) (g : Î¹ â†’ Mâ‚) :\n    f (âˆ‘ i in s, g i) = âˆ‘ i in s, f (g i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a certain type Î¹, a function v from Î¹ to M, and a linear independence i of v, given a set w of M with finite elements, if the range of v is less than or equal to the span of R and w, then the cardinality of Î¹ is less than or equal to the cardinality of w.",
    "output": "theorem linearIndependent_le_span' {Î¹ : Type _} (v : Î¹ â†’ M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : range v â‰¤ span R w) : (#Î¹) â‰¤ Fintype.card w :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f has a derivative f' at a point x with respect to a filter L, then the function that subtracts a constant c from f also has a derivative f' at the same point x with respect to the same filter L.",
    "output": "theorem HasDerivAtFilter.sub_const (hf : HasDerivAtFilter f f' x L) (c : F) :\n    HasDerivAtFilter (fun x => f x - c) f' x L :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a list 'l' with no duplicate elements (Nodup l) and a length of at least 2 (2 â‰¤ l.length), the cycle of the formPerm function applied to 'l' and an element 'x' is equal to the formPerm function applied to 'l'.",
    "output": "theorem cycleOf_formPerm (hl : Nodup l) (hn : 2 â‰¤ l.length) (x) :\n    cycleOf l.attach.formPerm x = l.attach.formPerm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given isomorphism 'f' from 'N' to 'M' and a submonoid 'K' of 'M', the preimage of 'K' under 'f' is equal to the image of 'K' under the inverse of 'f'.",
    "output": "theorem comap_equiv_eq_map_symm (f : N â‰ƒ* M) (K : Submonoid M) :\n    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The fractional part of 'm' with respect to 'b' equals the fractional part of 'n' with respect to 'b' if and only if the difference of 'm' and 'n' is an integer multiple of 'b'.",
    "output": "theorem fract_eq_fract (m n : E) : fract b m = fract b n â†” -m + n âˆˆ span â„¤ (Set.range b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two uniform space homeomorphisms 'h' and 'h'' from 'Î±' to 'Î²', if for every 'x' in 'Î±', 'h' at 'x' equals 'h'' at 'x', then 'h' is equal to 'h''.",
    "output": "theorem ext {h h' : Î± â‰ƒáµ¤ Î²} (H : âˆ€ x, h x = h' x) : h = h' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite dimensional vector space V over a field K, given a type Î¹ and a function b from Î¹ to V that is linearly independent, the cardinality of Î¹ is less than or equal to the finite rank of the vector space V over the field K.",
    "output": "theorem cardinal_mk_le_finrank_of_linearIndependent [FiniteDimensional K V] {Î¹ : Type w} {b : Î¹ â†’ V}\n    (h : LinearIndependent K b) : (#Î¹) â‰¤ finrank K V :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If F is a sheaf on X (in the category C), then the pushforward of F along some morphism f is also a sheaf.",
    "output": "theorem pushforward_sheaf_of_sheaf {F : X.Presheaf C} (h : F.IsSheaf) : (f _* F).IsSheaf :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given pair of vertices 'p' in a graph 'G' where 'p.1' and 'p.2' are adjacent, the edge of the dart created from 'p' and this adjacency is equivalent to the unordered pair of 'p'.",
    "output": "theorem Dart.edge_mk {p : V Ã— V} (h : G.Adj p.1 p.2) : (Dart.mk p h).edge = âŸ¦pâŸ§ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the upper bounds of a set under a function is a subset of the upper bounds of the image of the set under the same function.",
    "output": "theorem image_upperBounds_subset_upperBounds_image : f '' upperBounds s âŠ† upperBounds (f '' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'f' has a sum 'a' over a finite set 's' if and only if the function 'f' has a sum of 'a' minus the sum of 'f' over 's' for all elements 'x' not in 's'.",
    "output": "theorem Finset.hasSum_iff_compl (s : Finset Î²) :\n    HasSum f a â†” HasSum (fun x : { x // x âˆ‰ s } => f x) (a - âˆ‘ i in s, f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'w' is a commutative square with 'fst', 'snd', 'f', and 'g' as its elements, and 'w.cone' is a limit, then 'fst', 'snd', 'f', and 'g' form a pullback.",
    "output": "theorem of_isLimit' (w : CommSq fst snd f g) (h : Limits.IsLimit w.cone) :\n    IsPullback fst snd f g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two multi-variable polynomials 'p' and 'q', the support of the sum of 'p' and 'q' is a subset of the union of the support of 'p' and the support of 'q'. This is under the condition that there exists a decidable equality for 'Ïƒ'.",
    "output": "theorem support_add [DecidableEq Ïƒ] : (p + q).support âŠ† p.support âˆª q.support :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is monotone and the composition of functions 'h' and 'g' is less than or equal to the composition of 'f' and 'h', then for any natural number 'n', the composition of 'h' and the 'n'-th iteration of 'g' is less than or equal to the 'n'-th iteration of 'f' composed with 'h'.",
    "output": "theorem le_iterate_comp_of_le (hf : Monotone f) (H : h âˆ˜ g â‰¤ f âˆ˜ h) (n : â„•) :\n    h âˆ˜ g^[n] â‰¤ f^[n] âˆ˜ h :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A constant function (which always returns the value 'b') is Lipschitz continuous with a Lipschitz constant of 0.",
    "output": "theorem const (b : Î²) : LipschitzWith 0 fun _ : Î± => b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of algebra, given an algebra structure over rings R and A, and a scalar tower structure over R, A, and B, A is integral over R.",
    "output": "theorem isIntegral_algebra [Algebra R A] [IsScalarTower R A B] : Algebra.IsIntegral R A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponential function is continuous on the metric ball centered at 0 with radius equal to the radius of the exponential series.",
    "output": "theorem continuousOn_exp : ContinuousOn (exp ğ•‚ : ğ”¸ â†’ ğ”¸) (EMetric.ball 0 (expSeries ğ•‚ ğ”¸).radius) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given property 'p' applicable to a multiset 's' of any type 'Î±', and a proof 'H' of this property, the result of applying strong induction on 's' with 'H' is equal to the result of applying 'H' to 's' and a function that applies strong induction on any 't' that is a subset of 's' with 'H'.",
    "output": "theorem strongInductionOn_eq {p : Multiset Î± â†’ Sort _} (s : Multiset Î±) (H) :\n    @strongInductionOn _ p s H = H s fun t _h => @strongInductionOn _ p t H :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of a Lie algebra 'L', any element 'm' of a module 'M', and any natural number 'k', the 'k'-th iteration of 'x' under the endomorphism 'toEndomorphism' applied to 'm' is an element of the 'k'-th lower central series of the module 'M' over the ring 'R' and the Lie algebra 'L'.",
    "output": "theorem iterate_toEndomorphism_mem_lowerCentralSeries (x : L) (m : M) (k : â„•) :\n    (toEndomorphism R L M x^[k]) m âˆˆ lowerCentralSeries R L M k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'f' is continuous on the set 's' if and only if for every set 't' in the codomain, if 't' is open, then there exists a set 'u' in the domain such that 'u' is open and the preimage of 't' under 'f' intersected with 's' is equal to 'u' intersected with 's'.",
    "output": "theorem continuousOn_iff' {f : Î± â†’ Î²} {s : Set Î±} :\n    ContinuousOn f s â†” âˆ€ t : Set Î², IsOpen t â†’ âˆƒ u, IsOpen u âˆ§ f â»Â¹' t âˆ© s = u âˆ© s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' from the set 'ğ”¸', the exponential series is summable, where each term in the series is the result of applying the exponential series function to 'x'.",
    "output": "theorem expSeries_summable (x : ğ”¸) : Summable fun n => expSeries ğ•‚ ğ”¸ n fun _ => x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A module 'M' quotiented by a submodule 'm' over a ring 'R' is a simple module if and only if 'm' is a coatom.",
    "output": "theorem isSimpleModule_iff_isCoatom : IsSimpleModule R (M â§¸ m) â†” IsCoatom m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'a' and its corresponding natural number 'a'', and any natural number 'c', if 'a' is a natural number equivalent to 'a'' and the successor of 'a'' is equal to 'c', then the successor of 'a' is a natural number equivalent to 'c'.",
    "output": "theorem isNat_natSucc : {a : â„•} â†’ {a' c : â„•} â†’\n    IsNat a a' â†’ Nat.succ a' = c â†’ IsNat (a.succ) c"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'s' is a lower set if and only if for all 'a', if 'a' is an element of 's', then the set of all elements less than or equal to 'a' is a subset of 's'.",
    "output": "theorem isLowerSet_iff_Iic_subset : IsLowerSet s â†” âˆ€ â¦ƒaâ¦„, a âˆˆ s â†’ Iic a âŠ† s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', when 'n' is cast from lexicographic order to any type 'Î±' using the natural number casting function, it remains equal to 'n'.",
    "output": "theorem ofLex_natCast [NatCast Î±] (n : â„•) : (ofLex n : Î±) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î± that is small, there is no injective function from the set of ordinals to Î±.",
    "output": "theorem not_injective_of_ordinal_of_small {Î± : Type v} [Small.{u} Î±] (f : Ordinal.{u} â†’ Î±) :\n    Â¬Injective f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' in the dual order, 'a' is the maximum element if and only if 'a' is the minimum element.",
    "output": "theorem isMax_ofDual_iff {a : Î±áµ’áµˆ} : IsMax (ofDual a) â†” IsMin a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two sets s and t, if the neighborhood of s contains boxes of t, then the neighborhood of t also contains boxes of s. This property is symmetric.",
    "output": "theorem NhdsContainBoxes.symm {s : Set Î±} {t : Set Î²} :\n    NhdsContainBoxes s t â†’ NhdsContainBoxes t s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite sets sâ‚ and sâ‚‚ of any type Î±, sâ‚ is a subset of sâ‚‚ as a set of type Î± if and only if sâ‚ is a subset of sâ‚‚ as a finite set.",
    "output": "theorem coe_subset {sâ‚ sâ‚‚ : Finset Î±} : (sâ‚ : Set Î±) âŠ† sâ‚‚ â†” sâ‚ âŠ† sâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Mapping the range of an additive equivalence that reflects the type M is the same as reflecting an additive equivalence of a function from Î± to M.",
    "output": "theorem mapRange.addEquiv_refl : mapRange.addEquiv (AddEquiv.refl M) = AddEquiv.refl (Î± â†’â‚€ M) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ordered semiring Î±, and any elements a and b of Î±, if a equals 0 and b is less than or equal to 0, then the sum of a and b is less than or equal to 0.",
    "output": "theorem le_of_eq_of_le {Î±} [OrderedSemiring Î±] {a b : Î±} (ha : a = 0) (hb : b â‰¤ 0) : a + b â‰¤ 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given Boolean value 'b', 'b' is either false or true.",
    "output": "theorem dichotomy (b : Bool) : b = false âˆ¨ b = true :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of category theory, for any type 'C' that forms a groupoid, and for any two objects 'X' and 'Y' of type 'C', 'X' is isomorphic to 'Y' if and only if there exists at least one morphism from 'X' to 'Y'.",
    "output": "theorem Groupoid.isIsomorphic_iff_nonempty_hom {C : Type u} [Groupoid.{v} C] {X Y : C} :\n    IsIsomorphic X Y â†” Nonempty (X âŸ¶ Y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An ordinal number 'a' is less than the predecessor of an ordinal number 'b' if and only if the successor of 'a' is less than 'b'.",
    "output": "theorem lt_pred {a b} : a < pred b â†” succ a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is the greatest element in set 's', then 'a' is included in the maximal elements of the set 's' with respect to the less than or equal to relation.",
    "output": "theorem IsGreatest.mem_maximals (h : IsGreatest s a) : a âˆˆ maximals (Â· â‰¤ Â·) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The head of a vector, which is a function from the successor of a finite number 'n' to an arbitrary type 'Î±' and is initialized to zero, is equal to zero.",
    "output": "theorem head_zero : vecHead (0 : Fin n.succ â†’ Î±) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The preimage of the set of real numbers between 'a' and 'b' under the function that casts integers to real numbers is the set of integers between the ceiling of 'a' and the floor of 'b'.",
    "output": "theorem preimage_Icc {a b : Î±} : (Int.cast : â„¤ â†’ Î±) â»Â¹' Set.Icc a b = Set.Icc âŒˆaâŒ‰ âŒŠbâŒ‹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two objects 'p' and 'q' in the action category of 'M' and 'X', and any morphism 'f' from 'p' to 'q', the map of 'f' under the projection functor 'Ï€' from 'M' to 'X' is equal to the value of 'f'.",
    "output": "theorem Ï€_map (p q : ActionCategory M X) (f : p âŸ¶ q) : (Ï€ M X).map f = f.val :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any Boolean value 'b' and any element 'a' of any type 'Î±', the condition that returns 'a' whether 'b' is true or false is equal to 'a'.",
    "output": "theorem cond_self.{u} {Î± : Type u} (b : Bool) (a : Î±) : cond b a a = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± and any function f from Boolean to Î±, the function f is injective if and only if the function f applied to false is not equal to the function f applied to true.",
    "output": "theorem injective_iff {Î± : Sort _} {f : Bool â†’ Î±} : Function.Injective f â†” f false â‰  f true :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an ordered type Î±, the \"some\" option of a is less than the \"some\" option of b if and only if a is less than b.",
    "output": "theorem some_lt_some : @LT.lt (WithBot Î±) _ (Option.some a) (Option.some b) â†” a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The symmetric difference of 'a' and 'b', excluding 'c', is equal to 'a' excluding the union of 'b' and 'c', union 'b' excluding the union of 'a' and 'c'.",
    "output": "theorem symmDiff_sdiff : a âˆ† b \\ c = a \\ (b âŠ” c) âŠ” b \\ (a âŠ” c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The right take-while operation on a list 'l' with a predicate 'p' equals an empty list if and only if for all non-empty lists 'l', the predicate 'p' applied to the last element of 'l' is not true.",
    "output": "theorem rtakeWhile_eq_nil_iff : rtakeWhile p l = [] â†” âˆ€ hl : l â‰  [], Â¬p (l.getLast hl) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f has a derivative f' within a set s at a point x, then the function that maps x to the complex sine of f(x) has a derivative within the same set s at the same point x, which is the complex cosine of f(x) times f'.",
    "output": "theorem HasFDerivWithinAt.csin (hf : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (fun x => Complex.sin (f x)) (Complex.cos (f x) â€¢ f') s x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The factor multiset of 1 is equal to 0.",
    "output": "theorem factorMultiset_one : factorMultiset 1 = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a functor F from category J to the category of topological spaces, the topology of the limit of F is the infimum of the topologies induced by the limit projections from the limit of F to each object in the image of F.",
    "output": "theorem limit_topology (F : J â¥¤ TopCatMax.{v, u}) :\n    (limit F).str = â¨… j, (F.obj j).str.induced (limit.Ï€ F j) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two trivializations 'e' and 'e'' of a fiber bundle with projection 'proj', the source of the transformation from the inverse of 'e' to 'e'' is equal to the intersection of the base sets of 'e' and 'e'' cross the universal set.",
    "output": "theorem symm_trans_source_eq (e e' : Trivialization F proj) :\n    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).source = (e.baseSet âˆ© e'.baseSet) Ã—Ë¢ univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set R which is a right transversal of a subset H of a group G, and a given set S such that its closure is the entire group G, the closure of the image of the set resulting from multiplying R and S, under a function that maps each element g to the pair consisting of g multiplied by the inverse of the function applied to g (where this function is guaranteed to map g to an element of G), is also the entire group G. This is under the condition that the identity element of G is in R.",
    "output": "theorem closure_mul_image_eq_top (hR : R âˆˆ rightTransversals (H : Set G)) (hR1 : (1 : G) âˆˆ R)\n    (hS : closure S = âŠ¤) : closure ((R * S).image fun g =>\n      âŸ¨g * (toFun hR g : G)â»Â¹, mul_inv_toFun_mem hR gâŸ© : Set H) = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The ordered connected component of 's' at 'a' is in the neighborhood of 'a' if and only if 's' is in the neighborhood of 'a'.",
    "output": "theorem ordConnectedComponent_mem_nhds : ordConnectedComponent s a âˆˆ ğ“ a â†” s âˆˆ ğ“ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The algebraic evaluation of the polynomial 1 with respect to any variable x in the ring R is equal to 1.",
    "output": "theorem aeval_one : aeval x (1 : R[X]) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given non-unital subsemiring 's' of 'R', the subsemigroup of 's' when considered as a set of 'R', is equal to 's' itself.",
    "output": "theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for all x, the preimage of the set of all elements less than x under the function f is a measurable set, then the function f is measurable.",
    "output": "theorem measurable_of_Iio {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Iio x)) : Measurable f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of a function 'f' is surjective if and only if the function 'f' itself is surjective.",
    "output": "theorem image_surjective : Surjective (image f) â†” Surjective f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every index i, the value of function f at i is less than or equal to a, then the supremum (least upper bound) of the function f is less than or equal to a.",
    "output": "theorem iSup_le (h : âˆ€ i, f i â‰¤ a) : iSup f â‰¤ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of a function 'f' with the range splitting of 'f' is equal to the inclusion function. Here, 'f' is a function from type Î± to type Î².",
    "output": "theorem comp_rangeSplitting (f : Î± â†’ Î²) :\n  f âˆ˜ rangeSplitting f = (â†‘) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'a' is differentiable on a set 's' in a field 'ğ•œ', then the function that maps 'x' to the 'n'-th power of 'a(x)' is also differentiable on 's'.",
    "output": "theorem DifferentiableOn.pow (ha : DifferentiableOn ğ•œ a s) (n : â„•) :\n    DifferentiableOn ğ•œ (fun x => a x ^ n) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the first element of the antidiagonal divisors of a number n is equal to the divisors of n.",
    "output": "theorem image_fst_divisorsAntidiagonal : (divisorsAntidiagonal n).image Prod.fst = divisors n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If U is a closed set in the group G, then the left coset of U with respect to any element x in G is also a closed set.",
    "output": "theorem IsClosed.leftCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (leftCoset x U) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear equivalence 'f' between two modules 'M' and 'Mâ‚' over a ring 'R', and a submodule 'p' of 'M', the rank of the image of 'p' under 'f' is equal to the rank of 'p'.",
    "output": "theorem LinearEquiv.rank_map_eq (f : M â‰ƒâ‚—[R] Mâ‚) (p : Submodule R M) :\n    Module.rank R (p.map (f : M â†’â‚—[R] Mâ‚)) = Module.rank R p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± that has a top element (OrderTop Î±) and any subtype of Î± that also has a top element (OrderTop (Subtype p)), if the top element of Î± satisfies the property p (htop : p âŠ¤), then the top element of the subtype created with this property (mk âŠ¤ htop) is equal to the top element of the subtype itself (âŠ¤).",
    "output": "theorem mk_top [OrderTop Î±] [OrderTop (Subtype p)] (htop : p âŠ¤) : mk âŠ¤ htop = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' in a vector space 'E' is star-convex with respect to a point 'x', then the image of this set under an affine transformation 'f' is also star-convex with respect to the image of 'x' under the same transformation.",
    "output": "theorem StarConvex.affine_image (f : E â†’áµƒ[ğ•œ] F) {s : Set E} (hs : StarConvex ğ•œ x s) :\n    StarConvex ğ•œ (f x) (f '' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero divisor in a ring M' and a function f that is injective, the set of non-zero divisors in M is less than or equal to the preimage of the set of non-zero divisors in M' under the function f.",
    "output": "theorem nonZeroDivisors_le_comap_nonZeroDivisors_of_injective [NoZeroDivisors M']\n    [MonoidWithZeroHomClass F M M'] (f : F) (hf : Function.Injective f) : Mâ° â‰¤ M'â°.comap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any elements 'z' and 'u', 'f.map hy k z' equals 'u' if and only if 'k.toMap' applied to 'g' of the first element of 'f.sec z' equals 'k.toMap' applied to 'g' of the second element of 'f.sec z' multiplied by 'u'.",
    "output": "theorem map_spec (z u) : f.map hy k z = u â†” k.toMap (g (f.sec z).1) = k.toMap (g (f.sec z).2) * u :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The closed interval from a to b, excluding both a and b, is equal to the open interval from a to b.",
    "output": "theorem Icc_diff_both : Icc a b \\ {a, b} = Ioo a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If C is preperfect, then the closure of C is perfect. This is under the context of topology.",
    "output": "theorem Preperfect.perfect_closure (hC : Preperfect C) : Perfect (closure C) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function 'v' mapping from 'm' to 'Î±' in a star-ring, the conjugate transpose of a column vector 'v' is equal to the row vector of the star of 'v'.",
    "output": "theorem conjTranspose_col [Star Î±] (v : m â†’ Î±) : (col v)á´´ = row (star v) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite measure Î¼ on a set Î©, the mass of Î¼ is not equal to zero if and only if Î¼ is not equal to zero.",
    "output": "theorem mass_nonzero_iff (Î¼ : FiniteMeasure Î©) : Î¼.mass â‰  0 â†” Î¼ â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' belongs to the space of measurable functions 'Memâ„’p' for a measure 'Î¼' and a real number 'p', and if 'c' is a non-infinite extended non-negative real number, then 'f' also belongs to the space of measurable functions 'Memâ„’p' for the measure 'c' times 'Î¼'.",
    "output": "theorem Memâ„’p.smul_measure {f : Î± â†’ E} {c : â„â‰¥0âˆ} (hf : Memâ„’p f p Î¼) (hc : c â‰  âˆ) :\n    Memâ„’p f p (c â€¢ Î¼) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'embedProduct M' induces a topology.",
    "output": "theorem inducing_embedProduct : Inducing (embedProduct M) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type 'Î±', the application of the function 'pureOneHom' to 'a' is equal to the application of the function 'pure' to 'a'.",
    "output": "theorem pureOneHom_apply (a : Î±) : pureOneHom a = pure a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Subtracting any element 'a' from zero results in zero.",
    "output": "theorem zero_tsub (a : Î±) : 0 - a = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ideal I in a ring R, if I is not equal to the top element, then the characteristic of the quotient ring R/I is zero. Under these conditions, the cast of 1 from the positive natural numbers to the multiplicative group of R is equal to 1.",
    "output": "theorem pnatCast_one [Fact (âˆ€ I : Ideal R, I â‰  âŠ¤ â†’ CharZero (R â§¸ I))] : ((1 : â„•+) : RË£) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given cardinal number 'a' and a natural number 'n', the lift of 'a' is less than or equal to 'n' if and only if 'a' is less than or equal to 'n'.",
    "output": "theorem lift_le_nat_iff {a : Cardinal.{u}} {n : â„•} : lift.{v} a â‰¤ n â†” a â‰¤ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three games xâ‚, xâ‚‚, and y, if xâ‚ is equivalent to xâ‚‚, then the fuzzy relation of xâ‚ and y is equivalent to the fuzzy relation of xâ‚‚ and y.",
    "output": "theorem fuzzy_congr_left {xâ‚ xâ‚‚ y : PGame} (hx : xâ‚ â‰ˆ xâ‚‚) : xâ‚ â€– y â†” xâ‚‚ â€– y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' of type Î±, the function that takes an element 'b' of type Î² and maps it to the pair (a, b) is continuous.",
    "output": "theorem Continuous.Prod.mk (a : Î±) : Continuous fun b : Î² => (a, b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two filters 'lâ‚' and 'lâ‚‚' and any two functions 'Ixx' and 'Ixx'' that map from 'Î±' to 'Î±' to a set of 'Î±', if for all 'a' and 'b', the set 'Ixx' of 'a' and 'b' is a subset of the set 'Ixx'' of 'a' and 'b', and if 'Ixx'' tends to 'Ixx' class from 'lâ‚' to 'lâ‚‚', then 'Ixx' also tends to 'Ixx' class from 'lâ‚' to 'lâ‚‚'.",
    "output": "theorem tendstoIxxClass_of_subset {lâ‚ lâ‚‚ : Filter Î±} {Ixx Ixx' : Î± â†’ Î± â†’ Set Î±}\n    (h : âˆ€ a b, Ixx a b âŠ† Ixx' a b) [h' : TendstoIxxClass Ixx' lâ‚ lâ‚‚] : TendstoIxxClass Ixx lâ‚ lâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any split simplicial object S in a category C, the functor of the identity morphism from S to S is equal to the identity morphism in the category of the object S.X.",
    "output": "theorem id_F (S : Split C) : (ğŸ™ S : S âŸ¶ S).F = ğŸ™ S.X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three integers i, j, and k, the greatest common divisor of i and j divides the greatest common divisor of i and the product of j and k.",
    "output": "theorem gcd_dvd_gcd_mul_right_right (i j k : â„¤) : gcd i j âˆ£ gcd i (j * k) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements x and y in a module M, x and y are on the same ray or x and (-y) are on the same ray if and only if x and y are not linearly independent.",
    "output": "theorem sameRay_or_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y âˆ¨ SameRay R x (-y) â†” Â¬LinearIndependent R ![x, y] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The difference of the interval from a to b, excluding b, and the set containing only b, is equal to the open interval from a to b.",
    "output": "theorem Ioc_diff_right : Ioc a b \\ {b} = Ioo a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' of a set 'Î±', the equivalence class of 'a' is equal to the equivalence class of 'b' if and only if the product of the inverse of 'a' and 'b' is an element of the subset 's'.",
    "output": "theorem eq' {a b : Î±} : (mk a : Î± â§¸ s) = mk b â†” aâ»Â¹ * b âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A presheaf P is separated for a sieve R and for every family of elements of P over R, if the family is compatible, then there exists an amalgamation, if and only if P is a sheaf for R.",
    "output": "theorem isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :\n    (IsSeparatedFor P R âˆ§ âˆ€ x : FamilyOfElements P R, x.Compatible â†’ âˆƒ t, x.IsAmalgamation t) â†”\n      IsSheafFor P R :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The evaluation of a singleton list containing an element 'a' in a deterministic finite automaton 'M' is equal to the result of stepping from the start state of 'M' with 'a'.",
    "output": "theorem eval_singleton (a : Î±) : M.eval [a] = M.step M.start a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every index i, the value of the function g at i is nonnegative, then the infinite sum of the function g over all indices i is also nonnegative.",
    "output": "theorem tsum_nonneg (h : âˆ€ i, 0 â‰¤ g i) : 0 â‰¤ âˆ‘' i, g i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function 'f' from a product of types 'Î±' and 'Î´ a' to 'Î²', a finite set 's' of type 'Î±', and a function 't' that assigns to each element of 'Î±' a finite set of type 'Î´ a', the product over 's' of the sum over 't a' of 'f a b' is equal to the sum over the product set 's.pi t' of the product over 's.attach' of 'f x.1 (p x.1 x.2)'. Here, 's.pi t' is the set of all functions from 's' to the union of 't a' for 'a' in 's', and 's.attach' is the set of all elements of 's' along with their indices.",
    "output": "theorem prod_sum {Î´ : Î± â†’ Type _} [DecidableEq Î±] [âˆ€ a, DecidableEq (Î´ a)] {s : Finset Î±}\n    {t : âˆ€ a, Finset (Î´ a)} {f : âˆ€ a, Î´ a â†’ Î²} :\n    (âˆ a in s, âˆ‘ b in t a, f a b) = âˆ‘ p in s.pi t, âˆ x in s.attach, f x.1 (p x.1 x.2) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two subsemigroups S and T of a semigroup M, and any two elements x and y from M, if x is an element of S and y is an element of T, then the product of x and y is an element of the union of S and T.",
    "output": "theorem mul_mem_sup {S T : Subsemigroup M} {x y : M} (hx : x âˆˆ S) (hy : y âˆˆ T) : x * y âˆˆ S âŠ” T :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type S with a commutative ring structure and an algebra structure over a ring R, and a subalgebra S' of this algebra, given a finite set Î¹' of type Î¹, and two functions s and l from Î¹ to S such that the sum of the product of l i and s i over all i in Î¹' equals 1, and for all i, s i and l i are elements of S', if for a given element x of S, for all i there exists a natural number n such that the n-th power of s i times x is an element of S', then x is an element of S'.",
    "output": "theorem mem_of_finset_sum_eq_one_of_pow_smul_mem {S : Type _} [CommRing S] [Algebra R S]\n    (S' : Subalgebra R S) {Î¹ : Type _} (Î¹' : Finset Î¹) (s : Î¹ â†’ S) (l : Î¹ â†’ S)\n    (e : (âˆ‘ i in Î¹', l i * s i) = 1) (hs : âˆ€ i, s i âˆˆ S') (hl : âˆ€ i, l i âˆˆ S') (x : S)\n    (H : âˆ€ i, âˆƒ n : â„•, (s i ^ n : S) â€¢ x âˆˆ S') : x âˆˆ S' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cardinality of the set of all elements less than a given boundary 'b' is equal to 'b' itself.",
    "output": "theorem card_fintypeIio : Fintype.card (Set.Iio b) = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'f' from a vector space 'E' to another vector space 'E'', if 'f' preserves the inner product (as specified by 'h'), then the function corresponding to the isometry of 'f' is equal to 'f' itself.",
    "output": "theorem LinearMap.coe_isometryOfInner (f : E â†’â‚—[ğ•œ] E') (h) : â‡‘(f.isometryOfInner h) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a multiset t of polynomials with coefficients in a ring R, if the zero polynomial is not an element of t, then the degree of the product of all polynomials in t is equal to the sum of the degrees of all polynomials in t.",
    "output": "theorem natDegree_multiset_prod (h : (0 : R[X]) âˆ‰ t) :\n    natDegree t.prod = (t.map natDegree).sum :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any complete type 'p' in the language 'L' with variables of type 'Î±', and any sentence 'Ï†' in this language, either 'Ï†' is in 'p' or the negation of 'Ï†' is in 'p'.",
    "output": "theorem mem_or_not_mem (p : T.CompleteType Î±) (Ï† : L[[Î±]].Sentence) : Ï† âˆˆ p âˆ¨ Ï†.not âˆˆ p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If two angles Î¸ and Ïˆ are such that twice the angle Î¸ is equal to twice the angle Ïˆ (in the integer multiples sense), then the tangent of angle Î¸ is equal to the tangent of angle Ïˆ.",
    "output": "theorem tan_eq_of_two_zsmul_eq {Î¸ Ïˆ : Angle} (h : (2 : â„¤) â€¢ Î¸ = (2 : â„¤) â€¢ Ïˆ) : tan Î¸ = tan Ïˆ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given property 'p' pertaining to a pair of elements from sets 'Î±' and 'Î²', the property 'p' holds eventually for all elements in the product of 'f' and 'g' if and only if the property 'p' holds eventually for all elements in the swapped product of 'g' and 'f'.",
    "output": "theorem eventually_swap_iff {p : Î± Ã— Î² â†’ Prop} :\n    (âˆ€á¶  x : Î± Ã— Î² in f Ã—Ë¢ g, p x) â†” âˆ€á¶  y : Î² Ã— Î± in g Ã—Ë¢ f, p y.swap :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A cardinal number 'c' is less than or equal to the rank of a module over a field 'K' and a vector space 'V' if and only if there exists a set 's' of vectors in 'V' such that the cardinality of 's' is 'c' and the function that maps 's' to 'V' is linearly independent.",
    "output": "theorem le_rank_iff_exists_linearIndependent {c : Cardinal} :\n    c â‰¤ Module.rank K V â†” âˆƒ s : Set V, (#s) = c âˆ§ LinearIndependent K ((â†‘) : s â†’ V) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all rational numbers x, the p-adic number representation of the negation of x is equal to the negation of the p-adic number representation of x.",
    "output": "theorem coe_neg : âˆ€ {x : â„š}, (â†‘(-x) : â„š_[p]) = -â†‘x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î¹ and a function v from Î¹ to E, if v is orthonormal and s is a submodule of E such that every element of v is in s, then the codomain restriction of v to s is also orthonormal.",
    "output": "theorem Orthonormal.codRestrict {Î¹ : Type _} {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (s : Submodule ğ•œ E)\n    (hvs : âˆ€ i, v i âˆˆ s) : @Orthonormal ğ•œ s _ _ _ Î¹ (Set.codRestrict v s hvs) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a relation 'r' is reflexive on a set 'Î±', then 'r' is reflexive.",
    "output": "theorem IsRefl.reflexive [IsRefl Î± r] : Reflexive r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any relation 'p' on elements of type 'Î±', if for all 'a' and 'b', the relation 'r' from 'a' to 'b' implies the transitive closure of 'p' from 'a' to 'b', then the transitive closure of 'r' from 'a' to 'b' implies the transitive closure of 'p' from 'a' to 'b'.",
    "output": "theorem TransGen.closed {p : Î± â†’ Î± â†’ Prop} :\n    (âˆ€ a b, r a b â†’ TransGen p a b) â†’ TransGen r a b â†’ TransGen p a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given affine map 'f' from Pâ‚ to Pâ‚‚ and given affine subspaces 's' and 't' of Pâ‚‚, if 's' is a subset of or equal to 't', then the preimage of 's' under 'f' is a subset of or equal to the preimage of 't' under 'f'.",
    "output": "theorem comap_mono {f : Pâ‚ â†’áµƒ[k] Pâ‚‚} {s t : AffineSubspace k Pâ‚‚} : s â‰¤ t â†’ s.comap f â‰¤ t.comap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'p' is a root of 'x' in a commutative semiring 'R' and 'p' divides 'q', then 'q' is also a root of 'x'.",
    "output": "theorem IsRoot.dvd {R : Type _} [CommSemiring R] {p q : R[X]} {x : R} (h : p.IsRoot x)\n    (hpq : p âˆ£ q) : q.IsRoot x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' that takes an index 'i' and elements from two indexed families of types 'Î²â‚ i' and 'Î²â‚‚ i' and returns an element of type 'Î² i', and for any two functions 'gâ‚' and 'gâ‚‚' that are defined for all indices 'i' and return elements of types 'Î²â‚ i' and 'Î²â‚‚ i' respectively, if 'f' returns zero when both its arguments are zero, then the support of the function obtained by zipping 'gâ‚' and 'gâ‚‚' with 'f' is a subset of the union of the supports of 'gâ‚' and 'gâ‚‚'. Here, the support of a function is the set of indices for which the function does not return zero.",
    "output": "theorem support_zipWith {f : âˆ€ i, Î²â‚ i â†’ Î²â‚‚ i â†’ Î² i} {hf : âˆ€ i, f i 0 0 = 0} {gâ‚ : Î â‚€ i, Î²â‚ i}\n    {gâ‚‚ : Î â‚€ i, Î²â‚‚ i} : (zipWith f hf gâ‚ gâ‚‚).support âŠ† gâ‚.support âˆª gâ‚‚.support :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î¹, a finite set t of type Î¹, and a function f from Î¹ to the set of E, the set s absorbs the union of the set f(i) for all i in t if and only if for all i in t, the set s absorbs the set f(i).",
    "output": "theorem absorbs_iUnion_finset {Î¹ : Type _} {t : Finset Î¹} {f : Î¹ â†’ Set E} :\n    Absorbs ğ•œ s (â‹ƒ i âˆˆ t, f i) â†” âˆ€ i âˆˆ t, Absorbs ğ•œ s (f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponential of a scalar multiple of a number x (where the scalar is a natural number n) is equal to the exponential of x raised to the power of n.",
    "output": "theorem exp_nsmul (n : â„•) (x : ğ”¸) : exp ğ•‚ (n â€¢ x) = exp ğ•‚ x ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' and a multiset 's' of a certain type 'Î±', the greatest common divisor (gcd) of the multiset obtained by non-duplicating insertion of 'a' into 's' is equal to the gcd of 'a' and the gcd of 's'.",
    "output": "theorem gcd_ndinsert (a : Î±) (s : Multiset Î±) : (ndinsert a s).gcd = GCDMonoid.gcd a s.gcd :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A relation is directed on the universal set if and only if the relation is directed on the set Î±.",
    "output": "theorem directedOn_univ_iff : DirectedOn r Set.univ â†” IsDirected Î± r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a morphism 'f' from object 'X' to 'Y' in a category, given that 'f' has an image, and for another object 'Y'' in the category 'C' and a morphism 'h' from 'Y' to 'Y'' that is an isomorphism, the composition of the homomorphism of the image subobject composition isomorphism of 'f' and 'h' with the arrow of the image subobject of 'f' is equal to the composition of the arrow of the image subobject of the composition of 'f' and 'h' with the inverse of 'h'.",
    "output": "theorem imageSubobjectCompIso_hom_arrow (f : X âŸ¶ Y) [HasImage f] {Y' : C} (h : Y âŸ¶ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).hom â‰« (imageSubobject f).arrow =\n      (imageSubobject (f â‰« h)).arrow â‰« inv h :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Two sets, s and t, are disjoint if and only if the intersection of s and t is an empty set.",
    "output": "theorem disjoint_iff_inter_eq_empty : Disjoint s t â†” s âˆ© t = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponential of the difference between two numbers (x - y) is equal to the division of the exponential of the first number by the exponential of the second number.",
    "output": "theorem exp_sub : exp (x - y) = exp x / exp y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nondegenerate bilinear form B on a vector space V over a field K, and a linear map Ï† from V to V, the left adjoint of Ï† with respect to B is an adjoint pair with Ï† under B.",
    "output": "theorem isAdjointPairLeftAdjointOfNondegenerate (B : BilinForm K V) (b : B.Nondegenerate)\n    (Ï† : V â†’â‚—[K] V) : IsAdjointPair B B (B.leftAdjointOfNondegenerate b Ï†) Ï† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î¹, any filter l on Î¹, and any function x from Î¹ to the real numbers, if the limit inferior (liminf) of the function that maps each element of Î¹ to the non-negative real number equivalent of the absolute value of the function x at that element is not infinite, then there exists a real number R such that, frequently in the filter l, the value of the function x at an element of Î¹ is less than R.",
    "output": "theorem exists_frequently_lt_of_liminf_ne_top {Î¹ : Type _} {l : Filter Î¹} {x : Î¹ â†’ â„}\n    (hx : liminf (fun n => (Real.nnabs (x n) : â„â‰¥0âˆ)) l â‰  âˆ) : âˆƒ R, âˆƒá¶  n in l, x n < R :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' from 'L', the application of the function 'lift R f' to 'Î¹ R x' equals the application of the function 'f' to 'x'.",
    "output": "theorem lift_Î¹_apply (x : L) : lift R f (Î¹ R x) = f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 't' is a lower set, then the product of 's' and 't' is also a lower set.",
    "output": "theorem IsLowerSet.mul_left (ht : IsLowerSet t) : IsLowerSet (s * t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²' that is an ordered monoid homomorphism, the ordered monoid homomorphism of 'f' is equal to 'f' itself.",
    "output": "theorem toOrderMonoidHom_eq_coe (f : Î± â†’*â‚€o Î²) : f.toOrderMonoidHom = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the list of its factors is in non-decreasing order.",
    "output": "theorem factors_chain' (n) : List.Chain' (Â· â‰¤ Â·) (factors n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"a is less than or equal to b implies c\" if and only if \"b is less than or equal to a implies c\".",
    "output": "theorem le_himp_comm : a â‰¤ b â‡¨ c â†” b â‰¤ a â‡¨ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Within a unique differentiable subset 's' at a point 'x' in a field 'ğ•œ', the derivative of a linear map 'e' at point 'x' within subset 's' is equal to the value of 'e' at 1.",
    "output": "theorem LinearMap.derivWithin (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    derivWithin e s x = e 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The norm function, mapping from E to real numbers, is convex on the entire set of real numbers.",
    "output": "theorem convexOn_univ_norm : ConvexOn â„ univ (norm : E â†’ â„) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a relation 'r' on a set 'univ' is an antichain, then the relation 'r' is antisymmetric on the set 'Î±'.",
    "output": "theorem isAntisymm (h : IsAntichain r univ) : IsAntisymm Î± r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the mapping of the Chebyshev polynomial of the first kind of degree 'n' in ring 'R' to ring 'S' is equal to the Chebyshev polynomial of the first kind of degree 'n' in ring 'S'.",
    "output": "theorem map_U (f : R â†’+* S) : âˆ€ n : â„•, map f (U R n) = U S n"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the function pair f and g is antivariant, then the composition of f and g with another function k is also antivariant.",
    "output": "theorem Antivary.comp_right (h : Antivary f g) (k : Î¹' â†’ Î¹) : Antivary (f âˆ˜ k) (g âˆ˜ k) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type A, the lift operation in the context of a FreeGroup A is equal to the lift operation defined in the FreeGroup.",
    "output": "theorem lift'_eq_freeGroup_lift {A : Type u} : @lift (FreeGroup A) _ _ H _ = FreeGroup.lift :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A sum type (a type that can hold values of either type Î± or type Î²) is empty if and only if both type Î± and type Î² are empty.",
    "output": "theorem isEmpty_sum {Î± Î²} : IsEmpty (Sum Î± Î²) â†” IsEmpty Î± âˆ§ IsEmpty Î² :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any point x in the Euclidean space E, the neighborhood of x has a basis consisting of all open balls centered at x with a positive radius. This basis is characterized by the property that for any real number r, if r is greater than 0, then the corresponding basis element is the open ball centered at x with radius r.",
    "output": "theorem nhds_basis_ball {x : E} : (ğ“ x).HasBasis (fun r : â„ => 0 < r) (ball x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given prime number 'p', natural numbers 'k' and 'm' (where 'm' is positive), and a multiplicative group element 'Î¶' of a ring 'R' with characteristic 'p', 'Î¶' raised to the power of 'p' to the power of 'k' times 'm' equals 1 if and only if 'Î¶' is a root of unity of order 'm' in the ring 'R'.",
    "output": "theorem mem_rootsOfUnity_prime_pow_mul_iff' (p k : â„•) (m : â„•+) [hp : Fact p.Prime] [CharP R p]\n    {Î¶ : RË£} : Î¶ ^ (p ^ k * â†‘m) = 1 â†” Î¶ âˆˆ rootsOfUnity m R :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a reflexive relation 'r' on a set, given any two elements 'a' and 'b' from a set 'Î±' where 'a' is related to 'b' under the relation 'r', the relation 'r' is directed on the set that contains 'a' and 'b'.",
    "output": "theorem directedOn_pair (h : Reflexive r) {a b : Î±} (hab : a â‰¼ b) : DirectedOn r ({a, b} : Set Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type 'R' that has a zero element, a given element 'n' of type 'R' is not non-zero if and only if 'n' is equal to zero.",
    "output": "theorem not_neZero {R : Type _} [Zero R] {n : R} : Â¬NeZero n â†” n = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have two ring homomorphisms, 'f' from ring 'A' to ring 'B' and 'g' from ring 'B' to ring 'C', and if 'f' has a finite presentation, 'g' is surjective, and the kernel of 'g' is finitely generated, then the composition of 'g' and 'f' also has a finite presentation.",
    "output": "theorem comp_surjective {f : A â†’+* B} {g : B â†’+* C} (hf : f.FinitePresentation) (hg : Surjective g)\n    (hker : g.ker.FG) : (g.comp f).FinitePresentation :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given multiplication operation 'mul' on the tensor product of A and B over a ring R, if for all elements aâ‚, aâ‚‚, aâ‚ƒ of A and bâ‚, bâ‚‚, bâ‚ƒ of B, the multiplication operation satisfies the associative property, then for all elements x, y, z of the tensor product of A and B, the multiplication operation also satisfies the associative property. In other words, the multiplication of x, y, and z in any order will yield the same result.",
    "output": "theorem mul_assoc' (mul : A âŠ—[R] B â†’â‚—[R] A âŠ—[R] B â†’â‚—[R] A âŠ—[R] B)\n    (h :\n      âˆ€ (aâ‚ aâ‚‚ aâ‚ƒ : A) (bâ‚ bâ‚‚ bâ‚ƒ : B),\n        mul (mul (aâ‚ âŠ—â‚œ[R] bâ‚) (aâ‚‚ âŠ—â‚œ[R] bâ‚‚)) (aâ‚ƒ âŠ—â‚œ[R] bâ‚ƒ) =\n          mul (aâ‚ âŠ—â‚œ[R] bâ‚) (mul (aâ‚‚ âŠ—â‚œ[R] bâ‚‚) (aâ‚ƒ âŠ—â‚œ[R] bâ‚ƒ))) :\n    âˆ€ x y z : A âŠ—[R] B, mul (mul x y) z = mul x (mul y z) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given index 'i' and an element 'y' from the group 'N i', the non-commutative product of the function 'Ï•', the commutativity proof 'hcomm', and the multiplication of the single element 'i' with 'y', is equal to the application of the function 'Ï•' to 'i' and 'y'.",
    "output": "theorem noncommPiCoprod_mulSingle (i : Î¹) (y : N i) :\n    noncommPiCoprod Ï• hcomm (Pi.mulSingle i y) = Ï• i y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any set 'a', the cardinality of the lift of 'a' is equal to the lift of the cardinality of 'a'.",
    "output": "theorem lift_card (a) : Cardinal.lift.{u,v} (card a)= card (lift.{u,v} a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î² that forms a semi-normed additive commutative group, and any function f from Î± to Î² that is almost everywhere strongly measurable with respect to measure Î¼, the function that maps each element a to the non-negative extended real number norm of f(a) is almost everywhere measurable with respect to measure Î¼.",
    "output": "theorem ennnorm {Î² : Type _} [SeminormedAddCommGroup Î²] {f : Î± â†’ Î²}\n    (hf : AEStronglyMeasurable f Î¼) : AEMeasurable (fun a => (â€–f aâ€–â‚Š : â„â‰¥0âˆ)) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nonempty index set Î¹, a function f from Î¹ to Î±, and a value a in Î±, if the range of the function f is bounded above, then the supremum of f is less than or equal to a if and only if for all indices i, the value of the function f at i is less than or equal to a.",
    "output": "theorem ciSup_le_iff [Nonempty Î¹] {f : Î¹ â†’ Î±} {a : Î±} (hf : BddAbove (range f)) :\n    iSup f â‰¤ a â†” âˆ€ i, f i â‰¤ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The skew-adjoint part of a continuous module over a ring is also continuous. This is under the conditions that the module has a continuous subtraction operation, a continuous star operation, and a continuous scalar multiplication by a constant.",
    "output": "theorem continuous_skewAdjointPart [ContinuousSub A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    Continuous (@skewAdjointPart R A _ _ _ _ _ _ _ _) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'x' is infinitely negative and 'y' is not infinitesimal and negative, then the product of 'x' and 'y' is infinitely positive.",
    "output": "theorem infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg {x y : â„*} :\n    InfiniteNeg x â†’ Â¬Infinitesimal y â†’ y < 0 â†’ InfinitePos (x * y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite set 's' of sets of elements of type Î±, the union of 's' is in filter 'f' if and only if there exists a set 't' in 's' that is in filter 'f'.",
    "output": "theorem finite_sUnion_mem_iff {s : Set (Set Î±)} (hs : s.Finite) : â‹ƒâ‚€ s âˆˆ f â†” âˆƒ t âˆˆ s, t âˆˆ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'v' and 'w' from 'n' to 'R', if the dot product of 'v' and any function 'u' is equal to the dot product of 'w' and the same function 'u', then 'v' must be equal to 'w'.",
    "output": "theorem dotProduct_eq (v w : n â†’ R) (h : âˆ€ u, dotProduct v u = dotProduct w u) : v = w :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two hyperreal numbers 'x' and 'y', if 'x' is negatively infinite and 'y' is not infinite, then the sum of 'x' and 'y' is negatively infinite.",
    "output": "theorem infiniteNeg_add_not_infinite {x y : â„*} :\n    InfiniteNeg x â†’ Â¬Infinite y â†’ InfiniteNeg (x + y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' and any element 'x' of an ordered additive monoid 'Î±', if 'x' is nonnegative, then 'n' times the nonnegative element 'x' is equal to the nonnegative element 'n' times 'x', with the nonnegativity of the latter ensured by the property that the n-fold addition of a nonnegative number is nonnegative.",
    "output": "theorem nsmul_mk [AddMonoid Î±] [Preorder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (n : â„•) {x : Î±}\n    (hx : 0 â‰¤ x) : (n â€¢ (âŸ¨x, hxâŸ© : { x : Î± // 0 â‰¤ x })) = âŸ¨n â€¢ x, nsmul_nonneg hx nâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The identity function on the centroid homomorphism for a given type Î± is equal to the identity function on the additive monoid for the same type Î±.",
    "output": "theorem toAddMonoidHom_id : (CentroidHom.id Î± : Î± â†’+ Î±) = AddMonoidHom.id Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given substructure T of N and a function f from M to N, if the map of S through function f is less than or equal to T, then S is less than or equal to the preimage of T under function f.",
    "output": "theorem le_comap_of_map_le {T : L.Substructure N} {f : M â†’[L] N} : S.map f â‰¤ T â†’ S â‰¤ T.comap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the generated sieve R is in the Grothendieck topology of the open set U in the topological space X, then the supremum of the covering of the presieve U R is equal to U.",
    "output": "theorem iSup_eq_of_mem_grothendieck (hR : Sieve.generate R âˆˆ Opens.grothendieckTopology X U) :\n    iSup (coveringOfPresieve U R) = U :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every element 'a' in set 's', there exists an element 'b' in set 't' such that relation 'r' holds between 'a' and 'b', and for every element 'b' in set 't', the set of all elements 'a' in set 's' for which relation 'r' holds with 'b' is a subsingleton (i.e., it contains at most one element), then the cardinality (or size) of set 's' is less than or equal to the cardinality of set 't'.",
    "output": "theorem card_le_card_of_forall_subsingleton (hs : âˆ€ a âˆˆ s, âˆƒ b, b âˆˆ t âˆ§ r a b)\n    (ht : âˆ€ b âˆˆ t, ({ a âˆˆ s | r a b } : Set Î±).Subsingleton) : s.card â‰¤ t.card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The omega limit of the intersection of a collection of sets (indexed by Î¹) is a subset of the intersection of the omega limits of each individual set in the collection.",
    "output": "theorem omegaLimit_iInter (p : Î¹ â†’ Set Î±) : Ï‰ f Ï• (â‹‚ i, p i) âŠ† â‹‚ i, Ï‰ f Ï• (p i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given interval from 'a' to 'b' (inclusive of 'a' and exclusive of 'b'), if 'a' is less than or equal to 'c', then the image of the interval under the function that subtracts each element from 'c' is equal to the interval from 'c + 1 - b' to 'c + 1 - a' (inclusive of 'c + 1 - b' and exclusive of 'c + 1 - a').",
    "output": "theorem Ico_image_const_sub_eq_Ico (hac : a â‰¤ c) :\n    ((Ico a b).image fun x => c - x) = Ico (c + 1 - b) (c + 1 - a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function 'f' from 'Î²' to 'Î±' in a second-countable topological space, if 'f' is summable and 's' is a set in 'Î²', then the sum over 's' of 'f' plus the sum over the complement of 's' of 'f' equals the total sum over 'f'.",
    "output": "theorem tsum_subtype_add_tsum_subtype_compl [T2Space Î±] {f : Î² â†’ Î±} (hf : Summable f) (s : Set Î²) :\n    ((âˆ‘' x : s, f x) + âˆ‘' x : â†‘(sá¶œ), f x) = âˆ‘' x, f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type 'Î¹' with a finite number of elements, a function 'H' from 'Î¹' to some type, a function 'M' from 'Î¹' to some type, where each 'H i' and 'M i' are topological spaces and each 'M i' is a charted space with model 'H i', and a function 'f' from 'Î¹' to 'M i', the chart at 'f' in the product space of 'H' is equal to the product of the charts at 'f i' in each 'H i'.",
    "output": "theorem piChartedSpace_chartAt {Î¹ : Type _} [Fintype Î¹] (H : Î¹ â†’ Type _)\n    [âˆ€ i, TopologicalSpace (H i)] (M : Î¹ â†’ Type _) [âˆ€ i, TopologicalSpace (M i)]\n    [âˆ€ i, ChartedSpace (H i) (M i)] (f : âˆ€ i, M i) :\n    chartAt (H := ModelPi H) f = LocalHomeomorph.pi fun i â†¦ chartAt (H i) (f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For three continuous functions f, g, and h, where f maps from Î³ to Î´, g maps from Î² to Î³, and h maps from Î± to Î², the composition of f and g, followed by the composition with h, is equal to the composition of f with the composition of g and h. This is the principle of associativity in function composition.",
    "output": "theorem comp_assoc (f : Î³ â†’CO Î´) (g : Î² â†’CO Î³) (h : Î± â†’CO Î²) :\n    (f.comp g).comp h = f.comp (g.comp h) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The reverse of an empty walk (represented as 'nil') in a graph G from a vertex 'u' to itself is also an empty walk.",
    "output": "theorem reverse_nil {u : V} : (nil : G.Walk u u).reverse = nil :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The bottom filter of a set Î± is not equal to the hyperfilter of the same set Î±.",
    "output": "theorem bot_ne_hyperfilter : (âŠ¥ : Filter Î±) â‰  hyperfilter Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A list 'l' is a sublist of a list that replicates an element 'a' 'n' times if and only if there exists a number 'k' less than or equal to 'n' such that 'l' is equal to a list that replicates 'a' 'k' times.",
    "output": "theorem sublist_replicate_iff {l : List Î±} {a : Î±} {n : â„•} :\n    l <+ replicate n a â†” âˆƒ k â‰¤ n, l = replicate k a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functors F and G from category C to category D, both of which are additive, and a natural transformation Î± from F to G, for any natural number n and any object X in category C with a projective resolution P, the application of the n-th left derived functor of Î± to X is equal to the composition of the homomorphism from the n-th left derived object of F with respect to P, the map induced by Î± on the n-th homology group of the complex associated with P, and the inverse of the homomorphism from the n-th left derived object of G with respect to P.",
    "output": "theorem NatTrans.leftDerived_eq {F G : C â¥¤ D} [F.Additive] [G.Additive] (Î± : F âŸ¶ G) (n : â„•) {X : C}\n    (P : ProjectiveResolution X) :\n    (NatTrans.leftDerived Î± n).app X =\n      (F.leftDerivedObjIso n P).hom â‰«\n        (homologyFunctor D _ n).map ((NatTrans.mapHomologicalComplex Î± _).app P.complex) â‰«\n          (G.leftDerivedObjIso n P).inv :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'f' maps to a set 't' from the union of sets 'sâ‚' and 'sâ‚‚' if and only if 'f' maps to 't' from both 'sâ‚' and 'sâ‚‚'.",
    "output": "theorem mapsTo_union : MapsTo f (sâ‚ âˆª sâ‚‚) t â†” MapsTo f sâ‚ t âˆ§ MapsTo f sâ‚‚ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cycle type of a permutation Ïƒ is equal to the mapping of the cardinality of the support function over the first element of the cycle factors of Ïƒ in a finite set.",
    "output": "theorem cycleType_def (Ïƒ : Perm Î±) :\n    Ïƒ.cycleType = Ïƒ.cycleFactorsFinset.1.map (Finset.card âˆ˜ support) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î¹' to 'Î±', for any 'i' in 'Î¹', the infimum (greatest lower bound) of 'f' is less than or equal to 'f' at 'i'.",
    "output": "theorem ciInf_le' (f : Î¹ â†’ Î±) (i : Î¹) : iInf f â‰¤ f i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is dense if and only if the closure of the set 's' is dense.",
    "output": "theorem dense_closure {s : Set Î±} : Dense (closure s) â†” Dense s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two ideals I and J of a ring R, and any element x of R, x is in the intersection of I and J if and only if x is in I and x is in J.",
    "output": "theorem mem_inf {I J : Ideal R} {x : R} : x âˆˆ I âŠ“ J â†” x âˆˆ I âˆ§ x âˆˆ J :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'c' in the set 'Î±', if 'a + c' is congruent to 'b + c' modulo 'p', then 'a' is congruent to 'b' modulo 'p'.",
    "output": "theorem add_right_cancel' (c : Î±) : a + c â‰¡ b + c [PMOD p] â†’ a â‰¡ b [PMOD p] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set function T from a set of Î± to the space of continuous linear maps from G' to G'', and a real number C, if T is dominated and finitely additive with respect to measure Î¼ and C, and if for all measurable sets s with finite measure, and for all x greater than or equal to 0, T s x is also greater than or equal to 0, then for any function f from Î± to G' that is integrable with respect to Î¼ and is greater than or equal to 0, the setToL1 of T and f is also greater than or equal to 0.",
    "output": "theorem setToL1_nonneg {T : Set Î± â†’ G' â†’L[â„] G''} {C : â„} (hT : DominatedFinMeasAdditive Î¼ T C)\n    (hT_nonneg : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ T s x) {f : Î± â†’â‚[Î¼] G'}\n    (hf : 0 â‰¤ f) : 0 â‰¤ setToL1 hT f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'sectionÎ“'Bool' is a left inverse of the function 'inclusionBoolÎ“''.",
    "output": "theorem leftInverse_section_inclusion : Function.LeftInverse sectionÎ“'Bool inclusionBoolÎ“' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' and a given multiset 's', the count of 'a' in 's' is greater than 0 if and only if 'a' is an element of 's'.",
    "output": "theorem count_pos {a : Î±} {s : Multiset Î±} : 0 < count a s â†” a âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any tropicalized ring R, the untropicalization of zero in the tropical ring R is equal to the top element.",
    "output": "theorem untrop_zero [Top R] : untrop (0 : Tropical R) = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index 'i', if 'i' does not have a relation with the next index in the complex 'c', then the differential from 'i' in the complex 'C' is zero.",
    "output": "theorem dFrom_eq_zero {i : Î¹} (h : Â¬c.Rel i (c.next i)) : C.dFrom i = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite type Ïƒ, the finite dimensional rank of the polynomial ring R over the field K in Ïƒ variables is equal to the cardinality of the set of all functions from Ïƒ to K.",
    "output": "theorem finrank_R [Fintype Ïƒ] : FiniteDimensional.finrank K (R Ïƒ K) = Fintype.card (Ïƒ â†’ K) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from a set 'Î±' to a group with zero 'Gâ‚€', and a filter 'l' on 'Î±', if 'f' tends to a point 'a' in 'Gâ‚€' under the filter 'l', then for any integer 'm', if 'a' is not zero or 'm' is non-negative, the function 'f' raised to the power 'm' also tends to 'a' raised to the power 'm' under the filter 'l'.",
    "output": "theorem Filter.Tendsto.zpowâ‚€ {f : Î± â†’ Gâ‚€} {l : Filter Î±} {a : Gâ‚€} (hf : Tendsto f l (ğ“ a)) (m : â„¤)\n    (h : a â‰  0 âˆ¨ 0 â‰¤ m) : Tendsto (fun x => f x ^ m) l (ğ“ (a ^ m)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a filtration F is stable and the zeroth term of F is less than or equal to the zeroth term of F', then there exists a non-negative integer nâ‚€ such that for all non-negative integers n, the (n + nâ‚€)th term of F is less than or equal to the nth term of F'.",
    "output": "theorem Stable.exists_forall_le (h : F.Stable) (e : F.N 0 â‰¤ F'.N 0) :\n    âˆƒ nâ‚€, âˆ€ n, F.N (n + nâ‚€) â‰¤ F'.N n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a morphism 'f' from object 'X' to object 'Y' in category 'C', and 'X' is isomorphic to the zero object, then 'f' is a zero morphism.",
    "output": "theorem zero_of_source_iso_zero {X Y : C} (f : X âŸ¶ Y) (i : X â‰… 0) : f = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An element 'a' is an antichain of a relation 'r' in the set 's' if and only if 's' is an antichain of 'r' and for all elements 'b' in 's', 'a' is not equal to 'b' and 'a' is not related to 'b' in 'r' and 'b' is not related to 'a' in 'r'.",
    "output": "theorem _root_.isAntichain_insert :\n    IsAntichain r (insert a s) â†” IsAntichain r s âˆ§ âˆ€ â¦ƒbâ¦„, b âˆˆ s â†’ a â‰  b â†’ Â¬r a b âˆ§ Â¬r b a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'a' belongs to the multiset 's' after the element 'b' has been removed, then 'a' must have originally belonged to the multiset 's'.",
    "output": "theorem mem_of_mem_erase {a b : Î±} {s : Multiset Î±} : a âˆˆ s.erase b â†’ a âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given pair 'p' consisting of an element and a set of elements, if 'p' is in the index of 'h', then the covering of 'p' by 'h' is in the set of 'v' at the first element of 'p'.",
    "output": "theorem covering_mem_family {p : Î± Ã— Set Î±} (hp : p âˆˆ h.index) : h.covering p âˆˆ v.setsAt p.1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'x' and 'y' in a set 'F' of type 'Î±', if 'y' is in the connected component in 'F' of 'x', then the connected component in 'F' of 'x' is equal to the connected component in 'F' of 'y'.",
    "output": "theorem connectedComponentIn_eq {x y : Î±} {F : Set Î±} (h : y âˆˆ connectedComponentIn F x) :\n    connectedComponentIn F x = connectedComponentIn F y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The infimum (greatest lower bound) of the set of all elements i such that the function f applied to i is not the top element, is equal to the infimum of the set of all elements i under the function f.",
    "output": "theorem iInf_ne_top_subtype (f : Î¹ â†’ Î±) : (â¨… i : { i // f i â‰  âŠ¤ }, f i) = â¨… i, f i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bilinear form B on a module M over a ring R, and for any two elements x and y of M, x and y are orthogonal with respect to B if and only if the bilinear form B applied to x and y equals zero.",
    "output": "theorem isOrtho_def {B : BilinForm R M} {x y : M} : B.IsOrtho x y â†” B x y = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any finite type 'n', any monoid 'R', any non-unital non-associative semiring 'S', any distributive multiplication action of 'R' on 'S', and any scalar tower of 'R', 'S', and 'S', given a matrix 'M' of 'n' by 'm' with elements from 'S', a scalar 'b' from 'R', and a vector 'v' from 'n' to 'S', the vector multiplication of 'M' and the scaled vector 'b â€¢ v' is equal to the scaled vector of the vector multiplication of 'M' and 'v' by 'b'. This essentially means that scalar multiplication can be distributed over vector multiplication.",
    "output": "theorem vecMul_smul [Fintype n] [Monoid R] [NonUnitalNonAssocSemiring S] [DistribMulAction R S]\n    [IsScalarTower R S S] (M : Matrix n m S) (b : R) (v : n â†’ S) :\n    M.vecMul (b â€¢ v) = b â€¢ M.vecMul v :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two multisets 's' and 't', 's' and 't' are disjoint if and only if for any element 'a', if 'a' is in 's' then 'a' is not in 't'.",
    "output": "theorem disjoint_left {s t : Multiset Î±} : Disjoint s t â†” âˆ€ {a}, a âˆˆ s â†’ a âˆ‰ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given group homomorphism 'f' from group 'G' to group 'N', and given subgroups 'K' of 'G' and 'H' of 'N', the image of 'K' under 'f' is a subgroup of 'H' if and only if 'K' is a subgroup of the preimage of 'H' under 'f'.",
    "output": "theorem map_le_iff_le_comap {f : G â†’* N} {K : Subgroup G} {H : Subgroup N} :\n    K.map f â‰¤ H â†” K â‰¤ H.comap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of type Î±, a set 'T' of sets of type Î², and a function 'f' from Î± to Î², if for every subset 't' in 'T', 'f' is surjective on 's' to 't', then 'f' is surjective on 's' to the union of all subsets in 'T'.",
    "output": "theorem surjOn_sUnion {s : Set Î±} {T : Set (Set Î²)} {f : Î± â†’ Î²} (H : âˆ€ t âˆˆ T, SurjOn f s t) :\n    SurjOn f s (â‹ƒâ‚€T) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a prime number 'p', 'p' does not divide 1.",
    "output": "theorem Prime.not_dvd_one {p : â„•} (pp : Prime p) : Â¬p âˆ£ 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If graph G is a subgraph of graph H, then the set of all n-cliques in graph G is a subset of the set of all n-cliques in graph H.",
    "output": "theorem cliqueFinset_mono (h : G â‰¤ H) : G.cliqueFinset n âŠ† H.cliqueFinset n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements x and y of the Centroid Homomorphism of Î±, the endomorphism of the product of x and y is equal to the product of the endomorphisms of x and y.",
    "output": "theorem toEnd_mul (x y : CentroidHom Î±) : (x * y).toEnd = x.toEnd * y.toEnd :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A bilinear form B on a vector space Mâ‚ƒ over a field A is non-degenerate if and only if the determinant of the matrix representation of B with respect to a basis b of Mâ‚ƒ is not equal to zero.",
    "output": "theorem nondegenerate_iff_det_ne_zero {B : BilinForm A Mâ‚ƒ} (b : Basis Î¹ A Mâ‚ƒ) :\n    B.Nondegenerate â†” (toMatrix b B).det â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Rescaling by zero is equivalent to composing the ring constant function with the constant coefficient function in the ring R.",
    "output": "theorem rescale_zero : rescale 0 = (C R).comp (constantCoeff R) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'p' and 'n', if 'p' is an idempotent element, then 'p' to the power of 'n' is also an idempotent element.",
    "output": "theorem pow {p : N} (n : â„•) (h : IsIdempotentElem p) : IsIdempotentElem (p ^ n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two lists (lâ‚ and lâ‚‚), the property of having no duplicate elements in the list formed by appending lâ‚ and lâ‚‚ is equivalent to the property of having no duplicate elements in the list formed by appending lâ‚‚ and lâ‚.",
    "output": "theorem nodup_append_comm {lâ‚ lâ‚‚ : List Î±} : Nodup (lâ‚ ++ lâ‚‚) â†” Nodup (lâ‚‚ ++ lâ‚) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the image of a set 's' under a function 'm' is an element of a filter 'g', then the intersection of the filter obtained by preimage under 'm' of 'g' and the principal filter generated by 's' is not the bottom filter.",
    "output": "theorem comap_inf_principal_neBot_of_image_mem (h : m '' s âˆˆ g) : (Filter.comap m g âŠ“ ğ“Ÿ s).NeBot :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set U of M, if U is an element of B, then there exists a neighborhood V of 0 in R and a set W in B such that the scalar multiplication of V and W is a subset of U.",
    "output": "theorem smul {U : Set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ ğ“ (0 : R), âˆƒ W âˆˆ B, V â€¢ W âŠ† U :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type 'Î±', 'a' is an element of 'pure a'.",
    "output": "theorem mem_pure_self (a : Î±) : a âˆˆ pure a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'a' is a member of list 'l' and the minimum value of list 'l' is 'm', then 'a' is not less than 'm'.",
    "output": "theorem minimum_not_lt_of_mem : a âˆˆ l â†’ (minimum l : WithTop Î±) = m â†’ Â¬a < m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite sets 'u' and 'v', if for every element 'x' in 'u', there exists an element 'y' in 'v' such that the set 'u' with 'x' removed is compressed to the set 'v' with 'y' removed within the set family 'ğ’œ', then the cardinality of the shadow of the compression of the set family 'ğ’œ' with respect to 'u' and 'v' is less than or equal to the cardinality of the shadow of the set family 'ğ’œ'.",
    "output": "theorem card_shadow_compression_le (u v : Finset Î±)\n    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :\n    ((âˆ‚ ) (ğ“’ u v ğ’œ)).card â‰¤ ((âˆ‚ ) ğ’œ).card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse of 'f' is less than or equal to the inverse of 'g' if and only if 'f' is less than or equal to 'g'.",
    "output": "theorem inv_le_inv_iff : fâ»Â¹ â‰¤ gâ»Â¹ â†” f â‰¤ g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given natural number 'n', in the context where Ïƒ is a decidable equality and R is nontrivial, the support of the elementary symmetric function 'esymm' of Ïƒ, R, and n is equal to the bi-union of the power set of length n of the universal set of Ïƒ and the function that maps each element 't' to the sum of the Finsupp.single function applied to each element 'i' in 't' with the argument 1.",
    "output": "theorem support_esymm' (n : â„•) [DecidableEq Ïƒ] [Nontrivial R] :\n    (esymm Ïƒ R n).support =\n      (powersetLen n (univ : Finset Ïƒ)).biUnion fun t => {âˆ‘ i : Ïƒ in t, Finsupp.single i 1} :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The preimage of the identity function on a set of elements of type Î± is equal to the identity function itself.",
    "output": "theorem preimage_id_eq : preimage (id : Î± â†’ Î±) = id :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of relation 'r' with the equality relation is equal to relation 'r'.",
    "output": "theorem comp_eq : r âˆ˜r (Â· = Â·) = r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a morphism 'f' from 'j' to 'i', the eventual range of 'j' maps to the eventual range of 'i' through the functor 'F' applied to 'f'. This is within the context of a cofiltered system in category theory.",
    "output": "theorem eventualRange_mapsTo (f : j âŸ¶ i) :\n    (F.eventualRange j).MapsTo (F.map f) (F.eventualRange i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given constant 'b' of type 'Î²', 'b' is the maximum value on set 's' at point 'a'.",
    "output": "theorem isMaxOn_const {b : Î²} : IsMaxOn (fun _ => b) s a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given values of k, n, and r, the function u applied to the sum of the product of k and n and r is less than or equal to the sum of the product of k and the function u applied to n, and the function u applied to r.",
    "output": "theorem apply_mul_add_le (k n r) : u (k * n + r) â‰¤ k * u n + u r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given affine subspace 's' of points 'P' over a ring 'R', and given points 'x', 'y', and 'z', if 'z' is between 'x' and 'y' (denoted by Wbtw R x y z) and 'z' is an element of 's', then 's' is on the same side of 'y' and 'x'.",
    "output": "theorem _root_.Wbtw.wSameSideâ‚‚â‚ {s : AffineSubspace R P} {x y z : P} (h : Wbtw R x y z)\n    (hz : z âˆˆ s) : s.WSameSide y x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x', the application of the function 'single' with parameters 'a' and 'b' to 'x' belongs to the set that contains only '0' and 'b'. This set is a subset of the set 'M'.",
    "output": "theorem single_apply_mem (x) : single a b x âˆˆ ({0, b} : Set M) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function \"f\" from the set of bounded continuous functions between X and Y, and a real number \"C\", for any element \"x\" in X, the set of all values of \"f\" applied to the pair consisting of \"x\" and any element \"y\" from Y, plus \"C\", is bounded below.",
    "output": "theorem HD_below_aux1 {f : Cb X Y} (C : â„) {x : X} :\n    BddBelow (range fun y : Y => f (inl x, inr y) + C) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The infimum of the symmetric difference of sets t and u with set s is a subset of the symmetric difference of the infimum of set t with set s and the infimum of set u with set s.",
    "output": "theorem infs_sups_subset_right : (t âŠ» u) âŠ¼ s âŠ† t âŠ¼ s âŠ» u âŠ¼ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any x in the open interval between 0 and 1 (not including 0 and 1), the value of x is greater than 0.",
    "output": "theorem coe_pos (x : Ioc (0 : Î±) 1) : 0 < (x : Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every pair of distinct elements 'a' and 'b' in a multiset 's', the relation 'r' holds between 'a' and 'b', and if 's' has no duplicate elements, then 's' is pairwise related by 'r'.",
    "output": "theorem Nodup.pairwise : (âˆ€ a âˆˆ s, âˆ€ b âˆˆ s, a â‰  b â†’ r a b) â†’ Nodup s â†’ Pairwise r s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cosine of the angle between two vectors x and y is equal to the inner product of x and y divided by the product of the magnitudes of x and y.",
    "output": "theorem cos_angle (x y : V) : Real.cos (angle x y) = âŸªx, yâŸ« / (â€–xâ€– * â€–yâ€–) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer 'n', the function that maps any element of type 'Î±' to 'n' in the continuous functions from 'Î±' to 'Î²' (where 'Î²' has an integer cast), is equal to 'n'.",
    "output": "theorem coe_int_cast [IntCast Î²] (n : â„¤) : ((n : C(Î±, Î²)) : Î± â†’ Î²) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a topological homomorphism 'f' from 'Î²' to 'Î³', another topological homomorphism 'g' from 'Î±' to 'Î²', and an element 'a' from 'Î±', the composition of 'f' and 'g' applied to 'a' is equal to 'f' applied to 'g' of 'a'.",
    "output": "theorem comp_apply (f : TopHom Î² Î³) (g : TopHom Î± Î²) (a : Î±) : (f.comp g) a = f (g a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and c of a group G, the result of multiplying a and b, then dividing by the result of dividing a by c, is equal to the result of multiplying b and c.",
    "output": "theorem mul_div_div_cancel (a b c : G) : a * b / (a / c) = b * c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 's' is a compact set and 't' is an open set such that 's' is a subset of 't', then there exists a positive real number 'Î´' such that the 'Î´'-thickening of 's' is a subset of 't'.",
    "output": "theorem _root_.IsCompact.exists_cthickening_subset_open (hs : IsCompact s) (ht : IsOpen t)\n    (hst : s âŠ† t) :\n    âˆƒ Î´, 0 < Î´ âˆ§ cthickening Î´ s âŠ† t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a zero element in set M and an additive commutative monoid in set N, given a function 'f' mapping from Î± to M and another function 'h' mapping from Î± and M to a multiset of N, the sum of the multiset resulting from the sum of function 'f' applied to function 'h' is equal to the sum of function 'f' applied to a function that takes two arguments 'a' and 'b' and returns the sum of the multiset resulting from applying function 'h' to 'a' and 'b'.",
    "output": "theorem multiset_sum_sum [Zero M] [AddCommMonoid N] {f : Î± â†’â‚€ M} {h : Î± â†’ M â†’ Multiset N} :\n    Multiset.sum (f.sum h) = f.sum fun a b => Multiset.sum (h a b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of a group with zero 'Gâ‚€' and any integer 'n' that is not equal to zero, 'a' raised to the power of 'n' equals zero if and only if 'a' equals zero.",
    "output": "theorem zpow_eq_zero_iff {a : Gâ‚€} {n : â„¤} (hn : n â‰  0) : a ^ n = 0 â†” a = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a right rigid category V, the right dual of object X in V is equal to the right dual of the object X in V.",
    "output": "theorem rightDual_v [RightRigidCategory V] : Xá˜.V = X.Vá˜ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Zero is less than or equal to a positional game 'x' if and only if there exists a move 'i' such that zero is less than or equal to the game 'x' after making the left move 'i'.",
    "output": "theorem zero_lf_le {x : PGame} : 0 â§ x â†” âˆƒ i, 0 â‰¤ x.moveLeft i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' from an index set 'Î¹' to a set 'Î±', any index 'i' in 'Î¹', and any element 'b' in 'Î±', the image of the function 'f' updated at index 'i' with value 'b' over the interval from 'f i' to 'b' (not including 'b') is equal to the interval from 'f' to the updated function 'f' at index 'i' with value 'b' (not including the updated function 'f' at index 'i' with value 'b').",
    "output": "theorem image_update_Ico_right (f : âˆ€ i, Î± i) (i : Î¹) (b : Î± i) :\n    update f i '' Ico (f i) b = Ico f (update f i b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the conjunction (logical \"and\") of two propositions 'a' and 'b' is true, then the proposition 'b' is also true.",
    "output": "theorem eq_true_of_and_eq_true_right {a b : Prop} (h : (a âˆ§ b) = True) : b = True :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The trailing degree of the polynomial 1 in the ring R[X] is greater than or equal to zero.",
    "output": "theorem trailingDegree_one_le : (0 : â„•âˆ) â‰¤ trailingDegree (1 : R[X]) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any finite set 's' of type 'Î²' and any function 'f' from 'Î²' to the set of subsets of 'Î±', if every subset 'f i' for 'i' in 's' is both closed and open (clopen), then the intersection of all such subsets 'f i' is also clopen.",
    "output": "theorem isClopen_biInter_finset {Î² : Type _} {s : Finset Î²} {f : Î² â†’ Set Î±}\n    (h : âˆ€ i âˆˆ s, IsClopen (f i)) : IsClopen (â‹‚ i âˆˆ s, f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If G is a full subcategory and H is a cover dense for categories K and G, then the cover is locally dense for categories K and G.",
    "output": "theorem CoverDense.locallyCoverDense [Full G] (H : CoverDense K G) : LocallyCoverDense K G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any structured arrow 'f' from 'S' to 'T', mapping the identity morphism of 'S' to 'f' results in 'f' itself.",
    "output": "theorem map_id {f : StructuredArrow S T} : (map (ğŸ™ S)).obj f = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponential function is measurable.",
    "output": "theorem measurable_exp : Measurable exp :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' of set 'M', the application of the inverse function of 'ofTop p h' to 'x' is equal to the pair consisting of 'x' and the trivial proof that 'x' belongs to the preimage of 'p' under 'h'.",
    "output": "theorem ofTop_symm_apply {h} (x : M) : (ofTop p h).symm x = âŸ¨x, h.symm â–¸ trivialâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two linear maps 'f' and 'g', the matrix representation of the product of 'f' and 'g' is equal to the product of the matrix representation of 'f' and the matrix representation of 'g'.",
    "output": "theorem LinearMap.toMatrix_mul (f g : Mâ‚ â†’â‚—[R] Mâ‚) :\n    LinearMap.toMatrix vâ‚ vâ‚ (f * g) = LinearMap.toMatrix vâ‚ vâ‚ f â¬ LinearMap.toMatrix vâ‚ vâ‚ g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' from a measurable space 'Î±' to a topological space 'Î²', 'f' is almost everywhere strongly measurable with respect to the zero measure on 'Î±'.",
    "output": "theorem aestronglyMeasurable_zero_measure [MeasurableSpace Î±] [TopologicalSpace Î²] (f : Î± â†’ Î²) :\n    AEStronglyMeasurable f (0 : Measure Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The transpose of the adjugate of a matrix A is equal to the adjugate of the transpose of matrix A.",
    "output": "theorem adjugate_transpose (A : Matrix n n Î±) : (adjugate A)áµ€ = adjugate Aáµ€ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given multiplicative equivalence 'e' between two mathematical structures M and N, and for any element 'y' from N, applying 'e' to the inverse of 'y' under 'e' gives 'y' back.",
    "output": "theorem apply_symm_apply (e : M â‰ƒ* N) (y : N) : e (e.symm y) = y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a probability mass function 'p' and an element 'a', the probability of 'a' under 'p' is less than or equal to 1.",
    "output": "theorem coe_le_one (p : Pmf Î±) (a : Î±) : p a â‰¤ 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' of type Î±, a submonoid 'S' of M, and an element 'x' of M, 'x' is in the set resulting from the operation of 'aâ»Â¹' (the inverse of 'a') on 'S' if and only if the result of the operation of 'a' on 'x' is in 'S'.",
    "output": "theorem mem_inv_pointwise_smul_iff {a : Î±} {S : Submonoid M} {x : M} : x âˆˆ aâ»Â¹ â€¢ S â†” a â€¢ x âˆˆ S :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The derivative of the polynomial function (X - C), where C is a constant, is equal to 1.",
    "output": "theorem derivative_X_sub_C (c : R) : derivative (X - C c) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a pregroupoid PG on a topological space H, and for all pairs of local homeomorphisms e and e' from the atlas of M to H, the property of PG holds for the composition of the inverse of e and e' on the source of this composition, then M has the groupoid associated with PG.",
    "output": "theorem hasGroupoid_of_pregroupoid (PG : Pregroupoid H) (h : âˆ€ {e e' : LocalHomeomorph M H},\n      e âˆˆ atlas H M â†’ e' âˆˆ atlas H M â†’ PG.property (e.symm â‰«â‚• e') (e.symm â‰«â‚• e').source) :\n    HasGroupoid M PG.groupoid :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' tends to a value 'a' as it approaches infinity, then the extended distance between the function at 0 and 'a' is less than or equal to 'C' divided by (1 - 'r').",
    "output": "theorem edist_le_of_edist_le_geometric_of_tendstoâ‚€ {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :\n    edist (f 0) a â‰¤ C / (1 - r) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function M mapping from Î› to Stmtâ‚, a finite set S of Î›, and a statement q of type Stmtâ‚, if M supports S, then if some statement q is in the statements of M and S, S supports the statement q.",
    "output": "theorem stmts_supportsStmt {M : Î› â†’ Stmtâ‚} {S : Finset Î›} {q : Stmtâ‚} (ss : Supports M S) :\n    some q âˆˆ stmts M S â†’ SupportsStmt S q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite sets s and t, the union of s with the union of s and t is equal to the union of s and t. This is essentially saying that adding s to the union of s and t doesn't change the result, which is the union of s and t.",
    "output": "theorem union_left_idem (s t : Finset Î±) : s âˆª (s âˆª t) = s âˆª t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all indices i, if each element a i is in set t i, then the image of the function that maps each index i to the pair (i, a i) over set s is a subset of the Cartesian product of set s and set t.",
    "output": "theorem image_sigmaMk_subset_sigma_left {a : âˆ€ i, Î± i} (ha : âˆ€ i, a i âˆˆ t i) :\n    (fun i â†¦ Sigma.mk i (a i)) '' s âŠ† s.Sigma t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 's' is an antichain with respect to relation 'r', then 's' is also an antichain with respect to the swapped relation 'r'.",
    "output": "theorem swap (hs : IsAntichain r s) : IsAntichain (swap r) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two lists (lâ‚ and lâ‚‚), taking the initial elements from the combined list (lâ‚ ++ lâ‚‚) up to the length of the first list (lâ‚) will result in the first list (lâ‚).",
    "output": "theorem takeI_left (lâ‚ lâ‚‚ : List Î±) : takeI (length lâ‚) (lâ‚ ++ lâ‚‚) = lâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a list of elements of type M, if every element in the list is equal to a specific element m, then the product of all elements in the list is equal to m raised to the power of the length of the list.",
    "output": "theorem prod_eq_pow_card (l : List M) (m : M) (h : âˆ€ x âˆˆ l, x = m) : l.prod = m ^ l.length :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The equivalence of the finite successor of a multivariate polynomial in ring R and natural number n with the polynomial of variable 0 is equal to the polynomial of variable X.",
    "output": "theorem finSuccEquiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of a group 'M' and any natural number 'n', the power of 'a' to the 'n + 1' is equal to 'a' multiplied by the power of 'a' to the 'n'.",
    "output": "theorem pow_succ (a : M) (n : â„•) : a ^ (n + 1) = a * a ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'l' of type Î², a function 'f' from Î² to a product type Ï€ indexed by i, and a point 'x' of the same product type, if 'f' tends to 'x' along 'l', then for any index 'i', the function that maps each element 'a' of the domain to the 'i'-th component of 'f(a)' also tends to the 'i'-th component of 'x' along 'l'.",
    "output": "theorem Filter.Tendsto.apply {l : Filter Î²} {f : Î² â†’ âˆ€ i, Ï€ i} {x : âˆ€ i, Ï€ i}\n    (h : Tendsto f l (ğ“ x)) (i : Î¹) : Tendsto (fun a => f a i) l (ğ“ <| x i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types indexed by Î¹â‚ and Î¹â‚‚ respectively, and a property p that relates an element of the first type, an index of the first type, an element of the second type, and an index of the second type, the existence of such elements and indices that satisfy the property is commutative. That is, it doesn't matter in which order we consider the elements and indices from the two types, the existence of such elements and indices that satisfy the property remains the same.",
    "output": "theorem existsâ‚‚_comm {Îºâ‚ : Î¹â‚ â†’ Sort _} {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _} {p : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Prop} :\n    (âˆƒ iâ‚ jâ‚ iâ‚‚ jâ‚‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚) â†” âˆƒ iâ‚‚ jâ‚‚ iâ‚ jâ‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a group with zero, if x is not equal to zero, then the function that multiplies y by x is injective. This means that for any two different values of y, their products with x will also be different.",
    "output": "theorem GroupWithZero.mul_right_injective (h : x â‰  0) :\n    Function.Injective fun y => y * x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'b' is less than 'b'' and 'r' is greater than 0, then the line map of 'a', 'b', and 'r' is less than the line map of 'a', 'b'', and 'r'.",
    "output": "theorem lineMap_strict_mono_right (hb : b < b') (hr : 0 < r) : lineMap a b r < lineMap a b' r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero number 'a' and two natural numbers 'm' and 'n' such that 'n' is less than or equal to 'm', the inverse of 'a' raised to the power of the difference between 'm' and 'n' is equal to the inverse of 'a' raised to the power of 'm' multiplied by 'a' raised to the power of 'n'.",
    "output": "theorem inv_pow_subâ‚€ (ha : a â‰  0) (h : n â‰¤ m) : aâ»Â¹ ^ (m - n) = (a ^ m)â»Â¹ * a ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The maximum value obtained by folding function 'f' over set 's' starting with 'b' is less than 'c' if and only if 'b' is less than 'c' and for all elements 'x' in set 's', the function 'f' of 'x' is less than 'c'.",
    "output": "theorem fold_max_lt : s.fold max b f < c â†” b < c âˆ§ âˆ€ x âˆˆ s, f x < c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponent of a group G is equal to 0 if there exists an element g in G such that the order of g is 0. Otherwise, the exponent of G is the supremum of the order of all elements g in G.",
    "output": "theorem exponent_eq_iSup_orderOf' :\n    exponent G = if âˆƒ g : G, orderOf g = 0 then 0 else â¨† g : G, orderOf g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' of a certain type 'Î±', and any integer 'm', the function 'toIcoDiv' applied to 'hp', 'a - m' times 'p', and 'b' is equal to the function 'toIcoDiv' applied to 'hp', 'a', and 'b' plus 'm'.",
    "output": "theorem toIcoDiv_sub_zsmul' (a b : Î±) (m : â„¤) : toIcoDiv hp (a - m â€¢ p) b = toIcoDiv hp a b + m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any set 's' that is closed, the interior of the frontier of 's' is an empty set.",
    "output": "theorem interior_frontier {s : Set Î±} (h : IsClosed s) : interior (frontier s) = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two supremum-preserving functions 'f' and 'g' from a partially ordered set 'Î±' to another partially ordered set 'Î²', and for any element 'a' in 'Î±', the supremum of the images of 'a' under 'f' and 'g' is equal to the image of 'a' under the supremum of 'f' and 'g'.",
    "output": "theorem sup_apply (f g : SupHom Î± Î²) (a : Î±) : (f âŠ” g) a = f a âŠ” g a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a nontrivial ring R, if the function p from the finite set of size 2 to R is such that p(0) and p(1) are coprime, then p cannot be the zero function.",
    "output": "theorem IsCoprime.ne_zero [Nontrivial R] {p : Fin 2 â†’ R} (h : IsCoprime (p 0) (p 1)) : p â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is open if and only if for every element 'a' in 's', 's' is an element of the neighborhood of 'a'.",
    "output": "theorem isOpen_iff_mem_nhds {s : Set Î±} : IsOpen s â†” âˆ€ a âˆˆ s, s âˆˆ ğ“ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type F that is a monoid, and any function c from F to the transformation of M to M, if c applied to 1 equals the identity function, and for all elements f and g in F, c applied to the product of f and g equals the composition of c applied to f and c applied to g, then for any element f in F, for all natural numbers n, c applied to f raised to the power of n equals the nth iterate of c applied to f.",
    "output": "theorem hom_coe_pow {F : Type _} [Monoid F] (c : F â†’ M â†’ M) (h1 : c 1 = id)\n    (hmul : âˆ€ f g, c (f * g) = c f âˆ˜ c g) (f : F) : âˆ€ n, c (f ^ n) = c f^[n]"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any rational number 'q' and any absolute value function 'abv' on the rational numbers, the function 'ofRat' applied to 'q' is equal to 'q' considered as a Cauchy sequence with respect to the absolute value 'abv'.",
    "output": "theorem ofRat_rat {abv : â„š â†’ â„š} [IsAbsoluteValue abv] (q : â„š) :\n    ofRat (q : â„š) = (q : Cauchy abv) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given two distinct elements 'a' and 'b' and a function 'f' such that 'f' of 'a' equals 1, the multinomial of the set containing 'a' and 'b' with respect to function 'f' equals the successor of 'f' of 'b'. Here, the successor of a number is the next number following it.",
    "output": "theorem binomial_one [DecidableEq Î±] (h : a â‰  b) (hâ‚ : f a = 1) :\n    multinomial {a, b} f = (f b).succ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a prime number p and a finite Sylow p-subgroup P of a group G, if an element x belongs to the centralizer of P and the element obtained by conjugating x by the inverse of another element g also belongs to the centralizer of P, then there exists an element n in the normalizer of P such that the element obtained by conjugating x by the inverse of g is equal to the element obtained by conjugating x by n.",
    "output": "theorem Sylow.conj_eq_normalizer_conj_of_mem_centralizer [Fact p.Prime] [Finite (Sylow p G)]\n    (P : Sylow p G) (x g : G) (hx : x âˆˆ (P : Subgroup G).centralizer)\n    (hy : gâ»Â¹ * x * g âˆˆ (P : Subgroup G).centralizer) :\n    âˆƒ n âˆˆ (P : Subgroup G).normalizer, gâ»Â¹ * x * g = nâ»Â¹ * x * n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "I is continuous in the context of smooth manifolds with corners.",
    "output": "theorem continuous : Continuous I :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The basic open set of the product of two elements f and g from a ring R is a subset of or equal to the basic open set of the element f.",
    "output": "theorem basicOpen_mul_le_left (f g : R) : basicOpen (f * g) â‰¤ basicOpen f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for a given measurable space 'Î±' with measures 'm' and 'm0', and a measure 'Î¼' on 'Î±', if 'm' is less than or equal to 'm0' and a function 'f' from 'Î±' to 'Î²' is almost everywhere strongly measurable with respect to the trimmed measure 'Î¼.trim hm', then 'f' is also almost everywhere strongly measurable with respect to the measure 'Î¼'.",
    "output": "theorem _root_.aestronglyMeasurable_of_aestronglyMeasurable_trim {Î±} {m m0 : MeasurableSpace Î±}\n    {Î¼ : Measure Î±} (hm : m â‰¤ m0) {f : Î± â†’ Î²} (hf : AEStronglyMeasurable f (Î¼.trim hm)) :\n    AEStronglyMeasurable f Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a property Q that applies to Laurent polynomials over a ring R, and for any Laurent polynomial f, if for all polynomials f in R[X] and for all natural numbers n, the property Q holds for the product of the Laurent polynomial conversion of f and the negation of T raised to the power of n, then the property Q holds for the Laurent polynomial f.",
    "output": "theorem induction_on_mul_T {Q : R[T;Tâ»Â¹] â†’ Prop} (f : R[T;Tâ»Â¹])\n    (Qf : âˆ€ {f : R[X]} {n : â„•}, Q (toLaurent f * T (-n))) : Q f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of the lift of the kernel of g with respect to f and w, and Ï€' of f, g, and w, equals zero.",
    "output": "theorem condition_Ï€' : kernel.lift g f w â‰« Ï€' f g w = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a pairwise relation 'r', and for all pairs 'i' and 'j', if 'r' applies to 'i' and 'j' then 'p' also applies to 'i' and 'j', then 'p' is also a pairwise relation.",
    "output": "theorem Pairwise.mono (hr : Pairwise r) (h : âˆ€ â¦ƒi jâ¦„, r i j â†’ p i j) : Pairwise p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'fromRel' applied to a relation that is symmetric and always false (represented by the bottom symbol 'âŠ¥') for any elements x, y, and z of a type Î±, results in an empty set.",
    "output": "theorem fromRel_bot : fromRel (fun (x y : Î±) z => z : Symmetric âŠ¥) = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map T from a vector space E to itself, if T is positive, then the real part of the inner product of T applied to a vector x and x itself is nonnegative.",
    "output": "theorem IsPositive.inner_nonneg_left {T : E â†’L[ğ•œ] E} (hT : IsPositive T) (x : E) :\n    0 â‰¤ re âŸªT x, xâŸ« :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If S is a subalgebra of a ring A over a ring R, and if this subalgebra is Noetherian as a submodule over R, then any element x in S is integral over R.",
    "output": "theorem isIntegral_of_submodule_noetherian (S : Subalgebra R A)\n    (H : IsNoetherian R (Subalgebra.toSubmodule S)) (x : A) (hx : x âˆˆ S) : IsIntegral R x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' with a decidable predicate, the function of the order embedding of the set 's' is equal to the composition of the coercion function and the subtype of natural numbers in the set 's'.",
    "output": "theorem coe_orderEmbeddingOfSet [DecidablePred (Â· âˆˆ s)] :\n    â‡‘(orderEmbeddingOfSet s) = (â†‘) âˆ˜ Subtype.ofNat s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have two algebraic structures, g and f, such that g maps from B to C and f maps from A to B over a ring R, and both g and f are finite, then the composition of g and f (g composed with f) is also finite.",
    "output": "theorem comp {g : B â†’â‚[R] C} {f : A â†’â‚[R] B} (hg : g.Finite) (hf : f.Finite) : (g.comp f).Finite :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two extended real numbers x and y, if neither x nor y is equal to positive infinity, then the sum of x and y is less than positive infinity.",
    "output": "theorem add_lt_top {x y : EReal} (hx : x â‰  âŠ¤) (hy : y â‰  âŠ¤) : x + y < âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'g' mapping from two variables 'Î²' and 'Î³' to 'Î´', if 'g' is continuous when its arguments are uncurried, and there are two measurable functions 'fâ‚' and 'fâ‚‚' mapping from 'Î±' to 'Î²' and 'Î³' respectively with respect to a measure 'Î¼', then the composition of 'g' with 'fâ‚' and 'fâ‚‚' is equal to the composition of 'g' with the pair of 'fâ‚' and 'fâ‚‚'.",
    "output": "theorem compâ‚‚_eq_pair (g : Î² â†’ Î³ â†’ Î´) (hg : Continuous (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²)\n    (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) : compâ‚‚ g hg fâ‚ fâ‚‚ = comp _ hg (fâ‚.pair fâ‚‚) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given submodule U of an inner product space E over a field ğ•œ, assuming U is a complete space, the norm of the difference between a vector y in E and its orthogonal projection in U is equal to the infimum of the norm of the difference between y and any vector x in U.",
    "output": "theorem orthogonalProjection_minimal {U : Submodule ğ•œ E} [CompleteSpace U] (y : E) :\n    â€–y - orthogonalProjection U yâ€– = â¨… x : U, â€–y - xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If infinity is not an element of set s, then set s is open if and only if the preimage of set s under the embedding function is an open set in X.",
    "output": "theorem isOpen_iff_of_not_mem (h : âˆ âˆ‰ s) : IsOpen s â†” IsOpen ((â†‘) â»Â¹' s : Set X) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'x' is a generic point of 'S' and 'f' is a continuous function, then the image of 'x' under 'f' is a generic point of the closure of the image of 'S' under 'f'.",
    "output": "theorem image (h : IsGenericPoint x S) {f : Î± â†’ Î²} (hf : Continuous f) :\n    IsGenericPoint (f x) (closure (f '' S)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given seminorm 'p' on a vector space 'Eâ‚‚' over a field 'ğ•œâ‚‚', and a given linear map 'f' from a vector space 'E' to 'Eâ‚‚', the composition of 'p' and 'f' applied to a vector 'x' in 'E' is equal to 'p' applied to the image of 'x' under 'f'.",
    "output": "theorem comp_apply (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (x : E) : (p.comp f) x = p (f x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two sets 's' and 't', if for every element 'b', there is a Galois connection between the composition of 'toDual' and 'lâ‚ b' and the composition of 'swap u b' and 'ofDual', and for every element 'a', there is a Galois connection between the composition of 'toDual' and 'lâ‚‚ a' and the composition of 'u a' and 'ofDual', then the infimum of the image of the function 'u' over the Cartesian product of 's' and 't' is equal to the value of the function 'u' at the supremum of 's' and the supremum of 't'.",
    "output": "theorem sInf_image2_eq_sSup_sSup (hâ‚ : âˆ€ b, GaloisConnection (toDual âˆ˜ lâ‚ b) (swap u b âˆ˜ ofDual))\n    (hâ‚‚ : âˆ€ a, GaloisConnection (toDual âˆ˜ lâ‚‚ a) (u a âˆ˜ ofDual)) :\n    sInf (image2 u s t) = u (sSup s) (sSup t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If A is an adjacency matrix (as indicated by 'IsAdjMatrix A'), then the complement of A (denoted by 'A.compl') is also an adjacency matrix. This is true under the conditions that Î± is a set that includes zero and one.",
    "output": "theorem compl [Zero Î±] [One Î±] (h : IsAdjMatrix A) : IsAdjMatrix A.compl :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the cokernel of a morphism 'f' is zero, then 'f' is an epimorphism.",
    "output": "theorem epi_of_cokernel_Ï€_eq_zero (h : cokernel.Ï€ f = 0) : Epi f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The empty set is a member of the powerset of any given finite set.",
    "output": "theorem empty_mem_powerset (s : Finset Î±) : âˆ… âˆˆ powerset s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The evaluation tower with the identity algebra homomorphism from S to S is equal to the algebra evaluation function, which maps a function from Ïƒ to S and a multivariate polynomial over Ïƒ and S to an algebra homomorphism from S to S.",
    "output": "theorem aevalTower_id :\n    aevalTower (AlgHom.id S S) = (aeval : (Ïƒ â†’ S) â†’ MvPolynomial Ïƒ S â†’â‚[S] S) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The double symmetry of 'e' is equal to 'e' itself.",
    "output": "theorem symm_symm : e.symm.symm = e :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a matrix A represents a linear transformation f with respect to a basis b, and another matrix A' represents a different linear transformation f' with respect to the same basis b, then the matrix obtained by adding A and A' represents the linear transformation obtained by adding f and f'.",
    "output": "theorem Matrix.Represents.add {A A' : Matrix Î¹ Î¹ R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : Matrix.Represents b A' f') : (A + A').Represents b (f + f') :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a T2 space and compact space X, which is also a totally disconnected space, for any two elements x and y of X, if for every discrete quotient Q of X, the projection of x equals the projection of y, then x equals y.",
    "output": "theorem eq_of_forall_proj_eq [T2Space X] [CompactSpace X] [disc : TotallyDisconnectedSpace X]\n    {x y : X} (h : âˆ€ Q : DiscreteQuotient X, Q.proj x = Q.proj y) : x = y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' mapping from a strict convex space 'PF' to 'PE', if 'f' is an isometry, then applying the affine isometry of the strict convex space to a point 'p' in 'PF' is equivalent to applying the function 'f' to the point 'p'.",
    "output": "theorem affineIsometryOfStrictConvexSpace_apply {f : PF â†’ PE} (hi : Isometry f) (p : PF) :\n    hi.affineIsometryOfStrictConvexSpace p = f p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "There exists a non-negative constant C such that for all elements x in the set Î±, the distance between the function values f(x) and g(x) is less than or equal to C.",
    "output": "theorem dist_set_exists : âˆƒ C, 0 â‰¤ C âˆ§ âˆ€ x : Î±, dist (f x) (g x) â‰¤ C :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a relation 'r' between indices and a relation 's' for each index between elements of type 'Î±', and for two functions 'a' and 'b' from indices to elements of type 'Î±', 'a' is lexicographically less than 'b' (according to 'r' and 's') if and only if there exists an index 'j' such that for all indices 'd', if 'd' is related to 'j' by 'r', then 'a' at 'd' equals 'b' at 'd', and 'a' at 'j' is related to 'b' at 'j' by 's'.",
    "output": "theorem lex_def {r : Î¹ â†’ Î¹ â†’ Prop} {s : âˆ€ i, Î± i â†’ Î± i â†’ Prop} {a b : Î â‚€ i, Î± i} :\n    Dfinsupp.Lex r s a b â†” âˆƒ j, (âˆ€ d, r d j â†’ a d = b d) âˆ§ s j (a j) (b j) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 't' is order-connected in the non-negative real numbers, then the image of 't' under the function that maps each element to its corresponding element in the extended non-negative real numbers is also order-connected.",
    "output": "theorem image_coe_nnreal_ennreal (h : t.OrdConnected) : ((â†‘) '' t : Set â„â‰¥0âˆ).OrdConnected :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A pair (a, b) is in the intersection of edges r, s, and t if and only if a is in s, b is in t, and r is an edge connecting a and b.",
    "output": "theorem mk_mem_interedges_iff : (a, b) âˆˆ interedges r s t â†” a âˆˆ s âˆ§ b âˆˆ t âˆ§ r a b :="
  },
  {
    "instruction": "",
    "input": "For a local homeomorphism 'e' between two sets Î± and Î², a point 'b' in the target set of 'e', and two functions 'f' and 'g' from Î² to E and F respectively, and a real number 'C', the function 'f' is Big O of 'g' at 'b' with constant 'C' if and only if the function 'f' composed with the inverse of 'e' is Big O of the function 'g' composed with the inverse of 'e' at the inverse image of 'b' under 'e', with the same constant 'C'.",
    "output": "theorem isBigOWith_congr (e : LocalHomeomorph Î± Î²) {b : Î²} (hb : b âˆˆ e.target) {f : Î² â†’ E}\n    {g : Î² â†’ F} {C : â„} : IsBigOWith C (ğ“ b) f g â†” IsBigOWith C (ğ“ (e.symm b)) (f âˆ˜ e) (g âˆ˜ e) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an ideal I in a ring Î± is maximal, then I is also prime.",
    "output": "theorem IsMaximal.isPrime {I : Ideal Î±} (H : I.IsMaximal) : I.IsPrime :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functions 'f' and 'g' from a normed space 'E' to another normed space 'A', and a natural number 'N' (possibly infinite), if 'f' and 'g' are continuously differentiable on a subset 's' of 'E' up to order 'N', and 's' has unique derivatives, then for any point 'x' in 's' and any natural number 'n' less than or equal to 'N', the norm of the 'n'-th derivative of the function 'f*y*g*y' at 'x' is less than or equal to the sum, over all 'i' in the range from 0 to 'n', of the binomial coefficient 'n choose i' times the norm of the 'i'-th derivative of 'f' at 'x' times the norm of the '(n-i)'-th derivative of 'g' at 'x'.",
    "output": "theorem norm_iteratedFDerivWithin_mul_le {f : E â†’ A} {g : E â†’ A} {N : â„•âˆ} (hf : ContDiffOn ğ•œ N f s)\n    (hg : ContDiffOn ğ•œ N g s) (hs : UniqueDiffOn ğ•œ s) {x : E} (hx : x âˆˆ s) {n : â„•}\n    (hn : (n : â„•âˆ) â‰¤ N) : â€–iteratedFDerivWithin ğ•œ n (fun y => f y * g y) s xâ€– â‰¤\n      âˆ‘ i in Finset.range (n + 1), (n.choose i : â„) * â€–iteratedFDerivWithin ğ•œ i f s xâ€– *\n        â€–iteratedFDerivWithin ğ•œ (n - i) g s xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measurable space Î±, a countable set Î±, a measurable space Î², and a function f from Î² to Î±, if for every element y, the preimage of the set {f y} under f is a measurable set, then the function f is measurable.",
    "output": "theorem measurable_to_countable [MeasurableSpace Î±] [Countable Î±] [MeasurableSpace Î²] {f : Î² â†’ Î±}\n    (h : âˆ€ y, MeasurableSet (f â»Â¹' {f y})) : Measurable f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a morphism 'f' from presheaf P to Q, and a family of elements 'x' of P that is compatible, then the composition of 'x' with the presheaf map 'f' is also compatible.",
    "output": "theorem FamilyOfElements.Compatible.compPresheafMap (f : P âŸ¶ Q) {x : FamilyOfElements P R}\n    (h : x.Compatible) : (x.compPresheafMap f).Compatible :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A presheaf F satisfies the sheaf condition with respect to a cover of open sets if and only if it satisfies the sheaf condition with respect to pairwise intersections of open sets.",
    "output": "theorem isSheafOpensLeCover_iff_isSheafPairwiseIntersections :\n    F.IsSheafOpensLeCover â†” F.IsSheafPairwiseIntersections :="
  },
  {
    "instruction": "",
    "input": "For a polynomial 'f' over a ring 'R' and for any two elements 'x' and 'y' of 'R', the evaluation of 'f' at the sum of 'x' and 'y' is equal to the sum of three terms:",
    "output": "theorem poly_binom_aux3 (f : R[X]) (x y : R) :\n    f.eval (x + y) =\n      ((f.sum fun e a => a * x ^ e) + f.sum fun e a => a * e * x ^ (e - 1) * y) +\n        f.sum fun e a => a * (polyBinomAux1 x y e a).val * y ^ 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero ideal I and an element x from field K, x is in the inverse of I if and only if for all elements y in I, the product of x and y is in the unit fractional ideal of the field K.",
    "output": "theorem mem_inv_iff (hI : I â‰  0) {x : K} : x âˆˆ Iâ»Â¹ â†” âˆ€ y âˆˆ I, x * y âˆˆ (1 : FractionalIdeal Râ‚â° K) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' is convex in a real vector space 'R', and for every element 'i' in a set 't', the weight 'w i' is greater than or equal to zero, and the sum of the weights 'w i' over all 'i' in 't' equals 1, and for every 'i' in 't', 'z i' is an element of 's', then the weighted sum of 'z i' over all 'i' in 't' is an element of 's'.",
    "output": "theorem Convex.sum_mem (hs : Convex R s) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i) (hâ‚ : (âˆ‘ i in t, w i) = 1)\n    (hz : âˆ€ i âˆˆ t, z i âˆˆ s) : (âˆ‘ i in t, w i â€¢ z i) âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function that maps the sum of two functions, f and g, is continuous if and only if both f and g are continuous.",
    "output": "theorem continuous_sum_map {f : Î± â†’ Î²} {g : Î³ â†’ Î´} :\n    Continuous (Sum.map f g) â†” Continuous f âˆ§ Continuous g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements x and y from the unit interval I, the product of x and y is less than or equal to y.",
    "output": "theorem mul_le_right {x y : I} : x * y â‰¤ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'g' from 'P' to 'Q', the lift of the composition of 'f' and 'g' is equal to the composition of 'g' and the lift of 'f'.",
    "output": "theorem lift_comprâ‚‚ (g : P â†’â‚—[R] Q) : lift (f.comprâ‚‚ g) = g.comp (lift f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two Lie Ideals Iâ‚ and Iâ‚‚ of a Lie algebra L over a commutative ring R, if Iâ‚ is a subset of or equal to Iâ‚‚, then the function 'homOfLe' that maps Iâ‚ to Iâ‚‚ is injective. In other words, if two elements in Iâ‚ are mapped to the same element in Iâ‚‚ by 'homOfLe', then those two elements were originally the same in Iâ‚.",
    "output": "theorem homOfLe_injective {Iâ‚ Iâ‚‚ : LieIdeal R L} (h : Iâ‚ â‰¤ Iâ‚‚) : Function.Injective (homOfLe h) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an infinite set Î±, the cardinality of Î± when converted to a partial extended natural number equals the greatest element in the set of all partial extended natural numbers.",
    "output": "theorem mk_toPartENat_of_infinite [h : Infinite Î±] : toPartENat (#Î±) = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and c in a set Î±, subtracting the sum of b and c from a is equal to subtracting c from a and then subtracting b.",
    "output": "theorem tsub_add_eq_tsub_tsub_swap (a b c : Î±) : a - (b + c) = a - c - b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The measure with zero density is equal to zero.",
    "output": "theorem withDensity_zero : Î¼.withDensity 0 = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two lists of elements (l and l'), the set of elements x such that the product of swapping elements in l and l' at position x does not equal x, is a subset of the union of the finite sets of l and l'.",
    "output": "theorem zipWith_swap_prod_support' (l l' : List Î±) :\n    { x | (zipWith swap l l').prod x â‰  x } â‰¤ l.toFinset âŠ” l'.toFinset :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any property 'p' pertaining to an element of type 'Î±', an element 'a' of type 'Î±', and a lazy list 'l' of elements of type 'Î±', the property 'p' holds for every element in the lazy list that is constructed by adding 'a' to 'l' if and only if the property 'p' holds for 'a' and for every element in 'l'.",
    "output": "theorem forall_mem_cons {Î±} {p : Î± â†’ Prop} {a : Î±} {l : Thunk (LazyList Î±)} :\n    (âˆ€ x âˆˆ @LazyList.cons _ a l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l.get, p x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type 'Î±' and any natural number 'k', given that 'Î±' and 'Sym Î± k' are finite types, the cardinality of 'Sym Î± k' is equal to the multichoose of the cardinality of 'Î±' and 'k'.",
    "output": "theorem card_sym_eq_multichoose (Î± : Type _) (k : â„•) [Fintype Î±] [Fintype (Sym Î± k)] :\n    card (Sym Î± k) = multichoose (card Î±) k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given point 'x' and two points 'y' and 'z', 'x' is between 'y' and 'z' and 'x' is between 'z' and 'y' if and only if 'y' is equal to 'z'. This is under the condition that there are no zero scalar multiplication or division operations in the real number space 'R' and the vector space 'V'.",
    "output": "theorem wbtw_swap_right_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} :\n    Wbtw R x y z âˆ§ Wbtw R x z y â†” y = z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function which takes a pair of points in Î± and returns the non-negative distance between them is continuous.",
    "output": "theorem continuous_nndist : Continuous fun p : Î± Ã— Î± => nndist p.1 p.2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The integral function, which takes a function from Î± to E (with respect to measure Î¼) and returns its integral, is continuous.",
    "output": "theorem continuous_integral : Continuous fun f : Î± â†’â‚[Î¼] E => âˆ« a, f a âˆ‚Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a tree 't' of order 'Î±' is valid within the bounds 'oâ‚' and 'oâ‚‚', and if 'x' is bounded by 'oâ‚' and nil, and all elements of 't' are less than 'x', then 't' is valid within the bounds 'oâ‚' and 'x'.",
    "output": "theorem Valid'.of_lt {t : Ordnode Î±} {x : Î±} {oâ‚ oâ‚‚} (H : Valid' oâ‚ t oâ‚‚) (hâ‚ : Bounded nil oâ‚ x)\n    (hâ‚‚ : All (Â· < x) t) : Valid' oâ‚ t x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²' that is almost everywhere measurable with respect to measure 'Î¼', and for a measurable set 's', 's' is in the almost everywhere measure of the map of 'f' with respect to 'Î¼' if and only if the preimage of 's' under 'f' is in the almost everywhere measure of 'Î¼'.",
    "output": "theorem mem_ae_map_iff {f : Î± â†’ Î²} (hf : AEMeasurable f Î¼) {s : Set Î²} (hs : MeasurableSet s) :\n    s âˆˆ (Î¼.map f).ae â†” f â»Â¹' s âˆˆ Î¼.ae :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nontrivial ring R and a subset M that is a subset of the non-zero divisors of R, if an element x from R is in the non-zero divisors of R, then the algebraic mapping of x from R to another ring S is not zero.",
    "output": "theorem to_map_ne_zero_of_mem_nonZeroDivisors [Nontrivial R] (hM : M â‰¤ nonZeroDivisors R)\n    {x : R} (hx : x âˆˆ nonZeroDivisors R) : algebraMap R S x â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two natural numbers 'a' and 'b', if 'a' is greater than or equal to 2 and 'b' is strictly greater than 2, then the value of the expression '(a to the power of b plus 1) divided by (a plus 1)' is always greater than or equal to 2.",
    "output": "theorem b_id_helper {a b : â„•} (ha : 2 â‰¤ a) (hb : 2 < b) : 2 â‰¤ (a ^ b + 1) / (a + 1) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cardinality (or the number of elements) of a pair, consisting of elements 'a' and 'b' of any type 'Î±', is equal to 2.",
    "output": "theorem card_pair (a b : Î±) : card {a, b} = 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' is a compact operator from a module 'Mâ‚‚' over a ring 'Râ‚‚' to a module 'Mâ‚ƒ', and 'g' is a continuous linear map from a module 'Mâ‚' to 'Mâ‚‚', then the composition of 'f' and 'g' is also a compact operator.",
    "output": "theorem IsCompactOperator.comp_clm [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {f : Mâ‚‚ â†’ Mâ‚ƒ}\n    (hf : IsCompactOperator f) (g : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚) : IsCompactOperator (f âˆ˜ g) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"a is less than the supremum of a and b if and only if b is not less than or equal to a.\"",
    "output": "theorem left_lt_sup : a < a âŠ” b â†” Â¬b â‰¤ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' has a local minimum at a point 'a' in a set 's', and if 'f' is eventually equal to another function 'g' at 'a' within the set 's', and if 'a' is an element of 's', then 'g' also has a local minimum at 'a' in the set 's'.",
    "output": "theorem IsLocalMinOn.congr {f g : Î± â†’ Î²} {a : Î±} (h : IsLocalMinOn f s a)\n    (heq : f =á¶ [ğ“[s] a] g) (hmem : a âˆˆ s) : IsLocalMinOn g s a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î²' to 'Î±' and a measure 'Î¼' on 'Î²', if 'f' is almost everywhere measurable with respect to 'Î¼', then the function that maps each element 'a' to the extended non-negative real number equivalent of the norm of 'f(a)' is also almost everywhere measurable with respect to 'Î¼'.",
    "output": "theorem AEMeasurable.ennnorm {f : Î² â†’ Î±} {Î¼ : Measure Î²} (hf : AEMeasurable f Î¼) :\n    AEMeasurable (fun a => (â€–f aâ€–â‚Š : â„â‰¥0âˆ)) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'snd' and 'f' are isomorphisms, then for a commutative square 'sq' with 'fst', 'snd', 'f', and 'g', the square is a pullback.",
    "output": "theorem of_vert_isIso [IsIso snd] [IsIso f] (sq : CommSq fst snd f g) : IsPullback fst snd f g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"x is within Îµ distance of y in a closed ball if and only if y is within Îµ distance of x in a closed ball\".",
    "output": "theorem mem_closedBall_comm : x âˆˆ closedBall y Îµ â†” y âˆˆ closedBall x Îµ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If X is a type with a topological space structure, a T1 space structure, and is finite, then X has a discrete topology structure.",
    "output": "theorem discrete_of_t1_of_finite {X : Type _} [TopologicalSpace X] [T1Space X] [Finite X] :\n    DiscreteTopology X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer 'n', in the context of an additive group with one element (Î±) that has characteristic zero, 'n' being equal to zero in Î± is equivalent to 'n' being zero in the integers.",
    "output": "theorem cast_eq_zero [AddGroupWithOne Î±] [CharZero Î±] {n : â„¤} : (n : Î±) = 0 â†” n = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The preimage of the product set 's' and 't' under the function that pairs each element 'a' with 'b', is equal to 's' if 'b' is an element of 't', otherwise it is an empty set. This is under the condition that whether an element belongs to 't' is decidable.",
    "output": "theorem mk_preimage_prod_left_eq_if [DecidablePred (Â· âˆˆ t)] :\n    (fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = if b âˆˆ t then s else âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' mapping from 'Î±' and 'Î³' to 'Î´', and another function 'g' mapping from 'Î²' to 'Î³', mapping 'f' with 'a' and the result of mapping 'g' with 'b' is equivalent to mapping a function that takes 'a' and 'b' and applies 'f' to 'a' and 'g' to 'b', with 'a' and 'b'.",
    "output": "theorem mapâ‚‚_map_right (f : Î± â†’ Î³ â†’ Î´) (g : Î² â†’ Î³) :\n    mapâ‚‚ f a (b.map g) = mapâ‚‚ (fun a b => f a (g b)) a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is strictly monotonic (meaning it either consistently increases or decreases), and if 'a' is less than 'b', then 'f(a)' is less than 'f(b)'.",
    "output": "theorem StrictMono.imp (hf : StrictMono f) (h : a < b) : f a < f b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a pretrivialization 'e' of a fiber bundle with projection 'Ï€ E', if a base 'b' is not in the base set of 'e', then the inverse of 'e' at 'b' is equal to zero when viewed as a function from the fiber 'F' to the fiber over 'b' in 'E'.",
    "output": "theorem coe_symm_of_not_mem (e : Pretrivialization F (Ï€ E)) {b : B} (hb : b âˆ‰ e.baseSet) :\n    (e.symm b : F â†’ E b) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the field E over the scalar field ğ•œ is not finite-dimensional, then there exists a real number R and a sequence of elements in E such that R is greater than 1, the norm of each element in the sequence is less than or equal to R, and for any two distinct elements in the sequence, the norm of their difference is greater than or equal to 1.",
    "output": "theorem exists_seq_norm_le_one_le_norm_sub (h : Â¬FiniteDimensional ğ•œ E) :\n    âˆƒ (R : â„)(f : â„• â†’ E), 1 < R âˆ§ (âˆ€ n, â€–f nâ€– â‰¤ R) âˆ§ âˆ€ m n, m â‰  n â†’ 1 â‰¤ â€–f m - f nâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a function G from Î² to Î³ that is Lipschitz continuous with a constant C, then the composition of G and H is also continuous. This composition is a function from the set of bounded continuous functions from Î± to Î² to the set of bounded continuous functions from Î± to Î³.",
    "output": "theorem continuous_comp {G : Î² â†’ Î³} {C : â„â‰¥0} (H : LipschitzWith C G) :\n    Continuous (comp G H : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ‡ Î³) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and c, if a is less than or equal to b and b is less than or equal to c, then a is less than or equal to c.",
    "output": "theorem le_trans : âˆ€ {a b c : Î±}, a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' in the space 'Î²' and a function 't' mapping from 'Î¹' to the set of 'Î²', the vector difference of 's' and the intersection of all 't i' is a subset of the intersection of all vector differences of 's' and 't i'.",
    "output": "theorem vsub_iInter_subset (s : Set Î²) (t : Î¹ â†’ Set Î²) : (s -áµ¥ â‹‚ i, t i) âŠ† â‹‚ i, s -áµ¥ t i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "There is a Galois connection between the set of subsets of R and the set of subsets of the prime spectrum of R. This connection is established through the functions 'zeroLocus' and 'vanishingIdeal'. The 'zeroLocus' function takes a subset of R and returns the set of prime ideals where the elements of the subset vanish. The 'vanishingIdeal' function takes a subset of the prime spectrum of R and returns the ideal generated by the elements that vanish on the subset.",
    "output": "theorem gc_set :\n    @GaloisConnection (Set R) (Set (PrimeSpectrum R))áµ’áµˆ _ _ (fun s => zeroLocus s) fun t =>\n      vanishingIdeal t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', 9 divides 'n' if and only if 9 divides the sum of the digits of 'n' when 'n' is expressed in base 10.",
    "output": "theorem nine_dvd_iff (n : â„•) : 9 âˆ£ n â†” 9 âˆ£ (digits 10 n).sum :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the cardinality of set t is less than the cardinality of set s, and there exists a function f that maps every element of set s to set t, then there exist two distinct elements x and y in set s such that f(x) equals f(y).",
    "output": "theorem exists_ne_map_eq_of_ncard_lt_of_maps_to {t : Set Î²} (hc : t.ncard < s.ncard) {f : Î± â†’ Î²}\n  (hf : âˆ€ a âˆˆ s, f a âˆˆ t) (ht : t.Finite := by toFinite_tac) :\n    âˆƒ x âˆˆ s, âˆƒ y âˆˆ s, x â‰  y âˆ§ f x = f y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any unit 'u' in the set of associates of 'Î±', 'u' is equal to 1.",
    "output": "theorem units_eq_one (u : (Associates Î±)Ë£) : u = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' from a type 'Î±' to the same type 'Î±', 'f' commutes with itself.",
    "output": "theorem refl (f : Î± â†’ Î±) : Commute f f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function 'f' reaches its maximum at point 'a' within set 's' and function 'g' reaches its minimum at the same point 'a' within the same set 's', then the function defined as the difference between 'f' and 'g' will also reach its maximum at point 'a' within set 's'.",
    "output": "theorem IsMaxOn.sub (hf : IsMaxOn f s a) (hg : IsMinOn g s a) : IsMaxOn (fun x => f x - g x) s a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functions 'f' and 'g' from sets 'Î±' and 'Î²' to a set 'M', if there exists a bijective function 'e' from 'Î±' to 'Î²' such that for every element 'x' in 'Î±', 'f(x)' equals 'g(e(x))', then the infinite product of 'f' over all elements in 'Î±' equals the infinite product of 'g' over all elements in 'Î²'.",
    "output": "theorem finprod_eq_of_bijective {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (heâ‚€ : Bijective e)\n    (heâ‚ : âˆ€ x, f x = g (e x)) : (âˆá¶  i, f i) = âˆá¶  j, g j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given topological space 'Î±' and a set 's' within this space, if 's' is compact, and there is a function 'f' that is continuous on 's', then there exists a constant 'C' such that for all elements 'x' in 's', the norm of 'f(x)' is less than or equal to 'C'.",
    "output": "theorem IsCompact.exists_bound_of_continuous_on' [TopologicalSpace Î±] {s : Set Î±} (hs : IsCompact s)\n    {f : Î± â†’ E} (hf : ContinuousOn f s) : âˆƒ C, âˆ€ x âˆˆ s, â€–f xâ€– â‰¤ C :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î“ and Î“' that are inhabited, given a pointed map 'f' from Î“ to Î“', and a list 'l' of type Î“ that is blank, the head of the list 'l' mapped by 'f' is equal to the result of 'f' applied to the head of the list 'l'.",
    "output": "theorem ListBlank.head_map {Î“ Î“'} [Inhabited Î“] [Inhabited Î“'] (f : PointedMap Î“ Î“')\n    (l : ListBlank Î“) : (l.map f).head = f l.head :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-negative real number 'r', the representation of 'r' as a non-negative extended real number is equal to the non-negative extended real number obtained from 'r'.",
    "output": "theorem coe_nnreal_eq (r : â„â‰¥0) : (r : â„â‰¥0âˆ) = ENNReal.ofReal r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type M with structures L and L', and any expansion Ï• on M, for any function f from L with arity n and any function x from the finite set of size n to M, the function map of the expansion of f on x is equal to the function map of f on x.",
    "output": "theorem map_onFunction {M : Type _} [L.Structure M] [L'.Structure M] [Ï•.IsExpansionOn M] {n}\n    (f : L.Functions n) (x : Fin n â†’ M) : funMap (Ï•.onFunction f) x = funMap f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bilinear form B over a ring Râ‚‚ and a function from n to Râ‚‚, converting the bilinear form to a matrix and then back to a bilinear form will yield the original bilinear form B.",
    "output": "theorem Matrix.toBilin'_toMatrix' (B : BilinForm Râ‚‚ (n â†’ Râ‚‚)) :\n    Matrix.toBilin' (BilinForm.toMatrix' B) = B :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the series of function f is summable and the series of function g is also summable, then the series of the function that subtracts g from f for each input b is also summable.",
    "output": "theorem Summable.sub (hf : Summable f) (hg : Summable g) : Summable fun b => f b - g b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any affine subspace Q of a vector space E over a field ğ•œ, Q is a convex set in E.",
    "output": "theorem AffineSubspace.convex (Q : AffineSubspace ğ•œ E) : Convex ğ•œ (Q : Set E) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have an algebra from A to B and a scalar tower from R to A to B, then if A is of finite type over R and B is of finite type over A, it follows that B is of finite type over R.",
    "output": "theorem trans [Algebra A B] [IsScalarTower R A B] (hRA : FiniteType R A) (hAB : FiniteType A B) :\n    FiniteType R B :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of subobjects of an object 'A' in category 'C', and a subobject 'f' that belongs to 's', the infimum (greatest lower bound) of 's' is less than or equal to 'f'.",
    "output": "theorem sInf_le {A : C} (s : Set (Subobject A)) (f) (hf : f âˆˆ s) : sInf s â‰¤ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The rank of the module K with a finite function from natural number n to K is equal to n.",
    "output": "theorem rank_fin_fun (n : â„•) : Module.rank K (Fin n â†’ K) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of elements of type 'A', if the zero element of 'A' is in 's' and for any two elements 'a' and 'b' of 'A' that are in 's', the result of 'a' subtracted by 'b' is also in 's', then 's' is an additive subgroup.",
    "output": "theorem IsAddSubgroup.of_sub (s : Set A) (zero_mem : (0 : A) âˆˆ s)\n    (sub_mem : âˆ€ {a b : A}, a âˆˆ s â†’ b âˆˆ s â†’ a - b âˆˆ s) : IsAddSubgroup s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is an element of the closed interval box I, then the single box partition of I at x is a Henstock partition.",
    "output": "theorem isHenstock_single (h : x âˆˆ Box.Icc I) : IsHenstock (single I I le_rfl x h) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a transitive relation R on a type Î±, and a list lâ‚‚ forms a chain with respect to R starting from an element a, then if list lâ‚ is a sublist of lâ‚‚, lâ‚ also forms a chain with respect to R starting from the same element a.",
    "output": "theorem Chain.sublist [IsTrans Î± R] (hl : lâ‚‚.Chain R a) (h : lâ‚ <+ lâ‚‚) :\n    lâ‚.Chain R a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If you reflect a point 'p' in a subspace 'K' twice, you will get back the original point 'p'.",
    "output": "theorem reflection_reflection (p : E) : reflection K (reflection K p) = p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function g from the Cartesian product of Eâ‚ and Eâ‚‚ to G is continuously differentiable, and if two functions fâ‚ and fâ‚‚ from F to Eâ‚ and Eâ‚‚ respectively are continuously differentiable on a set s, then the function that maps x in s to g of the pair (fâ‚ of x, fâ‚‚ of x) is also continuously differentiable on the set s.",
    "output": "theorem ContDiff.comp_contDiff_onâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {s : Set F}\n    (hg : ContDiff ğ•œ n g) (hfâ‚ : ContDiffOn ğ•œ n fâ‚ s) (hfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s) :\n    ContDiffOn ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set C of subsets of Î±, if the initial measure m0 is generated from C, and C is a pi system, and Î¼ is a finite measure, and for all subsets s in C, the measure Î¼ of s is equal to the measure Î½ of s, and the measure Î¼ of the universal set is equal to the measure Î½ of the universal set, then the measure Î¼ is equal to the measure Î½.",
    "output": "theorem ext_of_generate_finite (C : Set (Set Î±)) (hA : m0 = generateFrom C) (hC : IsPiSystem C)\n    [IsFiniteMeasure Î¼] (hÎ¼Î½ : âˆ€ s âˆˆ C, Î¼ s = Î½ s) (h_univ : Î¼ univ = Î½ univ) : Î¼ = Î½ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a special linear group of order 2 over the real numbers, denoted as SL(2, R), the inverse of a matrix A in this group is given by a 2x2 matrix where the elements are determined by the elements of A. Specifically, the first row of the inverse matrix consists of the element at the second row and second column of A, and the negative of the element at the first row and second column of A. The second row of the inverse matrix consists of the negative of the element at the second row and first column of A, and the element at the first row and first column of A. The determinant of this inverse matrix is given by the function SL2_inv_expl_det applied to A.",
    "output": "theorem SL2_inv_expl (A : SL(2, R)) :\n    Aâ»Â¹ = âŸ¨![![A.1 1 1, -A.1 0 1], ![-A.1 1 0, A.1 0 0]], SL2_inv_expl_det AâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite maps 's' and 't' of some type 'Î²', 's' and 't' are equal if and only if their entries are equal.",
    "output": "theorem ext_iff {s t : Finmap Î²} : s.entries = t.entries â†” s = t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a simple function 'f' from 'Î±' to 'E' that belongs to the space of measurable functions 'Memâ„’p' with norm 'p' and measure 'Î¼', the norm of the function 'f' when it is transformed to 'Lp' space is equal to the real part of the essential supremum norm of 'f' with respect to 'p' and 'Î¼'. This is true when 'p' is greater than or equal to 1.",
    "output": "theorem norm_toLp [Fact (1 â‰¤ p)] (f : Î± â†’â‚› E) (hf : Memâ„’p f p Î¼) :\n    â€–toLp f hfâ€– = ENNReal.toReal (snorm f p Î¼) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If you first apply the function 'I.fst' to 'a' and then apply 'K.Ï€' to the result of 'I.fstFrom a', it is equal to first applying the function 'I.snd' to 'a' and then applying 'K.Ï€' to the result of 'I.sndFrom a'.",
    "output": "theorem condition (a) : I.fst a â‰« K.Ï€ (I.fstFrom a) = I.snd a â‰« K.Ï€ (I.sndFrom a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function fâ‚ is less than or equal to function fâ‚‚, and function gâ‚ is less than or equal to function gâ‚‚, then the product of function fâ‚ and function gâ‚ is less than or equal to the product of function fâ‚‚ and function gâ‚‚.",
    "output": "theorem smul_le_smul : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ â€¢ gâ‚ â‰¤ fâ‚‚ â€¢ gâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is homeomorphic to y, then the neighborhood of x is equal to the neighborhood of y.",
    "output": "theorem nhds_eq (h : x ~áµ¢ y) : ğ“ x = ğ“ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b', 'a' is equal to 'b' if and only if the injection of 'a' into the right component of the sum type is equal to the injection of 'b' into the right component of the sum type.",
    "output": "theorem inr.inj_iff {a b} : (inr a : Sum Î± Î²) = inr b â†” a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for all x in set s, f is differentiable at x, and the norm of the derivative of f at x minus Ï† is less than or equal to C, and if s is a convex set, and x and y are elements of s, then the norm of f(y) minus f(x) minus Ï† applied to (y - x) is less than or equal to C times the norm of (y - x).",
    "output": "theorem norm_image_sub_le_of_norm_fderiv_le' (hf : âˆ€ x âˆˆ s, DifferentiableAt ğ•œ f x)\n    (bound : âˆ€ x âˆˆ s, â€–fderiv ğ•œ f x - Ï†â€– â‰¤ C) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) :\n    â€–f y - f x - Ï† (y - x)â€– â‰¤ C * â€–y - xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± and any two semilattice infimum structures A and B on Î±, if for all x and y of type Î±, x is less than or equal to y in A if and only if x is less than or equal to y, then for any x and y of type Î±, the infimum of x and y in A is equal to the infimum of x and y.",
    "output": "theorem SemilatticeInf.ext_inf {Î±} {A B : SemilatticeInf Î±}\n    (H : âˆ€ x y : Î±, (haveI := A; x â‰¤ y) â†” x â‰¤ y)\n    (x y : Î±) :\n    (haveI := A; x âŠ“ y) = x âŠ“ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The unit of the Free Monoidal Category is equal to the identity of the functor applied to the category C.",
    "output": "theorem unit_eq_unit : FreeMonoidalCategory.Unit = ğŸ™_ (F C) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any set 's' of pairs of elements from two sets 'Î±' and 'Î²' that have an infimum, the first element of the infimum of 's' is equal to the infimum of the set of all first elements of 's'.",
    "output": "theorem fst_sInf [InfSet Î±] [InfSet Î²] (s : Set (Î± Ã— Î²)) : (sInf s).fst = sInf (Prod.fst '' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' and 'b' are codisjoint, then the images of 'a' and 'b' under a function 'f' are also codisjoint.",
    "output": "theorem Codisjoint.map (h : Codisjoint a b) : Codisjoint (f a) (f b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given ring Î±, if a function f is periodic with period c, then the value of the function at any integer multiple of the period is equal to the value of the function at zero.",
    "output": "theorem Periodic.int_mul_eq [Ring Î±] (h : Periodic f c) (n : â„¤) : f (n * c) = f 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a continuous linear map 'f' from 'F' to 'G' and a formal multilinear series 'p' from 'ğ•œ' to 'E' to 'F', the composition of 'f' with the 'n'-th term of the formal multilinear series 'p' is equal to the composition of 'f' with the 'n'-th continuous multilinear map of 'p'.",
    "output": "theorem compFormalMultilinearSeries_apply (f : F â†’L[ğ•œ] G) (p : FormalMultilinearSeries ğ•œ E F)\n    (n : â„•) : (f.compFormalMultilinearSeries p) n = f.compContinuousMultilinearMap (p n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The complement of a singleton set {x} is dense if and only if the singleton set {x} is not open.",
    "output": "theorem dense_compl_singleton_iff_not_open {x : Î±} :\n    Dense ({x}á¶œ : Set Î±) â†” Â¬IsOpen ({x} : Set Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'b' is an element of the closed interval from 'a' to 'b' if and only if 'a' is less than or equal to 'b'.",
    "output": "theorem right_mem_Icc : b âˆˆ Icc a b â†” a â‰¤ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an element 'b' not in set 's', the infimum (greatest lower bound) of the function 'f' over the set obtained by adding 'b' to 's' is equal to the infimum of 'f' at 'b' and the infimum of 'f' over 's'.",
    "output": "theorem inf_cons {b : Î²} (h : b âˆ‰ s) : (cons b s h).inf f = f b âŠ“ s.inf f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given real number 'a' and another real number 'c' which is greater than zero, the preimage of the function that multiplies 'x' by 'c' in the interval of all real numbers less than 'a' is equal to the interval of all real numbers less than 'a' divided by 'c'.",
    "output": "theorem preimage_mul_const_Iio (a : Î±) {c : Î±} (h : 0 < c) :\n    (fun x => x * c) â»Â¹' Iio a = Iio (a / c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements x and y from a set R, the inverse action of x applied to y is equal to the inverse of the action of x on y.",
    "output": "theorem invAct_apply (x y : R) : (act' x)â»Â¹ y = x â—ƒâ»Â¹ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a property P that applies to integers, and a given integer m, if P holds for m, and for any integer n that is less than or equal to m, if P holds for n then P also holds for n minus 1, then for any integer n that is less than or equal to m, P holds for n. This is a form of induction going downwards from m.",
    "output": "theorem le_induction_down {P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m)\n    (h1 : âˆ€ n : â„¤, n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The half-open interval from 'a' to 'b' is totally bounded.",
    "output": "theorem totallyBounded_Ico (a b : Î±) : TotallyBounded (Ico a b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of the total function with the representation function of a linearly independent vector is equal to the subtype of a submodule.",
    "output": "theorem LinearIndependent.total_comp_repr :\n    (Finsupp.total Î¹ M R v).comp hv.repr = Submodule.subtype _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An open interval from a point 'a' to the same point 'a' is an empty set.",
    "output": "theorem Ioo_self (a : Î±) : Ioo a a = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a continuous function 'f' from 'Î±' to 'Î²' and a set 't' in 'Î²', the closure of the preimage of 't' under 'f' is a subset of the preimage of the closure of 't' under 'f'.",
    "output": "theorem Continuous.closure_preimage_subset {f : Î± â†’ Î²} (hf : Continuous f) (t : Set Î²) :\n    closure (f â»Â¹' t) âŠ† f â»Â¹' closure t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the function pair f and g is anti-variant on a set s, then the composition of f and g with another function k is also anti-variant on the preimage of set s under function k.",
    "output": "theorem AntivaryOn.comp_right (h : AntivaryOn f g s) (k : Î¹' â†’ Î¹) :\n    AntivaryOn (f âˆ˜ k) (g âˆ˜ k) (k â»Â¹' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of points where a linear map 'f' from a module 'M' to another module 'Mâ‚‚' equals itself is the entire space.",
    "output": "theorem eqLocus_same (f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) : f.eqLocus f = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The application of the outer measure to a set 't' from a uniform distribution of a finite set 's' is equal to the ratio of the cardinality of the set 's' filtered by the elements in 't' to the cardinality of the set 's'.",
    "output": "theorem toOuterMeasure_uniformOfFinset_apply :\n    (uniformOfFinset s hs).toOuterMeasure t = (s.filter (Â· âˆˆ t)).card / s.card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two finite sets 's' and 't', and any two functions 'f' and 'g', the supremum (or greatest lower bound) of the infimum (or least upper bound) of 'f' over 's' and the infimum of 'g' over 't' is equal to the infimum over the Cartesian product of 's' and 't' of the supremum of 'f' applied to the first element of the pair and 'g' applied to the second element of the pair.",
    "output": "theorem inf_sup_inf (s : Finset Î¹) (t : Finset Îº) (f : Î¹ â†’ Î±) (g : Îº â†’ Î±) :\n    s.inf f âŠ” t.inf g = (s Ã—Ë¢ t).inf fun i => f i.1 âŠ” g i.2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is irrational, then its negative, -x, is also irrational.",
    "output": "theorem neg (h : Irrational x) : Irrational (-x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of elements in E, the balanced core of 's' with respect to the field ğ•œ is balanced.",
    "output": "theorem balancedCore_balanced (s : Set E) : Balanced ğ•œ (balancedCore ğ•œ s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' that maps each element of type 'Î± i' to an element of type 'Î² i', the Cartesian product of the universal set 'Set Î¹' and the range of 'f i' is equal to the range of a function that maps each element 'x' of the Cartesian product of 'Î¹' and 'Î± i' to a pair consisting of the first element of 'x' and the image of the second element of 'x' under 'f'.",
    "output": "theorem sigma_univ_range_eq {f : âˆ€ i, Î± i â†’ Î² i} :\n    ((univ : Set Î¹).Sigma fun i â†¦ range (f i)) = range fun x : Î£i, Î± i â†¦ âŸ¨x.1, f _ x.2âŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite set 'S' and a function 'f' mapping from 'S' to the free module 'N', the sum over 'S' of the function 'f' applied to each element in 'S' is equal to the sum over 'S' of the function 'f' applied to each element in 'S' and then mapped to the free module 'N'. This is under the condition that 'N' is an additive commutative monoid.",
    "output": "theorem coe_finset_sum [AddCommMonoid N] (S : Finset Î¹) (f : Î¹ â†’ Î± â†’â‚€ N) :\n    â‡‘(âˆ‘ i in S, f i) = âˆ‘ i in S, â‡‘(f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index 'i', and any elements 'a' from the zeroth component of the direct sum and 'b' from the 'i'th component of the direct sum, the direct sum of the scalar multiplication of 'a' and 'b' is equal to the product of the direct sum of 'a' and the direct sum of 'b'.",
    "output": "theorem of_zero_smul {i} (a : A 0) (b : A i) : of _ _ (a â€¢ b) = of _ _ a * of _ _ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î² with decidable equality, a value x of type Î², a function e that is an equivalence between the option of type Î± and Î² such that e applied to none equals x, a value a of type Î±, and a proof h, the application of the function optionSubtype with arguments x, e, and a equals a pair consisting of the application of e to a and the proof h.",
    "output": "theorem optionSubtype_apply_apply\n    [DecidableEq Î²] (x : Î²)\n    (e : { e : Option Î± â‰ƒ Î² // e none = x })\n    (a : Î±)\n    (h) : optionSubtype x e a = âŸ¨(e : Option Î± â‰ƒ Î²) a, hâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number 'x', the function 'untrop' applied to the function 'trop' of 'x' equals 'x'.",
    "output": "theorem untrop_trop (x : R) : untrop (trop x) = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a monoid structure Î±, given an irreducible element p and two elements a and b such that p equals the product of a and b, either a or b is a unit.",
    "output": "theorem isUnit_or_isUnit [Monoid Î±] {p : Î±} (hp : Irreducible p) {a b : Î±} (h : p = a * b) :\n    IsUnit a âˆ¨ IsUnit b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given tree 't' and objects 'oâ‚' and 'oâ‚‚', if 't' is valid with respect to 'oâ‚' and 'oâ‚‚', then 't' is valid.",
    "output": "theorem Valid'.valid {t oâ‚ oâ‚‚} (h : @Valid' Î± _ oâ‚ t oâ‚‚) : Valid t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given point 'c' in an affine space 'P1', the coercion of the homothety affine map of 'c' is equal to the homothety of 'c'.",
    "output": "theorem coe_homothetyAffine (c : P1) : â‡‘(homothetyAffine c : k â†’áµƒ[k] _) = homothety c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given injective function 'f' from model 'M' to model 'N' in the language 'L', the function 'f' when converted to a homomorphism (using 'toHom') from 'M' to 'N' is still the same function 'f'.",
    "output": "theorem coe_toHom {f : M â†ª[L] N} : (f.toHom : M â†’ N) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The preimage of the set of real numbers between 'a' and 'b' (including 'a' but excluding 'b') under the function that casts natural numbers to real numbers, is equal to the set of natural numbers between the ceiling of 'a' and the ceiling of 'b' (including the ceiling of 'a' but excluding the ceiling of 'b').",
    "output": "theorem preimage_Ico {a b : Î±} : (Nat.cast : â„• â†’ Î±) â»Â¹' Set.Ico a b = Set.Ico âŒˆaâŒ‰â‚Š âŒˆbâŒ‰â‚Š :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the algebraic mapping of R to A is continuous, then the scalar multiplication of R and A is also continuous.",
    "output": "theorem continuousSMul_of_algebraMap (h : Continuous (algebraMap R A)) : ContinuousSMul R A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' and an element 'a' of the integers modulo 'n', the value of 'a' is equal to zero if and only if 'a' itself is equal to zero.",
    "output": "theorem val_eq_zero : âˆ€ {n : â„•} (a : ZMod n), a.val = 0 â†” a = 0"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î± and Î², where Î² is a preorder, and any two functions f and g from Î± to Î², and any element a of type Î± and any filter l on Î±, if g is eventually less than or equal to f at filter l, and f at a equals g at a, and if f is a maximum filter at a with respect to l, then g is also a maximum filter at a with respect to l.",
    "output": "theorem Filter.EventuallyLE.isMaxFilter {Î± Î² : Type _} [Preorder Î²] {f g : Î± â†’ Î²} {a : Î±}\n    {l : Filter Î±} (hle : g â‰¤á¶ [l] f) (hfga : f a = g a) (h : IsMaxFilter f l a) :\n    IsMaxFilter g l a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The object 'zero' in the operation 'walkingParallelPairOp' is equal to the operation 'one' applied to its opposite.",
    "output": "theorem walkingParallelPairOp_zero : walkingParallelPairOp.obj zero = op one :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function F tends uniformly towards another function f on a set Ï† within a thickening of Î´ around a set K, and if Î´ is greater than 0, and if the function F is continuous on the thickening of Î´ around K for all eventually n in Ï†, then the complex derivative of F tends uniformly towards the complex derivative of f on the set K.",
    "output": "theorem _root_.TendstoUniformlyOn.cderiv (hF : TendstoUniformlyOn F f Ï† (cthickening Î´ K))\n    (hÎ´ : 0 < Î´) (hFn : âˆ€á¶  n in Ï†, ContinuousOn (F n) (cthickening Î´ K)) :\n    TendstoUniformlyOn (cderiv Î´ âˆ˜ F) (cderiv Î´ f) Ï† K :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A multivariate polynomial 'p' is equal to zero if and only if the coefficient of 'p' for any degree 'd' is zero.",
    "output": "theorem eq_zero_iff {p : MvPolynomial Ïƒ R} : p = 0 â†” âˆ€ d, coeff d p = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two objects Y and Z in category C, and a morphism f from Z to Y, if I is an injective resolution of Y and J is an injective resolution of Z, then the composition of J's augmentation morphism and the descendent of f with respect to I and J is equal to the composition of the map of f in the zeroth cochain complex of C and I's augmentation morphism.",
    "output": "theorem desc_commutes {Y Z : C} (f : Z âŸ¶ Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) : J.Î¹ â‰« desc f I J = (CochainComplex.singleâ‚€ C).map f â‰« I.Î¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of sets s and t is a subset of set u if and only if for every element b in set t, the scalar multiplication of b and set s is a subset of set u.",
    "output": "theorem mul_subset_iff_right : s * t âŠ† u â†” âˆ€ b âˆˆ t, op b â€¢ s âŠ† u :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list 'l', 'l' is a sub-permutation of itself.",
    "output": "theorem Subperm.refl (l : List Î±) : l <+~ l :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a simple graph G with vertex set V, the simple graph derived from the structure of G is equal to G itself.",
    "output": "theorem _root_.SimpleGraph.simpleGraphOfStructure (G : SimpleGraph V) :\n    @simpleGraphOfStructure V G.structure _ = G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set s is balanced in the field ğ•œ if and only if for all elements a in ğ•œ such that the norm of a is less than or equal to 1, and for all elements x in the vector space E, if x is in s then the scalar multiplication of a and x is in s.",
    "output": "theorem balanced_iff_smul_mem : Balanced ğ•œ s â†” âˆ€ â¦ƒa : ğ•œâ¦„, â€–aâ€– â‰¤ 1 â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ s â†’ a â€¢ x âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If sets 'a' and 'b' are disjoint, then set 'c' is less than or equal to the symmetric difference of 'a' and 'c' union the symmetric difference of 'b' and 'c'.",
    "output": "theorem Disjoint.le_symmDiff_sup_symmDiff_left (h : Disjoint a b) : c â‰¤ a âˆ† c âŠ” b âˆ† c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function which adds two extended real numbers is continuous at any point (a, b) in the extended real plane.",
    "output": "theorem continuousAt_add_coe_coe (a b : â„) :\n    ContinuousAt (fun p : EReal Ã— EReal => p.1 + p.2) (a, b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' of type Î± and given subgroups 'S' and 'T' of type A, 'a' multiplied by 'S' is less than or equal to 'T' if and only if 'S' is less than or equal to the inverse of 'a' multiplied by 'T'.",
    "output": "theorem pointwise_smul_le_iff {a : Î±} {S T : AddSubgroup A} : a â€¢ S â‰¤ T â†” S â‰¤ aâ»Â¹ â€¢ T :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two nonempty compact subsets x and y of a metric space Î±, the distance between x and y is equal to the Hausdorff distance between the set x and y.",
    "output": "theorem NonemptyCompacts.dist_eq {x y : NonemptyCompacts Î±} :\n    dist x y = hausdorffDist (x : Set Î±) y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²', if the set 's' is finite and the image of 's' under 'f' is also finite, then the conversion of the image of 's' under 'f' to a finite set is equal to the image of the conversion of 's' to a finite set under 'f'. This is under the condition that 'Î²' has decidable equality.",
    "output": "theorem toFinset_image [DecidableEq Î²] (f : Î± â†’ Î²) (hs : s.Finite) (h : (f '' s).Finite) :\n    h.toFinset = hs.toFinset.image f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f has a derivative at a point x, and a constant c is greater than 0, then the derivative of the function that raises c to the power of f(x) at the point x is equal to the product of c raised to the power of f(x), the natural logarithm of c, and the derivative of f at x.",
    "output": "theorem HasFDerivAt.const_rpow (hf : HasFDerivAt f f' x) (hc : 0 < c) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Real.log c) â€¢ f') x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a point x is a member of a set s, then the infimum (greatest lower bound) of the extended distance between x and s is zero.",
    "output": "theorem infEdist_zero_of_mem (h : x âˆˆ s) : infEdist x s = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type Î±, the infimum (greatest lower bound) of the application of 'a' to the functions 'f' and 'g' is equal to the infimum of the results of applying 'a' to 'f' and 'g' separately.",
    "output": "theorem inf_apply (a : Î±) : (f âŠ“ g) a = f a âŠ“ g a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The seminorm of the negation of a function 'f' is equal to the seminorm of the function 'f' itself.",
    "output": "theorem snorm'_neg {f : Î± â†’ F} : snorm' (-f) q Î¼ = snorm' f q Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The frontier (the boundary between the interior and the closure) of the set of complex numbers 'z' such that the real part of 'z' is greater than or equal to a real number 'a', is equal to the set of complex numbers 'z' where the real part of 'z' is exactly equal to 'a'.",
    "output": "theorem frontier_setOf_le_re (a : â„) : frontier { z : â„‚ | a â‰¤ z.re } = { z | z.re = a } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The closed interval from 'a' to 'b' is equal to the range from 'a' to 'b + 1 - a', where the list does not contain any duplicate elements.",
    "output": "theorem Icc_eq_range' : Icc a b = âŸ¨List.range' a (b + 1 - a), List.nodup_range' _ _âŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a division ring R, for any elements a, b, c, and d of R, if the inverse of b is equal to c and the product of a and c is equal to d, then the result of dividing a by b is equal to d.",
    "output": "theorem div_pf {R} [DivisionRing R] {a b c d : R}\n    (_ : bâ»Â¹ = c) (_ : a * c = d) : a / b = d :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer n and any element a of a normed group, the non-negative norm of a raised to the power of n is less than or equal to the product of the non-negative norm of n and the non-negative norm of a.",
    "output": "theorem nnnorm_zpow_le_mul_norm (n : â„¤) (a : Î±) : â€–a ^ nâ€–â‚Š â‰¤ â€–nâ€–â‚Š * â€–aâ€–â‚Š :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The infimum (greatest lower bound) of any element 'a' and the top element is 'a'.",
    "output": "theorem inf_top_eq : a âŠ“ âŠ¤ = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If J is an element of Ï€, then J is a subset of the union of Ï€.",
    "output": "theorem subset_iUnion (h : J âˆˆ Ï€) : â†‘J âŠ† Ï€.iUnion :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Mapping an equivalence in the ring of multivariate polynomials with the reflection operation on the ring R is equivalent to the reflection operation on the ring of multivariate polynomials.",
    "output": "theorem mapEquiv_refl : mapEquiv Ïƒ (RingEquiv.refl R) = RingEquiv.refl _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the product of two sets 's' and 't' is bounded and the set 's' is nonempty, then the set 't' is also bounded.",
    "output": "theorem IsBounded.snd_of_prod (h : IsBounded (s Ã—Ë¢ t)) (hs : s.Nonempty) : IsBounded t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every element 'b', there is a Galois connection between 'lâ‚ b' and the swapped version of 'u b', and for every element 'a', there is a Galois connection between 'lâ‚‚ a' and 'u a', then if 's' is nonempty and bounded below, and 't' is also nonempty and bounded below, the infimum of the image of the function 'u' over the sets 's' and 't' is equal to the value of 'u' at the infimum of 's' and the infimum of 't'.",
    "output": "theorem csInf_image2_eq_csInf_csInf (hâ‚ : âˆ€ b, GaloisConnection (lâ‚ b) (swap u b))\n    (hâ‚‚ : âˆ€ a, GaloisConnection (lâ‚‚ a) (u a)) :\n    s.Nonempty â†’ BddBelow s â†’ t.Nonempty â†’ BddBelow t â†’ sInf (image2 u s t) = u (sInf s) (sInf t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' of type Î±, the greatest fixed point of the infimum of the constant function at 'x' and a function 'f' is less than or equal to 'x'.",
    "output": "theorem gfp_const_inf_le (x : Î±) : gfp (const Î± x âŠ“ f) â‰¤ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If m is less than or equal to n, then the product of the function f(i) for all i in the interval from m to n+1, divided by f(n), is equal to the product of the function f(i) for all i in the interval from m to n.",
    "output": "theorem prod_Ico_succ_div_top (hmn : m â‰¤ n) :\n    (âˆ i in Ico m (n + 1), f i) / f n = âˆ i in Ico m n, f i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite set 's' of type Î±, a function 'f' from Î± to M, and elements 'hf' and 'a', applying the function 'onFinset' to 's', 'f', 'hf', and 'a' is equal to applying the function 'f' to 'a'.",
    "output": "theorem onFinset_apply {s : Finset Î±} {f : Î± â†’ M} {hf a} : (onFinset s f hf : Î± â†’â‚€ M) a = f a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a polynomial 'p' with coefficients in a ring 'R', a polynomial 'q' in the PolynomialModule with coefficients in 'R' and values in a module 'M', and an element 'r' of 'R', the evaluation of the composition of 'p' and 'q' at 'r' is equal to the evaluation of 'q' at the evaluation of 'p' at 'r'.",
    "output": "theorem comp_eval (p : R[X]) (q : PolynomialModule R M) (r : R) :\n    eval r (comp p q) = eval (p.eval r) q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type S, which is a semiring and nontrivial, and a given ring homomorphism f from R to S, if a polynomial p is monic and the map of p under f equals 1, then the polynomial p must be equal to 1.",
    "output": "theorem eq_one_of_map_eq_one {S : Type _} [Semiring S] [Nontrivial S] (f : R â†’+* S) (hp : p.Monic)\n    (map_eq : p.map f = 1) : p = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of the difference of two morphisms (f and f') and another morphism g is equal to the difference of the compositions of f and g and f' and g.",
    "output": "theorem sub_comp : (f - f') â‰« g = f â‰« g - f' â‰« g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse of the right multiplication E-transform of 'e' and 'x' is equal to the swap of the swap of the left multiplication E-transform of 'e' and 'x'.",
    "output": "theorem mulEtransformRight_inv : mulEtransformRight eâ»Â¹ x = (mulEtransformLeft e x.swap).swap :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' and any stream 's', taking the first 'n+1' elements from the stream that starts with 'a' and is followed by 's', is equivalent to having 'a' followed by the first 'n' elements of 's'.",
    "output": "theorem take_succ_cons (n : Nat) (s : Stream' Î±) : take (n+1) (a::s) = a :: take n s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The division of set 's' by the singleton set containing element 'a' is equal to the image of set 's' under the operation of division by 'a'.",
    "output": "theorem div_singleton (a : Î±) : s / {a} = s.image (Â· / a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The Lie span (in the context of Lie algebras) of the union of a set of subsets (indexed by Î¹) is equal to the supremum of the Lie spans of the individual subsets.",
    "output": "theorem span_iUnion {Î¹} (s : Î¹ â†’ Set L) : lieSpan R L (â‹ƒ i, s i) = â¨† i, lieSpan R L (s i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a complete space E, for a function v mapping real numbers to E, given real numbers tMin, tâ‚€, tMax, an element xâ‚€ of E, and real numbers C, R, and a non-negative real number L, if the function v satisfies the Picard-Lindelof condition with these parameters, then there exists a function f mapping real numbers to E such that f at tâ‚€ equals xâ‚€ and for all t in the closed interval from tMin to tMax, the derivative of f at t within this interval equals v of t applied to f of t.",
    "output": "theorem IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq [CompleteSpace E] {v : â„ â†’ E â†’ E}\n    {tMin tâ‚€ tMax : â„} (xâ‚€ : E) {C R : â„} {L : â„â‰¥0}\n    (hpl : IsPicardLindelof v tMin tâ‚€ tMax xâ‚€ L R C) :\n    âˆƒ f : â„ â†’ E, f tâ‚€ = xâ‚€ âˆ§\n      âˆ€ t âˆˆ Icc tMin tMax, HasDerivWithinAt f (v t (f t)) (Icc tMin tMax) t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given condition 'h' which is either 'b' or 'for all x, p x', for any 'x', the condition 'b or p x' holds true.",
    "output": "theorem forall_or_of_or_forall (h : b âˆ¨ âˆ€ x, p x) (x) : b âˆ¨ p x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of an ordered ring, if b is less than or equal to c and a is non-negative (greater than or equal to 0), then the product of b and a is less than or equal to the product of c and a.",
    "output": "theorem mul_le_mul_of_nonneg_right [MulPosMono Î±] (h : b â‰¤ c) (a0 : 0 â‰¤ a) : b * a â‰¤ c * a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of the function \"ZMod.lift n f\" and the function that coverts integers to another type is equal to the function \"f\".",
    "output": "theorem lift_comp_coe : ZMod.lift n f âˆ˜ ((â†‘) : â„¤ â†’ _) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' is a monoid homomorphism from a multiplicative monoid 'Î±' to another multiplicative monoid 'Î²', then 'f' is also an additive monoid homomorphism from the additive monoid corresponding to 'Î±' to the additive monoid corresponding to 'Î²'.",
    "output": "theorem Additive.isAddMonoidHom [MulOneClass Î±] [MulOneClass Î²] {f : Î± â†’ Î²}\n    (hf : IsMonoidHom f) : @IsAddMonoidHom (Additive Î±) (Additive Î²) _ _ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An element 'x' is in the span of a set containing 'y' multiplied by a set 'P' if and only if there exists an element 'z' in 'P' such that 'y' multiplied by 'z' equals 'x'.",
    "output": "theorem mem_span_singleton_mul {x y : A} : x âˆˆ span R {y} * P â†” âˆƒ z âˆˆ P, y * z = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function f has a Taylor series up to order n on the entire domain if and only if the function f has a Taylor series up to order n.",
    "output": "theorem hasFTaylorSeriesUpToOn_univ_iff :\n    HasFTaylorSeriesUpToOn n f p univ â†” HasFTaylorSeriesUpTo n f p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The vector from any point 'p' to the midpoint of points 'pâ‚' and 'pâ‚‚' is equal to the sum of half the vector from 'p' to 'pâ‚' and half the vector from 'p' to 'pâ‚‚'.",
    "output": "theorem midpoint_vsub (pâ‚ pâ‚‚ p : P) :\n    midpoint R pâ‚ pâ‚‚ -áµ¥ p = (â…Ÿ 2 : R) â€¢ (pâ‚ -áµ¥ p) + (â…Ÿ 2 : R) â€¢ (pâ‚‚ -áµ¥ p) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The division of p by q is equal to p minus 1.",
    "output": "theorem div_conj_eq_sub_one : p / q = p - 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The space P, under the structure of an Additive Torsor, is a connected space.",
    "output": "theorem AddTorsor.connectedSpace : ConnectedSpace P :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î± and Î², and any two sets f (which is a set of functions from Î± to Î²) and s (which is a set of Î±), if both f and s are finite, then the set resulting from applying each function in f to each element in s (denoted as f <*> s) is also finite.",
    "output": "theorem Finite.seq' {Î± Î² : Type u} {f : Set (Î± â†’ Î²)} {s : Set Î±} (hf : f.Finite) (hs : s.Finite) :\n    (f <*> s).Finite :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse of the dual of the identity function under the infimum-top homomorphism is equal to the identity function under the infimum-top homomorphism in the context of a given type Î±.",
    "output": "theorem symm_dual_id : InfTopHom.dual.symm (SupBotHom.id _) = InfTopHom.id Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set T of elements in a field extension E, the field obtained by first adjoining a set S to a field F and then adjoining T to the result, when restricted to scalars from F, is equal to the field obtained by first adjoining T to F and then adjoining S to the result, when also restricted to scalars from F.",
    "output": "theorem adjoin_adjoin_comm (T : Set E) :\n    (adjoin (adjoin F S) T).restrictScalars F = (adjoin (adjoin F T) S).restrictScalars F :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' that maps any ordinal number 'a' less than zero to another ordinal number, the result of the function 'blsub' with zero and 'f' as arguments is zero.",
    "output": "theorem blsub_zero (f : âˆ€ a < (0 : Ordinal), Ordinal) : blsub 0 f = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'E', if 'f' belongs to the space of 'p'-integrable functions with respect to measure 'Î¼', then the 'p'-seminorm of 'f' with respect to measure 'Î¼' is less than infinity.",
    "output": "theorem Memâ„’p.snorm_lt_top {f : Î± â†’ E} (hfp : Memâ„’p f p Î¼) : snorm f p Î¼ < âˆ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a cocompact map 'f' from 'Î±' to 'Î²', and another function 'f'' from 'Î±' to 'Î²' that is equal to 'f', then copying 'f' to 'f'' results in 'f'.",
    "output": "theorem copy_eq (f : CocompactMap Î± Î²) (f' : Î± â†’ Î²) (h : f' = f) : f.copy f' h = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two sets T and T' of type Î± mapped to E and then linearly mapped to F, with real numbers C and C' such that T is dominated and finitely additive with respect to measure Î¼ and C, and T' is dominated and finitely additive with respect to measure Î¼ and C'. If for all subsets s, s is a measurable set and the measure of s is less than infinity implies that T of s equals T' of s, then for any function f from Î± to E with respect to measure Î¼, the setToL1 of T and f equals the setToL1 of T' and f.",
    "output": "theorem setToL1_congr_left' (T T' : Set Î± â†’ E â†’L[â„] F) {C C' : â„}\n    (hT : DominatedFinMeasAdditive Î¼ T C) (hT' : DominatedFinMeasAdditive Î¼ T' C')\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ T s = T' s) (f : Î± â†’â‚[Î¼] E) :\n    setToL1 hT f = setToL1 hT' f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²' that is uniformly continuous, and another function 'g' from the separation quotient of 'Î±' to the separation quotient of 'Î²' such that the composition of the quotient map and 'f' equals the composition of 'g' and the quotient map, then the map of 'f' equals 'g'.",
    "output": "theorem map_unique {f : Î± â†’ Î²} (hf : UniformContinuous f)\n    {g : SeparationQuotient Î± â†’ SeparationQuotient Î²}\n    (comm : Quotient.mk _ âˆ˜ f = g âˆ˜ Quotient.mk _) : map f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero scalar 'a', the scalar multiplication of the difference of two sets 's' and 't' is equal to the difference of the scalar multiplication of set 's' and the scalar multiplication of set 't'.",
    "output": "theorem smul_set_sdiffâ‚€ (ha : a â‰  0) : a â€¢ (s \\ t) = a â€¢ s \\ a â€¢ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'b' that is less than or equal to 1 and any real number 'r', the common logarithm of 'r' with base 'b' is equal to 0.",
    "output": "theorem clog_of_left_le_one {b : â„•} (hb : b â‰¤ 1) (r : R) : clog b r = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any additive monoid 'A', and any endomorphism 'f' of 'A', and any natural number 'n', the nth power of 'f' under function composition is equal to the nth iterate of 'f'.",
    "output": "theorem AddMonoid.End.coe_pow {A} [AddMonoid A] (f : AddMonoid.End A) (n : â„•) : â‡‘(f ^ n) = f^[n] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "There exists a linear equivalence between two vector spaces V and Vâ‚ if and only if the rank of vector space V over field K is equal to the rank of vector space Vâ‚ over field K.",
    "output": "theorem LinearEquiv.nonempty_equiv_iff_rank_eq :\n    Nonempty (V â‰ƒâ‚—[K] Vâ‚) â†” Module.rank K V = Module.rank K Vâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If I and J are fractional ideals in a field K over a ring Râ‚â°, and the product of I and J equals 1, then I cannot be zero.",
    "output": "theorem ne_zero_of_mul_eq_one (I J : FractionalIdeal Râ‚â° K) (h : I * J = 1) : I â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'E' and a filter 'l' on 'Î±', 'f' is Big O of itself with a constant factor of 1.",
    "output": "theorem isBigOWith_refl (f : Î± â†’ E) (l : Filter Î±) : IsBigOWith 1 l f f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a left inverse function 'fâ‚' for function 'f' on set 's', then function 'f' is injective on set 's'.",
    "output": "theorem LeftInvOn.injOn (h : LeftInvOn fâ‚' f s) : InjOn f s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cardinality of the set of all propositions is 2.",
    "output": "theorem mk_Prop : (#Prop) = 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The range of a function 'f' from 'Î±' to 'Î²' is equal to a set 's' if and only if for every element 'a', 'f(a)' is an element of 's' and for every element 'b' in 's', there exists an element 'a' such that 'f(a)' is equal to 'b'.",
    "output": "theorem range_eq_iff (f : Î± â†’ Î²) (s : Set Î²) :\n    range f = s â†” (âˆ€ a, f a âˆˆ s) âˆ§ âˆ€ b âˆˆ s, âˆƒ a, f a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given square matrix A, if all elements in a row i are zero (for any i), then the determinant of matrix A is zero.",
    "output": "theorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : âˆ€ j, A i j = 0) : det A = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-zero elements 'a', 'b', and 'c' of a ring 'R', if no prime factor 'd' divides both 'a' and 'b', then if 'a' divides the product of 'b' and 'c', 'a' must also divide 'c'.",
    "output": "theorem dvd_of_dvd_mul_right_of_no_prime_factors {a b c : R} (ha : a â‰  0)\n    (no_factors : âˆ€ {d}, d âˆ£ a â†’ d âˆ£ b â†’ Â¬Prime d) : a âˆ£ b * c â†’ a âˆ£ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is an embedding function 'f' from a simple graph 'G' to another simple graph 'G'', and if 'G'' is 'n'-colorable, then 'G' is also 'n'-colorable.",
    "output": "theorem Colorable.of_embedding {V' : Type _} {G' : SimpleGraph V'} (f : G â†ªg G') {n : â„•}\n    (h : G'.Colorable n) : G.Colorable n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sign of the angle Ï€ (pi) is equal to 0.",
    "output": "theorem sign_coe_pi : (Ï€ : Angle).sign = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given Young Diagram 'Î¼' and a semistandard Young tableau 'T' of 'Î¼', if we have two natural numbers 'i1' and 'i2' such that 'i1' is less than 'i2', and a pair '(i2, j)' that belongs to 'Î¼', then the value of 'T' at 'i1, j' is less than the value of 'T' at 'i2, j'.",
    "output": "theorem col_strict {Î¼ : YoungDiagram} (T : Ssyt Î¼) {i1 i2 j : â„•} (hi : i1 < i2)\n    (hcell : (i2, j) âˆˆ Î¼) : T i1 j < T i2 j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any set S of real numbers, if every element x in S is less than or equal to zero, then the greatest lower bound (infimum) of S is also less than or equal to zero.",
    "output": "theorem sInf_nonpos (S : Set â„) (hS : âˆ€ x âˆˆ S, x â‰¤ (0 : â„)) : sInf S â‰¤ 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'f' and a set 's' of type 'Î±', the infimum (greatest lower bound) of 'f' and the principal filter generated by 's' is the bottom element if and only if the complement of 's' is in 'f'.",
    "output": "theorem inf_principal_eq_bot {f : Filter Î±} {s : Set Î±} : f âŠ“ ğ“Ÿ s = âŠ¥ â†” sá¶œ âˆˆ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given vertex 'v' in a graph 'G', the degree of 'v' (i.e., the number of edges connected to 'v') is less than the total number of vertices in the graph 'G'. This is assuming that whether two vertices in 'G' are adjacent is decidable.",
    "output": "theorem degree_lt_card_verts [DecidableRel G.Adj] (v : V) : G.degree v < Fintype.card V :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'b' is not the minimum, then the interval of all numbers greater than 'a' and less than or equal to the predecessor of 'b' is equal to the interval of all numbers strictly between 'a' and 'b'.",
    "output": "theorem Ioc_pred_right_of_not_isMin (ha : Â¬IsMin b) : Ioc a (pred b) = Ioo a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is not equal to y, then the natural degree of the basis divisor of x and y is equal to 1.",
    "output": "theorem natDegree_basisDivisor_of_ne (hxy : x â‰  y) : (basisDivisor x y).natDegree = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' from set M and a pair 'x' from the Cartesian product of sets Î± and Î², the scalar multiplication of 'a' and 'x' is equal to the pair formed by the scalar multiplication of 'a' and each element of 'x'.",
    "output": "theorem smul_def (a : M) (x : Î± Ã— Î²) : a â€¢ x = (a â€¢ x.1, a â€¢ x.2) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any elements x, y, and z of a ring R, if x and y are coprime, then the sum of x and the product of y and z is also coprime with y.",
    "output": "theorem add_mul_left_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (x + y * z) y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The identity matrix (denoted by 1) is a diagonal matrix. This is true for any size of the matrix (n by n) and any type of elements (Î±) in the matrix, given that zero and one are defined for the type of elements, and equality can be decided for the size of the matrix.",
    "output": "theorem isDiag_one [DecidableEq n] [Zero Î±] [One Î±] : (1 : Matrix n n Î±).IsDiag :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f is integrable at a filter l with respect to a measure Î¼, then for all eventually occurring small sets s in l, the function f is integrable on s with respect to the measure Î¼.",
    "output": "theorem IntegrableAtFilter.eventually (h : IntegrableAtFilter f l Î¼) :\n    âˆ€á¶  s in l.smallSets, IntegrableOn f s Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î¹' to the filter of 'Î±', given that 'Î¹' is nonempty and 'f' is directed by the greater than or equal to relation, the greatest lower bound of 'f' is not the bottom element if and only if for all 'i', 'f(i)' is not the bottom element.",
    "output": "theorem iInf_neBot_iff_of_directed' {f : Î¹ â†’ Filter Î±} [Nonempty Î¹] (hd : Directed (Â· â‰¥ Â·) f) :\n    NeBot (iInf f) â†” âˆ€ i, NeBot (f i) :="
  },
  {
    "instruction": "",
    "input": "For a type G that is a group and a topological space, if the following conditions are met:",
    "output": "theorem TopologicalGroup.of_nhds_one' {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ğ“ 1 Ã—Ë¢ ğ“ 1) (ğ“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ğ“ 1) (ğ“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ğ“ xâ‚€ = map (fun x => xâ‚€ * x) (ğ“ 1))\n    (hright : âˆ€ xâ‚€ : G, ğ“ xâ‚€ = map (fun x => x * xâ‚€) (ğ“ 1)) : TopologicalGroup G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' is a bounded linear map over a field 'ğ•œ', then the scalar multiplication of 'f' by a scalar 'c' from the same field 'ğ•œ' is also a bounded linear map over 'ğ•œ'.",
    "output": "theorem smul (c : ğ•œ) (hf : IsBoundedLinearMap ğ•œ f) : IsBoundedLinearMap ğ•œ (c â€¢ f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function of casting from rational numbers to a type K is monotone.",
    "output": "theorem cast_mono : Monotone ((â†‘) : â„š â†’ K) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any projective resolution P of an object Z in a category C and any natural number n, the composition of the differential maps d from (n + 2) to (n + 1) and from (n + 1) to n in the complex of P is equal to zero.",
    "output": "theorem complex_d_succ_comp {Z : C} (P : ProjectiveResolution Z) (n : â„•) :\n    P.complex.d (n + 2) (n + 1) â‰« P.complex.d (n + 1) n = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the total variation of a signed measure 's' over a set 'i' is zero, then the value of the signed measure 's' over the set 'i' is also zero.",
    "output": "theorem null_of_totalVariation_zero (s : SignedMeasure Î±) {i : Set Î±}\n    (hs : s.totalVariation i = 0) : s i = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function Ï† from Î± to a sort v, given two elements a and a' of Î±, and two proofs pâ‚ of Ï† a and pâ‚‚ of Ï† a', if a equals a' (denoted by e) and the equality is recursively defined (denoted by hâ‚‚) such that pâ‚ equals pâ‚‚ when a equals a', then pâ‚ is definitionally equal to pâ‚‚.",
    "output": "theorem heq_of_eq_rec_left {Ï† : Î± â†’ Sort v} {a a' : Î±} {pâ‚ : Ï† a} {pâ‚‚ : Ï† a'} :\n    (e : a = a') â†’ (hâ‚‚ : Eq.rec (motive := fun a _ â†¦ Ï† a) pâ‚ e = pâ‚‚) â†’ HEq pâ‚ pâ‚‚"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object 'W' in category 'C', and any two morphisms 'i' and 'j' from the multicoequalizer of 'I' to 'W', if for all objects 'b', the composition of the projection from the multicoequalizer of 'I' to 'b' and 'i' is equal to the composition of the projection from the multicoequalizer of 'I' to 'b' and 'j', then 'i' is equal to 'j'.",
    "output": "theorem hom_ext {W : C} (i j : multicoequalizer I âŸ¶ W)\n    (h : âˆ€ b, Multicoequalizer.Ï€ I b â‰« i = Multicoequalizer.Ï€ I b â‰« j) : i = j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given commutative monoid N, a function f from Î± to Î², a function s from Î± to M where M is a finite subset of Î±, and a function h from Î² to M to N, if the function f is injective, then the product of the mapDomain of s and f, and h is equal to the product of s and the function that takes a and b and returns h of f of a and b.",
    "output": "theorem prod_mapDomain_index_inj [CommMonoid N] {f : Î± â†’ Î²} {s : Î± â†’â‚€ M} {h : Î² â†’ M â†’ N}\n    (hf : Function.Injective f) : (s.mapDomain f).prod h = s.prod fun a b => h (f a) b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type 'Î±' and a property 'p' that applies to 'Î±', the cardinality of the subtype for which 'p' holds is less than or equal to the cardinality of 'Î±'.",
    "output": "theorem mk_subtype_le {Î± : Type u} (p : Î± â†’ Prop) : (#Subtype p) â‰¤ (#Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object X in category C, the morphism component of the isomorphism 'zeroProdIso X' is equal to the second projection of the product.",
    "output": "theorem zeroProdIso_hom (X : C) : (zeroProdIso X).hom = prod.snd :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for all eventually occurring elements 'x' in a filter 'l', the function 'f' applied to 'x' is less than or equal to zero, and if the function 'g' tends to negative infinity as 'x' tends to 'l', then the function that adds the results of 'f' and 'g' also tends to negative infinity as 'x' tends to 'l'.",
    "output": "theorem tendsto_atBot_add_nonpos_left' (hf : âˆ€á¶  x in l, f x â‰¤ 0) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given CU structure 'c' on a topological space 'X', a natural number 'n', and a point 'x' in 'X' that does not belong to the set 'U' of 'c', the 'n'-th approximation of 'x' in 'c' equals 1.",
    "output": "theorem approx_of_nmem_U (c : CU X) (n : â„•) {x : X} (hx : x âˆ‰ c.U) : c.approx n x = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'f' that takes two inputs of types 'Î±' and 'Î²' and returns an output of type 'Ïƒ' is primitive recursive if and only if the function that takes the same inputs and returns the output of 'f' wrapped in 'some' is also primitive recursive.",
    "output": "theorem option_some_iff {f : Î± â†’ Î² â†’ Ïƒ} : (Primrecâ‚‚ fun a b => some (f a b)) â†” Primrecâ‚‚ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an equivalence 'e' between two types 'Î±' and 'Î²', 'Î±' is infinite if and only if 'Î²' is infinite.",
    "output": "theorem Equiv.infinite_iff (e : Î± â‰ƒ Î²) : Infinite Î± â†” Infinite Î² :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is greater than or equal to 0, y is greater than 0, and the natural logarithm of x is less than z times the natural logarithm of y, then x is less than y raised to the power of z.",
    "output": "theorem lt_rpow_of_log_lt (hx : 0 â‰¤ x) (hy : 0 < y) (h : Real.log x < z * Real.log y) :\n    x < y ^ z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The infimum (greatest lower bound) of 'a' and the infimum of 'a' and 'b' is equal to the infimum of 'a' and 'b'.",
    "output": "theorem inf_left_idem : a âŠ“ (a âŠ“ b) = a âŠ“ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "There exists a subset 'b' of 't', such that the span of 'b' over the field 'K' is equal to the span of 't' over 'K', and 'b' is linearly independent over 'K'.",
    "output": "theorem exists_linearIndependent :\n    âˆƒ (b : _)(_ : b âŠ† t), span K b = span K t âˆ§ LinearIndependent K ((â†‘) : b â†’ V) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given a set 's' of elements of type 'E' and a function 'v' that is continuously differentiable on 's', and given that 's' is in the neighborhood of 'xâ‚€', there exists a real number 'Îµ' greater than zero, and a function 'f' from real numbers to 'E' such that 'f' at 'tâ‚€' equals 'xâ‚€' and for all 't' in the open interval from 'tâ‚€ - Îµ' to 'tâ‚€ + Îµ', 'f' at 't' is in 's' and 'f' has a derivative at 't' equal to 'v' at 'f' at 't'.",
    "output": "theorem exists_forall_deriv_at_Ioo_eq_of_contDiffOn_nhds {s : Set E} (hv : ContDiffOn â„ 1 v s)\n    (hs : s âˆˆ ğ“ xâ‚€) :\n    âˆƒ Îµ > (0 : â„),\n      âˆƒ f : â„ â†’ E, f tâ‚€ = xâ‚€ âˆ§ âˆ€ t âˆˆ Ioo (tâ‚€ - Îµ) (tâ‚€ + Îµ), f t âˆˆ s âˆ§ HasDerivAt f (v (f t)) t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'J' to 'C' that has a biproduct, and for any object 'Z' in 'C', if two morphisms 'g' and 'h' from 'Z' to the biproduct of 'f' satisfy the condition that for all 'j', the composition of 'g' and the projection of the biproduct of 'f' at 'j' is equal to the composition of 'h' and the same projection, then 'g' is equal to 'h'.",
    "output": "theorem biproduct.hom_ext {f : J â†’ C} [HasBiproduct f] {Z : C} (g h : Z âŸ¶ â¨ f)\n    (w : âˆ€ j, g â‰« biproduct.Ï€ f j = h â‰« biproduct.Ï€ f j) : g = h :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' with elements of type 'Î±' is countable if and only if the set resulting from inserting an element 'a' of type 'Î±' into 's' is also countable.",
    "output": "theorem countable_insert {s : Set Î±} {a : Î±} : (insert a s).Countable â†” s.Countable :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any vertex 'v' in a graph 'G', if there is a path 'p' from 'v' to itself, then this path 'p' is equivalent to a path with no edges (Path.nil).",
    "output": "theorem loop_eq {v : V} (p : G.Path v v) : p = Path.nil :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two objects A and B in category T, and any two morphisms f and g from A to B, the arrow constructed from f is equal to the arrow constructed from g if and only if f is equal to g.",
    "output": "theorem mk_inj (A B : T) {f g : A âŸ¶ B} : Arrow.mk f = Arrow.mk g â†” f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of a Boolean algebra with elements of type Î±, for any element 't' and any set 'S' of type Î±, 't' is in the complement image of 'S' if and only if the complement of 't' is in 'S'.",
    "output": "theorem mem_compl_image [BooleanAlgebra Î±] (t : Î±) (S : Set Î±) :\n  t âˆˆ HasCompl.compl '' S â†” tá¶œ âˆˆ S :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two sets s and t of elements of type Î±, if s is a subset of t, then the image of s under function f is a subset of the image of t under function f.",
    "output": "theorem image_mono {s t : Set Î±} (h : s âŠ† t) : f.image s âŠ† f.image t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The division of 'a' by the product of 'b' and 'c' is equal to the division of 'a' by 'c' and then dividing the result by 'b'.",
    "output": "theorem div_mul_eq_div_div_swap : a / (b * c) = a / c / b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list 'l' and any composition 'ns', the length of the list obtained by splitting 'l' with respect to the composition 'ns' is equal to the length of 'ns'.",
    "output": "theorem length_splitWrtCompositionAux (l : List Î±) (ns) :\n    length (l.splitWrtCompositionAux ns) = ns.length :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function f has a dense range if and only if the closure of the range of f equals the universe.",
    "output": "theorem denseRange_iff_closure_range : DenseRange f â†” closure (range f) = univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'b' of type Î², if 'b' is an element of set 's' and 'f' of 'b' is less than or equal to 'a', then the infimum (greatest lower bound) of the set 's' under the function 'f' is less than or equal to 'a'.",
    "output": "theorem inf_le_of_le {b : Î²} (hb : b âˆˆ s) (h : f b â‰¤ a) : s.inf f â‰¤ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' of type 'X' and a type 'I' in a topological space, if 'f' evenly covers 'x' in 'I', then 'f' also evenly covers 'x' in the preimage of 'x' under 'f'.",
    "output": "theorem to_isEvenlyCovered_preimage {x : X} {I : Type _} [TopologicalSpace I]\n    (h : IsEvenlyCovered f x I) : IsEvenlyCovered f x (f â»Â¹' {x}) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two additive valuations vâ‚ and vâ‚‚ on a ring R with values in an ordered abelian group Î“â‚€, if for every element r in R, the valuation of r under vâ‚ is equal to the valuation of r under vâ‚‚, then vâ‚ is equal to vâ‚‚.",
    "output": "theorem ext {vâ‚ vâ‚‚ : AddValuation R Î“â‚€} (h : âˆ€ r, vâ‚ r = vâ‚‚ r) : vâ‚ = vâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from an optional Î² to Î±, the supremum (or least upper bound) over all options 'o' of 'f' is equal to the supremum of 'f' applied to 'none' and the supremum over all 'b' of 'f' applied to 'some b'.",
    "output": "theorem iSup_option (f : Option Î² â†’ Î±) : (â¨† o, f o) = f none âŠ” â¨† b, f (Option.some b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any semiring R and natural numbers n and k, the coefficient of the k-th term in the polynomial (X + 1) raised to the power of n is equal to the binomial coefficient \"n choose k\" in the semiring R.",
    "output": "theorem coeff_X_add_one_pow (R : Type _) [Semiring R] (n k : â„•) :\n    ((X + 1) ^ n).coeff k = (n.choose k : R) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a natural number 'n' for which property 'P' holds, the smallest natural number satisfying property 'P' is less than or equal to 'n'.",
    "output": "theorem find_le (n : â„•) (h : P n) : find P â‰¤ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two subalgebras S and T of an algebra A over a ring R, the submodule corresponding to the intersection of S and T is equal to the intersection of the submodules corresponding to S and T.",
    "output": "theorem inf_toSubmodule (S T : Subalgebra R A) :\n    toSubmodule (S âŠ“ T) = toSubmodule S âŠ“ toSubmodule T :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A constant function with value 'a' is less than or equal to a constant function with value 'b' if and only if 'a' is less than or equal to 'b'.",
    "output": "theorem const_le_const : const Î² a â‰¤ const Î² b â†” a â‰¤ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function f mapping from any index to a type Î±, the preimage of the product of sets s and t under this function is equal to the set of all functions from the universal set to the function that constructs a finite list with s and t as its elements, where the function finZeroElim is used to handle the case when the list is empty.",
    "output": "theorem Fin.preimage_apply_01_prod {Î± : Fin 2 â†’ Type u} (s : Set (Î± 0)) (t : Set (Î± 1)) :\n    (fun f : âˆ€ i, Î± i => (f 0, f 1)) â»Â¹' s Ã—Ë¢ t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types 'Î±' and 'Î²' where 'Î±' is finite, and any two sets 's' of type 'Î±' and 't' of type 'Î²', if the cardinality of 'Î±' lifted to the maximum of 'v' and 'w' is equal to the cardinality of 'Î²' lifted to the maximum of 'u' and 'w', and the cardinality of 's' lifted to the maximum of 'v' and 'w' is equal to the cardinality of 't' lifted to the maximum of 'u' and 'w', then the cardinality of the complement of 's' lifted to the maximum of 'v' and 'w' is equal to the cardinality of the complement of 't' lifted to the maximum of 'u' and 'w'.",
    "output": "theorem mk_compl_eq_mk_compl_finite_lift {Î± : Type u} {Î² : Type v} [Finite Î±] {s : Set Î±}\n    {t : Set Î²} (h1 : (lift.{max v w, u} (#Î±)) = (lift.{max u w, v} (#Î²)))\n    (h2 : lift.{max v w, u} (#s) = lift.{max u w, v} (#t)) :\n    lift.{max v w} (#(sá¶œ : Set Î±)) = lift.{max u w} (#(tá¶œ : Set Î²)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The square of the norm of the sum of two vectors x and y is equal to the sum of the squares of the norms of x and y if and only if the angle between x and y is Ï€/2 (or 90 degrees).",
    "output": "theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n    â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” angle x y = Ï€ / 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given multiset 's' and any two elements 'a' and 'b', erasing 'a' from 's' and then erasing 'b' from the result is the same as erasing 'b' from 's' and then erasing 'a' from the result. In other words, the order of erasing elements does not affect the final result.",
    "output": "theorem erase_comm (s : Multiset Î±) (a b : Î±) : (s.erase a).erase b = (s.erase b).erase a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An integer m raised to the power of a natural number n is odd if and only if m is odd or n equals zero.",
    "output": "theorem odd_pow {n : â„•} : Odd (m ^ n) â†” Odd m âˆ¨ n = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The intersection of sets s and t is nonempty if and only if there exists an element x in set t that is also in set s.",
    "output": "theorem inter_nonempty_iff_exists_right : (s âˆ© t).Nonempty â†” âˆƒ x âˆˆ t, x âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î² with a topological space structure, any set s of type Î± that is an analytic set, and any function f from Î± to Î² that is continuous, the image of the set s under the function f is also an analytic set.",
    "output": "theorem AnalyticSet.image_of_continuous {Î² : Type _} [TopologicalSpace Î²] {s : Set Î±}\n    (hs : AnalyticSet s) {f : Î± â†’ Î²} (hf : Continuous f) : AnalyticSet (f '' s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-negative extended real number 'x' and any natural number 'n', the nth power of 'x' when converted to an extended real number is equal to the nth power of 'x' as an extended real number.",
    "output": "theorem coe_ennreal_pow (x : â„â‰¥0âˆ) (n : â„•) : (â†‘(x ^ n) : EReal) = (x : EReal) ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' in the field 'K', the algebraic mapping of the numerator of 'x' in ring 'A' divided by the algebraic mapping of the denominator of 'x' in ring 'A' is equal to 'x'.",
    "output": "theorem mk'_num_den' (x : K) : algebraMap A K (num A x) / algebraMap A K (den A x) = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there exists a unique element 'a' in list 'l' that satisfies property 'p', then the chosen element that satisfies property 'p' in list 'l' is indeed in list 'l' and satisfies property 'p'.",
    "output": "theorem choose_spec (hp : âˆƒ! a, a âˆˆ l âˆ§ p a) : choose p l hp âˆˆ l âˆ§ p (choose p l hp) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ordered node 'l' and any element 'x', the left rotation of 'l' and 'x' with an empty node results in a new node with 'l' and 'x' and an empty node.",
    "output": "theorem rotateL_nil (l : Ordnode Î±) (x : Î±) : rotateL l x nil = node' l x nil :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index 'i' and any two functions 'fâ‚' and 'fâ‚‚', erasing the element at index 'i' from the sum of 'fâ‚' and 'fâ‚‚' is equal to the sum of the result of erasing the element at index 'i' from 'fâ‚' and 'fâ‚‚' respectively.",
    "output": "theorem erase_add (i : Î¹) (fâ‚ fâ‚‚ : Î â‚€ i, Î² i) : erase i (fâ‚ + fâ‚‚) = erase i fâ‚ + erase i fâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any additive commutative monoid G, and any elements r of type k and x of type G, the operation of applying the ring equivalence to the opposite of the single element x with coefficient r in the monoid algebra is equal to the single element x with the opposite of the coefficient r.",
    "output": "theorem opRingEquiv_single [AddCommMonoid G] (r : k) (x : G) :\n    AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The Lp space representation of the zero function in the simple function space is equal to the zero element in the Lp space of simple functions.",
    "output": "theorem toLp_zero : toLp (0 : Î± â†’â‚› E) zero_memâ„’p = (0 : Lp.simpleFunc E p Î¼) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a T2 topological space B and a star subalgebra S of R and A, if we have two star algebra homomorphisms Ï† and Ïˆ from the topological closure of S to B, and both Ï† and Ïˆ are continuous, then if the composition of Ï† and the inclusion of the topological closure of S is equal to the composition of Ïˆ and the inclusion of the topological closure of S, then Ï† is equal to Ïˆ.",
    "output": "theorem _root_.StarAlgHom.ext_topologicalClosure [T2Space B] {S : StarSubalgebra R A}\n    {Ï† Ïˆ : S.topologicalClosure â†’â‹†â‚[R] B} (hÏ† : Continuous Ï†) (hÏˆ : Continuous Ïˆ)\n    (h :\n      Ï†.comp (inclusion (le_topologicalClosure S)) = Ïˆ.comp (inclusion (le_topologicalClosure S))) :\n    Ï† = Ïˆ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type 'Î±', applying the function 'ofDual' to the result of 'toDual' applied to 'a' gives back 'a'.",
    "output": "theorem ofDual_toDual (a : Î±) : ofDual (toDual a) = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements x and y in the subsemigroup S', the product of the elements x and y (denoted as âŸ¨x, hxâŸ© * âŸ¨y, hyâŸ©) is equal to the element that is the product of x and y in S' (denoted as âŸ¨x * y, mul_mem hx hyâŸ©).",
    "output": "theorem mk_mul_mk (x y : M) (hx : x âˆˆ S') (hy : y âˆˆ S') :\n    (âŸ¨x, hxâŸ© : S') * âŸ¨y, hyâŸ© = âŸ¨x * y, mul_mem hx hyâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' reaches its maximum at 'a' in the set 's' and 'g' also reaches its maximum at 'a' in the set 's', then the function that is the sum of 'f' and 'g' also reaches its maximum at 'a' in the set 's'.",
    "output": "theorem IsMaxOn.add (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x + g x) s a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers 'n' and 'x', if 'x' is in the range of 'n', then 'x' is less than or equal to 'n'.",
    "output": "theorem mem_range_le {n x : â„•} (hx : x âˆˆ range n) : x â‰¤ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given relation 'r' and an element 'a' such that 'a' is accessible by 'r', the rank of 'a' is equal to the supremum of the successor of the rank of 'b' for all 'b' such that 'b' is related to 'a' by 'r'.",
    "output": "theorem rank_eq (h : Acc r a) :\n    h.rank = Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ (h.inv b.2).rank :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'p', if the Lucas-Lehmer residue of 'p + 2' is zero, then the 'Ï‰' (a certain element in the field X of the polynomial ring over the finite field with 'q(p' + 2)' elements) raised to the power of '2' to the power of 'p + 2' equals one.",
    "output": "theorem Ï‰_pow_eq_one (p' : â„•) (h : lucasLehmerResidue (p' + 2) = 0) :\n    (Ï‰ : X (q (p' + 2))) ^ 2 ^ (p' + 2) = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If measure Î¼ is less than or equal to measure Î½, then almost everywhere (ae) with respect to measure Î¼ is less than or equal to almost everywhere (ae) with respect to measure Î½.",
    "output": "theorem ae_mono (h : Î¼ â‰¤ Î½) : Î¼.ae â‰¤ Î½.ae :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a continuous affine map 'f' from 'P' to 'Q', the continuous linear part of 'f' is equal to the linear part of 'f' when 'f' is considered as an affine map from 'P' to 'Q'.",
    "output": "theorem coe_contLinear_eq_linear (f : P â†’A[R] Q) :\n    (f.contLinear : V â†’â‚—[R] W) = (f : P â†’áµƒ[R] Q).linear :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two natural numbers 'a' and 'b', if you pair them and then unpair them, you will get back the original pair '(a, b)'.",
    "output": "theorem unpair_pair (a b : â„•) : unpair (pair a b) = (a, b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In group theory, for any group G and any element x of G, the order of x divides the cardinality of the group G.",
    "output": "theorem orderOf_dvd_nat_card {G : Type _} [Group G] {x : G} : orderOf x âˆ£ Nat.card G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a ring homomorphism 'f' from a ring 'R' to itself, a natural number 'p' that is a prime number, and a characteristic 'p' of the ring 'R', for any natural number 'n', the 'n'-th iteration of 'f' applied to the Frobenius endomorphism of 'R' at 'p' applied to 'x' is equal to the Frobenius endomorphism of 'R' at 'p' applied to the 'n'-th iteration of 'f' applied to 'x'.",
    "output": "theorem RingHom.iterate_map_frobenius (f : R â†’+* R) (p : â„•) [Fact p.Prime] [CharP R p] (n : â„•) :\n    (f^[n]) (frobenius R p x) = frobenius R p ((f^[n]) x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of integers greater than 'a' is a subset of the union of the set of integers greater than or equal to 'a' and less than or equal to 'b', and the set of integers greater than or equal to 'b'.",
    "output": "theorem Ioi_subset_Ioc_union_Ici : Ioi a âŠ† Ioc a b âˆª Ici b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'not (a implies b)' is equivalent to 'a and not b'.",
    "output": "theorem not_imp : Â¬(a â†’ b) â†” a âˆ§ Â¬b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The order of the rotation by one unit in the Dihedral Group of order n is n.",
    "output": "theorem orderOf_r_one : orderOf (r 1 : DihedralGroup n) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the intersection of two sets, tâ‚ and tâ‚‚, under a function s is a subset of the intersection of the images of the two sets under the same function.",
    "output": "theorem disjSups_inter_subset_right : s â—‹ (tâ‚ âˆ© tâ‚‚) âŠ† s â—‹ tâ‚ âˆ© s â—‹ tâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the antidiagonal of 'n + 2' is equal to the list that starts with the pair (0, n + 2), followed by the antidiagonal of 'n' where both elements of each pair are incremented by one, and ends with the pair (n + 2, 0).",
    "output": "theorem antidiagonal_succ_succ' {n : â„•} :\n    antidiagonal (n + 2) =\n      (0, n + 2) :: (antidiagonal n).map (Prod.map Nat.succ Nat.succ) ++ [(n + 2, 0)] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number r, the ball centered at zero with radius r in the seminorm space p is balanced over the field ğ•œ.",
    "output": "theorem balanced_ball_zero (r : â„) : Balanced ğ•œ (ball p 0 r) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'c' is a unit, then the function that multiplies 'c' with the output of function 'f' is continuous within a set 's' at a point 'b' if and only if the function 'f' itself is continuous within the set 's' at the point 'b'.",
    "output": "theorem continuousWithinAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousWithinAt (fun x => c â€¢ f x) s b â†” ContinuousWithinAt f s b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'l' on a set 'Î²' and a function 'f' from a set 'Î±' to the set of subsets of 'Î²', the comap (the inverse image function) of 'f' and the small sets of 'l' is equal to the lift' (a function that lifts a function to a filter) of 'l' and the composition of the preimage function of 'f' and the powerset function.",
    "output": "theorem comap_smallSets (l : Filter Î²) (f : Î± â†’ Set Î²) :\n    comap f l.smallSets = l.lift' (preimage f âˆ˜ powerset) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set Î± is not finite if and only if it is infinite.",
    "output": "theorem not_finite_iff_infinite : Â¬Finite Î± â†” Infinite Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The preimage of the closed ball in real numbers with center x and radius r under the function that maps integers to real numbers, is equal to the closed ball in integers with center x and radius r.",
    "output": "theorem preimage_closedBall (x : â„¤) (r : â„) : (â†‘) â»Â¹' closedBall (x : â„) r = closedBall x r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The polynomial constant function C applied to a equals the polynomial constant function C applied to b if and only if a equals b.",
    "output": "theorem C_inj : C a = C b â†” a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The equality locus of a ring homomorphism function 'f' from ring 'R' to ring 'S' is equal to the top element, or the whole set.",
    "output": "theorem eqLocus_same (f : R â†’+* S) : f.eqLocus f = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of a GCD Monoid structure on a set Î±, for any three elements a, b, and c in Î±, the greatest common divisor of the product of a and b and the product of a and c is associated with the product of a and the greatest common divisor of b and c.",
    "output": "theorem gcd_mul_left' [GCDMonoid Î±] (a b c : Î±) :\n    Associated (gcd (a * b) (a * c)) (a * gcd b c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two linear maps 'f' from M to Mâ‚‚ and 'g' from Mâ‚‚ to Mâ‚ƒ, the kernel of 'g' is less than or equal to the range of 'f' if and only if the composition of the quotient by the range of 'f' and the subtype of the kernel of 'g' equals zero.",
    "output": "theorem ker_le_range_iff {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {g : Mâ‚‚ â†’â‚›â‚—[Ï„â‚‚â‚ƒ] Mâ‚ƒ} :\n    ker g â‰¤ range f â†” f.range.mkQ.comp g.ker.subtype = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two linear maps 'f' from Mâ‚‚ to Mâ‚ƒ and 'g' from Mâ‚ to Mâ‚‚, the matrix representation of the composition of 'f' and 'g' is equal to the product of the matrix representation of 'f' and the matrix representation of 'g'. This is under the conditions that 'l' is a finite type and 'm' is decidable.",
    "output": "theorem LinearMap.toMatrix_comp [Fintype l] [DecidableEq m] (f : Mâ‚‚ â†’â‚—[R] Mâ‚ƒ) (g : Mâ‚ â†’â‚—[R] Mâ‚‚) :\n    LinearMap.toMatrix vâ‚ vâ‚ƒ (f.comp g) =\n    LinearMap.toMatrix vâ‚‚ vâ‚ƒ f â¬ LinearMap.toMatrix vâ‚ vâ‚‚ g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is antitone on a set 's' and the image of 's' under 'f' is both bounded below and above, then there exists a function 'g' that is antitone and equals 'f' on 's'.",
    "output": "theorem AntitoneOn.exists_antitone_extension (h : AntitoneOn f s) (hl : BddBelow (f '' s))\n    (hu : BddAbove (f '' s)) : âˆƒ g : Î± â†’ Î², Antitone g âˆ§ EqOn f g s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Ïƒ' to 'Ï„', a function 'd' from 'Ïƒ' to non-negative integers 'â„•', and a real number 'r', renaming 'f' in the monomial 'd' and 'r' is equal to the monomial of 'd' mapped to the domain 'f' and 'r'.",
    "output": "theorem rename_monomial (f : Ïƒ â†’ Ï„) (d : Ïƒ â†’â‚€ â„•) (r : R) :\n    rename f (monomial d r) = monomial (d.mapDomain f) r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'b' is a unit, then 'a' divided by 'b' equals one if and only if 'a' equals 'b'.",
    "output": "theorem div_eq_one_iff_eq (h : IsUnit b) : a / b = 1 â†” a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite group G and a subgroup s of G, the cardinality (or size) of the preimage of a set t under the quotient group mapping is equal to the product of the cardinality of the subgroup s and the cardinality of the set t.",
    "output": "theorem QuotientGroup.card_preimage_mk [Fintype G] (s : Subgroup G) (t : Set (G â§¸ s)) :\n    Fintype.card (QuotientGroup.mk â»Â¹' t) = Fintype.card s * Fintype.card t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two vertices 'v' and 'w' in a graph 'G', if 'w' is a neighbor of 'v', then the other vertex of any edge incident to 'v' (that is, connected to 'v') is 'w'. This is proven by applying the property that a vertex is a neighbor of another if and only if there is an edge between them.",
    "output": "theorem incidence_other_neighbor_edge {v w : V} (h : w âˆˆ G.neighborSet v) :\n    G.otherVertexOfIncident (G.mem_incidence_iff_neighbor.mpr h) = w :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The closed ball in a metric space, centered at a point 'x' with radius 'Îµ', is a measurable set.",
    "output": "theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x Îµ) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 's.piecewise f f'' is equal to a function 'g' on a set 't' if and only if the function 'f' is equal to 'g' on the intersection of 't' and 's', and the function 'f'' is equal to 'g' on the intersection of 't' and the complement of 's'.",
    "output": "theorem eqOn_piecewise {f f' g : Î± â†’ Î²} {t} :\n    EqOn (s.piecewise f f') g t â†” EqOn f g (t âˆ© s) âˆ§ EqOn f' g (t âˆ© sá¶œ) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a seminormed add commutative group Î², where p is not equal to infinity and Î² has an element 1, the nonnegative norm of the inverse of the equivalence of p and the function from Î¹ to Î² applied to 1 is equal to the nonnegative real number obtained by raising the cardinality of the finite type Î¹ to the power of the reciprocal of p, multiplied by the nonnegative norm of 1 in Î².",
    "output": "theorem nnnorm_equiv_symm_one {Î²} [SeminormedAddCommGroup Î²] (hp : p â‰  âˆ) [One Î²] :\n    â€–(PiLp.equiv p fun _ : Î¹ => Î²).symm 1â€–â‚Š =\n      (Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal * â€–(1 : Î²)â€–â‚Š :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The successor of a natural number 'n' when cast as an ordinal is equal to the successor of 'n' as an ordinal.",
    "output": "theorem nat_cast_succ (n : â„•) : â†‘n.succ = succ (n : Ordinal) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The conjugate of a complex number 'z' is equal to 'z' if and only if there exists a real number 'r' such that 'z' is equal to the complex number representation of 'r'.",
    "output": "theorem conj_eq_iff_real {z : K} : conj z = z â†” âˆƒ r : â„, z = (r : K) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'm' of set 'X', the quotient of 'm' by the relation 'FreeAlgebra.Rel R X' is equal to the application of the function 'Î¹ R' to 'm'.",
    "output": "theorem quot_mk_eq_Î¹ (m : X) : Quot.mk (FreeAlgebra.Rel R X) m = Î¹ R m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The operation mâ‚‚ is commutative.",
    "output": "theorem mul_comm : IsCommutative _ mâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of all elements 'x' such that 'x' is greater than or equal to 'a' and less than or equal to 'b' is equal to the closed interval between 'a' and 'b'.",
    "output": "theorem Icc_def (a b : Î±) : { x | a â‰¤ x âˆ§ x â‰¤ b } = Icc a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'f' from 'Nâ‚—' to 'Pâ‚—', another linear map 'g' from 'M' to 'Nâ‚—', and an element 'x' from 'M', the left-left composition of 'f' and 'g' at 'x' is equal to 'f' applied to 'g' at 'x'.",
    "output": "theorem llcomp_apply (f : Nâ‚— â†’â‚—[R] Pâ‚—) (g : M â†’â‚—[R] Nâ‚—) (x : M) :\n    llcomp R M Nâ‚— Pâ‚— f g x = f (g x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"a is congruent to b modulo 0 if and only if a is equal to b.\"",
    "output": "theorem modEq_zero : a â‰¡ b [PMOD 0] â†” a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any sort 'P' and any polynomials 'p' and 'q' in the field of rational functions 'K[X]', given a function 'f' that maps any two polynomials to 'P' and a condition 'f0' that 'f' of any polynomial and 0 equals 'f' of 0 and 1, if for any polynomials 'p', 'q', and 'a' such that 'q' and 'a' are not zero, 'f' of 'a' times 'p' and 'a' times 'q' equals 'f' of 'p' and 'q', then the liftOn' of the rational function made by 'p' and 'q' on 'f' with respect to 'H' equals 'f' of 'p' and 'q'.",
    "output": "theorem liftOn'_mk {P : Sort v} (p q : K[X]) (f : âˆ€ _p _q : K[X], P) (f0 : âˆ€ p, f p 0 = f 0 1)\n    (H : âˆ€ {p q a} (_hq : q â‰  0) (_ha : a â‰  0), f (a * p) (a * q) = f p q) :\n    (RatFunc.mk p q).liftOn' f @H = f p q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'x' belongs to a singleton set that only contains 'y' in a finite set of elements of type 'Î±', then 'x' is equal to 'y'.",
    "output": "theorem eq_of_mem_singleton {x y : Î±} (h : x âˆˆ ({y} : Finset Î±)) : x = y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two preordered sets Î± and Î², and an order isomorphism 'e' between them, and a filter 'l' on a set Î³, and a function 'u' from Î³ to Î±, the function 'u' is bounded under the filter 'l' if and only if the composition of 'e' and 'u' is also bounded under the filter 'l'.",
    "output": "theorem _root_.OrderIso.isBoundedUnder_le_comp [Preorder Î±] [Preorder Î²] (e : Î± â‰ƒo Î²) {l : Filter Î³}\n    {u : Î³ â†’ Î±} : (IsBoundedUnder (Â· â‰¤ Â·) l fun x => e (u x)) â†” IsBoundedUnder (Â· â‰¤ Â·) l u :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A multiset 's' has no duplicate elements in its powerset if and only if the multiset 's' itself has no duplicate elements.",
    "output": "theorem nodup_powerset {s : Multiset Î±} : Nodup (powerset s) â†” Nodup s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The empty set is convex in the field ğ•œ for any set E.",
    "output": "theorem convex_empty : Convex ğ•œ (âˆ… : Set E) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero element 'c' in a group with zero, the inverse of the right multiplication by 'c' homeomorphism is the same as right multiplication by the inverse of 'c'.",
    "output": "theorem mulRightâ‚€_symm_apply (c : Î±) (hc : c â‰  0) :\n    ((Homeomorph.mulRightâ‚€ c hc).symm : Î± â†’ Î±) = (Â· * câ»Â¹) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' is infinite, then it is not bounded above.",
    "output": "theorem _root_.Set.Infinite.not_bddAbove {s : Set Î±} : s.Infinite â†’ Â¬BddAbove s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'l' on a normed space 'E', the function 'f' is Big O of the identity function (i.e., the function that maps each element to itself) with respect to the filter 'l' and the norm of 'f'.",
    "output": "theorem isBigOWith_id (l : Filter E) : IsBigOWith â€–fâ€– l f fun x => x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a trivialization 'e' of a vector bundle with fiber 'F' and projection 'Ï€ E', given that 'e' is linear over a ring 'R', for any element 'b' in the base set of 'e' and any element 'y' in 'F', the linear map at 'b' applied to the inverse linear map at 'b' applied to 'y' equals 'y'.",
    "output": "theorem linearMapAt_symmâ‚— (e : Trivialization F (Ï€ E)) [e.IsLinear R] {b : B} (hb : b âˆˆ e.baseSet)\n    (y : F) : e.linearMapAt R b (e.symmâ‚— R b y) = y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' of elements of type Î“â‚€ is open if and only if either the element '0' of type Î“â‚€ is not in 's', or there exists an element 'Î³' such that 'Î³' is not equal to '0' and the set of all elements less than 'Î³' is a subset of 's'.",
    "output": "theorem isOpen_iff {s : Set Î“â‚€} : IsOpen s â†” (0 : Î“â‚€) âˆ‰ s âˆ¨ âˆƒ Î³, Î³ â‰  0 âˆ§ Iio Î³ âŠ† s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear recurrence E of a certain order, and for any initial condition 'init' of that order, the solution generated by 'init' at any point 'n' within that order is equal to the initial condition at 'n'.",
    "output": "theorem mkSol_eq_init (init : Fin E.order â†’ Î±) : âˆ€ n : Fin E.order, E.mkSol init n = init n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'm' mapping from Î³ to Î² to Î´ and a function 'n' mapping from Î± to Î³, mapping 'm' over the result of mapping 'n' over 'f' and then applying 'g' is equivalent to mapping a function that applies 'm' to the result of applying 'n' to 'a' and 'b' over 'f' and 'g'.",
    "output": "theorem mapâ‚‚_map_left (m : Î³ â†’ Î² â†’ Î´) (n : Î± â†’ Î³) :\n    mapâ‚‚ m (f.map n) g = mapâ‚‚ (fun a b => m (n a) b) f g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' maps from a module 'M' to another module 'Mâ‚‚' in a surjective ring homomorphism 'Ïƒâ‚â‚‚', and if 'f' applied to an element 'x' of 'M' does not belong to the span of the image of a set 's' under 'f' in the ring 'Râ‚‚', then 'x' does not belong to the span of 's' in the ring 'R'.",
    "output": "theorem not_mem_span_of_apply_not_mem_span_image [RingHomSurjective Ïƒâ‚â‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) {x : M}\n    {s : Set M} (h : f x âˆ‰ Submodule.span Râ‚‚ (f '' s)) : x âˆ‰ Submodule.span R s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given substructure 'T' of 'N' and a function 'f' from 'M' to 'N', if 'S' is less than or equal to the preimage of 'T' under 'f', then the image of 'S' under 'f' is less than or equal to 'T'.",
    "output": "theorem map_le_of_le_comap {T : L.Substructure N} {f : M â†’[L] N} : S â‰¤ T.comap f â†’ S.map f â‰¤ T :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Submonoid S is equal to the top element if and only if for every element x in monoid M, x is an element of S.",
    "output": "theorem eq_top_iff' : S = âŠ¤ â†” âˆ€ x : M, x âˆˆ S :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any additive commutative group M, M is a torsion additive monoid if and only if M is a torsion module over the integers.",
    "output": "theorem isTorsion_iff_isTorsion_int [AddCommGroup M] :\n    AddMonoid.IsTorsion M â†” Module.IsTorsion â„¤ M :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index 'i', any element 'a' of a group 'G' at index 'i', and any function 'f' from the lp space 'G' with p=2, the inner product of 'f' and the single element at index 'i' with value 'a' in the lp space is equal to the inner product of the value of 'f' at index 'i' and 'a'.",
    "output": "theorem inner_single_right (i : Î¹) (a : G i) (f : lp G 2) : âŸªf, lp.single 2 i aâŸ« = âŸªf i, aâŸ« :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f has a derivative f' at point x with respect to a filter L, and function g has a derivative g' at the same point x with respect to the same filter L, then the function that is the sum of f and g has a derivative that is the sum of f' and g' at point x with respect to filter L.",
    "output": "theorem HasDerivAtFilter.add (hf : HasDerivAtFilter f f' x L)\n    (hg : HasDerivAtFilter g g' x L) : HasDerivAtFilter (fun y => f y + g y) (f' + g') x L :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the set Î± is empty, then the cardinality (or the number of elements) of Î± is equal to zero.",
    "output": "theorem card_eq_zero [IsEmpty Î±] : card Î± = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given natural number 'n' and any two bit vectors 'vâ‚€' and 'vâ‚' of length 'n', if 'vâ‚€' is less than or equal to 'vâ‚', then the conversion of 'vâ‚€' to a finite number is also less than or equal to the conversion of 'vâ‚' to a finite number.",
    "output": "theorem toFin_le_toFin_of_le {n} {vâ‚€ vâ‚ : Bitvec n} (h : vâ‚€ â‰¤ vâ‚) : vâ‚€.toFin â‰¤ vâ‚.toFin :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a relation R between Î± and Î², swapping the order of the LiftRel function and the relation R is equivalent to applying the LiftRel function to the swapped relation R.",
    "output": "theorem LiftRel.swap (R : Î± â†’ Î² â†’ Prop) : swap (LiftRel R) = LiftRel (swap R) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'x' and 'y' of a set 'Î±', the list obtained by applying the function 'toList' to the permutation formed by the singleton list containing 'x', when evaluated at 'y', is an empty list.",
    "output": "theorem toList_formPerm_singleton (x y : Î±) : toList (formPerm [x]) y = [] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Under the conditions of a second countable topology on either Î± or E, a fact that p is greater than or equal to 1, p is not equal to infinity, and Î¼ is weakly regular, the topological closure of the set of bounded continuous functions from E to p with respect to measure Î¼ is equal to the entire space.",
    "output": "theorem boundedContinuousFunction_dense [SecondCountableTopologyEither Î± E] [_i : Fact (1 â‰¤ p)]\n    (hp : p â‰  âˆ) [Î¼.WeaklyRegular] : (boundedContinuousFunction E p Î¼).topologicalClosure = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A is a Noetherian ring.",
    "output": "theorem isNoetherianRing : IsNoetherianRing A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given three conditions: the first power of 'a' raised to 'bâ‚' equals 'câ‚', the second power of 'a' raised to 'bâ‚‚' equals 'câ‚‚', and the product of 'câ‚' and 'câ‚‚' equals 'd', then for any real number 'a', 'a' raised to the power of the sum of 'bâ‚' and 'bâ‚‚' equals 'd'.",
    "output": "theorem pow_add (_ : a ^ bâ‚ = câ‚) (_ : a ^ bâ‚‚ = câ‚‚) (_ : câ‚ * câ‚‚ = d) :\n  (a : R) ^ (bâ‚ + bâ‚‚) = d :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have three preordered sets Î±, Î², and Î³, and two functions g : Î² â†’ Î³ and f : Î± â†’ Î², along with two sets s and t, such that g is strictly decreasing on t, f is strictly decreasing on s, and f maps s to t, then the composition of g and f is strictly increasing on s.",
    "output": "theorem StrictAntiOn.comp [Preorder Î±] [Preorder Î²] [Preorder Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} {s : Set Î±}\n    {t : Set Î²} (hg : StrictAntiOn g t) (hf : StrictAntiOn f s) (hs : Set.MapsTo f s t) :\n    StrictMonoOn (g âˆ˜ f) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given field 'k' and a ring homomorphism 'f' from 'R' to 'k', a polynomial 'p' is a unit under the map 'f' if and only if 'p' is a unit itself.",
    "output": "theorem isUnit_map [Field k] (f : R â†’+* k) : IsUnit (p.map f) â†” IsUnit p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The non-negative distance between the point obtained by applying the line map to points pâ‚ and pâ‚‚ with a coefficient c, and point pâ‚‚, is equal to the product of the non-negative norm of 1 minus c and the non-negative distance between pâ‚ and pâ‚‚.",
    "output": "theorem nndist_lineMap_right (pâ‚ pâ‚‚ : P) (c : ğ•œ) :\n    nndist (lineMap pâ‚ pâ‚‚ c) pâ‚‚ = â€–1 - câ€–â‚Š * nndist pâ‚ pâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any nonempty interval 's' of type Î±, applying the function 'toDualProd' to 's' results in a pair consisting of the dual of the first element of 's' and the second element of 's'.",
    "output": "theorem toDualProd_apply (s : NonemptyInterval Î±) : s.toDualProd = (toDual s.fst, s.snd) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given equivalence 'e' between two types 'Î¹' and 'Î¹'', and given two functions 'f' and 'g' from 'Î¹'' and 'Î¹' to 'M' respectively, if 'f' composed with 'e' equals 'g', then 'g' is linearly independent if and only if 'f' is linearly independent.",
    "output": "theorem linearIndependent_equiv' (e : Î¹ â‰ƒ Î¹') {f : Î¹' â†’ M} {g : Î¹ â†’ M} (h : f âˆ˜ e = g) :\n    LinearIndependent R g â†” LinearIndependent R f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element x from a set R, the least common multiple of x and 0 is 0.",
    "output": "theorem lcm_zero_right (x : R) : lcm x 0 = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If set s is a subset of set t, then the tangent cone at point x of set s is also a subset of the tangent cone at point x of set t.",
    "output": "theorem tangentCone_mono (h : s âŠ† t) : tangentConeAt ğ•œ s x âŠ† tangentConeAt ğ•œ t x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two structured arrows X and Y in the categories S and T respectively, if there is a morphism f from X to Y, then the left component of f is equal to the identity morphism.",
    "output": "theorem left_eq_id {X Y : StructuredArrow S T} (f : X âŸ¶ Y) :\n  f.left = ğŸ™ _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two trivializations 'e' and 'e'' of a fiber bundle with projection 'proj', the target of the transformation from the inverse of 'e' to 'e'' is equal to the intersection of the base sets of 'e' and 'e'' cross the universal set.",
    "output": "theorem symm_trans_target_eq (e e' : Trivialization F proj) :\n    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).target = (e.baseSet âˆ© e'.baseSet) Ã—Ë¢ univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a lattice Î± is atomic, complemented, and modular, then it is also coatomic.",
    "output": "theorem isCoatomic_of_isAtomic_of_complementedLattice_of_isModular [IsAtomic Î±] :\n    IsCoatomic Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two star subalgebras S and T of a ring R over an algebra A, and for any element x in A, x is in the intersection of S and T if and only if x is in S and x is in T.",
    "output": "theorem mem_inf {S T : StarSubalgebra R A} {x : A} : x âˆˆ S âŠ“ T â†” x âˆˆ S âˆ§ x âˆˆ T :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given order with a bottom element, the bottom element is the least element of a set if and only if the bottom element is in the set.",
    "output": "theorem isLeast_bot_iff [OrderBot Î±] : IsLeast s âŠ¥ â†” âŠ¥ âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the cast of the negative successor of 'n' to a real number 'R' is equal to the negative of the cast of 'n + 1' to a real number.",
    "output": "theorem cast_negSucc (n : â„•) : (-[n+1] : R) = -(n + 1 : â„•) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The primitive part of a polynomial p is not equal to zero.",
    "output": "theorem primPart_ne_zero (p : R[X]) : p.primPart â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sine of the difference between pi and any complex number x is equal to the sine of x.",
    "output": "theorem sin_pi_sub (x : â„‚) : sin (Ï€ - x) = sin x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two affine transformations, one from Pâ‚ to Pâ‚‚ (denoted as e) and another from Pâ‚‚ to Pâ‚ƒ (denoted as e'), the composition of these transformations (e followed by e') is the same as applying the transformation e' after e.",
    "output": "theorem coe_trans (e : Pâ‚ â‰ƒáµƒ[k] Pâ‚‚) (e' : Pâ‚‚ â‰ƒáµƒ[k] Pâ‚ƒ) : â‡‘(e.trans e') = e' âˆ˜ e :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The non-empty locus of the difference between two functions 'f' and 'g' subtracted from 'f' is equal to the support of 'g'.",
    "output": "theorem neLocus_self_sub_left : neLocus (f - g) f = g.support :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any property 'p' pertaining to an element 'Î±', if 'x' is an element of an empty set of 'Î±', then 'p' is true. This is logically equivalent to 'True', because there are no elements in an empty set, so any statement about elements of an empty set is vacuously true.",
    "output": "theorem forall_mem_empty_iff (p : Î± â†’ Prop) : (âˆ€ x, x âˆˆ (âˆ… : Finset Î±) â†’ p x) â†” True :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of type 'Î²', swapping the right injection of 'x' into the sum of 'Î±' and 'Î²' results in the left injection of 'x'.",
    "output": "theorem swap_inr (x : Î²) : swap (inr x : Sum Î± Î²) = inl x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of the type 'WithBot Î±', 'âŠ¥' is less than 'x' if and only if 'x' is not equal to 'âŠ¥'.",
    "output": "theorem bot_lt_iff_ne_bot : âˆ€ {x : WithBot Î±}, âŠ¥ < x â†” x â‰  âŠ¥"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any objects X and Y in category C, if for any object Z in C and any morphism g from Z to X, the composition of g and f equals zero implies that g equals zero, then f is a monomorphism.",
    "output": "theorem mono_of_cancel_zero {X Y : C} (f : X âŸ¶ Y)\n    (hf : âˆ€ (Z : C) (g : Z âŸ¶ X) (_ : g â‰« f = 0), g = 0) : Mono f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is continuous from a topological space 't' to another topological space 't'', then the coinduced topology on 't' by 'f' is less than or equal to the topology 't''.",
    "output": "theorem Continuous.coinduced_le (h : Continuous[t, t'] f) : t.coinduced f â‰¤ t' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given symbol 's' of type 'Sym Î± n' and an element 'x' that belongs to 's', 'x' is also an element of 's.attach'.",
    "output": "theorem mem_attach (s : Sym Î± n) (x : { x // x âˆˆ s }) : x âˆˆ s.attach :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The absolute value of the distance between two points a and b is equal to the distance between a and b.",
    "output": "theorem abs_dist {a b : Î±} : |dist a b| = dist a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The polynomial constant of the sum of two numbers (a and b) is equal to the sum of the polynomial constants of each number separately.",
    "output": "theorem C_add : C (a + b) = C a + C b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"A Lie Submodule is a singleton if and only if the module M is a singleton.\"",
    "output": "theorem subsingleton_iff : Subsingleton (LieSubmodule R L M) â†” Subsingleton M :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function 'f' attains its maximum at 'a' over the set 's', and if function 'g' is monotone, then the composition of 'g' and 'f' (g âˆ˜ f) also attains its maximum at 'a' over the set 's'.",
    "output": "theorem IsMaxOn.comp_mono (hf : IsMaxOn f s a) {g : Î² â†’ Î³} (hg : Monotone g) :\n    IsMaxOn (g âˆ˜ f) s a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an invertible matrix A, the inverse of the inverse of A is equal to A itself.",
    "output": "theorem inv_inv_of_invertible [Invertible A] : Aâ»Â¹â»Â¹ = A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a multiplicative equivalence 'f' between two structures 'M' and 'N', the inverse of 'f' when considered as a plain equivalence (not necessarily multiplicative) between 'M' and 'N' is the same as the multiplicative inverse of 'f'.",
    "output": "theorem coe_toEquiv_symm (f : M â‰ƒ* N) : ((f : M â‰ƒ N).symm : N â†’ M) = f.symm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bilinear map B from E to F to G, and two functions f from D to E and g from D to F, if both f and g are continuously differentiable up to order N, then the norm of the n-th derivative of the function that maps y to B applied to f of y and g of y at a point x, is less than or equal to the norm of B times the sum over i from 0 to n of the binomial coefficient \"n choose i\" times the norm of the i-th derivative of f at x times the norm of the (n-i)-th derivative of g at x, where n is a natural number less than or equal to N.",
    "output": "theorem ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear (B : E â†’L[ğ•œ] F â†’L[ğ•œ] G) {f : D â†’ E}\n    {g : D â†’ F} {N : â„•âˆ} (hf : ContDiff ğ•œ N f) (hg : ContDiff ğ•œ N g) (x : D) {n : â„•}\n    (hn : (n : â„•âˆ) â‰¤ N) :\n    â€–iteratedFDeriv ğ•œ n (fun y => B (f y) (g y)) xâ€– â‰¤ â€–Bâ€– * âˆ‘ i in Finset.range (n + 1),\n      (n.choose i : â„) * â€–iteratedFDeriv ğ•œ i f xâ€– * â€–iteratedFDeriv ğ•œ (n - i) g xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An integer 'x' is a unit if and only if the absolute value of 'x' is equal to 1.",
    "output": "theorem isUnit_iff_abs_eq {x : â„¤} : IsUnit x â†” abs x = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' that maps from type 'Î±' to type 'Î²', and for any sequence 'S', mapping 'f' over the joined sequence 'S' is equivalent to joining the sequence obtained by mapping 'f' over each element of 'S'.",
    "output": "theorem map_join (f : Î± â†’ Î²) : âˆ€ S, map f (join S) = join (map (map f) S)"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given an affine subspace 's' of real numbers in a point set 'P' with a finite dimensional direction and a finrank of 2, and given two spheres 'sâ‚' and 'sâ‚‚' in 'P', and three points 'pâ‚', 'pâ‚‚', and 'p' in 'P', if the center of 'sâ‚' and 'sâ‚‚' are in 's', and 'pâ‚', 'pâ‚‚', and 'p' are in 's', and 'sâ‚' is not equal to 'sâ‚‚', and 'pâ‚' is not equal to 'pâ‚‚', and 'pâ‚', 'pâ‚‚', and 'p' are in 'sâ‚', and 'pâ‚', 'pâ‚‚', and 'p' are in 'sâ‚‚', then 'p' is either equal to 'pâ‚' or 'pâ‚‚'.",
    "output": "theorem eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two {s : AffineSubspace â„ P}\n    [FiniteDimensional â„ s.direction] (hd : finrank â„ s.direction = 2) {sâ‚ sâ‚‚ : Sphere P}\n    {pâ‚ pâ‚‚ p : P} (hsâ‚ : sâ‚.center âˆˆ s) (hsâ‚‚ : sâ‚‚.center âˆˆ s) (hpâ‚s : pâ‚ âˆˆ s) (hpâ‚‚s : pâ‚‚ âˆˆ s)\n    (hps : p âˆˆ s) (hs : sâ‚ â‰  sâ‚‚) (hp : pâ‚ â‰  pâ‚‚) (hpâ‚sâ‚ : pâ‚ âˆˆ sâ‚) (hpâ‚‚sâ‚ : pâ‚‚ âˆˆ sâ‚) (hpsâ‚ : p âˆˆ sâ‚)\n    (hpâ‚sâ‚‚ : pâ‚ âˆˆ sâ‚‚) (hpâ‚‚sâ‚‚ : pâ‚‚ âˆˆ sâ‚‚) (hpsâ‚‚ : p âˆˆ sâ‚‚) : p = pâ‚ âˆ¨ p = pâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The square root of a natural number 'n' is greater than 0 if and only if 'n' is greater than 0.",
    "output": "theorem sqrt_pos {n : â„•} : 0 < sqrt n â†” 0 < n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function T is dominated and finitely additive with respect to a measure Î¼ and a constant C, and if two functions f and g are almost everywhere equal with respect to the measure Î¼, then the setToFun of f and g with respect to Î¼, T, and hT are equal.",
    "output": "theorem setToFun_congr_ae (hT : DominatedFinMeasAdditive Î¼ T C) (h : f =áµ[Î¼] g) :\n    setToFun Î¼ T hT f = setToFun Î¼ T hT g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set S of a certain type Î±, under the conditions that Î± is a conditionally complete linear order, Î± has a topological space, Î± has an order topology, Î± has a first countable topology, S is nonempty, and S is bounded above, there exists a sequence u (a function from natural numbers to Î±) such that u is monotone, u tends to the supremum of S, and every element of the sequence u is in S.",
    "output": "theorem exists_seq_tendsto_sSup {Î± : Type _} [ConditionallyCompleteLinearOrder Î±]\n    [TopologicalSpace Î±] [OrderTopology Î±] [FirstCountableTopology Î±] {S : Set Î±} (hS : S.Nonempty)\n    (hS' : BddAbove S) : âˆƒ u : â„• â†’ Î±, Monotone u âˆ§ Tendsto u atTop (ğ“ (sSup S)) âˆ§ âˆ€ n, u n âˆˆ S :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The range of the inclusion of N is equal to N itself.",
    "output": "theorem range_incl : N.incl.range = N :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given matrix A and two matrices Bâ‚ and Bâ‚‚, the Kronecker product of A with the sum of Bâ‚ and Bâ‚‚ is equal to the sum of the Kronecker product of A with Bâ‚ and the Kronecker product of A with Bâ‚‚.",
    "output": "theorem kroneckerTMul_add (A : Matrix l m Î±) (Bâ‚ Bâ‚‚ : Matrix n p Î±) :\n    A âŠ—â‚–â‚œ[R] (Bâ‚ + Bâ‚‚) = A âŠ—â‚–â‚œ Bâ‚ + A âŠ—â‚–â‚œ Bâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Subtracting one from p does not result in zero.",
    "output": "theorem sub_one_ne_zero : p - 1 â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any objects Y and Z in category C, and any morphism f from Y to Z, given projective resolutions P of Y and Q of Z, the composition of the lift of f with respect to P and Q at index 1 and the differential of Q at indices 1 and 0 is equal to the composition of the differential of P at indices 1 and 0 and the lift of f with respect to P and Q at index 0.",
    "output": "theorem liftOne_zero_comm {Y Z : C} (f : Y âŸ¶ Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) :\n    liftOne f P Q â‰« Q.complex.d 1 0 = P.complex.d 1 0 â‰« liftZero f P Q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A space is locally connected if and only if for every point in the space, for every neighborhood of that point, there exists a preconnected subset within the neighborhood of that point which is also a subset of the original neighborhood.",
    "output": "theorem locallyConnectedSpace_iff_connected_subsets :\n    LocallyConnectedSpace Î± â†” âˆ€ (x : Î±), âˆ€ U âˆˆ ğ“ x, âˆƒ V âˆˆ ğ“ x, IsPreconnected V âˆ§ V âŠ† U :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any types m, n, and k, and for any properties p, q, and r defined on m, n, and k respectively, and for any matrices A and B with elements from a ring R, the block transformation of the product of A and B is equal to the sum of the products of the block transformations of A and B, where the blocks are defined by the properties p, q, and r, and their negations.",
    "output": "theorem toBlock_mul_eq_add {m n k : Type _} [Fintype n] (p : m â†’ Prop) (q : n â†’ Prop)\n    [DecidablePred q] (r : k â†’ Prop) (A : Matrix m n R) (B : Matrix n k R) : (A â¬ B).toBlock p r =\n    A.toBlock p q â¬ B.toBlock q r + (A.toBlock p fun i => Â¬q i) â¬ B.toBlock (fun i => Â¬q i) r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The extension of function 'f' with respect to 'I' is equal to the composition of 'I' and 'f'.",
    "output": "theorem extend_coe : â‡‘(f.extend I) = I âˆ˜ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bounded linear map Ï† from a normed vector space E to another normed vector space F, and a non-negative real number M, if for all vectors x in E, the norm of Ï†x is less than or equal to M times the norm of x, and for all non-negative real numbers N, if the norm of Ï†x is less than or equal to N times the norm of x then M is less than or equal to N, then the operator norm of Ï† is equal to M.",
    "output": "theorem op_norm_eq_of_bounds {Ï† : E â†’SL[Ïƒâ‚â‚‚] F} {M : â„} (M_nonneg : 0 â‰¤ M)\n    (h_above : âˆ€ x, â€–Ï† xâ€– â‰¤ M * â€–xâ€–) (h_below : âˆ€ N â‰¥ 0, (âˆ€ x, â€–Ï† xâ€– â‰¤ N * â€–xâ€–) â†’ M â‰¤ N) :\n    â€–Ï†â€– = M :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Applying the inverse of the function 'zpowersMulHom' from group G to a function 'f' is equal to applying function 'f' to the multiplicative of the additive identity (1).",
    "output": "theorem zpowersMulHom_symm_apply [CommGroup G] (f : Multiplicative â„¤ â†’* G) :\n    (zpowersMulHom G).symm f = f (Multiplicative.ofAdd 1) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î³ and any property P that relates an element of Î³ to a set of Î³, if for every finite set t of Î³ there exists an element c of Î³ such that P holds for c and t, then there exists a sequence u of elements of Î³ (indexed by natural numbers) such that for every natural number n, P holds for the nth element of u and the set of all elements of u less than n.",
    "output": "theorem seq_of_forall_finite_exists {Î³ : Type _} {P : Î³ â†’ Set Î³ â†’ Prop}\n    (h : âˆ€ t : Set Î³, t.Finite â†’ âˆƒ c, P c t) : âˆƒ u : â„• â†’ Î³, âˆ€ n, P (u n) (u '' Iio n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two locally constant functions 'f' and 'g' from 'X' to 'Y', 'f' is equal to 'g' if and only if 'f' is equal to 'g'. This means that the function mapping is injective, i.e., distinct inputs produce distinct outputs.",
    "output": "theorem coe_inj {f g : LocallyConstant X Y} : (f : X â†’ Y) = g â†” f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function that converts extended non-negative real numbers to non-negative real numbers is measurable.",
    "output": "theorem measurable_toNNReal : Measurable ENNReal.toNNReal :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Filtering an empty multiset with any predicate results in an empty multiset.",
    "output": "theorem filter_zero : filter p 0 = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three finite sets sâ‚, sâ‚‚, and sâ‚ƒ, the intersection of sâ‚ with the intersection of sâ‚‚ and sâ‚ƒ is equal to the intersection of sâ‚‚ with the intersection of sâ‚ and sâ‚ƒ. This is a statement of the commutative property of intersection for finite sets.",
    "output": "theorem inter_left_comm (sâ‚ sâ‚‚ sâ‚ƒ : Finset Î±) : sâ‚ âˆ© (sâ‚‚ âˆ© sâ‚ƒ) = sâ‚‚ âˆ© (sâ‚ âˆ© sâ‚ƒ) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The composition of function 'f' and the homomorphism of 'i' is exactly the inverse of the composition of 'i' and function 'g' if and only if 'f' and 'g' are exact.",
    "output": "theorem exact_comp_hom_inv_comp_iff (i : B â‰… D) : Exact (f â‰« i.hom) (i.inv â‰« g) â†” Exact f g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two lists, lâ‚ and lâ‚‚, if for every element in lâ‚, the count of that element in lâ‚ is less than or equal to the count of that element in lâ‚‚, then the list formed by appending lâ‚‚ (minus the elements in lâ‚) to lâ‚ is a permutation of lâ‚‚.",
    "output": "theorem subperm_append_diff_self_of_count_le {lâ‚ lâ‚‚ : List Î±}\n    (h : âˆ€ x âˆˆ lâ‚, count x lâ‚ â‰¤ count x lâ‚‚) : lâ‚ ++ lâ‚‚.diff lâ‚ ~ lâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a linear map 'A' from a vector space 'E' to itself over a field 'ğ•œ' is symmetric, then 'A' is self-adjoint.",
    "output": "theorem _root_.LinearMap.IsSymmetric.isSelfAdjoint {A : E â†’L[ğ•œ] E}\n    (hA : (A : E â†’â‚—[ğ•œ] E).IsSymmetric) : IsSelfAdjoint A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given left cancel semigroup R, any element g of R is left regular.",
    "output": "theorem isLeftRegular_of_leftCancelSemigroup [LeftCancelSemigroup R]\n    (g : R) : IsLeftRegular g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a morphism 'f' from object 'X' to object 'Y' that is monic, and for a morphism 'g' from object 'X' to itself, 'g' followed by 'f' is equal to 'f' if and only if 'g' is the identity on 'X'.",
    "output": "theorem cancel_mono_id (f : X âŸ¶ Y) [Mono f] {g : X âŸ¶ X} : g â‰« f = f â†” g = ğŸ™ X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is less than or equal to 'c' and 'b' is less than or equal to 'c', then the supremum (or least upper bound) of 'a' and 'b' is less than or equal to 'c'.",
    "output": "theorem sup_le : a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the number 'bit1 n' (which represents an odd number) is not even.",
    "output": "theorem not_even_bit1 (n : â„•) : Â¬Even (bit1 n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two multisets s and t, s is less than or equal to the sum of s and t.",
    "output": "theorem le_add_right (s t : Multiset Î±) : s â‰¤ s + t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given multiset 's' of any type 'Î±', the sum of the count of each element 'a' in the finset converted from 's' is equal to the cardinality of 's'.",
    "output": "theorem toFinset_sum_count_eq (s : Multiset Î±) : (âˆ‘ a in s.toFinset, s.count a) = card s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any presheafed spaces X and Y over a category C, a morphism Î± from X to Y, and an open subset U of Y, the composition of the germ of the presheaf of Y at the point Î±.base x.1 with the stalk map of Î± at the point x is equal to the composition of the application of the structure morphism Î±.c at the open subset U with the germ of the presheaf of X at the point x.",
    "output": "theorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) (U : Opens Y)\n    (x : (Opens.map Î±.base).obj U) :\n    Y.presheaf.germ âŸ¨Î±.base x.1, x.2âŸ© â‰« stalkMap Î± â†‘x = Î±.c.app (op U) â‰« X.presheaf.germ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The intersection of the coercions of K and K' to a submodule of R in L is equal to the intersection of K and K' as submodules of R in L.",
    "output": "theorem inf_coe_to_submodule :\n    (â†‘(K âŠ“ K') : Submodule R L) = (K : Submodule R L) âŠ“ (K' : Submodule R L) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The natural sum of b and c is less than or equal to a if and only if for all b' less than b, the natural sum of b' and c is less than a, and for all c' less than c, the natural sum of b and c' is less than a.",
    "output": "theorem nadd_le_iff : b â™¯ c â‰¤ a â†” (âˆ€ b' < b, b' â™¯ c < a) âˆ§ âˆ€ c' < c, b â™¯ c' < a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of a module M over a ring R, given a linearly independent set of vectors v, if the scalar multiplication of a non-zero scalar c and a vector v[i] equals the scalar multiplication of another scalar d and a vector v[j], then the indices i and j must be the same.",
    "output": "theorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type _} [AddCommGroup M] [Module R M]\n    {v : Î¹ â†’ M} (li : LinearIndependent R v) (c d : R) (i j : Î¹) (hc : c â‰  0)\n    (h : c â€¢ v i = d â€¢ v j) : i = j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero vector x, the norm function is injective on the set of all vectors y that are on the same ray as x in the real numbers.",
    "output": "theorem norm_injOn_ray_left (hx : x â‰  0) : { y | SameRay â„ x y }.InjOn norm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For three matrices M, N, and K in a category C, and two morphisms f from M to N and g from N to K, the composition of f and g is equal to the function that takes two indices i and k and returns the sum over all indices j of N, of the composition of the element of f at i and j and the element of g at j and k.",
    "output": "theorem comp_def {M N K : Mat_ C} (f : M âŸ¶ N) (g : N âŸ¶ K) :\n    f â‰« g = fun i k => âˆ‘ j : N.Î¹, f i j â‰« g j k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The closure of the closure of a set s is equal to the closure of the set s.",
    "output": "theorem closure_closure {s : Set Î±} : closure (closure s) = closure s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functions `n` mapping from Î³ to Î´ and `m'` mapping from Î²' to Î±' to Î´, and two other functions `nâ‚` mapping from Î² to Î²' and `nâ‚‚` mapping from Î± to Î±', if for all `a` and `b`, `n` applied to `m` of `a` and `b` equals `m'` applied to `nâ‚` of `b` and `nâ‚‚` of `a`, then the map of `n` applied to the map of `m` with `f` and `g` equals the map of `m'` with the map of `g` with `nâ‚` and the map of `f` with `nâ‚‚`.",
    "output": "theorem map_mapâ‚‚_antidistrib {n : Î³ â†’ Î´} {m' : Î²' â†’ Î±' â†’ Î´} {nâ‚ : Î² â†’ Î²'} {nâ‚‚ : Î± â†’ Î±'}\n    (h_antidistrib : âˆ€ a b, n (m a b) = m' (nâ‚ b) (nâ‚‚ a)) :\n    (mapâ‚‚ m f g).map n = mapâ‚‚ m' (g.map nâ‚) (f.map nâ‚‚) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function from Î± to Î² and two sets of Î±, the image of the intersection of the two sets under the function is a subset of the intersection of the images of the two sets under the function.",
    "output": "theorem image_inter_subset (f : Î± â†’ Î²) (s t : Set Î±) : f '' (s âˆ© t) âŠ† f '' s âˆ© f '' t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' and any type 'Î±' that is denumerable (i.e., can be put into a one-to-one correspondence with the set of natural numbers), decoding 'n' in the context of 'Î±' is equivalent to some 'ofNat' function applied to 'Î±' and 'n'.",
    "output": "theorem decode_eq_ofNat (Î±) [Denumerable Î±] (n : â„•) : decode (Î± := Î±) n = some (ofNat Î± n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' that takes inputs from two lists of types 'Î±' and 'Î²' and produces an output of type 'Î³', and given two pairs of lists 'l' and 'la' of type 'Î±', and 'l'' and 'lb' of type 'Î²', if the length of list 'l' is equal to the length of list 'l'', then applying the function 'f' to the concatenation of 'l' and 'la', and 'l'' and 'lb', is equal to the concatenation of applying the function 'f' to 'l' and 'l'', and 'la' and 'lb'.",
    "output": "theorem zipWith_append (f : Î± â†’ Î² â†’ Î³) (l la : List Î±) (l' lb : List Î²)\n    (h : l.length = l'.length) :\n    zipWith f (l ++ la) (l' ++ lb) = zipWith f l l' ++ zipWith f la lb :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'hT' is a dominated finite measure additive function 'T' with a constant 'C', then the function 'setToL1' applied to 'hT' is Lipschitz continuous with a Lipschitz constant equal to the non-negative real number representation of 'C'.",
    "output": "theorem setToL1_lipschitz (hT : DominatedFinMeasAdditive Î¼ T C) :\n    LipschitzWith (Real.toNNReal C) (setToL1 hT) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If c is not equal to zero, then the integral from a to b of the function f at c times x is equal to the reciprocal of c times the integral from c times a to c times b of the function f at x.",
    "output": "theorem integral_comp_mul_left (hc : c â‰  0) :\n    (âˆ« x in a..b, f (c * x)) = câ»Â¹ â€¢ âˆ« x in c * a..c * b, f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± and any function f from Î± to non-negative extended real numbers, if the sum of the function f over all i does not equal infinity, then the function obtained by applying the conversion from extended non-negative real numbers to non-negative real numbers to f is summable.",
    "output": "theorem summable_toNNReal_of_tsum_ne_top {Î± : Type _} {f : Î± â†’ â„â‰¥0âˆ} (hf : (âˆ‘' i, f i) â‰  âˆ) :\n    Summable (ENNReal.toNNReal âˆ˜ f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If p is a prime number that divides the difference between x and y, and p does not divide x or n, then p does not divide the sum of the series where each term is x raised to the power of i times y raised to the power of n minus 1 minus i, for all i in the range of n.",
    "output": "theorem not_dvd_geom_sumâ‚‚ {p : R} (hp : Prime p) (hxy : p âˆ£ x - y) (hx : Â¬p âˆ£ x) (hn : Â¬p âˆ£ n) :\n    Â¬p âˆ£ âˆ‘ i in range n, x ^ i * y ^ (n - 1 - i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The element x belongs to the closed ball centered at x with radius Îµ.",
    "output": "theorem mem_closedBall_self : x âˆˆ closedBall x Îµ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is strictly monotonic, then 'f' is also monotonic.",
    "output": "theorem StrictMono.monotone (hf : StrictMono f) : Monotone f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two sets 's' and 't' of functions from an index set to another set 'Î±', if 's' is a subset of 't', then the premeasure of 's' is less than or equal to the premeasure of 't'.",
    "output": "theorem piPremeasure_pi_mono {s t : Set (âˆ€ i, Î± i)} (h : s âŠ† t) :\n    piPremeasure m s â‰¤ piPremeasure m t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite set S of lambda expressions, a direction d, and a statement q, the support of the statement \"move in direction d then execute statement q\" within the set S is equivalent to the support of the statement q within the set S.",
    "output": "theorem supportsStmt_move {S : Finset Î›'â‚} {d : Dir} {q : Stmt'â‚} :\n    SupportsStmt S (moveâ‚™ d q) = SupportsStmt S q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f commutes with function g, then the minimal period of the composition of f and g at point x divides the least common multiple of the minimal periods of f at x and g at x.",
    "output": "theorem Commute.minimalPeriod_of_comp_dvd_lcm {g : Î± â†’ Î±} (h : Function.Commute f g) :\n    minimalPeriod (f âˆ˜ g) x âˆ£ Nat.lcm (minimalPeriod f x) (minimalPeriod g x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the 'a' coefficient of a polynomial P is not zero, then the polynomial P itself cannot be zero.",
    "output": "theorem ne_zero_of_a_ne_zero (ha : P.a â‰  0) : P.toPoly â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given list of elements of type Î±, if an element x is in the last element of the list, then x is also in the last element of the list when another element y is added to the front of the list.",
    "output": "theorem mem_getLast?_cons {x y : Î±} : âˆ€ {l : List Î±}, x âˆˆ l.getLast? â†’ x âˆˆ (y :: l).getLast?"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' and any two finite sets of sets 'ğ’œ' and 'â„¬', the subfamily of the union of 'ğ’œ' and 'â„¬' that does not contain 'a' is equal to the union of the subfamily of 'ğ’œ' that does not contain 'a' and the subfamily of 'â„¬' that does not contain 'a'.",
    "output": "theorem nonMemberSubfamily_union (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆª â„¬).nonMemberSubfamily a = ğ’œ.nonMemberSubfamily a âˆª â„¬.nonMemberSubfamily a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f tends to uniformly on filter g with respect to filters l and l', and function f' tends to uniformly on filter g' with respect to filters l and l', then the product of functions f and f' tends to uniformly on the product of filters g and g' with respect to filters l and l'.",
    "output": "theorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' and any element 'r' from the ring 'R', the conversion of the monomial 'n r' to a Finsupp representation is equal to a Finsupp single representation with 'n' and 'r'.",
    "output": "theorem toFinsupp_monomial (n : â„•) (r : R) : (monomial n r).toFinsupp = Finsupp.single n r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The successor of any element 'a' is not the bottom element.",
    "output": "theorem succ_ne_bot (a : Î±) : succ a â‰  âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "At a given point x, the function 'iso' is differentiable over the field ğ•œ.",
    "output": "theorem differentiableAt : DifferentiableAt ğ•œ iso x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers 'c' and 'd', and any integers 'x' and 'y', the property of 'Nonnegg c d x y' is equivalent to the property of 'Nonnegg d c y x'. Here, 'Nonnegg' is a property or condition that is not explicitly defined in the given context.",
    "output": "theorem nonnegg_comm {c d : â„•} {x y : â„¤} : Nonnegg c d x y = Nonnegg d c y x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given decidable equality on Î¹, a graded monoid A, a graded module M over A, and any indices i and j, the application of the scalar multiplication additive monoid homomorphism to the direct sum of A at index i with element x, and the graded module M at index j with element y, is equal to the graded module M at the index of the sum of i and j, with the graded scalar multiplication of x and y.",
    "output": "theorem smulAddMonoidHom_apply_of_of [DecidableEq Î¹] [GMonoid A] [Gmodule A M] {i j} (x : A i)\n    (y : M j) :\n    smulAddMonoidHom A M (DirectSum.of A i x) (of M j y) = of M (i + j) (GSmul.smul x y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given irreflexive relation 'r' on a type 'Î±', the expansion of 'r' by cuts is less than or equal to the inverse image of the lexicographic order on finite support functions, where the lexicographic order is defined by the complement of 'r' intersected with the inequality relation, and the less than relation.",
    "output": "theorem cutExpand_le_invImage_lex [IsIrrefl Î± r] :\n    CutExpand r â‰¤ InvImage (Finsupp.Lex (rá¶œ âŠ“ (Â· â‰  Â·)) (Â· < Â·)) toFinsupp :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is covered by b (denoted as a â©¿ b) and c is less than b, then c is less than or equal to a.",
    "output": "theorem Wcovby.le_of_lt (hab : a â©¿ b) (hcb : c < b) : c â‰¤ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The determinant of a matrix M is equal to the determinant of the matrix formed by four blocks, where each block is a submatrix of M. The submatrices are determined by a predicate p: the first block contains the elements of M for which both row and column indices satisfy p, the second block contains the elements for which the row index satisfies p and the column index does not, the third block contains the elements for which the row index does not satisfy p and the column index does, and the fourth block contains the elements for which neither the row nor the column index satisfies p.",
    "output": "theorem det_toBlock (M : Matrix m m R) (p : m â†’ Prop) [DecidablePred p] :\n    M.det =\n      (fromBlocks (toBlock M p p) (toBlock M p fun j => Â¬p j) (toBlock M (fun j => Â¬p j) p) <|\n          toBlock M (fun j => Â¬p j) fun j => Â¬p j).det :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given predicate 'p' on a type 'Î±', a given finite set 's' of type 'Î±', and a condition 'h' that for all elements 'x' in 's', 'p' holds true, the map of the subtype of 's' satisfying 'p' under the embedding of the subtype equals 's' itself. This essentially means that if all elements of a set satisfy a certain property, then mapping the subtype of elements satisfying that property back to the original set gives us the original set.",
    "output": "theorem subtype_map_of_mem {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} (h : âˆ€ x âˆˆ s, p x) :\n    (s.subtype p).map (Embedding.subtype _) = s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers 'b' and 'b'', and any integer 'c', if 'b' divides 'b'' minus 'c', then 'b' divides 'n' if and only if 'b' divides the integer representation of the digits of 'n' in base 'b'' with coefficient 'c'.",
    "output": "theorem dvd_iff_dvd_ofDigits (b b' : â„•) (c : â„¤) (h : (b : â„¤) âˆ£ (b' : â„¤) - c) (n : â„•) :\n    b âˆ£ n â†” (b : â„¤) âˆ£ ofDigits c (digits b' n) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there exists a unique element 'a' in list 'l' that satisfies property 'p', then the element chosen by the function 'choose' from list 'l' based on property 'p' also satisfies property 'p'.",
    "output": "theorem choose_property (hp : âˆƒ! a, a âˆˆ l âˆ§ p a) : p (choose p l hp) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any topological spaces Y and Z, and for any morphisms f from X to Y and g from Y to Z, the inverse of the composition of f and g applied to a set U is equal to the identity.",
    "output": "theorem comp_inv_app {Y Z : TopCat.{w}} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :\n    (comp â„± f g).inv.app U = ğŸ™ _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'f' from M to N and another linear map 'g' from N to P, the left composition of 'f' and 'g' applied to an element 'x' from M is equal to 'g' applied to the result of 'f' applied to 'x'.",
    "output": "theorem lcompâ‚›â‚—_apply (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] N) (g : N â†’â‚›â‚—[Ïƒâ‚‚â‚ƒ] P) (x : M) :\n    lcompâ‚›â‚— P Ïƒâ‚‚â‚ƒ f g x = g (f x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any compact space 'X' and any set 'A' within 'X', the closure of the closure of 'A' is a subset of the closure of 'A'.",
    "output": "theorem cl_cl {X : Compactum} (A : Set X) : cl (cl A) âŠ† cl A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an orthonormal basis 'b' of a vector space 'E' over a field 'ğ•œ' indexed by 'Î¹', the function that converts 'b' to a basis and then to an equivalent function is the same as the function that represents 'b' as a linear equivalent.",
    "output": "theorem coe_toBasis_repr (b : OrthonormalBasis Î¹ ğ•œ E) :\n    b.toBasis.equivFun = b.repr.toLinearEquiv :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'f' and 'g' from an index set 'Î¹' to a group 'M' with addition, the difference of 'f' and 'g' converted to a dependent function with finite support is equal to the difference of 'f' converted to a dependent function with finite support and 'g' converted to a dependent function with finite support.",
    "output": "theorem toDfinsupp_sub [AddGroup M] (f g : Î¹ â†’â‚€ M) :\n    (f - g).toDfinsupp = f.toDfinsupp - g.toDfinsupp :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The double of a number 'x' in the set 'Î±', when considered as an element of the set 'WithTop Î±', is equal to the double of 'x' considered directly in the set 'WithTop Î±'.",
    "output": "theorem coe_bit0 : ((bit0 x : Î±) : WithTop Î±) = (bit0 x : WithTop Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A pair (p) belongs to the product of sets s and t if and only if the first element of the pair belongs to set s and the second element of the pair belongs to set t.",
    "output": "theorem mem_product {p : Î± Ã— Î²} : p âˆˆ s Ã—Ë¢ t â†” p.1 âˆˆ s âˆ§ p.2 âˆˆ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The coe function applied to an empty Sym of any type Î± is equal to an empty Multiset of the same type Î±.",
    "output": "theorem coe_nil : â†‘(@Sym.nil Î±) = (0 : Multiset Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of a set 'Î±', if the product of 'a' and 'u' equals 1, then the inverse of 'u' is equal to 'a'.",
    "output": "theorem inv_eq_of_mul_eq_one_left {a : Î±} (h : a * u = 1) : â†‘uâ»Â¹ = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The square of the cotangent ideal of any ideal I in a ring R is equal to the bottom element, often representing the zero ideal.",
    "output": "theorem cotangentIdeal_square (I : Ideal R) : I.cotangentIdeal ^ 2 = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any subring 's' of ring 'R' and any subring 't' of ring 'S', the supremum of the product of 's' and the bottom element and the product of the bottom element and 't' is equal to the product of 's' and 't'.",
    "output": "theorem prod_bot_sup_bot_prod (s : Subring R) (t : Subring S) : s.prod âŠ¥ âŠ” prod âŠ¥ t = s.prod t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is not equal to zero, then the degree of the polynomial represented by the constant b is less than the degree of the polynomial represented by the constant a multiplied by the variable X.",
    "output": "theorem degree_C_lt_degree_C_mul_X (ha : a â‰  0) : degree (C b) < degree (C a * X) :="
  },
  {
    "instruction": "",
    "input": "For any four objects W, X, Y, Z in a braided monoidal category C, the following equality holds:",
    "output": "theorem tensor_associativity_aux (W X Y Z : C) :\n    ((Î²_ W X).hom âŠ— ğŸ™ (Y âŠ— Z)) â‰«\n        (Î±_ X W (Y âŠ— Z)).hom â‰«\n          (ğŸ™ X âŠ— (Î±_ W Y Z).inv) â‰« (ğŸ™ X âŠ— (Î²_ (W âŠ— Y) Z).hom) â‰« (ğŸ™ X âŠ— (Î±_ Z W Y).inv) =\n      (ğŸ™ (W âŠ— X) âŠ— (Î²_ Y Z).hom) â‰«\n        (Î±_ (W âŠ— X) Z Y).inv â‰«\n          ((Î±_ W X Z).hom âŠ— ğŸ™ Y) â‰«\n            ((Î²_ W (X âŠ— Z)).hom âŠ— ğŸ™ Y) â‰« ((Î±_ X Z W).hom âŠ— ğŸ™ Y) â‰« (Î±_ X (Z âŠ— W) Y).hom :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any semiring Î±, any element 'a' of Î±, and any vertex 'v', the result of multiplying the adjacency matrix of a graph 'G' with a constant function of 'a', applied to 'v', is equal to the degree of the vertex 'v' in the graph 'G' multiplied by 'a'.",
    "output": "theorem adjMatrix_mulVec_const_apply [Semiring Î±] {a : Î±} {v : V} :\n    (G.adjMatrix Î±).mulVec (Function.const _ a) v = G.degree v * a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the index of group H is not zero and the index of group K is not zero, then the index of the intersection of groups H and K is also not zero.",
    "output": "theorem index_inf_ne_zero (hH : H.index â‰  0) (hK : K.index â‰  0) : (H âŠ“ K).index â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of fixed points for the identity function on any set Î± is the entire set Î± itself.",
    "output": "theorem fixedPoints_id : fixedPoints (@id Î±) = Set.univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type 'R' that forms a Rack and any element 'a' of the PreEnveloping Group of 'R', the PreEnveloping Group Relation of 'R' is reflexive for 'a'. This means that 'a' is related to itself in the PreEnveloping Group Relation of 'R'.",
    "output": "theorem PreEnvelGroupRel.refl {R : Type u} [Rack R] {a : PreEnvelGroup R} :\n    PreEnvelGroupRel R a a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± and any two relations r and s on Î±, if for all x and y, r x y implies s x y, then the composition of the factor function from r to s with the quotient set constructor function for r equals the quotient set constructor function for s.",
    "output": "theorem factor_mk_eq {Î± : Type _} (r s : Î± â†’ Î± â†’ Prop) (h : âˆ€ x y, r x y â†’ s x y) :\n    factor r s h âˆ˜ Quot.mk _ = Quot.mk _ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the function that adds a constant 'a' to a variable 'x', when applied to all elements greater than or equal to 'b', is equal to all elements greater than or equal to 'a + b'.",
    "output": "theorem image_const_add_Ici : (fun x => a + x) '' Ici b = Ici (a + b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î³', if 'f' is upper semicontinuous, then the preimage of the set of all elements greater than or equal to 'y' under 'f' is a closed set.",
    "output": "theorem UpperSemicontinuous.isClosed_preimage {f : Î± â†’ Î³} (hf : UpperSemicontinuous f) (y : Î³) :\n    IsClosed (f â»Â¹' Ici y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set 's' has a minimum value 'b', and there is a value 'a' that is less than 'b', then 'a' is not a member of the set 's'.",
    "output": "theorem not_mem_of_lt_min {s : Finset Î±} {a b : Î±} (hâ‚ : a < b) (hâ‚‚ : s.min = â†‘b) : a âˆ‰ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î¹ and Î¹' and any two functions f and g from these types to a complete Boolean algebra Î±, the infimum (greatest lower bound) of the supremum (least upper bound) of f over all elements of Î¹ and the supremum of g over all elements of Î¹' is equal to the supremum over all pairs of elements from Î¹ and Î¹' of the infimum of f applied to the first element of the pair and g applied to the second element of the pair.",
    "output": "theorem iSup_inf_iSup {Î¹ Î¹' : Type _} {f : Î¹ â†’ Î±} {g : Î¹' â†’ Î±} :\n    ((â¨† i, f i) âŠ“ â¨† j, g j) = â¨† i : Î¹ Ã— Î¹', f i.1 âŠ“ g i.2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every Cauchy sequence of elements in Î± there exists a limit point 'a' such that the sequence tends towards 'a', then Î± is a complete space.",
    "output": "theorem complete_of_cauchySeq_tendsto :\n    (âˆ€ u : â„• â†’ Î±, CauchySeq u â†’ âˆƒ a, Tendsto u atTop (ğ“ a)) â†’ CompleteSpace Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The lift of the root of a function f by the homomorphism liftHom, given f, a, and hfx, equals a.",
    "output": "theorem liftHom_root : liftHom f a hfx (root f) = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'toMulBot a' is less than 'toMulBot b' if and only if 'a' is less than 'b'.",
    "output": "theorem toMulBot_lt : toMulBot a < toMulBot b â†” a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Pi is less than 3.15.",
    "output": "theorem pi_lt_315 : Ï€ < 3.15 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of absolutely convex open sets in a vector space 'E' over a field 'ğ•œ', 's' is also a convex set in the real numbers.",
    "output": "theorem coe_convex (s : AbsConvexOpenSets ğ•œ E) : Convex â„ (s : Set E) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any monoid object M in a monoidal category C, the composition of the tensor product of the multiplication map of M and the right unitor of the monoidal unit with the right unitor of M is equal to the composition of the tensor product of two right unitors of M with the multiplication map of M.",
    "output": "theorem mul_rightUnitor {M : Mon_ C} :\n    (tensor_Î¼ C (M.X, ğŸ™_ C) (M.X, ğŸ™_ C) â‰« (M.mul âŠ— (Î»_ (ğŸ™_ C)).hom)) â‰« (Ï_ M.X).hom =\n      ((Ï_ M.X).hom âŠ— (Ï_ M.X).hom) â‰« M.mul :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two ideals I and J of a ring Î±, if for every element x, x is in I if and only if x is in J, then I is equal to J.",
    "output": "theorem ext {I J : Ideal Î±} (h : âˆ€ x, x âˆˆ I â†” x âˆˆ J) : I = J :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any equivalence between two sets n and m, and any square matrix A with elements from set m, the determinant of the submatrix of A defined by the equivalence is equal to the determinant of A itself.",
    "output": "theorem det_submatrix_equiv_self (e : n â‰ƒ m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a statement qâ‚ is an element of the set of statements generated by qâ‚‚, and if the set S supports the statement qâ‚‚, then the set S also supports the statement qâ‚.",
    "output": "theorem stmtsâ‚_supportsStmt_mono {S : Finset Î›} {qâ‚ qâ‚‚ : Stmtâ‚‚} (h : qâ‚ âˆˆ stmtsâ‚ qâ‚‚)\n    (hs : SupportsStmt S qâ‚‚) : SupportsStmt S qâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The dependent product index of an empty list, when mapped with any function from Î± to Î¹, is equal to zero.",
    "output": "theorem List.dProdIndex_nil (fÎ¹ : Î± â†’ Î¹) : ([] : List Î±).dProdIndex fÎ¹ = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'p' in a nontrivial ring 'R' with characteristic 'p', if 'p' is not equal to 2, then -1 is a primitive root of order 2.",
    "output": "theorem neg_one (p : â„•) [Nontrivial R] [h : CharP R p] (hp : p â‰  2) :\n    IsPrimitiveRoot (-1 : R) 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a natural number 'm', the p-adic norm of 'm' is less than one if and only if 'p' divides 'm'.",
    "output": "theorem nat_lt_one_iff (m : â„•) : padicNorm p m < 1 â†” p âˆ£ m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given binary bicone 'b' of 'X' and 'Y', if 'b' is a bilimit, then it is a pullback of the zero morphisms from '0' to 'X' and '0' to 'Y' along 'b.inl' and 'b.inr'.",
    "output": "theorem of_is_bilimit' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPullback (0 : 0 âŸ¶ X) (0 : 0 âŸ¶ Y) b.inl b.inr :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-zero extended non-negative real number 'a', there exists a natural number 'n' such that the inverse of 'n' (considered as an extended non-negative real number) is less than 'a'.",
    "output": "theorem exists_inv_nat_lt {a : â„â‰¥0âˆ} (h : a â‰  0) : âˆƒ n : â„•, (n : â„â‰¥0âˆ)â»Â¹ < a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bilinear form B on a module M over a ring R and a linear map r from M to M, the composition of B with the identity linear map on the left and r on the right is equal to the right composition of B with r.",
    "output": "theorem comp_id_left (B : BilinForm R M) (r : M â†’â‚—[R] M) :\n    B.comp LinearMap.id r = B.compRight r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and c of a Euclidean domain R, if b is not equal to zero and the product of a and b equals c, then a is equal to c divided by b.",
    "output": "theorem eq_div_of_mul_eq_left {a b c : R} (hb : b â‰  0) (h : a * b = c) : a = c / b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', casting 'n' to a rational number and then to an arbitrary type 'Î±' is equal to the original natural number 'n'.",
    "output": "theorem cast_coe_nat (n : â„•) : ((n : â„š) : Î±) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any scalar 'c' from the ring 'R' and any element 'x' from the restriction of scalars from 'S' to 'M' over 'R', the application of the addition equivalence on the scalar multiplication of 'c' and 'x' is equal to the scalar multiplication of the algebraic mapping of 'c' from 'R' to 'S' and the application of the addition equivalence on 'x'.",
    "output": "theorem RestrictScalars.addEquiv_map_smul (c : R) (x : RestrictScalars R S M) :\n    RestrictScalars.addEquiv R S M (c â€¢ x) = algebraMap R S c â€¢ RestrictScalars.addEquiv R S M x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given multiset of matrices 's' with elements from an additive commutative monoid 'Î±' that also forms a star-additive monoid, the conjugate transpose of the sum of the matrices in 's' is equal to the sum of the conjugate transposes of the matrices in 's'.",
    "output": "theorem conjTranspose_multiset_sum [AddCommMonoid Î±] [StarAddMonoid Î±]\n    (s : Multiset (Matrix m n Î±)) : s.sumá´´ = (s.map conjTranspose).sum :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a preorder set of elements Î±, which has no minimum order, any element x from Î± is disjoint from the set of all elements that are less than any given element in Î±.",
    "output": "theorem disjoint_pure_atBot [Preorder Î±] [NoMinOrder Î±] (x : Î±) : Disjoint (pure x) atBot :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two ordinals 'a' and 'b', the product of 'a' and the successor of 'b' is equal to the sum of the product of 'a' and 'b' and 'a'.",
    "output": "theorem mul_succ (a b : Ordinal) : a * succ b = a * b + a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two points x and y, y is between x and y itself in the relation R.",
    "output": "theorem wbtw_self_right (x y : P) : Wbtw R x y y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a complete space, if a sequence is Cauchy, then there exists a limit point such that the sequence tends to this limit point.",
    "output": "theorem cauchySeq_tendsto_of_complete [SemilatticeSup Î²] [CompleteSpace Î±] {u : Î² â†’ Î±}\n    (H : CauchySeq u) : âˆƒ x, Tendsto u atTop (ğ“ x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two real numbers 'a' and 'b', if the functions 'f' and 'g' are equal on the interval from 'a' to 'b', then the integral of 'f' from 'a' to 'b' is equal to the integral of 'g' from 'a' to 'b'.",
    "output": "theorem integral_congr {a b : â„} (h : EqOn f g [[a, b]]) :\n    (âˆ« x in a..b, f x âˆ‚Î¼) = âˆ« x in a..b, g x âˆ‚Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given Ctop structure 'F' on a set 'Î±' with a topology 'Ïƒ', a set 's' is in the neighborhood of a point 'a' in the topological space derived from 'F' if and only if there exists a 'b' such that 'a' is in 'F' of 'b' and 'F' of 'b' is a subset of 's'.",
    "output": "theorem mem_nhds_toTopsp (F : Ctop Î± Ïƒ) {s : Set Î±} {a : Î±} :\n    s âˆˆ @nhds _ F.toTopsp a â†” âˆƒ b, a âˆˆ F b âˆ§ F b âŠ† s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a second countable topology on X and the quotient map is an open map, then the quotient space also has a second countable topology.",
    "output": "theorem Quotient.secondCountableTopology [SecondCountableTopology X]\n    (h : IsOpenMap (Quotient.mk' : X â†’ Quotient S)) : SecondCountableTopology (Quotient S) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For every number 'n', the pre-previous value of 'n' when converted to a natural number is equal to the natural number pre-previous of 'n'.",
    "output": "theorem ppred_to_nat : âˆ€ n : Num, (â†‘) <$> ppred n = Nat.ppred n"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If aâ‚‚ is not equal to zero, then the condition that the series of the terms f(i) divided by aâ‚‚ has a sum of aâ‚ divided by aâ‚‚ is equivalent to the condition that the series of the terms f has a sum of aâ‚.",
    "output": "theorem hasSum_div_const_iff (h : aâ‚‚ â‰  0) : HasSum (fun i => f i / aâ‚‚) (aâ‚ / aâ‚‚) â†” HasSum f aâ‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If b and c are non-negative numbers, and a is less than or equal to the product of c and b, then the quotient of a and b is less than or equal to c.",
    "output": "theorem div_le_of_nonneg_of_le_mul (hb : 0 â‰¤ b) (hc : 0 â‰¤ c) (h : a â‰¤ c * b) : a / b â‰¤ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'f' from a ring 'A' to a ring 'B', and another function 'g' from ring 'B' to ring 'C', and if the composition of 'g' and 'f' has a finite presentation, and 'f' is of finite type, then 'g' also has a finite presentation.",
    "output": "theorem of_comp_finiteType (f : A â†’+* B) {g : B â†’+* C} (hg : (g.comp f).FinitePresentation)\n    (hf : f.FiniteType) : g.FinitePresentation :=\n  -- Porting note : need to specify some instances"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'f' is a linear map from 'F' to 'E' and 'f' is a surjective function (meaning every element of 'E' is the image of at least one element of 'F' under 'f'), then 'f' is an open map (meaning the image of an open set under 'f' is also an open set).",
    "output": "theorem isOpenMap_of_finiteDimensional (f : F â†’â‚—[ğ•œ] E) (hf : Function.Surjective f) :\n    IsOpenMap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a filter l has a basis defined by a predicate p and a set function s, then the filter l intersected with the principal filter of a set t is not the bottom filter if and only if for all elements i that satisfy the predicate p, the intersection of the set s(i) and t is nonempty.",
    "output": "theorem HasBasis.inf_principal_neBot_iff (hl : l.HasBasis p s) {t : Set Î±} :\n    NeBot (l âŠ“ ğ“Ÿ t) â†” âˆ€ â¦ƒiâ¦„, p i â†’ (s i âˆ© t).Nonempty :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The predecessor of a number 'o' equals 'o' if and only if there does not exist a number 'a' such that 'o' is the successor of 'a'.",
    "output": "theorem pred_eq_iff_not_succ {o} : pred o = o â†” Â¬âˆƒ a, o = succ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of all walks from vertex 'u' to vertex 'v' in a simple graph 'G' with length 'n+1' is equal to the union over all vertices 'w' adjacent to 'u' of the set of walks from 'w' to 'v' with length 'n', each extended by one step from 'u' to 'w'.",
    "output": "theorem set_walk_length_succ_eq (u v : V) (n : â„•) :\n    {p : G.Walk u v | p.length = n.succ} =\n      â‹ƒ (w : V) (h : G.Adj u w), Walk.cons h '' {p' : G.Walk w v | p'.length = n} :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' that takes an element of type Î± and an element of type Î² and returns an element of type Î², a value 'H', a value 'b', and a value 'a', the result of folding the function 'f' over the multiset containing only 'a' with 'b' as the initial value is equal to the result of applying the function 'f' to 'a' and 'b'.",
    "output": "theorem foldr_singleton (f : Î± â†’ Î² â†’ Î²) (H b a) : foldr f H b ({a} : Multiset Î±) = f a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of type 'Î´' and a function 't' that maps each element 'i' of type 'Î´' to a set of type 'Ï€ i', if 's' is countable and for every element 'i' in 's', the set 't i' is measurable, then the Cartesian product of 's' and 't', denoted as 's.pi t', is also measurable.",
    "output": "theorem MeasurableSet.pi {s : Set Î´} {t : âˆ€ i : Î´, Set (Ï€ i)} (hs : s.Countable)\n    (ht : âˆ€ i âˆˆ s, MeasurableSet (t i)) : MeasurableSet (s.pi t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measure 'Î¼' on a set 'Î±' that is sigma-finite (meaning it can be partitioned into a countable union of measurable sets with finite measure), and a function 'f' that is non-negative and measurable, the Lebesgue integral of the function 'f' with respect to the measure 'Î¼' is equal to the Lebesgue integral over the interval (0, âˆ) of the measure of the set of elements 'a' in 'Î±' for which 't' is less than 'f(a)'.",
    "output": "theorem lintegral_eq_lintegral_meas_lt (Î¼ : Measure Î±) [SigmaFinite Î¼] (f_nn : 0 â‰¤ f)\n    (f_mble : Measurable f) :\n    (âˆ«â» Ï‰, ENNReal.ofReal (f Ï‰) âˆ‚Î¼) = âˆ«â» t in Ioi 0, Î¼ {a : Î± | t < f a} :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object 'U' in the opposite category 'C', and any section 's' of 'F' at 'U', the family of elements of 'G' corresponding to the section 's' is compatible.",
    "output": "theorem Subpresheaf.family_of_elements_compatible {U : Cáµ’áµ–} (s : F.obj U) :\n    (G.familyOfElementsOfSection s).Compatible :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two lists, lâ‚ of type Î± and lâ‚‚ of type Î², if the length of lâ‚‚ is less than or equal to the length of lâ‚, then the second element of the pair resulting from unzipping the zipped pair of lâ‚ and lâ‚‚ is equal to lâ‚‚.",
    "output": "theorem unzip_zip_right {lâ‚ : List Î±} {lâ‚‚ : List Î²} (h : length lâ‚‚ â‰¤ length lâ‚) :\n    (unzip (zip lâ‚ lâ‚‚)).2 = lâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of 'a' and 'b' is less than zero if and only if either 'a' is greater than zero and 'b' is less than zero, or 'a' is less than zero and 'b' is greater than zero.",
    "output": "theorem mul_neg_iff : a * b < 0 â†” 0 < a âˆ§ b < 0 âˆ¨ a < 0 âˆ§ 0 < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two measurable functions 'f' and 'g' from a set 'Î±' to sets 'Î²' and 'Î³' respectively, with respect to a measure 'Î¼', the pair function of 'f' and 'g' is almost everywhere equal to a function that maps each element 'x' in 'Î±' to the pair consisting of the image of 'x' under 'f' and the image of 'x' under 'g'.",
    "output": "theorem coeFn_pair (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³) : f.pair g =áµ[Î¼] fun x => (f x, g x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of pairs of elements from sets 'Î±' and 'Î²', if 's' is a measurable set and the product measure of 's' with respect to measures 'Î¼' and 'Î½' is not infinite, then the function that maps each element 'x' from 'Î±' to the real number representation of the measure of the preimage of 's' under the function 'Prod.mk x' with respect to 'Î½' is integrable with respect to 'Î¼'.",
    "output": "theorem integrable_measure_prod_mk_left {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s)\n    (h2s : (Î¼.prod Î½) s â‰  âˆ) : Integrable (fun x => (Î½ (Prod.mk x â»Â¹' s)).toReal) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'f' is differentiable on the entire domain if and only if 'f' is differentiable.",
    "output": "theorem differentiableOn_univ : DifferentiableOn ğ•œ f univ â†” Differentiable ğ•œ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any semiring Î± and any natural number n, for any two functions v and w from the finite set of size n to Î±, the product of the circulant matrix of v and the circulant matrix of w equals the circulant matrix of the product of the circulant matrix of v and w.",
    "output": "theorem Fin.circulant_mul [Semiring Î±] :\n    âˆ€ {n} (v w : Fin n â†’ Î±), circulant v â¬ circulant w = circulant (mulVec (circulant v) w)"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The zeroth term of the lower central series of a Lie module M over an ideal I is the top element.",
    "output": "theorem lcs_zero : I.lcs M 0 = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'x' and 'y', the equivalence class of the sum of 'x' and 'y' under the relation 'Setoid.r' is equal to the sum of the equivalence classes of 'x' and 'y' in the colimit type 'F'.",
    "output": "theorem quot_add (x y) :\n    Quot.mk Setoid.r (add x y) = (ColimitType.mk x + ColimitType.mk y : ColimitType F) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number x, one raised to the power of x equals one.",
    "output": "theorem one_rpow (x : â„) : (1 : â„â‰¥0âˆ) ^ x = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite type Ïƒ and a list x that is accepted by a machine M, if the cardinality of Ïƒ is less than or equal to the length of the list x, then there exist lists a, b, and c such that x is the concatenation of a, b, and c, the sum of the lengths of a and b is less than or equal to the cardinality of Ïƒ, b is not an empty list, and the set of all possible concatenations of a, any number of repetitions of b, and c is a subset of the set of lists accepted by the machine M.",
    "output": "theorem pumping_lemma [Fintype Ïƒ] {x : List Î±} (hx : x âˆˆ M.accepts)\n    (hlen : Fintype.card Ïƒ â‰¤ List.length x) :\n    âˆƒ a b c,\n      x = a ++ b ++ c âˆ§\n        a.length + b.length â‰¤ Fintype.card Ïƒ âˆ§ b â‰  [] âˆ§ {a} * {b}âˆ— * {c} â‰¤ M.accepts :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î¹ and Î¹' and any two functions f and g from these types to a complete Boolean algebra Î±, the supremum (or join) of the infimum (or meet) of f over all elements of Î¹ and the infimum of g over all elements of Î¹' is equal to the infimum over all pairs of elements from Î¹ and Î¹' of the supremum of f applied to the first element of the pair and g applied to the second element of the pair.",
    "output": "theorem iInf_sup_iInf {Î¹ Î¹' : Type _} {f : Î¹ â†’ Î±} {g : Î¹' â†’ Î±} :\n    ((â¨… i, f i) âŠ” â¨… i, g i) = â¨… i : Î¹ Ã— Î¹', f i.1 âŠ” g i.2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any box 'I' and any finite set 's' of pairs of 'Î¹' and real numbers, the function 'splitMany' applied to 'I' and 's' results in a partition.",
    "output": "theorem isPartition_splitMany (I : Box Î¹) (s : Finset (Î¹ Ã— â„)) : IsPartition (splitMany I s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'a' is the minimum value of the function 'f' under the filter 'l' in the dual order if and only if 'a' is the maximum value of the function 'f' under the filter 'l' in the original order.",
    "output": "theorem isMinFilter_dual_iff : IsMinFilter (toDual âˆ˜ f) l a â†” IsMaxFilter f l a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The grade of 'a' is equal to the grade of 'b' if and only if 'a' is equal to 'b'.",
    "output": "theorem grade_eq_grade_iff : grade ğ•† a = grade ğ•† b â†” a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 's' in set 'S', the function 'mk'' with parameters 'f' and '0' and 's' equals to '0'.",
    "output": "theorem mk'_zero (s : S) : mk' f 0 s = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is strictly decreasing (StrictAnti f), and a constant 'a' is greater than zero (0 < a), then the function that multiplies 'a' with the output of 'f' for any input 'x' (fun x => a * f x) is also strictly decreasing (StrictAnti).",
    "output": "theorem StrictAnti.const_mul (hf : StrictAnti f) (ha : 0 < a) : StrictAnti fun x => a * f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A vertex 'v' is in the component complement 'C' of a graph 'G' and a set 'K' if and only if there exists a condition where 'v' is not in 'K' and the component complement of 'G' with respect to this condition equals 'C'.",
    "output": "theorem ComponentCompl.mem_supp_iff {v : V} {C : ComponentCompl G K} :\n    v âˆˆ C â†” âˆƒ vK : v âˆ‰ K, G.componentComplMk vK = C :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two structure-preserving functions 'f' from M to N and 'g' from N to P, the range of the composition of 'g' and 'f' (from M to P) is equal to the image of the range of 'f' under 'g'.",
    "output": "theorem range_comp (f : M â†’[L] N) (g : N â†’[L] P) : range (g.comp f : M â†’[L] P) = map g (range f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any additive monoid A, any element x of A, and any natural number n, the application of the multiples homomorphism on x and n is equal to n times x.",
    "output": "theorem multiplesHom_apply [AddMonoid A] (x : A) (n : â„•) : multiplesHom A x n = n â€¢ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any objects X and Y in category C, and any subobject P of Y, if P factors through the sum of two morphisms f and g from X to Y, and P also factors through each of f and g individually, then the morphism factoring P through the sum of f and g is equal to the sum of the morphisms factoring P through f and g individually.",
    "output": "theorem factorThru_add {X Y : C} {P : Subobject Y} (f g : X âŸ¶ Y) (w : P.Factors (f + g))\n    (wf : P.Factors f) (wg : P.Factors g) :\n    P.factorThru (f + g) w = P.factorThru f wf + P.factorThru g wg :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any set 's' of type 'Î¹', and any two functions 'f' and 'g' from 'Î¹' to 'Î±' and 'Î²' respectively, if 'Î¹' is a subsingleton (i.e., a set with at most one element), then 'f' and 'g' are monovariant on 's'. This means that the order of the values of 'f' and 'g' is preserved when applied to any two elements in 's'.",
    "output": "theorem Subsingleton.monovaryOn [Subsingleton Î¹] (f : Î¹ â†’ Î±) (g : Î¹ â†’ Î²) (s : Set Î¹) :\n    MonovaryOn f g s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The second element of the homological complex created by the function 'mk' with inputs Xâ‚€, Xâ‚, Xâ‚‚, dâ‚€, dâ‚, s, and succ is equal to Xâ‚‚.",
    "output": "theorem mk_X_2 : (mk Xâ‚€ Xâ‚ Xâ‚‚ dâ‚€ dâ‚ s succ).X 2 = Xâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three types Î±, Î², and Î³ that are primcodable, and for any properties p of Î±, q of Î², and r of Î³, if p and q are one-one equivalent, then p is one-one equivalent to r if and only if q is one-one equivalent to r.",
    "output": "theorem OneOneEquiv.congr_left {Î± Î² Î³} [Primcodable Î±] [Primcodable Î²] [Primcodable Î³]\n    {p : Î± â†’ Prop} {q : Î² â†’ Prop} {r : Î³ â†’ Prop} (h : OneOneEquiv p q) :\n    OneOneEquiv p r â†” OneOneEquiv q r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measure Î¼ on a set Î±, where Î¼ is a finite measure, and a non-negative real number r, the signed measure of r times Î¼ is equal to r times the signed measure of Î¼.",
    "output": "theorem toSignedMeasure_smul (Î¼ : Measure Î±) [IsFiniteMeasure Î¼] (r : â„â‰¥0) :\n    (r â€¢ Î¼).toSignedMeasure = r â€¢ Î¼.toSignedMeasure :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a monic polynomial 'g' and a finite sequence 'c' of coefficients in a ring 'R', the inverse representation of the power basis of 'g' applied to 'c' is equal to the polynomial 'g' constructed from the sum of monomials with coefficients from 'c'.",
    "output": "theorem powerBasisAux'_repr_symm_apply (hg : g.Monic) (c : Fin g.natDegree â†’â‚€ R) :\n    (powerBasisAux' hg).repr.symm c = mk g (âˆ‘ i : Fin _, monomial i (c i)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î± and Î², given a function 'g' from Î± to Î², a function 'q' from a finite set of size 'n' to Î±, and an element 'y' of type Î±, the composition of 'g' and the function 'snoc q y' (which appends 'y' to the end of the sequence defined by 'q') is equal to the function 'snoc (g âˆ˜ q) (g y)' (which appends 'g y' to the end of the sequence defined by 'g âˆ˜ q').",
    "output": "theorem comp_snoc {Î± : Type _} {Î² : Type _} (g : Î± â†’ Î²) (q : Fin n â†’ Î±) (y : Î±) :\n    g âˆ˜ snoc q y = snoc (g âˆ˜ q) (g y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given condition where aâ‚ is less than bâ‚, the closed interval from aâ‚ to bâ‚ is a subset of the closed interval from aâ‚‚ to bâ‚‚ if and only if aâ‚‚ is less than or equal to aâ‚ and bâ‚ is less than or equal to bâ‚‚.",
    "output": "theorem Ico_subset_Ico_iff (hâ‚ : aâ‚ < bâ‚) : Ico aâ‚ bâ‚ âŠ† Ico aâ‚‚ bâ‚‚ â†” aâ‚‚ â‰¤ aâ‚ âˆ§ bâ‚ â‰¤ bâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-zero element 'a' in a group with zero 'Gâ‚€', the function that multiplies 'a' to any element 'g' in the group is surjective. This means that for every element in the group, there is at least one element 'g' such that when 'g' is multiplied by 'a', that element is obtained.",
    "output": "theorem mul_right_surjectiveâ‚€ {a : Gâ‚€} (h : a â‰  0) : Surjective fun g => g * a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The restriction of the zero polynomial in the ring of polynomials over R is equal to zero.",
    "output": "theorem restriction_zero : restriction (0 : R[X]) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The integral of a function f over a circle with radius zero centered at a complex number c is equal to zero.",
    "output": "theorem integral_radius_zero (f : â„‚ â†’ E) (c : â„‚) : (âˆ® z in C(c, 0), f z) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any power series Ï† over a ring R, Ï† is equal to the product of a new power series (whose coefficients are the coefficients of Ï† shifted by one index) and the variable X, plus the constant term of Ï†.",
    "output": "theorem eq_shift_mul_X_add_const (Ï† : PowerSeries R) :\n    Ï† = (mk fun p => coeff R (p + 1) Ï†) * X + C R (constantCoeff R Ï†) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given multi-index 'n', the coefficient of the multivariate power series of the ring 'R' at 'n' for the series 'Ï†' when coerced is equal to the coefficient of 'Ï†' at 'n'.",
    "output": "theorem coeff_coe (n : Ïƒ â†’â‚€ â„•) : MvPowerSeries.coeff R n â†‘Ï† = coeff n Ï† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given type F, if R and S are rings, S is a domain, and F is a class of ring homomorphisms from R to S, then for any ring homomorphism f from R to S, the kernel of f is a prime ideal.",
    "output": "theorem ker_isPrime {F : Type _} [Ring R] [Ring S] [IsDomain S] [RingHomClass F R S] (f : F) :\n    (ker f).IsPrime :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bilinear map B from n-dimensional vectors to m-dimensional vectors over a ring R, and a matrix M with m rows and m' columns over the ring R, the matrix multiplication of the matrix representation of B and M is equal to the matrix representation of the composition of B and the linear map represented by M.",
    "output": "theorem LinearMap.toMatrixâ‚‚'_mul (B : (n â†’ R) â†’â‚—[R] (m â†’ R) â†’â‚—[R] R) (M : Matrix m m' R) :\n    toMatrixâ‚‚' B â¬ M = toMatrixâ‚‚' (B.complâ‚‚ <| toLin' M) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any centroid homomorphism 'f' of a type 'Î±', the composition of 'f' with the identity centroid homomorphism of 'Î±' is equal to 'f' itself.",
    "output": "theorem comp_id (f : CentroidHom Î±) : f.comp (CentroidHom.id Î±) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' in a topological space, if there exists an element 'b' that is less than 'a', then the neighborhood within the set of all elements less than 'a' has a basis consisting of the open intervals (Â·, a) where the left endpoint is less than 'a'.",
    "output": "theorem nhdsWithin_Iio_basis' {a : Î±} (h : âˆƒ b, b < a) : (ğ“[<] a).HasBasis (Â· < a) (Ioo Â· a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The intersection of the set of all numbers greater than 'a' and the set of all numbers less than 'b' is equal to the set of all numbers between 'a' and 'b' (exclusive).",
    "output": "theorem Ioi_inter_Iio : Ioi a âˆ© Iio b = Ioo a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The rounded value of the negative reciprocal of 2 is equal to 0.",
    "output": "theorem round_neg_two_inv : round (-2â»Â¹ : Î±) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is less than 'b' and 'b' is less than 'c', then the union of the interval from 'a' to 'b' (inclusive of 'b' and exclusive of 'a') and the interval from 'b' to 'c' (inclusive of 'b' and exclusive of 'c') is equal to the interval from 'a' to 'c' (exclusive of both 'a' and 'c').",
    "output": "theorem Ioc_union_Ico_eq_Ioo (hâ‚ : a < b) (hâ‚‚ : b < c) : Ioc a b âˆª Ico b c = Ioo a c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If graph G is preconnected and graph H is preconnected, then the Cartesian product of G and H (denoted as G â–¡ H) is also preconnected.",
    "output": "theorem Preconnected.boxProd (hG : G.Preconnected) (hH : H.Preconnected) :\n    (G â–¡ H).Preconnected :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The norm of the adjoint auxiliary of a linear map A from E to F is equal to the norm of A itself.",
    "output": "theorem adjointAux_norm (A : E â†’L[ğ•œ] F) : â€–adjointAux Aâ€– = â€–Aâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function that maps each element of a set Î± to its connected component is continuous.",
    "output": "theorem continuous_coe : Continuous (mk : Î± â†’ ConnectedComponents Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "There exists a sequence of rational numbers that converges to a Cauchy sequence under the p-adic norm.",
    "output": "theorem exi_rat_seq_conv_cauchy : IsCauSeq (padicNorm p) (limSeq f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three partial natural numbers x, y, and z, where z is not infinity, x plus z is less than y plus z if and only if x is less than y.",
    "output": "theorem add_lt_add_iff_right {x y z : PartENat} (hz : z â‰  âŠ¤) : x + z < y + z â†” x < y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list of elements of type Î± and any binary relation r on Î±, if r is reflexive (meaning that every element is related to itself) and for all distinct elements a and b in the list, a is related to b by r, then the list is pairwise related by r.",
    "output": "theorem pairwise_of_reflexive_of_forall_ne {l : List Î±} {r : Î± â†’ Î± â†’ Prop} (hr : Reflexive r)\n    (h : âˆ€ a âˆˆ l, âˆ€ b âˆˆ l, a â‰  b â†’ r a b) : l.Pairwise r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functions 'f' and 'g' that are equivalences between two types 'Î±' and 'Î²', if 'f' is equal to 'g', then the result of applying 'f' to any element 'x' of type 'Î±' is equal to the result of applying 'g' to the same 'x'.",
    "output": "theorem congr_fun {f g : Equiv Î± Î²} (h : f = g) (x : Î±) : f x = g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ordinal number 'o', the ordinal of the aleph function of 'o' is a limit ordinal.",
    "output": "theorem ord_aleph_isLimit (o : Ordinal) : (aleph o).ord.IsLimit :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any topological space E that is also a T1 space, if x is not equal to y, then there exists a continuous linear map f from E to the real numbers such that f(x) is less than f(y).",
    "output": "theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x â‰  y) :\n    âˆƒ f : E â†’L[â„] â„, f x < f y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The transformation of a bilinear form to a matrix using the basis function in the domain Râ‚‚ with dimension n is equal to the transformation of the bilinear form to a matrix using the prime transformation.",
    "output": "theorem BilinForm.toMatrix_basisFun :\n    BilinForm.toMatrix (Pi.basisFun Râ‚‚ n) = BilinForm.toMatrix' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a function 'f' that is surjective (or onto, meaning every element in the range is mapped to by at least one element in the domain) and the domain 'Î±' is a subsingleton (a set with at most one element), then the range 'Î²' is also a subsingleton.",
    "output": "theorem Surjective.subsingleton [Subsingleton Î±] (hf : Surjective f) : Subsingleton Î² :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two kernels Îº and Î·, the function application of their sum is equal to their sum.",
    "output": "theorem coeFn_add (Îº Î· : kernel Î± Î²) : â‡‘(Îº + Î·) = Îº + Î· :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any dual number of a quaternion over a ring R, the second imaginary part of the inverse of the dual number equivalence of the dual number is equal to the second imaginary part of the second part of the dual number.",
    "output": "theorem snd_imK_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imK.snd = d.snd.imK :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²', if 'f' is injective (meaning it never maps distinct elements of 'Î±' to the same element of 'Î²'), then the function that maps a set 's' to its preimage under 'f' is monotone (meaning that if 's' is a subset of 't', then the preimage of 's' under 'f' is a subset of the preimage of 't' under 'f').",
    "output": "theorem monotone_preimage {f : Î± â†’ Î²} (h : Injective f) :\n    Monotone fun s => preimage s f (h.injOn _) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given Baer module 'h' over a ring 'R' and a field 'Q', and for any element 'y' of a set 'N', if 'x' is a supremum extension of the maximum singleton 'i' and a function 'f' at 'y', and 'a' is an element of the domain of the extension of the maximum 'i' and function 'f', and 'r' is an element of the ring 'R', and if the element 'x' is equal to the element 'a' plus the scalar multiplication of 'r' and 'y', then the extension to function of the maximum adjoin 'i' and function 'f' at 'x' is equal to the linear map of the extension of the maximum 'i' and function 'f' at 'a' plus the extension of the ideal to the maximum adjoin 'i' and function 'f' at 'y' and 'r'.",
    "output": "theorem ExtensionOfMaxAdjoin.extensionToFun_wd (h : Module.Baer R Q) {y : N}\n    (x : supExtensionOfMaxSingleton i f y) (a : (extensionOfMax i f).domain)\n    (r : R) (eq1 : â†‘x = â†‘a + r â€¢ y) :\n    ExtensionOfMaxAdjoin.extensionToFun i f h x =\n      (extensionOfMax i f).toLinearPMap a + ExtensionOfMaxAdjoin.extendIdealTo i f h y r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function F, which maps from a set X to a set Î±, tends to a function f under a filter l, and if F is equicontinuous at a point xâ‚€ in X, then the function f is continuous at the point xâ‚€. This theorem assumes that the filter l is not the bottom element.",
    "output": "theorem Filter.Tendsto.continuousAt_of_equicontinuousAt {l : Filter Î¹} [l.NeBot] {F : Î¹ â†’ X â†’ Î±}\n    {f : X â†’ Î±} {xâ‚€ : X} (hâ‚ : Tendsto F l (ğ“ f)) (hâ‚‚ : EquicontinuousAt F xâ‚€) :\n    ContinuousAt f xâ‚€ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a ring homomorphism 'f' from ring 'R' to ring 'Sâ‚‚', and a multivariate polynomial 'p' over the ring 'R' and variables 'Ïƒ', the evaluation of 'p' at zero using 'f' is equal to the application of 'f' to the constant coefficient of 'p'.",
    "output": "theorem evalâ‚‚_zero_apply (f : R â†’+* Sâ‚‚) (p : MvPolynomial Ïƒ R) :\n    evalâ‚‚ f (0 : Ïƒ â†’ Sâ‚‚) p = f (constantCoeff p) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'f' from set R to set S, and this function is monotone (meaning it either always increases or always decreases), and we have a sequence 'a' in set R, and the function 'f' is continuous at the least upper bound of the sequence 'a', then the value of the function 'f' at the least upper bound of the sequence 'a' is equal to the least upper bound of the sequence obtained by applying the function 'f' to each element of the sequence 'a'.",
    "output": "theorem Monotone.map_limsup_of_continuousAt {f : R â†’ S} (f_incr : Monotone f) (a : Î¹ â†’ R)\n    (f_cont : ContinuousAt f (F.limsup a)) : f (F.limsup a) = F.limsup (f âˆ˜ a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a finite measure Î¼, a real number p that is greater than or equal to 1 and not infinity, a sequence of strongly measurable functions f indexed by natural numbers, and a strongly measurable function g such that g belongs to Lp space and the sequence of functions f is uniformly integrable with respect to p and Î¼. Moreover, for almost every x with respect to the measure Î¼, the sequence of functions f evaluated at x tends to the function g evaluated at x. Then, the sequence of the pth power norm of the difference between the functions f and g tends to 0.",
    "output": "theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âˆ)\n    {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)\n    (hg' : Memâ„’p g p Î¼) (hui : UnifIntegrable f p Î¼)\n    (hfg : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) atTop (ğ“ (g x))) :\n    Tendsto (fun n => snorm (f n - g) p Î¼) atTop (ğ“ 0) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given permutation 'f' and any two elements 'x' and 'y', the operation of swapping 'x' and 'y' and then applying 'f' is equivalent to applying 'f' first and then swapping the images of 'x' and 'y' under the inverse of 'f'.",
    "output": "theorem swap_mul_eq_mul_swap (f : Perm Î±) (x y : Î±) : swap x y * f = f * swap (fâ»Â¹ x) (fâ»Â¹ y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' from a set 'Î±' to a set 'Î²', where 'Î²' has a preorder and a zero element, and 'f' is almost everywhere measurable with respect to a measure 'Î¼', and 'f' is nonnegative almost everywhere with respect to 'Î¼', there exists a function 'g' that is measurable, nonnegative, and equal to 'f' almost everywhere with respect to 'Î¼'.",
    "output": "theorem exists_measurable_nonneg {Î²} [Preorder Î²] [Zero Î²] {mÎ² : MeasurableSpace Î²} {f : Î± â†’ Î²}\n    (hf : AEMeasurable f Î¼) (f_nn : âˆ€áµ t âˆ‚Î¼, 0 â‰¤ f t) : âˆƒ g, Measurable g âˆ§ 0 â‰¤ g âˆ§ f =áµ[Î¼] g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given natural number 'n', a real number 'Îµ' greater than 0, and a non-zero polynomial 'b' over a finite field 'Fq', and a function 'A' mapping from 'n' finite elements to polynomials over 'Fq', there exists a function 't' mapping from 'n' finite elements to finite elements of the cardinality of 'Fq' raised to the ceiling of the negative logarithm of 'Îµ' divided by the logarithm of the cardinality of 'Fq'. For this function 't', for any two finite elements 'iâ‚€' and 'iâ‚' of 'n', 't' of 'iâ‚€' equals 't' of 'iâ‚' if and only if the real number representation of the degree of the polynomial obtained by subtracting the remainder of 'A' of 'iâ‚€' divided by 'b' from the remainder of 'A' of 'iâ‚' divided by 'b', raised to the power of the cardinality of 'Fq', is less than the degree of 'b' raised to the power of the cardinality of 'Fq' multiplied by 'Îµ'.",
    "output": "theorem exists_partition_polynomial_aux (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : Fq[X]} (hb : b â‰  0)\n    (A : Fin n â†’ Fq[X]) : âˆƒ t : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log (Fintype.card Fq)âŒ‰â‚Š),\n      âˆ€ iâ‚€ iâ‚ : Fin n, t iâ‚€ = t iâ‚ â†”\n        (cardPowDegree (A iâ‚ % b - A iâ‚€ % b) : â„) < cardPowDegree b â€¢ Îµ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a countable index set Î¹, if every set f(b) indexed by b is measurable, then the intersection of all these sets f(b) is also measurable.",
    "output": "theorem MeasurableSet.iInter [Countable Î¹] {f : Î¹ â†’ Set Î±} (h : âˆ€ b, MeasurableSet (f b)) :\n    MeasurableSet (â‹‚ b, f b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The map of the inclusion of N into the preimage (under the inclusion of N) of N' is equal to the intersection of N and N'.",
    "output": "theorem map_comap_incl : map N.incl (comap N.incl N') = N âŠ“ N' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given value 'x' in the field 'ğ•œ', the function 'aeval x q' has a derivative within the set 's' at the point 'x'. The derivative is given by the function 'smulRight' applied to the number 1 (considered as a continuous linear map from 'ğ•œ' to 'ğ•œ') and the result of applying 'aeval x' to the derivative of 'q'.",
    "output": "theorem hasFDerivWithinAt_aeval (x : ğ•œ) :\n    HasFDerivWithinAt (fun x => aeval x q) (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ)\n      (aeval x (derivative q))) s x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer n, the open intervals from b to the power of n to b to the power of n+1 are pairwise disjoint.",
    "output": "theorem pairwise_disjoint_Ioo_zpow :\n    Pairwise (Disjoint on fun n : â„¤ => Ioo (b ^ n) (b ^ (n + 1))) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a functor 'F' from category 'C' to category 'D' and an object 'X' in category 'C', the mapping of the identity isomorphism of 'X' under 'F' is equal to the identity isomorphism of the image of 'X' under 'F'.",
    "output": "theorem mapIso_refl (F : C â¥¤ D) (X : C) : F.mapIso (Iso.refl X) = Iso.refl (F.obj X) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given setoid 't' of type 'Î²', a function 'f' from 'Î±' to 'Î²', a proof 'h', and an element 'x' of type 'Î±', mapping 'f' over the quotient of 'x' under the equivalence relation 's' is equal to the quotient of the image of 'x' under 'f' under the equivalence relation 't'.",
    "output": "theorem map'_mk [t : Setoid Î²] (f : Î± â†’ Î²) (h) (x : Î±) :\n    (Quotient.mk s x).map' f h = (Quotient.mk t (f x)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a convex cone S is blunt, then S is also salient.",
    "output": "theorem Blunt.salient {S : ConvexCone ğ•œ E} : S.Blunt â†’ S.Salient :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given a prime ideal I, such that I is a subset of J, and a ring element r that belongs to the set difference of J and I, if the polynomial p mapped by the quotient of the preimage of f is not zero and the evaluation of p at r using f is in I, then there exists a coefficient i of p such that i belongs to the set difference of the preimage of J under f and the preimage of I under f.",
    "output": "theorem exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff [IsPrime I] (hIJ : I â‰¤ J) {r : S}\n    (hr : r âˆˆ (J : Set S) \\ I) {p : R[X]} (p_ne_zero : p.map (Quotient.mk (I.comap f)) â‰  0)\n    (hpI : p.evalâ‚‚ f r âˆˆ I) : âˆƒ i, p.coeff i âˆˆ (J.comap f : Set R) \\ I.comap f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'l' and a function 'f' from 'Î±' to 'WeakBilin B', and a 'WeakBilin B' 'x', if 'B' is a function that is injective, then 'f' tends to 'x' with respect to the filter 'l' if and only if for all 'y', the function that maps 'i' to 'B' of 'f' of 'i' and 'y' tends to 'B' of 'x' and 'y' with respect to the filter 'l'.",
    "output": "theorem tendsto_iff_forall_eval_tendsto {l : Filter Î±} {f : Î± â†’ WeakBilin B} {x : WeakBilin B}\n    (hB : Function.Injective B) :\n    Tendsto f l (ğ“ x) â†” âˆ€ y, Tendsto (fun i => B (f i) y) l (ğ“ (B x y)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all properties 'p' of an element 'Î±' and 'q' of an element 'Î²', and given a bijective function 'f' from 'Î±' to 'Î²', if for all 'x', 'p' of the inverse of 'f' at 'x' is equivalent to 'q' at 'x', then the statement \"for all 'x', 'p' of 'x' is true\" is equivalent to the statement \"for all 'y', 'q' of 'y' is true\".",
    "output": "theorem forall_congr' {p : Î± â†’ Prop} {q : Î² â†’ Prop} (f : Î± â‰ƒ Î²)\n    (h : âˆ€ {x}, p (f.symm x) â†” q x) : (âˆ€ x, p x) â†” âˆ€ y, q y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'circleMap' with parameters 'c' (a complex number) and 'R' (a real number) is periodic with a period of '2 * Ï€'.",
    "output": "theorem periodic_circleMap (c : â„‚) (R : â„) : Periodic (circleMap c R) (2 * Ï€) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a sequence of functions 'u' is summable, and for all 'n' and 'x', the function 'f n' has a derivative at 'x' given by 'f' n x', and the norm of 'f' n x' is less than or equal to 'u n', then the function defined by the sum of 'f n y' for all 'n' is differentiable.",
    "output": "theorem differentiable_tsum (hu : Summable u) (hf : âˆ€ n x, HasFDerivAt (f n) (f' n x) x)\n    (hf' : âˆ€ n x, â€–f' n xâ€– â‰¤ u n) : Differentiable ğ•œ fun y => âˆ‘' n, f n y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of replicating a number 'a' 'n' times is equal to 'a' raised to the power of 'n'.",
    "output": "theorem prod_replicate (n : â„•) (a : Î±) : (replicate n a).prod = a ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f is Big O of g with respect to l and a constant c, and g is little o of k with respect to l, and if c is greater than 0, then f is little o of k with respect to l.",
    "output": "theorem IsBigOWith.trans_isLittleO (hfg : IsBigOWith c l f g) (hgk : g =o[l] k) (hc : 0 < c) :\n    f =o[l] k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given natural number 'n' and a given element 'x' of the finite set of size 'n+1', the function 'succAbove' applied to 'x' is equal for 'a' and 'b' if and only if 'a' is equal to 'b'.",
    "output": "theorem succAbove_right_inj {x : Fin (n + 1)} : x.succAbove a = x.succAbove b â†” a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n' greater than 0, the predecessor of 'n' in the set of positive natural numbers is equal to the predecessor of 'n' in the set of all natural numbers.",
    "output": "theorem natPred_eq_pred {n : â„•} (h : 0 < n) : natPred (âŸ¨n, hâŸ© : â„•+) = n.pred :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a set with seminorms 'p', and for every non-zero element 'x' there exists an 'i' such that the seminorm of 'x' with respect to 'i' is not zero, then the topological space 'E' is a T1 space.",
    "output": "theorem WithSeminorms.T1_of_separating (hp : WithSeminorms p)\n    (h : âˆ€ x, x â‰  0 â†’ âˆƒ i, p i x â‰  0) : T1Space E :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a quasi measure preserving function 'f' from 'Î±' to 'Î²', and two functions 'g' and 'g'' from 'Î²' to 'Î´', if 'g' is almost everywhere equal to 'g'' with respect to measure 'Î½', then the composition of 'g' and 'f' is almost everywhere equal to the composition of 'g'' and 'f' with respect to measure 'Î¼'.",
    "output": "theorem Measure.QuasiMeasurePreserving.ae_eq_comp {Î½ : Measure Î²} {f : Î± â†’ Î²} {g g' : Î² â†’ Î´}\n    (hf : QuasiMeasurePreserving f Î¼ Î½) (h : g =áµ[Î½] g') : g âˆ˜ f =áµ[Î¼] g' âˆ˜ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The degree of a monomial with a natural number 'n' and a coefficient 'a' from the ring 'R' is less than or equal to 'n'.",
    "output": "theorem degree_monomial_le (n : â„•) (a : R) : degree (monomial n a) â‰¤ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nonempty set A and a finite set B, with m and n as natural numbers, the cardinality of the set obtained by raising B to the power m and then dividing by B raised to the power n, is less than or equal to the cardinality of the set obtained by multiplying A and B, divided by the cardinality of A, all raised to the power of m plus n, and then multiplied by the cardinality of A. This is expressed in terms of nonnegative rational numbers.",
    "output": "theorem card_pow_div_pow_le (hA : A.Nonempty) (B : Finset Î±) (m n : â„•) :\n    ((B ^ m / B ^ n).card) â‰¤ ((A * B).card / A.card : â„šâ‰¥0) ^ (m + n) * A.card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'p' is a prime number in the p-adic integers.",
    "output": "theorem prime_p : Prime (p : â„¤_[p]) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The real number r is less than or equal to the real number q if and only if the non-negative extended real number representation of r is less than or equal to the non-negative extended real number representation of q.",
    "output": "theorem coe_le_coe : (â†‘r : â„â‰¥0âˆ) â‰¤ â†‘q â†” r â‰¤ q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is not infinity and b is not zero, then there exists a positive real number n such that the product of n and a is less than b.",
    "output": "theorem exists_nnreal_pos_mul_lt (ha : a â‰  âˆ) (hb : b â‰  0) : âˆƒ n > 0, â†‘(n : â„â‰¥0) * a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a summable function 'f' and a constant 'a' from a topological space 'M' that is also a T2 space (also known as a Hausdorff space), the infinite sum of the product of the function 'f' evaluated at 'z' and the constant 'a' is equal to the product of the infinite sum of the function 'f' evaluated at 'z' and the constant 'a'.",
    "output": "theorem tsum_smul_const [T2Space M] (hf : Summable f) (a : M) : (âˆ‘' z, f z â€¢ a) = (âˆ‘' z, f z) â€¢ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given ring homomorphism 'j' from ring 'L' to ring 'F', and a given polynomial 'f' over ring 'K', the polynomial 'f' splits over 'j' after mapping with 'i' if and only if 'f' splits over the composition of 'j' and 'i'.",
    "output": "theorem splits_map_iff (j : L â†’+* F) {f : K[X]} : Splits j (f.map i) â†” Splits (j.comp i) f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If Î² is a topological space and a T0 space, and if there is an embedding function f from Î± to Î², then Î± is also a T0 space.",
    "output": "theorem Embedding.t0Space [TopologicalSpace Î²] [T0Space Î²] {f : Î± â†’ Î²}\n    (hf : Embedding f) : T0Space Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given path 'p' from point 'a' to point 'b', the composition function 'p.comp' (which takes a path from 'b' to 'c' and returns a path from 'a' to 'c') is injective. In other words, if two paths from 'b' to 'c' are mapped to the same path from 'a' to 'c' by the composition function, then those two paths must have been the same to begin with.",
    "output": "theorem comp_injective_right (p : Path a b) : Injective (p.comp : Path b c â†’ Path a c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function g from Î± to ğ•œ and a non-zero constant c from ğ•œ, the function f is Big O of the function that multiplies c and g at limit l if and only if the function f is Big O of g at limit l.",
    "output": "theorem isBigO_const_mul_right_iff {g : Î± â†’ ğ•œ} {c : ğ•œ} (hc : c â‰  0) :\n    (f =O[l] fun x => c * g x) â†” f =O[l] g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a polynomial 'p' in field 'K', the numerator of the algebraic mapping of 'p' is equal to 'p' itself.",
    "output": "theorem num_algebraMap (p : K[X]) : num (algebraMap _ _ p) = p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The arccosine of a real number x is less than pi divided by 2 if and only if x is greater than 0.",
    "output": "theorem arccos_lt_pi_div_two {x : â„} : arccos x < Ï€ / 2 â†” 0 < x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a bilinear form B over a field K and a vector space V, if B is nondegenerate and reflexive, and a vector x is not orthogonal to itself, then the restriction of B to the orthogonal complement of the span of x is also nondegenerate.",
    "output": "theorem restrictOrthogonalSpanSingletonNondegenerate (B : BilinForm K V) (bâ‚ : B.Nondegenerate)\n    (bâ‚‚ : B.IsRefl) {x : V} (hx : Â¬B.IsOrtho x x) :\n    Nondegenerate <| B.restrict <| B.orthogonal (K âˆ™ x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite subgroup H, the cardinality of H is less than or equal to 1 if and only if H is the trivial group.",
    "output": "theorem card_le_one_iff_eq_bot [Fintype H] : Fintype.card H â‰¤ 1 â†” H = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a partially ordered set with a least element (denoted as âŠ¥), the interval from the least element to any given element is equal to the set containing only the least element.",
    "output": "theorem Iic_bot [PartialOrder Î±] [OrderBot Î±] : Iic (âŠ¥ : Î±) = {âŠ¥} :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f has a local minimum at a point a and function g also has a local minimum at the same point a, then the function that takes the minimum of f(x) and g(x) for each x also has a local minimum at point a.",
    "output": "theorem IsLocalMin.min (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\n    IsLocalMin (fun x => min (f x) (g x)) a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'x' tends to a filter 'f' along a filter 'l' if and only if for every set 's' in the filter 'f', eventually for every 'n' in the filter 'l', 'x n' is an element of 's'.",
    "output": "theorem tendsto_iff_forall_eventually_mem {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} :\n    Tendsto x l f â†” âˆ€ s âˆˆ f, âˆ€á¶  n in l, x n âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' from an ordered set 'Î²', the inequality 'a' is less than 'b' is equivalent to the inequality 'inr a' is less than 'inr b' in the sum of two ordered sets 'Î±' and 'Î²'. Here, 'inr' is a function that injects 'Î²' into the sum 'Î± + Î²'.",
    "output": "theorem inr_lt_inr_iff [LT Î±] [LT Î²] {a b : Î²} : (inr a : Sum Î± Î²) < inr b â†” a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two natural numbers 'a' and 'b', if 'a' divides 'b' and the quotient of 'b' divided by 'a' is zero, then 'b' must be zero.",
    "output": "theorem eq_zero_of_dvd_of_div_eq_zero {a b : â„•} (w : a âˆ£ b) (h : b / a = 0) : b = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integers x and y, the value of the auxiliary extended greatest common divisor function (xgcdAux) with parameters x, 1, 0, y, 0, 1 is equal to the pair consisting of the greatest common divisor of x and y, and the result of the extended greatest common divisor function (xgcd) on x and y.",
    "output": "theorem xgcd_aux_val (x y) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given measure Î¼, the function that maps every element of Î± to 1 in Î² is equal to the function that strongly measures the constant 1. This is under the condition that Î² has a defined operation of 1.",
    "output": "theorem one_def [One Î²] : (1 : Î± â†’â‚˜[Î¼] Î²) = mk (fun _ : Î± => 1) aestronglyMeasurable_const :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a covariant class Î± with respect to multiplication and less than or equal to relation, if a is less than or equal to d, b is less than or equal to e, and c is less than or equal to f, then the product of a, b, and c is less than or equal to the product of d, e, and f.",
    "output": "theorem mul_le_mul_three [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]\n    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)] {a b c d e f : Î±} (hâ‚ : a â‰¤ d) (hâ‚‚ : b â‰¤ e)\n    (hâ‚ƒ : c â‰¤ f) :\n    a * b * c â‰¤ d * e * f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The zero locus of the supremum of a collection of ideals (indexed by Î¹) is equal to the intersection of the zero loci of each individual ideal in the collection.",
    "output": "theorem zeroLocus_iSup {Î¹ : Sort _} (I : Î¹ â†’ Ideal R) :\n    zeroLocus ((â¨† i, I i : Ideal R) : Set R) = â‹‚ i, zeroLocus (I i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nonempty set Î± and an element b from set Î², the norm of the constant function from Î± to b is equal to the norm of b.",
    "output": "theorem norm_const_eq [h : Nonempty Î±] (b : Î²) : â€–const Î± bâ€– = â€–bâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a constant function (fun _ => c) in a filter L, the Frechet derivative at any point x in the domain E is zero. This is because the constant function does not change, so its rate of change (derivative) is zero.",
    "output": "theorem hasFDerivAtFilter_const (c : F) (x : E) (L : Filter E) :\n    HasFDerivAtFilter (fun _ => c) (0 : E â†’L[ğ•œ] F) x L :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For an injective function 'f' and an element 'x' from a set 'L', the equivalence of the range of the injective function 'f' applied to 'x' is equal to the pair consisting of 'f' applied to 'x' and the proof that 'f' applied to 'x' is in the range of 'f'.",
    "output": "theorem equivRangeOfInjective_apply (h : Function.Injective f) (x : L) :\n    f.equivRangeOfInjective h x = âŸ¨f x, mem_range_self f xâŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two matrices M and N, the product of the negation of M and N is equal to the negation of the product of M and N.",
    "output": "theorem neg_mul (M : Matrix m n Î±) (N : Matrix n o Î±) : (-M) â¬ N = -M â¬ N :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function from a pair of elements, one from set Î± and one from set Î², to a set M, if both set Î± and set Î² are finite, then the product of the function values over all elements in set Î± and for each of these, over all elements in set Î², is equal to the product of the function values over all elements in set Î² and for each of these, over all elements in set Î±. This essentially means that the order of taking the product does not matter.",
    "output": "theorem finprod_mem_comm {s : Set Î±} {t : Set Î²} (f : Î± â†’ Î² â†’ M) (hs : s.Finite) (ht : t.Finite) :\n    (âˆá¶  i âˆˆ s, âˆá¶  j âˆˆ t, f i j) = âˆá¶  j âˆˆ t, âˆá¶  i âˆˆ s, f i j :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"a\" raised to the power of an odd number \"n\" is less than zero if and only if \"a\" is less than zero.",
    "output": "theorem zpow_bit1_neg_iff : a ^ bit1 n < 0 â†” a < 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any composition as a set 'c', the boundaries of the composition converted to a regular composition are equal to the boundaries of the original composition as a set.",
    "output": "theorem CompositionAsSet.toComposition_boundaries (c : CompositionAsSet n) :\n    c.toComposition.boundaries = c.boundaries :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map T from a vector space E to itself that is self-adjoint, and a submodule U of the vector space E that is a complete space, the composition of the linear map U.subtypeL, the orthogonal projection onto U, the linear map T, the linear map U.subtypeL, and the orthogonal projection onto U is also self-adjoint.",
    "output": "theorem conj_orthogonalProjection {T : E â†’L[ğ•œ] E} (hT : IsSelfAdjoint T) (U : Submodule ğ•œ E)\n    [CompleteSpace U] :\n    IsSelfAdjoint\n      (U.subtypeL âˆ˜L orthogonalProjection U âˆ˜L T âˆ˜L U.subtypeL âˆ˜L orthogonalProjection U) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function from natural numbers to a set Î², and for any two natural numbers m and n, the product of the function's values over the interval from m to n (excluding n) is equal to the product of the function's values over the range from 0 to (n - m), where the function's argument is (m + k).",
    "output": "theorem prod_Ico_eq_prod_range (f : â„• â†’ Î²) (m n : â„•) :\n    (âˆ k in Ico m n, f k) = âˆ k in range (n - m), f (m + k) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The coefficient of the nth term of the negative of a polynomial p is equal to the negative of the coefficient of the nth term of the polynomial p.",
    "output": "theorem coeff_neg (p : R[X]) (n : â„•) : coeff (-p) n = -coeff p n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the cardinality (or the number of elements) of the support of a polynomial f is greater than or equal to 2, then erasing the leading term of f will not result in a zero polynomial.",
    "output": "theorem eraseLead_ne_zero (f0 : 2 â‰¤ f.support.card) : eraseLead f â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any submodule 'p' of a vector space 'V' over a field 'K', there exists a nonempty linear equivalence between the direct product of the quotient space 'V/p' and 'p' and the vector space 'V'.",
    "output": "theorem quotient_prod_linearEquiv (p : Submodule K V) : Nonempty (((V â§¸ p) Ã— p) â‰ƒâ‚—[K] V) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given non-negative real number p, a measurable set t, a measure Î¼ such that Î¼(t) is not infinite, and an element x from a set E, the integral of the indicator function of constant Lp over the set a with respect to the measure Î¼ is equal to the real part of the measure of the set t multiplied by the element x.",
    "output": "theorem integral_indicatorConstLp {p : â„â‰¥0âˆ} (ht : MeasurableSet t) (hÎ¼t : Î¼ t â‰  âˆ) (x : E) :\n    (âˆ« a, indicatorConstLp p ht hÎ¼t x a âˆ‚Î¼) = (Î¼ t).toReal â€¢ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero constant 'c' and any constant 'd', the integral from 'a' to 'b' of the function 'f' evaluated at 'd + c * x' is equal to the reciprocal of 'c' times the integral from 'd + c * a' to 'd + c * b' of the function 'f' evaluated at 'x'.",
    "output": "theorem integral_comp_add_mul (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (d + c * x)) = câ»Â¹ â€¢ âˆ« x in d + c * a..d + c * b, f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a real-valued function g and a positive real number p, the integral over the interval greater than 0 of p times x to the power of (p - 1) times the function g of x to the power of p, is equal to the integral over the interval greater than 0 of the function g of y.",
    "output": "theorem integral_comp_rpow_Ioi_of_pos {g : â„ â†’ E} {p : â„} (hp : 0 < p) :\n    (âˆ« x in Ioi 0, (p * x ^ (p - 1)) â€¢ g (x ^ p)) = âˆ« y in Ioi 0, g y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Removing the left operation from the identity natural transformation of the left operation of a functor F equals the identity functor of F.",
    "output": "theorem removeLeftOp_id : NatTrans.removeLeftOp (ğŸ™ F.leftOp) = ğŸ™ F :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have three elements x, y, and z from a ring S, and if x and y are integral elements under a ring homomorphism f, and if z is in the subring closure of the set containing x and y, then z is also an integral element under the ring homomorphism f.",
    "output": "theorem RingHom.is_integral_of_mem_closure {x y z : S} (hx : f.IsIntegralElem x)\n    (hy : f.IsIntegralElem y) (hz : z âˆˆ Subring.closure ({x, y} : Set S)) : f.IsIntegralElem z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of a set 'A', the image of the set of integer multiples of 'x' under the function that converts additive notation to multiplicative notation is equal to the set of integer powers of 'x' under multiplicative notation.",
    "output": "theorem ofAdd_image_zmultiples_eq_zpowers_ofAdd {x : A} :\n    Multiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) =\n      Subgroup.zpowers (Multiplicative.ofAdd x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the space M over the ideal I is Hausdorff, then for any element x in M, if x is congruent to 0 modulo the nth power of I times the top submodule of R over M for all natural numbers n, then x equals 0.",
    "output": "theorem IsHausdorff.haus (_ : IsHausdorff I M) :\n    âˆ€ x : M, (âˆ€ n : â„•, x â‰¡ 0 [SMOD (I ^ n â€¢ âŠ¤ : Submodule R M)]) â†’ x = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' that takes two inputs of types 'Î±' and 'Î²' and returns an output of type 'Î³', and for two lists 'l' and 'l'' of types 'Î±' and 'Î²' respectively, mapping the uncurried version of 'f' over the zipped version of 'l' and 'l'' is equivalent to zipping 'l' and 'l'' with 'f'.",
    "output": "theorem map_uncurry_zip_eq_zipWith (f : Î± â†’ Î² â†’ Î³) (l : List Î±) (l' : List Î²) :\n    map (Function.uncurry f) (l.zip l') = zipWith f l l' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'c' of type 'Sâ‚‚', the iteration of the function 'iterToSum' applied to the polynomial 'C (X c)' is equal to the polynomial 'X (Sum.inr c)'.",
    "output": "theorem iterToSum_C_X (c : Sâ‚‚) : iterToSum R Sâ‚ Sâ‚‚ (C (X c)) = X (Sum.inr c) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter 'l' and sets 's' and 't' of any type 'Î±', if 's' is a subset of 't', then 's' is eventually less than or equal to 't' with respect to the filter 'l'.",
    "output": "theorem HasSubset.Subset.eventuallyLE {Î±} {l : Filter Î±} {s t : Set Î±} (h : s âŠ† t) : s â‰¤á¶ [l] t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'hV' is a Hilbert sum of a field 'ğ•œ', a set 'G', and a vector space 'V', then for any element 'w' in the sequence space 'lp G 2', the sum of the function 'V i (w i)' over all 'i' equals the inverse of the linear isometry equivalence of 'hV' applied to 'w'. This is under the condition that the sum exists (HasSum).",
    "output": "theorem IsHilbertSum.hasSum_linearIsometryEquiv_symm (hV : IsHilbertSum ğ•œ G V)\n    (w : lp G 2) : HasSum (fun i => V i (w i)) (hV.linearIsometryEquiv.symm w) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'p' and 'q' are properties of an element 'x' in a set 'Î±', and both 'p' and 'q' are monotone (meaning they either always increase or always decrease), then the function that checks if both 'p' and 'q' are true for 'x' is also monotone.",
    "output": "theorem monotone_and {p q : Î± â†’ Prop} (m_p : Monotone p) (m_q : Monotone q) :\n    Monotone fun x => p x âˆ§ q x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is the smallest element and 'b' is the smallest element, then the pair (a, b) is also the smallest element.",
    "output": "theorem IsBot.prod_mk (ha : IsBot a) (hb : IsBot b) : IsBot (a, b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is not bounded below if and only if for every 'x', there exists a 'y' in 's' such that 'x' is not less than or equal to 'y'.",
    "output": "theorem not_bddBelow_iff' : Â¬BddBelow s â†” âˆ€ x, âˆƒ y âˆˆ s, Â¬x â‰¤ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is continuously differentiable on a closed subset 's' of the field 'ğ•œ', then the function that adds a constant 'c' to 'f' at each point 'x' is also continuously differentiable on 's'.",
    "output": "theorem const_add (hf : DiffContOnCl ğ•œ f s) (c : F) : DiffContOnCl ğ•œ (fun x => c + f x) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for all real numbers 'y' not equal to 'x', the function 'f' has a derivative at 'y' equal to 'g(y)', and if 'f' is continuous at 'x' and 'g' is also continuous at 'x', then 'f' has a derivative at 'x' equal to 'g(x)'.",
    "output": "theorem hasDerivAt_of_hasDerivAt_of_ne {f g : â„ â†’ E} {x : â„}\n    (f_diff : âˆ€ (y) (_ : y â‰  x), HasDerivAt f (g y) y) (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) : HasDerivAt f (g x) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse function of converting a matrix to a bilinear form, under the equivalence relation over the ring Râ‚‚, is equal to the function of converting a bilinear form to a matrix.",
    "output": "theorem Matrix.toBilin'_symm :\n    (Matrix.toBilin'.symm : _ â‰ƒâ‚—[Râ‚‚] Matrix n n Râ‚‚) = BilinForm.toMatrix' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number x, the absolute value of the sine of x is equal to the square root of (1 minus the square of the cosine of x).",
    "output": "theorem abs_sin_eq_sqrt_one_sub_cos_sq (x : â„) : |sin x| = sqrt (1 - cos x ^ 2) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The pairwise filter of an empty list under any relation R is an empty list.",
    "output": "theorem pwFilter_nil : pwFilter R [] = [] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a measurable set 's' and for almost every 'x' in the measure 'Î¼', if 'x' is in 's' then 'f(x)' is less than or equal to 'g(x)', then the integral of 'f' over 's' with respect to 'Î¼' is less than or equal to the integral of 'g' over 's' with respect to 'Î¼'.",
    "output": "theorem set_integral_mono_on_ae (hs : MeasurableSet s) (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x â‰¤ g x) :\n    (âˆ« a in s, f a âˆ‚Î¼) â‰¤ âˆ« a in s, g a âˆ‚Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'f' from module 'M' to 'Mâ‚ƒ', and another linear map 'g' from module 'Mâ‚‚' to 'Mâ‚ƒ', and for submodules 'p' of 'M' and 'q' of 'Mâ‚‚', the map of the coproduct of 'f' and 'g' on the product of 'p' and 'q' is equal to the superset of the map of 'f' on 'p' and the map of 'g' on 'q'.",
    "output": "theorem map_coprod_prod (f : M â†’â‚—[R] Mâ‚ƒ) (g : Mâ‚‚ â†’â‚—[R] Mâ‚ƒ) (p : Submodule R M)\n    (q : Submodule R Mâ‚‚) : map (coprod f g) (p.prod q) = map f p âŠ” map g q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a preconnected space, the frontier of a set is empty if and only if the set is either empty or the entire universe.",
    "output": "theorem frontier_eq_empty_iff [PreconnectedSpace Î±] {s : Set Î±} :\n    frontier s = âˆ… â†” s = âˆ… âˆ¨ s = univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a is non-negative (greater than or equal to zero) and less than b, then the square of a is less than the square of b.",
    "output": "theorem mul_self_lt_mul_self (h1 : 0 â‰¤ a) (h2 : a < b) : a * a < b * b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If b is less than or equal to a, then subtracting b from a and then adding c is equal to adding c to a and then subtracting b.",
    "output": "theorem tsub_add_eq_add_tsub (h : b â‰¤ a) : a - b + c = a + c - b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' and a function 'f' from 'Î²' to the set of 'Î±', if every 'f i' for all 'i' in 's' is closed, then the intersection of 'f i' for all 'i' in 's' is also closed.",
    "output": "theorem isClosed_biInter {s : Set Î²} {f : Î² â†’ Set Î±} (h : âˆ€ i âˆˆ s, IsClosed (f i)) :\n    IsClosed (â‹‚ i âˆˆ s, f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is continuously differentiable at a point 'x' in the field 'ğ•‚', and the order of differentiation 'n' is greater than or equal to 1, then 'f' has a strict derivative at 'x', and the value of this derivative is the derivative of 'f' at 'x'.",
    "output": "theorem ContDiffAt.hasStrictDerivAt {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : ContDiffAt ğ•‚ n f x) (hn : 1 â‰¤ n) :\n    HasStrictDerivAt f (deriv f x) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a non-zero constant 'c' and a function 'f' from 'Î±' to 'ğ•œ', the function 'f' is Big O of the function 'x' maps to 'c' times 'f(x)' at the limit 'l', with a constant of proportionality equal to the reciprocal of the norm of 'c'.",
    "output": "theorem isBigOWith_self_const_mul (c : ğ•œ) (hc : c â‰  0) (f : Î± â†’ ğ•œ) (l : Filter Î±) :\n    IsBigOWith â€–câ€–â»Â¹ l f fun x => c * f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a pseudometrizable space Î² and a measurable space Î±, a function f is almost everywhere strongly measurable with respect to the sum of measures Î¼ if and only if the function f is almost everywhere strongly measurable with respect to each individual measure Î¼ i.",
    "output": "theorem _root_.aestronglyMeasurable_sum_measure_iff [PseudoMetrizableSpace Î²]\n    {_m : MeasurableSpace Î±} {Î¼ : Î¹ â†’ Measure Î±} :\n    AEStronglyMeasurable f (sum Î¼) â†” âˆ€ i, AEStronglyMeasurable f (Î¼ i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is nontrivial if and only if there exists elements 'x' and 'y' in 's' such that 'x' is less than 'y'. This is under the condition that 'Î±' is a linear order.",
    "output": "theorem nontrivial_iff_exists_lt [LinearOrder Î±] :\n    s.Nontrivial â†” âˆƒ (x : Î±) (_ : x âˆˆ s) (y : Î±) (_ : y âˆˆ s), x < y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a prime number p and a finite group G, the cardinality (or the number of elements) of the Sylow p-subgroup of G is equal to the cardinality of the quotient group formed by G and the normalizer of the Sylow p-subgroup in G.",
    "output": "theorem card_sylow_eq_card_quotient_normalizer [Fact p.Prime] [Fintype (Sylow p G)]\n    (P : Sylow p G) : card (Sylow p G) = card (G â§¸ (P : Subgroup G).normalizer) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' in the dual of 'Î±', the dual of the Heyting implication from 'a' to 'b' is equal to the set difference of the dual of 'b' and the dual of 'a'.",
    "output": "theorem ofDual_himp (a b : Î±áµ’áµˆ) : ofDual (a â‡¨ b) = ofDual b \\ ofDual a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î±, there exists a nonempty erased type of Î± if and only if Î± is nonempty.",
    "output": "theorem nonempty_iff {Î±} : Nonempty (Erased Î±) â†” Nonempty Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'v' (from a set 'Î¹' to a set 'M') is not injective, then the result of applying another function 'f' to 'v' is zero.",
    "output": "theorem map_eq_zero_of_not_injective (v : Î¹ â†’ M) (hv : Â¬Function.Injective v) : f v = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two distinct elements 'a' and 'a'' of type Î±, any value 'v' of type Î² at 'a'', and any function 'f' from Î± to Î², updating the function 'f' at 'a'' with the value 'v' and then applying it to 'a' gives the same result as simply applying 'f' to 'a'. This is because 'a' and 'a'' are distinct, so updating the function at 'a'' does not affect its value at 'a'.",
    "output": "theorem update_noteq {a a' : Î±} (h : a â‰  a') (v : Î² a') (f : âˆ€ a, Î² a) : update f a' v a = f a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', the value of '1' in the finite set of size 'n + 2' is equal to '1'.",
    "output": "theorem val_one (n : â„•) : (1 : Fin (n + 2)).val = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any finite number 'k' within a set of size 'm' and any natural number 'n', applying the function 'finAddFlip' to the result of casting 'k' with an added 'n' is equivalent to adding 'n' to 'k' using the 'Fin.natAdd' function.",
    "output": "theorem finAddFlip_apply_castAdd (k : Fin m) (n : â„•) :\n    finAddFlip (Fin.castAdd n k) = Fin.natAdd n k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types M and N, where N is a monoid and there is a scalar multiplication operation between M and N, if for every element x of M and y of N, the operation y multiplied by the scalar multiplication of x and the identity element of N equals the scalar multiplication of x and y, then the scalar multiplication operation is commutative between M, N, and N.",
    "output": "theorem SMulCommClass.of_mul_smul_one {M N} [Monoid N] [SMul M N]\n    (H : âˆ€ (x : M) (y : N), y * x â€¢ (1 : N) = x â€¢ y) : SMulCommClass M N N :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given equivalence relation between two sets n and m, and a given matrix A with elements from set n, the inverse of the reindexed matrix A (with the reindexing defined by the equivalence relations eâ‚ and eâ‚‚) is equal to the reindexed inverse of matrix A (with the reindexing defined by the inverse of the equivalence relations eâ‚‚ and eâ‚).",
    "output": "theorem inv_reindex (eâ‚ eâ‚‚ : n â‰ƒ m) (A : Matrix n n Î±) : (reindex eâ‚ eâ‚‚ A)â»Â¹ = reindex eâ‚‚ eâ‚ Aâ»Â¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is algebraically independent over a ring R, then the multivariate polynomial option equivalent of the polynomial adjoin of x with respect to the polynomial X with no variables is equal to the polynomial X.",
    "output": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none\n    (hx : AlgebraicIndependent R x) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the angle formed by points pâ‚, pâ‚‚, and pâ‚ƒ is equal to Ï€/2 (a right angle), and either pâ‚ is not equal to pâ‚‚ or pâ‚ƒ is not equal to pâ‚‚, then the angle formed by points pâ‚‚, pâ‚ƒ, and pâ‚ is equal to the arcsine of the ratio of the distance between pâ‚ and pâ‚‚ to the distance between pâ‚ and pâ‚ƒ.",
    "output": "theorem angle_eq_arcsin_of_angle_eq_pi_div_two {pâ‚ pâ‚‚ pâ‚ƒ : P} (h : âˆ  pâ‚ pâ‚‚ pâ‚ƒ = Ï€ / 2)\n    (h0 : pâ‚ â‰  pâ‚‚ âˆ¨ pâ‚ƒ â‰  pâ‚‚) : âˆ  pâ‚‚ pâ‚ƒ pâ‚ = Real.arcsin (dist pâ‚ pâ‚‚ / dist pâ‚ pâ‚ƒ) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three functions m, n, and n', where m maps from Î´ and Î³ to Îµ, n maps from Î± and Î² to Î´, mâ‚ maps from Î± and Î³ to Î±', mâ‚‚ maps from Î² and Î³ to Î²', and n' maps from Î±' and Î²' to Îµ, if for all a, b, and c, the function m applied to the result of the function n applied to a and b and c equals the function n' applied to the result of the function mâ‚ applied to a and c and the result of the function mâ‚‚ applied to b and c, then the result of the function mapâ‚‚ applied to m, the result of the function mapâ‚‚ applied to n, f, and g, and h is less than or equal to the result of the function mapâ‚‚ applied to n', the result of the function mapâ‚‚ applied to mâ‚, f, and h, and the result of the function mapâ‚‚ applied to mâ‚‚, g, and h.",
    "output": "theorem mapâ‚‚_distrib_le_right {m : Î´ â†’ Î³ â†’ Îµ} {n : Î± â†’ Î² â†’ Î´} {mâ‚ : Î± â†’ Î³ â†’ Î±'} {mâ‚‚ : Î² â†’ Î³ â†’ Î²'}\n    {n' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ a b c, m (n a b) c = n' (mâ‚ a c) (mâ‚‚ b c)) :\n    mapâ‚‚ m (mapâ‚‚ n f g) h â‰¤ mapâ‚‚ n' (mapâ‚‚ mâ‚ f h) (mapâ‚‚ mâ‚‚ g h) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The interval from a to b, including both endpoints, is preconnected.",
    "output": "theorem isPreconnected_uIcc : IsPreconnected (uIcc a b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a uniformly continuous function 'f' and another uniformly continuous function 'g' from the completion of 'Î±' to 'Î²', such that for every element 'a' in 'Î±', 'f(a)' equals 'g' of the completion of 'a', then the extension of 'f' to the completion of 'Î±' is equal to 'g'.",
    "output": "theorem extension_unique (hf : UniformContinuous f) {g : Completion Î± â†’ Î²}\n    (hg : UniformContinuous g) (h : âˆ€ a : Î±, f a = g (a : Completion Î±)) :\n    Completion.extension f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite set 's' in a conditionally complete lattice 'Î±', the infimum of 's' using the identity function is equal to the greatest lower bound of 's'. The condition 'H' ensures that the set 's' is not empty.",
    "output": "theorem inf'_id_eq_csInf [ConditionallyCompleteLattice Î±] (s : Finset Î±) (H) :\n    s.inf' H id = sInf s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For three morphisms f, g, and h from X to Y, each having a cokernel, if f equals g (denoted by wâ‚) and g equals h (denoted by wâ‚‚), then the composition of the cokernel isomorphisms of wâ‚ and wâ‚‚ equals the cokernel isomorphism of the transitive relation of wâ‚ and wâ‚‚.",
    "output": "theorem cokernelIsoOfEq_trans {f g h : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] [HasCokernel h]\n    (wâ‚ : f = g) (wâ‚‚ : g = h) :\n    cokernelIsoOfEq wâ‚ â‰ªâ‰« cokernelIsoOfEq wâ‚‚ = cokernelIsoOfEq (wâ‚.trans wâ‚‚) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a sequence of sets V indexed by natural numbers, where each set V is in the uniformity of a topological space Î±, and for a sequence u of elements in Î± that converges to an element a in Î±, there exists a strictly increasing sequence Ï† of natural numbers such that the pair consisting of the first element of the sequence u indexed by Ï† and the element a is in the first set V, and for every natural number n, the pair consisting of the elements of the sequence u indexed by the (n+1)th and nth elements of the sequence Ï† is in the (n+1)th set V.",
    "output": "theorem Filter.Tendsto.subseq_mem_entourage {V : â„• â†’ Set (Î± Ã— Î±)} (hV : âˆ€ n, V n âˆˆ ğ“¤ Î±) {u : â„• â†’ Î±}\n    {a : Î±} (hu : Tendsto u atTop (ğ“ a)) : âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ (u (Ï† 0), a) âˆˆ V 0 âˆ§\n      âˆ€ n, (u <| Ï† (n + 1), u <| Ï† n) âˆˆ V (n + 1) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any prime number p that is not equal to 2, the number obtained by subtracting 1 from p is even.",
    "output": "theorem Prime.even_sub_one {p : â„•} (hp : p.Prime) (h2 : p â‰  2) : Even (p - 1) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is almost everywhere strongly measurable with respect to a measure 'Î¼', then the function 'f' created by 'hf' is strongly measurable.",
    "output": "theorem stronglyMeasurable_mk (hf : AEStronglyMeasurable f Î¼) : StronglyMeasurable (hf.mk f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given predicate P, a node (consisting of a left subtree l, a value x, and a right subtree r) satisfies P if and only if the left subtree l, the value x, and the right subtree r all satisfy P.",
    "output": "theorem all_node' {P l x r} : @All Î± P (node' l x r) â†” All P l âˆ§ P x âˆ§ All P r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any pair 'a' of type Î± and Î³, applying the symmetric of the sum-product distribution function to the left injection of 'a' results in a pair consisting of the left injection of the first element of 'a' and the second element of 'a'.",
    "output": "theorem sumProdDistrib_symm_apply_left (a : Î± Ã— Î³) :\n    (sumProdDistrib Î± Î² Î³).symm (inl a) = (inl a.1, a.2) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'c' is an additively left cancellable element and 'a - c' is less than 'b', then 'a' is less than 'b + c'.",
    "output": "theorem lt_add_of_tsub_lt_right (hc : AddLECancellable c) (h : a - c < b) :\n    a < b + c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'g' mapping from Î² to Î³ and 'f' mapping from Î± to Î², and for any symmetric pair 'x' of type Î±, applying the function 'g' to the result of applying the function 'f' to 'x' is the same as applying the composition of 'g' and 'f' to 'x'.",
    "output": "theorem map_map {g : Î² â†’ Î³} {f : Î± â†’ Î²} (x : Sym2 Î±) : map g (map f x) = map (g âˆ˜ f) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measure Î½ on a set Î± and a function Ï† from Î¹ to the set Î±, if Ï† is an almost everywhere cover for Î¼ at limit l and Î½ is absolutely continuous with respect to Î¼, then Ï† is also an almost everywhere cover for Î½ at limit l.",
    "output": "theorem mono_ac {Î½ : Measure Î±} {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) (hle : Î½ â‰ª Î¼) :\n    AECover Î½ l Ï† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î¹ and a function t from Î¹ to a finite set of Î±, and a finite set s of Î¹, if the cardinality of s is equal to the cardinality of the bi-union of s and t, and for all finite sets s of Î¹, the cardinality of s is less than or equal to the cardinality of the bi-union of s and t, then for a finite set s' of the complement of s in Î¹, the cardinality of s' is less than or equal to the cardinality of the bi-union of s' and the set difference of t x' and the bi-union of s and t.",
    "output": "theorem hall_cond_of_compl {Î¹ : Type u} {t : Î¹ â†’ Finset Î±} {s : Finset Î¹}\n    (hus : s.card = (s.biUnion t).card) (ht : âˆ€ s : Finset Î¹, s.card â‰¤ (s.biUnion t).card)\n    (s' : Finset (sá¶œ : Set Î¹)) : s'.card â‰¤ (s'.biUnion fun x' => t x' \\ s.biUnion t).card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any dual number of a quaternion over a ring R, the first real part of the inverse of the dual number equivalence of the dual number is equal to the real part of the first element of the dual number.",
    "output": "theorem fst_re_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).re.fst = d.fst.re :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The torsion of a commutative monoid G is equal to the submonoid generated by the torsion of G.",
    "output": "theorem torsion_eq_torsion_submonoid : CommMonoid.torsion G = (torsion G).toSubmonoid :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite dimensional field 'K' and vector space 'V', and a subspace 'W'' of the dual of the dual of 'V', the inverse of the map evaluation equivalence applied to 'W'' is equal to the co-domain of 'W'' under the evaluation map.",
    "output": "theorem mapEvalEquiv_symm_apply [FiniteDimensional K V] (W'' : Subspace K (Dual K (Dual K V))) :\n    (mapEvalEquiv K V).symm W'' = W''.comap (eval K V) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a subgroup H of a group G, if H is normal, then the normal closure of H is equal to H itself.",
    "output": "theorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure â†‘H = H :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a transitive relation 'r' on a set 'Î±', and 'a', 'b', and 'c' are elements of 'Î±' such that the antisymmetric relation holds between 'a' and 'b', and between 'b' and 'c', then the antisymmetric relation also holds between 'a' and 'c'.",
    "output": "theorem AntisymmRel.trans [IsTrans Î± r] {a b c : Î±} (hab : AntisymmRel r a b)\n    (hbc : AntisymmRel r b c) : AntisymmRel r a c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two indices 'i' and 'j' and any element 'x' of type 'Î² i', if 'i' is not equal to 'j', then erasing 'j' from the singleton set containing 'i' and 'x' will result in the original singleton set containing 'i' and 'x'.",
    "output": "theorem erase_single_ne {i j : Î¹} (x : Î² i) (h : i â‰  j) : (single i x).erase j = single i x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a linearly ordered commutative ring R, for any two elements a and b that are coprime, the sum of the squares of a and b is not equal to zero.",
    "output": "theorem sq_add_sq_ne_zero {R : Type _} [LinearOrderedCommRing R] {a b : R} (h : IsCoprime a b) :\n    a ^ 2 + b ^ 2 â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If two morphisms (or arrows) 'f' and 'g' from object 'X' to object 'Y' are equal (denoted by 'f = g'), then the composition of 'f' with another morphism 'h' from 'Y' to 'Z' is equal to the composition of 'g' with 'h'. This is denoted by 'f â‰« h = g â‰« h'. This is known as \"right whiskering\" in category theory.",
    "output": "theorem eq_whisker {f g : X âŸ¶ Y} (w : f = g) (h : Y âŸ¶ Z) : f â‰« h = g â‰« h :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function 'f' is continuously differentiable on the closure of the entire space 'ğ•œ' if and only if 'f' is differentiable on 'ğ•œ'.",
    "output": "theorem diffContOnCl_univ : DiffContOnCl ğ•œ f univ â†” Differentiable ğ•œ f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any relation 'r' between elements of type 'Î±', for any lists 'sâ‚' and 'sâ‚‚', and any list 't', if 'sâ‚' is lexicographically less than 'sâ‚‚' according to the relation 'r', then 'sâ‚' is also lexicographically less than the concatenation of 'sâ‚‚' and 't' according to the same relation 'r'.",
    "output": "theorem append_right (r : Î± â†’ Î± â†’ Prop) : âˆ€ {sâ‚ sâ‚‚} (t), Lex r sâ‚ sâ‚‚ â†’ Lex r sâ‚ (sâ‚‚ ++ t)"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite set 's' and a property 'p' that each element in 's' may or may not satisfy, the product of applying either function 'f' or 'g' to each element in 's' (depending on whether or not the element satisfies 'p') is equal to the product of applying 'f' to each element in 's' that satisfies 'p' multiplied by the product of applying 'g' to each element in 's' that does not satisfy 'p'.",
    "output": "theorem prod_ite {s : Finset Î±} {p : Î± â†’ Prop} {hp : DecidablePred p} (f g : Î± â†’ Î²) :\n    (âˆ x in s, if p x then f x else g x) =\n      (âˆ x in s.filter p, f x) * âˆ x in s.filter fun x => Â¬p x, g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any integer k, the norm of k (when considered as a p-adic number) is less than one if and only if p (considered as an integer) divides k.",
    "output": "theorem norm_int_lt_one_iff_dvd (k : â„¤) : â€–(k : â„š_[p])â€– < 1 â†” â†‘p âˆ£ k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three types Î±, Î², and Î³ that are primcodable, and for any properties p of Î±, q of Î², and r of Î³, if q and r are many-one equivalent, then p is many-one equivalent to q if and only if p is many-one equivalent to r.",
    "output": "theorem ManyOneEquiv.congr_right {Î± Î² Î³} [Primcodable Î±] [Primcodable Î²] [Primcodable Î³]\n    {p : Î± â†’ Prop} {q : Î² â†’ Prop} {r : Î³ â†’ Prop} (h : ManyOneEquiv q r) :\n    ManyOneEquiv p q â†” ManyOneEquiv p r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the context of an adhesive category C, if we have a pushout consisting of morphisms f, g, h, and i, and if g is a monomorphism, then this pushout is also a pullback.",
    "output": "theorem Adhesive.isPullback_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i)\n    [Mono g] : IsPullback f g h i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Assuming there is at least one element in set Î±, if function f is surjective on sets s and t, then the inverse function on f and s is a right inverse on set t.",
    "output": "theorem SurjOn.rightInvOn_invFunOn [Nonempty Î±] (h : SurjOn f s t) :\n    RightInvOn (invFunOn f s) f t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the codomain of a function is a subsingleton, then the function is almost everywhere measurable with respect to measure Î¼.",
    "output": "theorem aemeasurable_of_subsingleton_codomain [Subsingleton Î²] : AEMeasurable f Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given order-preserving monoid homomorphism 'f' from 'Î±' to 'Î²', the order homomorphism of 'f' is equal to 'f' itself.",
    "output": "theorem toOrderHom_eq_coe (f : Î± â†’*o Î²) : f.toOrderHom = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of elements of type 'Î±', an element 'a' of type 'Î±', and a property 'p' applicable to elements of type 'Î±', if every element in 's' has property 'p', then eventually, for all elements 'x' in the neighborhood of 'a' within set 's', 'x' will have property 'p'.",
    "output": "theorem eventually_nhdsWithin_of_forall {s : Set Î±} {a : Î±} {p : Î± â†’ Prop} (h : âˆ€ x âˆˆ s, p x) :\n    âˆ€á¶  x in ğ“[s] a, p x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a list L of elements of any type Î±, given two natural numbers i and j such that i is less than the length of L and i is also less than j, the i-th element of L is equal to the i-th element of the list obtained by taking the first j elements of L. This is true because the length of the taken list is less than or equal to the minimum of j and the length of L, and i is less than this minimum.",
    "output": "theorem nthLe_take (L : List Î±) {i j : â„•} (hi : i < L.length) (hj : i < j) :\n    nthLe L i hi = nthLe (L.take j) i (length_take .. â–¸ lt_min hj hi) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two natural numbers 'm' and 'n', the cardinality of 'm' is less than or equal to 'n' if and only if 'm' is less than or equal to 'n'.",
    "output": "theorem natCast_le {m n : â„•} : (m : Cardinal) â‰¤ n â†” m â‰¤ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type 'Î±' and any function 'f' from 'Î±' to 'Î²', the operation of mapping function 'f' over the option of 'a' is equal to the co-domain of function 'f' applied to 'a'.",
    "output": "theorem map_coe' {a : Î±} {f : Î± â†’ Î²} : Option.map f (a : Option Î±) = â†‘(f a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If R is a Noetherian ring and M is a module over R such that the whole module M is finitely generated, then M is a Noetherian module.",
    "output": "theorem isNoetherian_of_fg_of_noetherian' {R M} [Ring R] [AddCommGroup M] [Module R M]\n    [IsNoetherianRing R] (h : (âŠ¤ : Submodule R M).FG) : IsNoetherian R M :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cardinality of the set of algebraic elements in A over R is less than or equal to the product of the cardinality of the set of polynomials over R and the cardinality of the set of natural numbers.",
    "output": "theorem cardinal_mk_le_mul : (#{ x : A // IsAlgebraic R x }) â‰¤ (#R[X]) * â„µâ‚€ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' in a set 'Î±' and any unit 'b', the product of 'a' and 'b' divided by 'b' is equal to 'a'. Here, 'IsUnit b' means 'b' is a unit, i.e., 'b' has a multiplicative inverse.",
    "output": "theorem mul_mul_div (a : Î±) (h : IsUnit b) : a * b * (1 / b) = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponential function is continuous from a normed space to another normed space.",
    "output": "theorem exp_continuous : Continuous (exp ğ•‚ : ğ”¸ â†’ ğ”¸) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A hyperreal number 'x' is infinitely negative if and only if 'x' is infinite and 'x' is less than zero.",
    "output": "theorem infiniteNeg_iff_infinite_and_neg {x : â„*} : InfiniteNeg x â†” Infinite x âˆ§ x < 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all numbers 'n', the successor of 'n' when cast to a natural number is equal to 'n' plus one.",
    "output": "theorem succ_to_nat : âˆ€ n, (succ n : â„•) = n + 1"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any additive group with an identity element Î± that has characteristic zero and any integer n, n being not equal to 1 in Î± is equivalent to n not being equal to 1.",
    "output": "theorem cast_ne_one [AddGroupWithOne Î±] [CharZero Î±] {n : â„¤} : (n : Î±) â‰  1 â†” n â‰  1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a real number x that is greater than or equal to zero, and a complex number y such that the real part of y is not zero, the absolute value of x raised to the power of y is equal to x raised to the power of the real part of y.",
    "output": "theorem abs_cpow_eq_rpow_re_of_nonneg {x : â„} (hx : 0 â‰¤ x) {y : â„‚} (hy : re y â‰  0) :\n    abs (x ^ y) = x ^ re y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nonempty set Î² with a semilattice structure and a sequence u from Î² to Î±, the sequence u is a Cauchy sequence if and only if the function that takes a pair of elements from Î² and returns the distance between the images of these elements under u, tends to 0 as the pair goes to infinity.",
    "output": "theorem cauchySeq_iff_tendsto_dist_atTop_0 [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” Tendsto (fun n : Î² Ã— Î² => dist (u n.1) (u n.2)) atTop (ğ“ 0) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' has compact multiplication support, and the multiplication support of another function 'f'' is a subset of the multiplication support of 'f', then 'f'' also has compact multiplication support.",
    "output": "theorem HasCompactMulSupport.mono {f' : Î± â†’ Î³} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' âŠ† mulSupport f) : HasCompactMulSupport f' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two spectral maps 'f' and 'g' from 'Î±' to 'Î²', if for every 'a', 'f' at 'a' equals 'g' at 'a', then 'f' equals 'g'.",
    "output": "theorem ext {f g : SpectralMap Î± Î²} (h : âˆ€ a, f a = g a) : f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The bottom element in the set of extended non-negative real numbers is equal to zero.",
    "output": "theorem bot_eq_zero : (âŠ¥ : â„â‰¥0âˆ) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The diagonal of the union of two sets, s and t, is equal to the union of the diagonals of the two sets.",
    "output": "theorem diag_union : (s âˆª t).diag = s.diag âˆª t.diag :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The centralizer of the top element is equal to the center of the group G.",
    "output": "theorem centralizer_top : centralizer âŠ¤ = center G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any multisets 's' and 't' and any element 'a', 's' with 'a' erased is less than or equal to 't' if and only if 's' is less than or equal to 't' with 'a' added.",
    "output": "theorem erase_le_iff_le_cons {s t : Multiset Î±} {a : Î±} : s.erase a â‰¤ t â†” s â‰¤ a ::â‚˜ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î±, natural number n, bounded formula Ï† of L in Î± and n, and functions v and xs from Î± and Fin n to the top substructure of M respectively, the realization of Ï† with respect to v and xs is equivalent to the realization of Ï† with respect to the composition of v and xs with the inclusion function from the top substructure of M to M.",
    "output": "theorem realize_boundedFormula_top {Î± : Type _} {n : â„•} {Ï† : L.BoundedFormula Î± n}\n    {v : Î± â†’ (âŠ¤ : L.Substructure M)} {xs : Fin n â†’ (âŠ¤ : L.Substructure M)} :\n    Ï†.Realize v xs â†” Ï†.Realize (((â†‘) : _ â†’ M) âˆ˜ v) ((â†‘) âˆ˜ xs) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The greatest lower bound (infimum) of the function f over all elements x in the universal set is equal to the greatest lower bound of the function f over all elements x.",
    "output": "theorem iInf_univ {f : Î² â†’ Î±} : (â¨… x âˆˆ (univ : Set Î²), f x) = â¨… x, f x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The head of the negation of a vector 'a' is equal to the negation of the head of the vector 'a'.",
    "output": "theorem head_neg (a : Fin n.succ â†’ Î±) : vecHead (-a) = -vecHead a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite measure Î¼, another measure Î½ (which is also finite), and a function f from Î± to E, if f is integrable with respect to both Î¼ and Î½, then the integral of f with respect to the sum of Î¼ and Î½ is equal to the weighted sum of the integral of f with respect to Î¼ and the integral of f with respect to Î½. The weights are the ratio of the measure of the entire space under Î¼ and Î½ to the sum of the measures of the entire space under Î¼ and Î½, respectively.",
    "output": "theorem average_add_measure [IsFiniteMeasure Î¼] {Î½ : Measure Î±} [IsFiniteMeasure Î½] {f : Î± â†’ E}\n    (hÎ¼ : Integrable f Î¼) (hÎ½ : Integrable f Î½) :\n    (â¨ x, f x âˆ‚Î¼ + Î½) =\n      (((Î¼ univ).toReal / ((Î¼ univ).toReal + (Î½ univ).toReal)) â€¢ â¨ x, f x âˆ‚Î¼) +\n        ((Î½ univ).toReal / ((Î¼ univ).toReal + (Î½ univ).toReal)) â€¢ â¨ x, f x âˆ‚Î½ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given finite set 't' of type Î², the scalar multiplication of 't' by the zero set of type Î± is a subset of the zero set.",
    "output": "theorem zero_smul_subset (t : Finset Î²) : (0 : Finset Î±) â€¢ t âŠ† 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any non-negative real number 'a' and any two functions 'g' and 'h' that map from an index set 'Î¹' to the set of non-negative real numbers, if 'a' is less than or equal to the product of 'g i' and 'h j' for all 'i' and 'j' in the index set, then 'a' is also less than or equal to the product of the infimum (greatest lower bound) of 'g' and the infimum of 'h'.",
    "output": "theorem le_iInf_mul_iInf {a : â„â‰¥0} {g h : Î¹ â†’ â„â‰¥0} (H : âˆ€ i j, a â‰¤ g i * h j) :\n    a â‰¤ iInf g * iInf h :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type R and L, where R is a commutative ring, L is a Lie ring, and L is a Lie algebra over R, the bottom element of the Lie ideal of R in L is a Lie abelian.",
    "output": "theorem LieAlgebra.isLieAbelian_bot (R : Type u) (L : Type v) [CommRing R] [LieRing L]\n    [LieAlgebra R L] : IsLieAbelian (âŠ¥ : LieIdeal R L) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real numbers p and q that are conjugate exponents, and for any two functions f and g from Î± to the set of non-negative extended real numbers that are almost everywhere measurable with respect to measure Î¼, if the p-th power integrals of f and g with respect to Î¼ are not infinite, and if the p-th power integral of the sum of f and g with respect to Î¼ is not zero or infinite, then the p-th root of the p-th power integral of the sum of f and g with respect to Î¼ is less than or equal to the sum of the p-th roots of the p-th power integrals of f and g with respect to Î¼.",
    "output": "theorem lintegral_Lp_add_le_aux {p q : â„} (hpq : p.IsConjugateExponent q) {f g : Î± â†’ â„â‰¥0âˆ}\n    (hf : AEMeasurable f Î¼) (hf_top : (âˆ«â» a, f a ^ p âˆ‚Î¼) â‰  âŠ¤) (hg : AEMeasurable g Î¼)\n    (hg_top : (âˆ«â» a, g a ^ p âˆ‚Î¼) â‰  âŠ¤) (h_add_zero : (âˆ«â» a, (f + g) a ^ p âˆ‚Î¼) â‰  0)\n    (h_add_top : (âˆ«â» a, (f + g) a ^ p âˆ‚Î¼) â‰  âŠ¤) :\n    (âˆ«â» a, (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤\n      (âˆ«â» a, f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» a, g a ^ p âˆ‚Î¼) ^ (1 / p) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any composition series 's' of 'X', the top of the series after erasing the top element is less than or equal to the original top of the series 's'.",
    "output": "theorem eraseTop_top_le (s : CompositionSeries X) : s.eraseTop.top â‰¤ s.top :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two games x and y, and for any property P that applies to the left moves of the sum of x and y, if P holds for all left moves of x and all left moves of y when they are considered as left moves of the sum, then P holds for any left move of the sum of x and y.",
    "output": "theorem leftMoves_add_cases {x y : PGame} (k) {P : (x + y).LeftMoves â†’ Prop}\n    (hl : âˆ€ i, P <| toLeftMovesAdd (Sum.inl i)) (hr : âˆ€ i, P <| toLeftMovesAdd (Sum.inr i)) :\n    P k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function fâ‚ is eventually equal to function fâ‚‚ at filter l, and function fâ‚‚ is asymptotically equivalent to function g at the same filter, then function fâ‚ is also asymptotically equivalent to function g at filter l.",
    "output": "theorem _root_.Filter.EventuallyEq.trans_isTheta {fâ‚ fâ‚‚ : Î± â†’ E} {g : Î± â†’ F} (hf : fâ‚ =á¶ [l] fâ‚‚)\n    (h : fâ‚‚ =Î˜[l] g) : fâ‚ =Î˜[l] g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The keys of the associative list obtained by erasing an element 'a' from another associative list 's' are equal to the keys of 's' with 'a' erased.",
    "output": "theorem keys_erase (a : Î±) (s : AList Î²) : (erase a s).keys = s.keys.erase a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The image of the second projection linear map under the first projection submodule is the zero submodule.",
    "output": "theorem fst_map_snd : (Submodule.fst R M Mâ‚‚).map (LinearMap.snd R M Mâ‚‚) = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' that maps from the finite set of size 'm * n' to any type 'Î±', the list created by applying 'f' to each element in the finite set is equal to the list obtained by joining the list of lists created by applying 'f' to each element in the finite set of size 'm' for each element in the finite set of size 'n'. The index for 'f' in the latter case is calculated as 'm * i + j', where 'i' is the element from the finite set of size 'n' and 'j' is the element from the finite set of size 'm'. The theorem also includes a proof that 'm * i + j' is less than or equal to 'm * (i + 1)', which ensures that the index is within the bounds of the finite set of size 'm * n'.",
    "output": "theorem ofFn_mul' {m n} (f : Fin (m * n) â†’ Î±) :\n    List.ofFn f = List.join (List.ofFn fun i : Fin n => List.ofFn fun j : Fin m => f âŸ¨m * i + j,\n    calc\n      m * i + j < m * (i + 1) := (add_lt_add_left j.prop _).trans_eq (mul_add_one (_ : â„•) _).symm\n      _ â‰¤ _ := Nat.mul_le_mul_left _ i.propâŸ©) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from an optional value of type 'Î±' to type 'Î²', the range of 'f' is equal to the insertion of the function 'f' applied to 'none' into the range of the function 'f' composed with 'some'.",
    "output": "theorem range_eq {Î± Î²} (f : Option Î± â†’ Î²) : range f = insert (f none) (range (f âˆ˜ some)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given point 'x' in a set 'E' and a real number 'Î´', the open ball centered at 'x' with radius 'Î´' is a subset of the thickening of 'E' by 'Î´'.",
    "output": "theorem ball_subset_thickening {x : X} {E : Set X} (hx : x âˆˆ E) (Î´ : â„) :\n    ball x Î´ âŠ† thickening Î´ E :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements r and s from a ring R, the coercion of the division of r by s is equal to the division of the coerced r by the coerced s in a ring A.",
    "output": "theorem coe_div (r s : R) : â†‘(r / s) = (â†‘r / â†‘s : A) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the kernel of a homomorphism Ï• is a p-group, and the image of a subgroup P under Ï• is a subset of the range of Ï•, then the preimage of P under Ï• (with respect to the kernel being a p-group) is equal to the preimage of P under Ï•.",
    "output": "theorem coe_comapOfKerIsPGroup (hÏ• : IsPGroup p Ï•.ker) (h : â†‘P â‰¤ Ï•.range) :\n    (P.comapOfKerIsPGroup Ï• hÏ• h : Subgroup K) = Subgroup.comap Ï• â†‘P :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a scalar 's' and an element 'a' from the module over a field 'ğ•œ' and a ring 'A', the first component of the scaled element 's â€¢ a' is equal to the scalar multiplication of 's' and the first component of 'a'.",
    "output": "theorem smul_fst (s : S) (a : ğ“œ(ğ•œ, A)) : (s â€¢ a).fst = s â€¢ a.fst :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The kernel of the first projection function from a product of two modules over a ring to the first module is equal to the range of the function that injects the second module into the product.",
    "output": "theorem ker_fst : ker (fst R M Mâ‚‚) = range (inr R M Mâ‚‚) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î¹, and for any complete lattice Î², if we have a function f from Î¹ to the order-preserving function from Î± to Î², then the function obtained by taking the greatest lower bound over all i of the function f(i), when coerced to a function from Î± to Î², is equal to the function obtained by taking the greatest lower bound over all i of the function f(i) coerced to a function from Î± to Î².",
    "output": "theorem coe_iInf {Î¹ : Sort _} [CompleteLattice Î²] (f : Î¹ â†’ Î± â†’o Î²) :\n    ((â¨… i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨… i, (f i : Î± â†’ Î²) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any encodable type Î±, the function 'decodeâ‚‚ Î±' is a partial inverse of the function 'encode'. This means that if you encode a value and then decode it using 'decodeâ‚‚ Î±', you will get the original value back, at least for some values.",
    "output": "theorem decodeâ‚‚_is_partial_inv [Encodable Î±] : IsPartialInv encode (decodeâ‚‚ Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the function pair f and g is antivariant, then the sum of the product of f(i) and g(i) for all i is less than or equal to the sum of the product of f(Ïƒ(i)) and g(i) for all i. Here, Ïƒ is a permutation function.",
    "output": "theorem Antivary.sum_smul_le_sum_comp_perm_smul (hfg : Antivary f g) :\n    (âˆ‘ i, f i â€¢ g i) â‰¤ âˆ‘ i, f (Ïƒ i) â€¢ g i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If functions 'f' and 'g' are continuously differentiable 'n' times over the real numbers, then the inner product of 'f' and 'g' is also continuously differentiable 'n' times over the real numbers.",
    "output": "theorem ContDiff.inner (hf : ContDiff â„ n f) (hg : ContDiff â„ n g) :\n    ContDiff â„ n fun x => âŸªf x, g xâŸ« :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The FrÃ©chet derivative of a continuous linear map at any point is the map itself.",
    "output": "theorem ContinuousLinearMap.fderiv : fderiv ğ•œ e x = e :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type G with a group structure, and given types R and M with distributive multiplication actions by G, and given that G is a scalar tower over R and M, if the span of the set range of a function v from index set Î¹ to M over R equals the top element (i.e., the whole space), then the span of the set range of the function obtained by scaling v by a function w from Î¹ to G over R also equals the top element.",
    "output": "theorem groupSmul_span_eq_top {G : Type _} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] {v : Î¹ â†’ M} (hv : Submodule.span R (Set.range v) = âŠ¤) {w : Î¹ â†’ G} :\n    Submodule.span R (Set.range (w â€¢ v)) = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'q prime' is an element of the transformation of 'q' under the function 'trStmtsâ‚', then the set of elements transformed by 'trStmtsâ‚' from 'q prime' is a subset of the set of elements transformed by 'trStmtsâ‚' from 'q'.",
    "output": "theorem trStmtsâ‚_trans {q q'} : q' âˆˆ trStmtsâ‚ q â†’ trStmtsâ‚ q' âŠ† trStmtsâ‚ q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a multilinear map Ï† from a ring R to a set s of elements E, and for all elements f in set s, the auxiliary lift of Ï† at the tensor product of R and f is equal to Ï† at f.",
    "output": "theorem liftAux_tprod (Ï† : MultilinearMap R s E) (f : âˆ€ i, s i) : liftAux Ï† (tprod R f) = Ï† f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any filter 'l' and any function 'f', 'f' is eventually less than or equal to 'f' with respect to the filter 'l'.",
    "output": "theorem EventuallyLE.refl (l : Filter Î±) (f : Î± â†’ Î²) : f â‰¤á¶ [l] f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given index 'i' and a function 't' that maps each index to a set of elements of type 'Î± i', the Cartesian product of the set containing only 'i' and the function 't' is equal to the set of all functions 'x' such that the element of 'x' at index 'i' is in the set 't i'.",
    "output": "theorem singleton_pi' (i : Î¹) (t : âˆ€ i, Set (Î± i)) : pi {i} t = { x | x i âˆˆ t i } :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The size up to a given natural number 'i' in composition 'c' is less than or equal to 'n'.",
    "output": "theorem sizeUpTo_le (i : â„•) : c.sizeUpTo i â‰¤ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The evaluation function, which takes a continuous multilinear map from a scalar field ğ•œ and vector spaces E to a vector space G, and a function that assigns a vector in E to each index i, and applies the multilinear map to this function, is continuous.",
    "output": "theorem continuous_eval : Continuous fun p :\n    ContinuousMultilinearMap ğ•œ E G Ã— âˆ€ i, E i => p.1 p.2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given index 'i' in the set 'Î¹', the function 'of Î² i' is injective. An injective function is one where every element of the input maps to a unique element of the output, meaning there are no two different inputs that produce the same output.",
    "output": "theorem of_injective (i : Î¹) : Function.Injective (of Î² i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function that maps a ring homomorphism from Î± to Î² to its underlying additive monoid homomorphism is injective. This means that if two ring homomorphisms from Î± to Î² are different, then their underlying additive monoid homomorphisms are also different.",
    "output": "theorem coe_addMonoidHom_injective : Injective fun f : Î± â†’â‚™+* Î² => (f : Î± â†’+ Î²) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'a' does not belong to set 't', then the intersection of the set 't' and the set obtained by inserting 'a' into another set 's' is equal to the intersection of the sets 's' and 't'.",
    "output": "theorem insert_inter_of_not_mem (h : a âˆ‰ t) : insert a s âˆ© t = s âˆ© t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a unitary element U in the ring R, the inverse of U when considered as an element of the ring R is the same as the inverse of U when considered as a unitary element.",
    "output": "theorem coe_inv (U : unitary R) : â†‘Uâ»Â¹ = (Uâ»Â¹ : R) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list 'l' and for any integers 'm' and 'n', if 'm' is less than 'n', then there is a chain of strictly increasing elements starting from 'm' in the list obtained by applying the function 'raise'' to 'l' and 'n'.",
    "output": "theorem raise'_chain : âˆ€ (l) {m n}, m < n â†’ List.Chain (Â· < Â·) m (raise' l n)"
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index 'i' and any real number 'r' that is greater than zero, the open ball of radius 'r' centered at zero in the seminorm 'p i' is a member of the basis sets of 'p'.",
    "output": "theorem basisSets_singleton_mem (i : Î¹) {r : â„} (hr : 0 < r) : (p i).ball 0 r âˆˆ p.basisSets :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function fâ‚‚ is differentiable at a point x in a field ğ•œ, then the first component of the function fâ‚‚ at point x is also differentiable at that point.",
    "output": "theorem DifferentiableAt.fst (h : DifferentiableAt ğ•œ fâ‚‚ x) :\n    DifferentiableAt ğ•œ (fun x => (fâ‚‚ x).1) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of 'M F', if we apply the function 'dest' to 'x' and then apply the function 'M.mk' to the result, we will get back 'x'.",
    "output": "theorem mk_dest (x : M F) : M.mk (dest x) = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given complex number 'c', a real number 'R' (where 'R' is greater than or equal to 0), and another real number 'Î¸', the circle map of 'c', 'R', and 'Î¸' belongs to the sphere with center 'c' and radius 'R'.",
    "output": "theorem circleMap_mem_sphere (c : â„‚) {R : â„} (hR : 0 â‰¤ R) (Î¸ : â„) : circleMap c R Î¸ âˆˆ sphere c R :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'i' of type 'Î±' and any element 'b' that is not equal to zero, the support of the single function applied to 'i' and 'b' is not equal to the bottom element.",
    "output": "theorem support_single_ne_bot (i : Î±) (h : b â‰  0) : (single i b).support â‰  âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two affine equivalences 'e' and 'e'' between two points Pâ‚ and Pâ‚‚, 'e' is equal to 'e'' if and only if the equivalent transformation of 'e' is equal to the equivalent transformation of 'e''.",
    "output": "theorem toEquiv_inj {e e' : Pâ‚ â‰ƒáµƒ[k] Pâ‚‚} : e.toEquiv = e'.toEquiv â†” e = e' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The difference of a set with itself is the bottom element, or the empty set.",
    "output": "theorem sdiff_self : a \\ a = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given ring homomorphism class from R[X] to S[X], and a ring homomorphism Ï† such that the non-zero elements of R[X] are less than or equal to the preimage of the non-zero elements of S[X] under Ï†, the mapping of the ring homomorphism from the rational functions over R to the rational functions over S is equal to the mapping of Ï† under the same conditions.",
    "output": "theorem coe_mapRingHom_eq_coe_map [RingHomClass F R[X] S[X]] (Ï† : F) (hÏ† : R[X]â° â‰¤ S[X]â°.comap Ï†) :\n    (mapRingHom Ï† hÏ† : RatFunc R â†’ RatFunc S) = map Ï† hÏ† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set of vectors 'v' that are orthonormal (meaning, they are orthogonal and of unit length), and two functions 'lâ‚' and 'lâ‚‚' that map to the field of scalars, and a finite set 's', the inner product of the sum of the scaled vectors according to 'lâ‚' and 'lâ‚‚' over the set 's' is equal to the sum over 's' of the product of the conjugate of 'lâ‚' and 'lâ‚‚'.",
    "output": "theorem Orthonormal.inner_sum {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (lâ‚ lâ‚‚ : Î¹ â†’ ğ•œ) (s : Finset Î¹) :\n    âŸªâˆ‘ i in s, lâ‚ i â€¢ v i, âˆ‘ i in s, lâ‚‚ i â€¢ v iâŸ« = âˆ‘ i in s, conj (lâ‚ i) * lâ‚‚ i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is surjective (meaning that for every element in the target space there is at least one element in the domain that maps to it), then 'f' has a right inverse (meaning there exists a function that, when composed with 'f' from the right, results in the identity function).",
    "output": "theorem Surjective.hasRightInverse (hf : Surjective f) : HasRightInverse f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The closure of the union of a set of sets in field K is equal to the supremum of the closures of the sets in the set, for each set in the set.",
    "output": "theorem closure_sUnion (s : Set (Set K)) : closure (â‹ƒâ‚€ s) = â¨† t âˆˆ s, closure t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The matrix representation of the Gram-Schmidt orthonormal basis, when applied to a function f, is block triangular with respect to the identity function.",
    "output": "theorem gramSchmidtOrthonormalBasis_inv_blockTriangular :\n    ((gramSchmidtOrthonormalBasis h f).toBasis.toMatrix f).BlockTriangular id :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a trinomial with indices k, m, and n, where k is less than m and m is less than n, and where w is not equal to zero, the leading coefficient of the trinomial is equal to w.",
    "output": "theorem trinomial_leadingCoeff (hkm : k < m) (hmn : m < n) (hw : w â‰  0) :\n    (trinomial k m n u v w).leadingCoeff = w :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î±, if we have two thunks a and b of type Î±, and if the result of getting the value from a is equal to the result of getting the value from b, then a is equal to b.",
    "output": "theorem ext {Î± : Type u} {a b : Thunk Î±} (eq : a.get = b.get) : a = b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The closure of an empty set in a structure L is the bottom element.",
    "output": "theorem closure_empty : closure L (âˆ… : Set M) = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' of a certain set 'Î±', if 'a' is less than the successor of 'b', then 'a' is less than or equal to 'b'.",
    "output": "theorem le_of_lt_succ {a b : Î±} : a < succ b â†’ a â‰¤ b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a special linear group 'g' of order 'n' over a ring 'R', the matrix representation of 'g' when it is cast as a general linear group and then as a positive general linear group is the same as the matrix representation of 'g' itself.",
    "output": "theorem coe_GLPos_coe_GL_coe_matrix (g : SpecialLinearGroup n R) :\n    (â†‘(â†‘(â†‘g : GLPos n R) : GL n R) : Matrix n n R) = â†‘g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'f' from type Î± to Î², and a finite support function 's' from Î± to some type M, such that 'f' is injective on the support of 's', then the support of the function obtained by mapping the domain of 's' through 'f' is equal to the image of the support of 's' under 'f'. This is under the condition that Î² has a decidable equality.",
    "output": "theorem mapDomain_support_of_injOn [DecidableEq Î²] {f : Î± â†’ Î²} (s : Î± â†’â‚€ M)\n    (hf : Set.InjOn f s.support) : (mapDomain f s).support = Finset.image f s.support :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements x and y of a certain set Î±, the normalization of x equals the normalization of y if and only if x divides y and y divides x.",
    "output": "theorem normalize_eq_normalize_iff {x y : Î±} : normalize x = normalize y â†” x âˆ£ y âˆ§ y âˆ£ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a linear map 'f' from 'M' to 'N' and a function 'g' from 'Î±' to 'M', the application of the linear map 'f' to 'g' using the 'mapRange.linearMap' function is equal to the application of 'f' and 'f.map_zero' to 'g' using the 'mapRange' function.",
    "output": "theorem mapRange.linearMap_apply (f : M â†’â‚—[R] N) (g : Î± â†’â‚€ M) :\n  mapRange.linearMap f g = mapRange f f.map_zero g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If for every element 'a' in set 's', 'f a' is an element of set 't', and the cardinality of set 't' multiplied by 'b' is less than the cardinality of set 's', then there exists an element 'y' in set 't' such that 'b' is less than the cardinality of the subset of 's' for which 'f x' equals 'y'.",
    "output": "theorem exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to (hf : âˆ€ a âˆˆ s, f a âˆˆ t)\n    (ht : t.card â€¢ b < s.card) : âˆƒ y âˆˆ t, b < (s.filter fun x => f x = y).card :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cosine of (x minus two times pi) is equal to the cosine of x, for any real number x.",
    "output": "theorem cos_sub_two_pi (x : â„) : cos (x - 2 * Ï€) = cos x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse function of a member of a range is surjective, meaning that for every element in the codomain, there is at least one element in the domain that maps to it.",
    "output": "theorem invOfMemRange_surjective : Function.Surjective f.invOfMemRange :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functors F from category E to category D and G from category D to category C, the mapping of the composition of F and G is equal to the composition of the mapping of F and the mapping of G.",
    "output": "theorem map_comp_eq (F : E â¥¤ D) (G : D â¥¤ C) : map (F â‹™ G) = map F â‹™ map G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a set Î± is finite and nonempty, then the cardinality (or size) of Î± is greater than 0.",
    "output": "theorem Finite.card_pos [Finite Î±] [h : Nonempty Î±] : 0 < Nat.card Î± :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set S and group G with an involutive inverse, and assuming that S is a subset of G with an inverse element belonging to S, then for any subgroup H of S and any element x of G, the inverse of x is in H if and only if x is in H.",
    "output": "theorem inv_mem_iff {S G} [InvolutiveInv G] {_ : SetLike S G} [InvMemClass S G] {H : S}\n    {x : G} : xâ»Â¹ âˆˆ H â†” x âˆˆ H :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' from 'Î±' to 'Ïƒ', where 'Î±' and 'Ïƒ' are primitively encodable, if 'f' is a primitive recursive function, then 'f' is computable.",
    "output": "theorem Primrec.to_comp {Î± Ïƒ} [Primcodable Î±] [Primcodable Ïƒ] {f : Î± â†’ Ïƒ} (hf : Primrec f) :\n    Computable f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three paths p, q, and r in a topological space X, with p going from point xâ‚€ to xâ‚, q from xâ‚ to xâ‚‚, and r from xâ‚‚ to xâ‚ƒ, the path obtained by first traversing p, then q, and then r is the same as the path obtained by first traversing p, then the path obtained by traversing q and then r, after reparametrizing this latter path using a function that satisfies certain conditions (namely, it is continuous, and its values at 0 and 1 are the same as those of a certain auxiliary function).",
    "output": "theorem trans_assoc_reparam {xâ‚€ xâ‚ xâ‚‚ xâ‚ƒ : X} (p : Path xâ‚€ xâ‚) (q : Path xâ‚ xâ‚‚) (r : Path xâ‚‚ xâ‚ƒ) :\n    (p.trans q).trans r =\n      (p.trans (q.trans r)).reparam\n        (fun t => âŸ¨transAssocReparamAux t, transAssocReparamAux_mem_I tâŸ©) (by continuity)\n        (Subtype.ext transAssocReparamAux_zero) (Subtype.ext transAssocReparamAux_one) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' in Euclidean space 'E', if 's' is finite, then the convex hull of 's' in the real numbers is compact.",
    "output": "theorem Set.Finite.isCompact_convexHull {s : Set E} (hs : s.Finite) :\n    IsCompact (convexHull â„ s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given polynomial 'f' over a field 'K', if 'f' splits over the ring homomorphism identity on 'K', then the roots of the mapped polynomial 'f' under a function 'i' are equal to the roots of 'f' mapped under the same function 'i'.",
    "output": "theorem roots_map {f : K[X]} (hf : f.Splits <| RingHom.id K) : (f.map i).roots = f.roots.map i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The object 'one' of the parallel family 'f' is equal to 'Y'.",
    "output": "theorem parallelFamily_obj_one : (parallelFamily f).obj one = Y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two complex-valued functions 'f' and 'g', a complex number 'c', and a real number 'R', if 'f' and 'g' are both circle integrable with respect to 'c' and 'R', then the integral over the circle centered at 'c' with radius 'R' of the difference between 'f' and 'g' is equal to the difference between the integral of 'f' and the integral of 'g' over the same circle.",
    "output": "theorem integral_sub {f g : â„‚ â†’ E} {c : â„‚} {R : â„} (hf : CircleIntegrable f c R)\n    (hg : CircleIntegrable g c R) :\n    (âˆ® z in C(c, R), f z - g z) = (âˆ® z in C(c, R), f z) - âˆ® z in C(c, R), g z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given object 'k' in category 'K', the composition of the limit precomposition of functor 'F' with 'E' and the limit cone projection of the functor composition of 'E' and 'F' at 'k' is equal to the limit cone projection of 'F' at the object 'E.obj k'.",
    "output": "theorem limit.pre_Ï€ (k : K) : limit.pre F E â‰« limit.Ï€ (E â‹™ F) k = limit.Ï€ F (E.obj k) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given measure 'Î¼' and a set 's' in the measure space 'Î±', the set 's' is a subset of the measurable set 'toMeasurable Î¼ s'.",
    "output": "theorem subset_toMeasurable (Î¼ : Measure Î±) (s : Set Î±) : s âŠ† toMeasurable Î¼ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given commutative semiring R, a function f from M to Î¹, an element m of M, and an element r of R, the single-valued function (Finsupp.single) with m as the key and r as the value belongs to the gradeBy of R, f, and the function of m.",
    "output": "theorem single_mem_gradeBy {R} [CommSemiring R] (f : M â†’ Î¹) (m : M) (r : R) :\n    Finsupp.single m r âˆˆ gradeBy R f (f m) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If aâ‚‚ is less than or equal to bâ‚‚, aâ‚‚ is less than aâ‚, and bâ‚ is less than or equal to bâ‚‚, then the closed interval from aâ‚ to bâ‚ is a proper subset of the closed interval from aâ‚‚ to bâ‚‚.",
    "output": "theorem Icc_ssubset_Icc_left (hI : aâ‚‚ â‰¤ bâ‚‚) (ha : aâ‚‚ < aâ‚) (hb : bâ‚ â‰¤ bâ‚‚) : Icc aâ‚ bâ‚ âŠ‚ Icc aâ‚‚ bâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the natural degree of a polynomial 'p' is less than or equal to one, then there exist coefficients 'a' and 'b' such that 'p' can be expressed as 'a' times 'X' plus 'b'.",
    "output": "theorem exists_eq_X_add_C_of_natDegree_le_one (h : natDegree p â‰¤ 1) : âˆƒ a b, p = C a * X + C b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A constant function (denoted by 'c' and of type 'F') is differentiable over the field 'ğ•œ' and the domain 'E'.",
    "output": "theorem differentiable_const (c : F) : Differentiable ğ•œ fun _ : E => c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given filter L on a set E, the function that maps each element x' in E to the product of the inverse of the norm of the difference between x' and x, and the norm of the difference between the function f at x' and the function f at x minus the derivative of f at the difference between x' and x, tends to 0 as x' approaches x if and only if the function that maps each element x' in E to the scalar product of the inverse of the norm of the difference between x' and x, and the difference between the function f at x' and the function f at x minus the derivative of f at the difference between x' and x, tends to 0 as x' approaches x.",
    "output": "theorem has_fderiv_at_filter_real_equiv {L : Filter E} :\n    Tendsto (fun x' : E => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - f' (x' - x)â€–) L (ğ“ 0) â†”\n      Tendsto (fun x' : E => â€–x' - xâ€–â»Â¹ â€¢ (f x' - f x - f' (x' - x))) L (ğ“ 0) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any subgroup H of N, the product of the top subgroup of G and H is equal to the comap of H with respect to the second monoid homomorphism from G to N.",
    "output": "theorem top_prod (H : Subgroup N) : (âŠ¤ : Subgroup G).prod H = H.comap (MonoidHom.snd G N) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any four objects W, X, Y, Z in a category C, given that W and X have a binary biproduct and Y and Z also have a binary biproduct, for any morphism f from W to Y and any morphism g from X to Z, the composition of the biproduct map of f and g followed by the first projection of the biproduct is equal to the composition of the first projection of the biproduct followed by f.",
    "output": "theorem biprod.map_fst {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.map f g â‰« biprod.fst = biprod.fst â‰« f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a supremum operation on Î² and this operation is continuous, then if function f is strongly measurable and function g is also strongly measurable, the supremum of f and g is also strongly measurable.",
    "output": "theorem sup [Sup Î²] [ContinuousSup Î²] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f âŠ” g) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The absolute value of the sum of x and y equals the sum of the absolute values of x and y if and only if either x equals zero, y equals zero, or the argument of x equals the argument of y.",
    "output": "theorem abs_add_eq_iff : abs (x + y) = abs x + abs y â†” x = 0 âˆ¨ y = 0 âˆ¨ x.arg = y.arg :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given ring isomorphism between S and R, and a given element r of R, the inverse of the equivalence between L and M under the algebra map of R to M applied to r is equal to the algebra map of S to L applied to the inverse of the ring isomorphism applied to r.",
    "output": "theorem equivOfEquiv_symm_algebraMap (hSR : S â‰ƒ+* R) (r : R) :\n    (equivOfEquiv L M hSR).symm (algebraMap R M r) = algebraMap S L (hSR.symm r) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of a certain type 'Î±', under the conditions that 'Î±' has a topological space structure, a complete linear order, and an order topology, if the set 's' is nonempty, then the greatest lower bound (infimum) of the set 's' is an element of the closure of the set 's'.",
    "output": "theorem sInf_mem_closure {Î± : Type u} [TopologicalSpace Î±] [CompleteLinearOrder Î±] [OrderTopology Î±]\n    {s : Set Î±} (hs : s.Nonempty) : sInf s âˆˆ closure s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two supremum-preserving functions gâ‚ and gâ‚‚ from Î² to Î³, and a surjective supremum-preserving function f from Î± to Î², gâ‚ composed with f equals gâ‚‚ composed with f if and only if gâ‚ equals gâ‚‚. This is known as right cancellation.",
    "output": "theorem cancel_right {gâ‚ gâ‚‚ : SupHom Î² Î³} {f : SupHom Î± Î²} (hf : Surjective f) :\n    gâ‚.comp f = gâ‚‚.comp f â†” gâ‚ = gâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The neighborhood of infinity has a basis consisting of sets that are greater than a certain value, where this value is less than infinity.",
    "output": "theorem nhds_top_basis : (ğ“ âˆ).HasBasis (fun a => a < âˆ) fun a => Ioi a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functions fâ‚ and fâ‚‚ from Î± to Î², and two filters lâ‚ on Î± and lâ‚‚ on Î², if fâ‚ is eventually equal to fâ‚‚ at lâ‚, then the tendency of fâ‚ to go from lâ‚ to lâ‚‚ is equivalent to the tendency of fâ‚‚ to go from lâ‚ to lâ‚‚.",
    "output": "theorem tendsto_congr' {fâ‚ fâ‚‚ : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} (hl : fâ‚ =á¶ [lâ‚] fâ‚‚) :\n    Tendsto fâ‚ lâ‚ lâ‚‚ â†” Tendsto fâ‚‚ lâ‚ lâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' of the Centroid Homomorphism of 'Î±' and any natural number 'n', the endomorphism of 'x' raised to the power 'n' is equal to the endomorphism of 'x' itself raised to the power 'n'.",
    "output": "theorem toEnd_pow (x : CentroidHom Î±) (n : â„•) : (x ^ n).toEnd = x.toEnd ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The arccosine function is differentiable at a real number x if and only if x is not equal to -1 and x is not equal to 1.",
    "output": "theorem differentiableAt_arccos {x : â„} : DifferentiableAt â„ arccos x â†” x â‰  -1 âˆ§ x â‰  1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', and any function 'v' from the finite set of size 'n' to the real numbers 'R', the value of the Vandermonde matrix at the 'i'th row and 'j'th column is equal to the 'i'th value of 'v' raised to the power of 'j'.",
    "output": "theorem vandermonde_apply {n : â„•} (v : Fin n â†’ R) (i j) : vandermonde v i j = v i ^ (j : â„•) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function that maps a point to the infimum non-negative distance from that point to a set is continuous.",
    "output": "theorem continuous_infNndist_pt (s : Set Î±) : Continuous fun x => infNndist x s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any cardinal number 'c', 'c' is greater than or equal to 1 if and only if 'c' is not equal to 0.",
    "output": "theorem one_le_iff_ne_zero {c : Cardinal} : 1 â‰¤ c â†” c â‰  0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any four games w, x, y, z, if game w is less than or equal to game x and game y is not fuzzy with game z, then the sum of game w and game y is not fuzzy with the sum of game x and game z.",
    "output": "theorem add_lf_add_of_le_of_lf {w x y z : PGame} (hwx : w â‰¤ x) (hyz : y â§ z) : w + y â§ x + z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of sequences in 'E', if 's' is closed and nonempty, and 'x' is any sequence in 'E', then the intersection of 's' and the cylinder of 'x' with the longest prefix in 's' is also nonempty.",
    "output": "theorem inter_cylinder_longestPrefix_nonempty {s : Set (âˆ€ n, E n)} (hs : IsClosed s)\n    (hne : s.Nonempty) (x : âˆ€ n, E n) : (s âˆ© cylinder x (longestPrefix x s)).Nonempty :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' and any finite set 's', if 'a' is not a member of 's', then the set that results from attempting to remove 'a' from 's' is equal to 's'.",
    "output": "theorem erase_eq_of_not_mem {a : Î±} {s : Finset Î±} (h : a âˆ‰ s) : erase s a = s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The positive value is equal to one.",
    "output": "theorem pos_eq_one : pos = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two local equivalences 'e' between types Î± and Î², and 'e'' between types Î³ and Î´, the symmetry of the product of 'e' and 'e'' is equal to the product of the symmetries of 'e' and 'e''.",
    "output": "theorem prod_symm (e : LocalEquiv Î± Î²) (e' : LocalEquiv Î³ Î´) :\n    (e.prod e').symm = e.symm.prod e'.symm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', converting 'n' from a non-negative extended real number to a non-negative real number results in 'n' itself.",
    "output": "theorem toNNReal_nat (n : â„•) : (n : â„â‰¥0âˆ).toNNReal = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse of zero in the power series over a field k is zero.",
    "output": "theorem zero_inv : (0 : PowerSeries k)â»Â¹ = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function 'f' from 'Î±' to 'M' where 'M' is a zero element and 'G' is an additive commutative group, and two functions 'hâ‚' and 'hâ‚‚' from 'Î±' to 'M' to 'G', the sum of the differences between 'hâ‚' and 'hâ‚‚' for each element in 'f' is equal to the difference between the sum of 'hâ‚' for each element in 'f' and the sum of 'hâ‚‚' for each element in 'f'.",
    "output": "theorem sum_sub [Zero M] [AddCommGroup G] {f : Î± â†’â‚€ M} {hâ‚ hâ‚‚ : Î± â†’ M â†’ G} :\n    (f.sum fun a b => hâ‚ a b - hâ‚‚ a b) = f.sum hâ‚ - f.sum hâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of the reciprocals of the non-negative real numbers p and q is equal to 1.",
    "output": "theorem inv_add_inv_conj_nnreal : 1 / Real.toNNReal p + 1 / Real.toNNReal q = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' which is a complete lattice homomorphism from Î± to Î², the coercion of 'f' to an infimum-preserving function is equal to the function 'f' itself.",
    "output": "theorem toFun_eq_coe_aux {f : CompleteLatticeHom Î± Î²} : â†‘f.tosInfHom = â‡‘f :="
  },
  {
    "instruction": "",
    "input": "For a given type G, if G is a group and a topological space, and if the following conditions are met:",
    "output": "theorem TopologicalGroup.of_nhds_one {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ğ“ 1 Ã—Ë¢ ğ“ 1) (ğ“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ğ“ 1) (ğ“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ğ“ xâ‚€ = map (fun x => xâ‚€ * x) (ğ“ 1))\n    (hconj : âˆ€ xâ‚€ : G, Tendsto (fun x => xâ‚€ * x * xâ‚€â»Â¹) (ğ“ 1) (ğ“ 1)) : TopologicalGroup G :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If I and J are ideals of a ring A and both are homogeneous with respect to a graded algebra ğ’œ, then the product of I and J is also homogeneous with respect to ğ’œ.",
    "output": "theorem Ideal.IsHomogeneous.mul {I J : Ideal A} (HI : I.IsHomogeneous ğ’œ) (HJ : J.IsHomogeneous ğ’œ) :\n    (I * J).IsHomogeneous ğ’œ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'f' from 'Î±' to 'Î²', a set 's' of 'Î±', and an element 'a' of 'Î±', and if the function 'f' is strictly monotonically increasing on the set 's', and if the set 's' is in the neighborhood of 'a' with values greater than or equal to 'a', and if for every 'b' greater than 'f(a)', there exists a 'c' in 's' such that 'f(c)' is in the open interval between 'f(a)' and 'b', then the function 'f' is continuous at 'a' within the set of all 'Î±' greater than or equal to 'a'.",
    "output": "theorem StrictMonoOn.continuousWithinAt_right_of_exists_between {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}\n    (h_mono : StrictMonoOn f s) (hs : s âˆˆ ğ“[â‰¥] a) (hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b) :\n    ContinuousWithinAt f (Ici a) a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Ïƒ' to 'Ï„' that is injective, a multivariate polynomial 'Ï†' over 'Ïƒ' and 'R', and a function 'd' from 'Ïƒ' to the natural numbers, the coefficient of the renamed polynomial (where 'f' is applied to 'Ï†') at the domain mapped by 'f' is equal to the coefficient of 'Ï†' at 'd'.",
    "output": "theorem coeff_rename_mapDomain (f : Ïƒ â†’ Ï„) (hf : Injective f) (Ï† : MvPolynomial Ïƒ R) (d : Ïƒ â†’â‚€ â„•) :\n    (rename f Ï†).coeff (d.mapDomain f) = Ï†.coeff d :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A function 'f' is equitable on a set 's' if and only if for every element 'a' in 's', the value of 'f' at 'a' is equal to the sum of the values of 'f' at every element in 's' divided by the cardinality of 's', or the value of 'f' at 'a' is equal to the sum of the values of 'f' at every element in 's' divided by the cardinality of 's' plus one.",
    "output": "theorem equitableOn_iff :\n    EquitableOn (s : Set Î±) f â†”\n      âˆ€ a âˆˆ s, f a = (âˆ‘ i in s, f i) / s.card âˆ¨ f a = (âˆ‘ i in s, f i) / s.card + 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measurable set 's', the indicator function of 's' applied to a function 'f' is almost everywhere equal to the function 'f' restricted to the set 's' with respect to the measure 'Î¼'.",
    "output": "theorem indicator_ae_eq_restrict (hs : MeasurableSet s) : indicator s f =áµ[Î¼.restrict s] f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given equivalence between two types Î³ and Î², and a function from Î² to Î±, the infinite sum over Î³ of the function composed with the equivalence is equal to the infinite sum over Î² of the function.",
    "output": "theorem Equiv.tsum_eq (j : Î³ â‰ƒ Î²) (f : Î² â†’ Î±) : (âˆ‘' c, f (j c)) = âˆ‘' b, f b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any function 'f' that maps each index 'i' to a filter on 'Î± i', and for any index 'i', the function 'eval i' tends towards the filter 'f i' when evaluated over the product of filters 'pi f'.",
    "output": "theorem tendsto_eval_pi (f : âˆ€ i, Filter (Î± i)) (i : Î¹) : Tendsto (eval i) (pi f) (f i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": ", given a function 'k' that tends to 'l' at the top, the function 'f' has superpolynomial decay with respect to 'l' and 'k' if and only if for every integer 'z', 'f' is a big O of the function that maps 'a' (of type alpha) to 'k' of 'a' raised to the power of 'z', at 'l'.",
    "output": "theorem superpolynomialDecay_iff_isBigO (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k f â†” âˆ€ z : â„¤, f =O[l] fun a : Î± => k a ^ z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The range of the identity function from a structure L to a structure M is the top element or the whole set.",
    "output": "theorem range_id : range (id L M) = âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For two functions f and g that commute, where f is monotone and g is strictly monotone, for any x and a positive integer n, the nth iteration of f and g applied to x are equal if and only if the functions f and g are equal when applied to x.",
    "output": "theorem iterate_pos_eq_iff_map_eq (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : (f^[n]) x = (g^[n]) x â†” f x = g x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The bounded limit inferior (bliminf) of a function u with respect to a filter f for a condition that is either p(x) or q(x), is less than or equal to the bounded limit inferior of the same function with respect to the same filter for the condition p(x).",
    "output": "theorem bliminf_or_le_inf_aux_left : (bliminf u f fun x => p x âˆ¨ q x) â‰¤ bliminf u f p :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The dual pairing of a subspace W of Vâ‚ over a field K is nondegenerate.",
    "output": "theorem dualPairing_nondegenerate (W : Subspace K Vâ‚) : W.dualPairing.Nondegenerate :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural numbers 'b' and 'n', the logarithm base 'b' of the product of 'n' divided by 'b' and 'b' is equal to the logarithm base 'b' of 'n'.",
    "output": "theorem log_div_mul_self (b n : â„•) : log b (n / b * b) = log b n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any measure 'Î¼' on a group 'G', the condition that for all elements 'g' of 'G' and for all sets 'A' of 'G' that are measurable, the measure of the preimage of 'A' under the function that multiplies 'g' with an element 'h' is equal to the measure of 'A', if and only if the measure 'Î¼' is left invariant under multiplication.",
    "output": "theorem forall_measure_preimage_mul_iff (Î¼ : Measure G) :\n    (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ Î¼ ((fun h => g * h) â»Â¹' A) = Î¼ A) â†”\n      IsMulLeftInvariant Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a covariant class in algebraic order, given any three elements a, b, and c, the supremum (or greatest lower bound) of a and b, when multiplied by c, is equal to the supremum of the products of a and c, and b and c.",
    "output": "theorem sup_mul [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] (a b c : Î±) : (a âŠ” b) * c = a * c âŠ” b * c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given convex set 's' in a vector space 'E' and a given element 'x' in 'E', the set 's' remains convex after removing 'x' if and only if 'x' is not in the convex hull of the set 's' after 'x' has been removed.",
    "output": "theorem Convex.convex_remove_iff_not_mem_convexHull_remove {s : Set E} (hs : Convex ğ•œ s) (x : E) :\n    Convex ğ•œ (s \\ {x}) â†” x âˆ‰ convexHull ğ•œ (s \\ {x}) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' of a ring 'R', if 'a' is in the set of non-units of 'R', then '1 - a' is a unit.",
    "output": "theorem isUnit_one_sub_self_of_mem_nonunits (a : R) (h : a âˆˆ nonunits R) : IsUnit (1 - a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a preordered set Î±, if for every element a there exists an element b in set s such that a is less than or equal to b, then the set s is unbounded with respect to the less than relation.",
    "output": "theorem unbounded_lt_of_forall_exists_le [Preorder Î±] (h : âˆ€ a, âˆƒ b âˆˆ s, a â‰¤ b) :\n    Unbounded (Â· < Â·) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object X in category C, applying the function 'app Ï„' to the object 'W.Q.obj X' is equal to applying 'Ï„.app' to X.",
    "output": "theorem app_eq (X : C) : (app Ï„) (W.Q.obj X) = Ï„.app X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a nonempty set Î± and a real number M, the norm of function f is less than M if and only if for all elements x, the norm of f(x) is less than M.",
    "output": "theorem norm_lt_iff_of_nonempty [Nonempty Î±] {M : â„} : â€–fâ€– < M â†” âˆ€ x, â€–f xâ€– < M :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In the box product of two simple graphs G and H, the vertices (a, bâ‚) and (a, bâ‚‚) are adjacent if and only if the vertices bâ‚ and bâ‚‚ are adjacent in the graph H.",
    "output": "theorem boxProd_adj_right : (G â–¡ H).Adj (a, bâ‚) (a, bâ‚‚) â†” H.Adj bâ‚ bâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from set M to N, if the closure of a subset 's' equals the universal set, then the function derived from the closure of M equals the top left, which is equal to 'f'.",
    "output": "theorem coe_ofClosureMEqTopLeft (f : M â†’ N) (hs : closure s = âŠ¤) (h1 hmul) :\n    â‡‘(ofClosureMEqTopLeft f hs h1 hmul) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any even number 'n' and any element 'a' in a field, the nth power of 'a' is greater than or equal to zero.",
    "output": "theorem Even.zpow_nonneg (hn : Even n) (a : Î±) : 0 â‰¤ a ^ n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a decidable equality type Î· that is finite, given a function H that maps each element i to a subgroup of f(i), and a subgroup J of the function that maps each element i to f(i), the product over the universe of H is less than or equal to J if and only if for every element i of Î·, the map of the monoid homomorphism of f at i and H(i) is less than or equal to J.",
    "output": "theorem pi_le_iff [DecidableEq Î·] [Finite Î·] {H : âˆ€ i, Subgroup (f i)} {J : Subgroup (âˆ€ i, f i)} :\n    pi univ H â‰¤ J â†” âˆ€ i : Î·, map (MonoidHom.single f i) (H i) â‰¤ J :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function c is differentiable at a point x, then the derivative of the function that multiplies c by a constant d at the point x is equal to d times the derivative of c at x.",
    "output": "theorem fderiv_mul_const (hc : DifferentiableAt ğ•œ c x) (d : ğ”¸') :\n    fderiv ğ•œ (fun y => c y * d) x = d â€¢ fderiv ğ•œ c x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three numbers a, b, and c, the maximum value of the division of a by b and the division of a by c is equal to the division of a by the minimum value of b and c.",
    "output": "theorem max_div_div_left' (a b c : Î±) : max (a / b) (a / c) = a / min b c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The intersection over the union of two sets of sets, S and T, is equal to the intersection of the intersection over S and the intersection over T.",
    "output": "theorem sInter_union (S T : Set (Set Î±)) : â‹‚â‚€ (S âˆª T) = â‹‚â‚€ S âˆ© â‹‚â‚€ T :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a real-valued linear map 'f' from a function 'Î¹ â†’ â„' to another function 'Î¹ â†’ â„', if the determinant of 'f' is not zero, then the measure of the map 'f' with respect to the volume is equal to the scalar multiple of the volume, where the scalar is the inverse of the absolute value of the determinant of 'f'.",
    "output": "theorem map_linearMap_volume_pi_eq_smul_volume_pi {f : (Î¹ â†’ â„) â†’â‚—[â„] Î¹ â†’ â„}\n    (hf : LinearMap.det f â‰  0) : Measure.map f volume =\n      ENNReal.ofReal (abs (LinearMap.det f)â»Â¹) â€¢ volume :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'r' from set M and any elements 'x' and 'y' from set A, the scalar multiplication of 'r' with the division of 'x' and 'y' is equal to the division of the scalar multiplication of 'r' with 'x' and the scalar multiplication of 'r' with 'y'.",
    "output": "theorem smul_div' (r : M) (x y : A) : r â€¢ (x / y) = r â€¢ x / r â€¢ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a preorder set of elements Î±, where Î± is a subsingleton (a set with at most one element), any element x is less than or equal to any element y.",
    "output": "theorem Subsingleton.le [Preorder Î±] [Subsingleton Î±] (x y : Î±) : x â‰¤ y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three natural numbers a, b, and c, if a is greater than 0, then the product of b and a not being equal to the product of c and a implies that b is not equal to c.",
    "output": "theorem mul_ne_mul_left {a b c : â„•} (ha : 0 < a) : b * a â‰  c * a â†” b â‰  c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements aâ‚, bâ‚ from ring R and any two elements aâ‚‚, bâ‚‚ from module M, if the product of bâ‚ and the co-unit of aâ‚‚ equals the product of aâ‚ and the co-unit of bâ‚‚, then the localization of ring R at multiplicative set S with respect to aâ‚ and aâ‚‚ equals the localization of ring R at multiplicative set S with respect to bâ‚ and bâ‚‚.",
    "output": "theorem mk'_eq_of_eq' {aâ‚ bâ‚ : R} {aâ‚‚ bâ‚‚ : M} (H : bâ‚ * â†‘aâ‚‚ = aâ‚ * â†‘bâ‚‚) :\n    mk' S aâ‚ aâ‚‚ = mk' S bâ‚ bâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two decidable predicates P and Q, if P is less than or equal to Q, then the greatest natural number satisfying P is less than or equal to the greatest natural number satisfying Q.",
    "output": "theorem findGreatest_mono_left [DecidablePred Q] (hPQ : P â‰¤ Q) :\n    Nat.findGreatest P â‰¤ Nat.findGreatest Q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two fractional ideals I and J in a ring of fractions S over a ring P, and for any property C of elements in P, if an element r belongs to the product of I and J, and if the property C holds for the product of any element in I and any element in J, and if the property C holds for the sum of any two elements for which C holds, then the property C holds for the element r.",
    "output": "theorem mul_induction_on {I J : FractionalIdeal S P} {C : P â†’ Prop} {r : P}\n    (hr : r âˆˆ I * J) (hm : âˆ€ i âˆˆ I, âˆ€ j âˆˆ J, C (i * j)) (ha : âˆ€ x y, C x â†’ C y â†’ C (x + y)) :\n    C r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The degree of the product of a multiset 't' is less than or equal to the sum of the degrees of the polynomials in 't'.",
    "output": "theorem degree_multiset_prod_le : t.prod.degree â‰¤ (t.map Polynomial.degree).sum :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a Polish space, a measurable space, and a Borel space, for any set 's', if 's' is a measurable set, then 's' is clopenable.",
    "output": "theorem _root_.MeasurableSet.isClopenable [PolishSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±]\n    {s : Set Î±} (hs : MeasurableSet s) : IsClopenable s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a covariant class in algebra, given two elements b and c such that b is less than c, and another element a, the product of a and b is less than the product of a and c. This is under the condition that the operation is multiplication and the relation is less than.",
    "output": "theorem mul_lt_mul_left' [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)] {b c : Î±} (bc : b < c) (a : Î±) :\n    a * b < a * c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The Chebyshev polynomial of the second kind in ring R is equal to 2 times the square of the polynomial variable minus 1.",
    "output": "theorem T_two : T R 2 = 2 * X ^ 2 - 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The arccosine of zero is equal to pi divided by two.",
    "output": "theorem arccos_zero : arccos 0 = Ï€ / 2 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given multiset 'm' of type Î±, if we convert 'm' to an enumerated finite set and then map the first element of each pair in the set, we will get back the original multiset 'm'.",
    "output": "theorem Multiset.map_toEnumFinset_fst (m : Multiset Î±) : m.toEnumFinset.val.map Prod.fst = m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The exponential of the conjugate of a complex number is equal to the conjugate of the exponential of the complex number.",
    "output": "theorem exp_conj : exp (conj x) = conj (exp x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' in a set 's', the inclusion of 'x' in the subset that is identical to 's' (i.e., the subset is 's' itself) is equal to 'x'.",
    "output": "theorem inclusion_self (x : s) : inclusion Subset.rfl x = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a filter 'f' on a set 'Î±' and two functions 'ma' and 'mb' from 'Î±' to the extended non-negative real numbers, along with two extended non-negative real numbers 'a' and 'b'. If 'ma' tends to 'a' along 'f', 'a' is not zero or 'b' is not infinity, 'mb' tends to 'b' along 'f', and 'b' is not zero or 'a' is not infinity, then the function that maps 'a' to the product of 'ma' at 'a' and 'mb' at 'a' tends to the product of 'a' and 'b' along 'f'.",
    "output": "theorem Tendsto.mul {f : Filter Î±} {ma : Î± â†’ â„â‰¥0âˆ} {mb : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hma : Tendsto ma f (ğ“ a)) (ha : a â‰  0 âˆ¨ b â‰  âŠ¤) (hmb : Tendsto mb f (ğ“ b))\n    (hb : b â‰  0 âˆ¨ a â‰  âŠ¤) : Tendsto (fun a => ma a * mb a) f (ğ“ (a * b)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given point 'x' that is a generic point of a set 'S', and a set 'U' that is open, 'S' and 'U' are disjoint if and only if 'x' is not an element of 'U'.",
    "output": "theorem disjoint_iff (h : IsGenericPoint x S) (hU : IsOpen U) : Disjoint S U â†” x âˆ‰ U :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'x' from the trivial square zero extension of rings 'R' and 'M', if 'x.fst' (the first component of 'x') is invertible, then 'x' is equal to the scalar multiplication of 'x.fst' and the exponential of the scalar multiplication of the inverse of 'x.fst' and 'inr x.snd' (the second component of 'x' embedded in the extension).",
    "output": "theorem eq_smul_exp_of_invertible (x : tsze R M) [Invertible x.fst] :\n    x = x.fst â€¢ exp ğ•œ (â…Ÿ x.fst â€¢ inr x.snd) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The upper bounds of the set of all elements less than or equal to a certain value 'a' is the set of all elements greater than or equal to 'a'.",
    "output": "theorem upperBounds_Iic : upperBounds (Iic a) = Ici a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If R is a type with a commutative semiring structure, Ïƒ is a finite type, and R has no zero divisors, then the multivariate polynomial ring over R with variables from Ïƒ also has no zero divisors.",
    "output": "theorem noZeroDivisors_of_finite (R : Type u) (Ïƒ : Type v) [CommSemiring R] [Finite Ïƒ]\n    [NoZeroDivisors R] : NoZeroDivisors (MvPolynomial Ïƒ R) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The set of proper divisors of 1 is empty.",
    "output": "theorem properDivisors_one : properDivisors 1 = âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If set tâ‚ is a subset of set tâ‚‚, then the union of set s and tâ‚ is a subset of the union of set s and tâ‚‚.",
    "output": "theorem union_subset_union_right (h : tâ‚ âŠ† tâ‚‚) : s âˆª tâ‚ âŠ† s âˆª tâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b' from a set 'Î±', the function 'toBoolAlg' applied to 'a' equals 'toBoolAlg' applied to 'b' if and only if 'a' equals 'b'.",
    "output": "theorem toBoolAlg_inj {a b : Î±} : toBoolAlg a = toBoolAlg b â†” a = b :="
  },
  {
    "instruction": "",
    "input": "For any two positional games x and y, x is less than or equal to y if and only if one of the following two conditions is met:",
    "output": "theorem lf_def {x y : PGame} :\n    x â§ y â†”\n      (âˆƒ i, (âˆ€ i', x.moveLeft i' â§ y.moveLeft i) âˆ§ âˆ€ j, x â§ (y.moveLeft i).moveRight j) âˆ¨\n        âˆƒ j, (âˆ€ i, (x.moveRight j).moveLeft i â§ y) âˆ§ âˆ€ j', x.moveRight j â§ y.moveRight j' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any partial function 's' with output type 'Ïƒ', the function that ignores its input and always returns 's' is partially recursive.",
    "output": "theorem const' (s : Part Ïƒ) : Partrec fun _ : Î± => s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three finite sets s, t, and u, the difference of the difference of s and t with u is equal to the intersection of the difference of s and t with the difference of s and u.",
    "output": "theorem sdiff_sdiff_left' (s t u : Finset Î±) : (s \\ t) \\ u = s \\ t âˆ© (s \\ u) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any natural number 'n', casting 'n' to a real number and then to a field 'K' is equal to the original natural number 'n'.",
    "output": "theorem ofReal_natCast (n : â„•) : ((n : â„) : K) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The infimum (greatest lower bound) of the union of two multisets sâ‚ and sâ‚‚ is equal to the infimum of sâ‚ intersected with the infimum of sâ‚‚.",
    "output": "theorem inf_union (sâ‚ sâ‚‚ : Multiset Î±) : (sâ‚ âˆª sâ‚‚).inf = sâ‚.inf âŠ“ sâ‚‚.inf :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of 'a' and 'b' divided by 'c' is equal to 'a' divided by 'c' multiplied by 'b'.",
    "output": "theorem mul_div_right_comm : a * b / c = a / c * b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given preorder Î¹, a filter l, and a function s from Î¹ to the set of Î±, if l has an antitone basis s, then a set t is in l if and only if there exists an i such that s(i) is a subset of t.",
    "output": "theorem HasAntitoneBasis.mem_iff [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}\n    (hs : l.HasAntitoneBasis s) {t : Set Î±} : t âˆˆ l â†” âˆƒ i, s i âŠ† t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any given element 'c' in a set 'Î±', 'a' divided by 'c' is less than 'b' divided by 'c' if and only if 'a' is less than 'b'.",
    "output": "theorem div_lt_div_iff_right (c : Î±) : a / c < b / c â†” a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Mapping a matrix with the identity ring equivalence (which leaves every element unchanged) is the same as the identity ring equivalence of the matrix itself. This is true for a matrix of any size m by m with elements from the ring Î±.",
    "output": "theorem mapMatrix_refl : (RingEquiv.refl Î±).mapMatrix = RingEquiv.refl (Matrix m m Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two functions 'f' and 'g' from a set 'Î¹' to the non-negative real numbers, and for any real number 'p' greater than or equal to 1, if the series of 'f' to the power of 'p' and 'g' to the power of 'p' are both summable, then the series of '(f + g) to the power of 'p' is also summable. Furthermore, the pth root of the sum of '(f + g) to the power of 'p' is less than or equal to the sum of the pth root of 'f to the power of 'p' and the pth root of 'g to the power of 'p'.",
    "output": "theorem Lp_add_le_tsum {f g : Î¹ â†’ â„â‰¥0} {p : â„} (hp : 1 â‰¤ p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) âˆ§\n      (âˆ‘' i, (f i + g i) ^ p) ^ (1 / p) â‰¤\n        (âˆ‘' i, f i ^ p) ^ (1 / p) + (âˆ‘' i, g i ^ p) ^ (1 / p) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f has a derivative at a filter L around a point x, then the function obtained by scaling f by a constant c also has a derivative at the same filter, and this derivative is the original derivative scaled by the same constant c.",
    "output": "theorem HasDerivAtFilter.const_smul (c : R) (hf : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun y => c â€¢ f y) (c â€¢ f') x L :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any number 'n' of the numerical type 'Num', converting 'n' to a natural number and then to an integer results in the original number 'n'.",
    "output": "theorem to_nat_to_int (n : Num) : ((n : â„•) : â„¤) = n :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'a' is differentiable at a point 'x' in a field 'ğ•œ', then the derivative of the function that multiplies 'a' by a constant 'b' at the point 'x' is equal to the derivative of 'a' at 'x' multiplied on the right by 'b'.",
    "output": "theorem fderiv_mul_const' (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :\n    fderiv ğ•œ (fun y => a y * b) x = (fderiv ğ•œ a x).smulRight b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of a multiset 'i' is disjoint from a multiset 'a' if and only if every element 'b' in 'i' is disjoint from 'a'.",
    "output": "theorem disjoint_sum_left {a : Multiset Î±} {i : Multiset (Multiset Î±)} :\n    Multiset.Disjoint i.sum a â†” âˆ€ b âˆˆ i, Multiset.Disjoint b a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function f tends towards a and function g tends towards b as x approaches a certain value in the filter Î±, then the function that multiplies the outputs of f and g also tends towards the product of a and b.",
    "output": "theorem Filter.Tendsto.mul {f g : Î± â†’ M} {x : Filter Î±} {a b : M} (hf : Tendsto f x (ğ“ a))\n    (hg : Tendsto g x (ğ“ b)) : Tendsto (fun x => f x * g x) x (ğ“ (a * b)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A pair (u, v) is dependent in the projective space over a field K with vector space V if and only if u is equal to v.",
    "output": "theorem dependent_pair_iff_eq (u v : â„™ K V) : Dependent ![u, v] â†” u = v :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The length of the row lengths in a Young Diagram, denoted as Î¼, is equal to the length of the column at index 0.",
    "output": "theorem length_rowLens {Î¼ : YoungDiagram} : Î¼.rowLens.length = Î¼.colLen 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any bounded linear map 'f' from a normed space over a field 'ğ•œ' to a semi-normed space over a nontrivially normed field 'ğ•œâ‚‚', the supremum of the nonnegative norms of 'f' over the closed unit ball is equal to the nonnegative norm of 'f'.",
    "output": "theorem sSup_closed_unit_ball_eq_nnnorm {ğ•œ ğ•œâ‚‚ E F : Type _} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField ğ•œ] [NontriviallyNormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚}\n    [NormedSpace ğ•œ E] [NormedSpace ğ•œâ‚‚ F] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) :\n    sSup ((fun x => â€–f xâ€–â‚Š) '' closedBall 0 1) = â€–fâ€–â‚Š :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a reduction step from list Lâ‚ to list Lâ‚‚, then the reduction of list Lâ‚ is equal to the reduction of list Lâ‚‚.",
    "output": "theorem reduce.Step.eq (H : Red.Step Lâ‚ Lâ‚‚) : reduce Lâ‚ = reduce Lâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If Ï† is an integrable function from Î± to H, and L is a continuous linear map from H to E, then the composition of L and Ï† (i.e., the function that maps each element a in Î± to L(Ï†(a))) is also integrable.",
    "output": "theorem ContinuousLinearMap.integrable_comp {Ï† : Î± â†’ H} (L : H â†’L[ğ•œ] E) (Ï†_int : Integrable Ï† Î¼) :\n    Integrable (fun a : Î± => L (Ï† a)) Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given type Î± with a zero element, and another type Î¹, if we have a function f mapping Î¹ to Î± and another function g mapping Î¹ and Î± to a type A, then the product of the function f and g under a homomorphism Ï† is equal to the product of the function f and the function that maps i and a to the homomorphism Ï† of g applied to i and a.",
    "output": "theorem map_finsupp_prod {Î± : Type _} [Zero Î±] {Î¹ : Type _} (f : Î¹ â†’â‚€ Î±) (g : Î¹ â†’ Î± â†’ A) :\n    Ï† (f.prod g) = f.prod fun i a => Ï† (g i a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The product of the filters 'f' and 'g' is equal to the composition of the function 'Prod.swap' and the product of the filters 'g' and 'f'.",
    "output": "theorem prod_comm' : f Ã—Ë¢ g = comap Prod.swap (g Ã—Ë¢ f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "A set 's' is closed if and only if for every element 'x', if every neighborhood 'U' of 'x' has a nonempty intersection with 's', then 'x' belongs to 's'.",
    "output": "theorem isClosed_iff_nhds {s : Set Î±} : IsClosed s â†” âˆ€ x, (âˆ€ U âˆˆ ğ“ x, (U âˆ© s).Nonempty) â†’ x âˆˆ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The kernel of the subtype of a subgroup H of a group G is the trivial group.",
    "output": "theorem _root_.Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a morphism 'f' from the presheaf of 'G' to 'F'', given that 'F'' is a sheaf with respect to the Grothendieck topology 'J', the composition of the morphism derived from the less than or equal to relation of 'G' to the sheafification of 'J' and the lift of the sheafification of 'G' with respect to 'f' and 'h' is equal to 'f'.",
    "output": "theorem Subpresheaf.to_sheafifyLift (f : G.toPresheaf âŸ¶ F') (h : Presieve.IsSheaf J F') :\n    Subpresheaf.homOfLe (G.le_sheafify J) â‰« G.sheafifyLift f h = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'a' of type Î± that is not the bottom element, the predecessor of the co-element of 'a' in the type WithBot Î± is equal to the co-element of the predecessor of 'a'.",
    "output": "theorem pred_coe_of_ne_bot {a : Î±} (h : a â‰  âŠ¥) : pred (â†‘a : WithBot Î±) = â†‘(pred a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a continuous function 'f' from a topological space 'Î±' to another topological space 'Î²', the continuous map of 'f' is equal to 'f' itself.",
    "output": "theorem coe_toContinuousMap (f : Î± â†’CO Î²) : (f.toContinuousMap : Î± â†’ Î²) = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given equivalence 'e' that maps set 's' to set 't', for any element 'y', if 'y' is in the target of 'e', then 'y' is in 't' if and only if the inverse of 'e' applied to 'y' is in 's'.",
    "output": "theorem symm_apply_mem_iff (h : e.IsImage s t) : âˆ€ â¦ƒyâ¦„, y âˆˆ e.target â†’ (e.symm y âˆˆ s â†” y âˆˆ t) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any nonempty finite set 's', there exists an element 'a' such that 'a' is the maximum of set 's'.",
    "output": "theorem max_of_nonempty {s : Finset Î±} (h : s.Nonempty) : âˆƒ a : Î±, s.max = a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The interval from r to s under the function u is convex in the field ğ•œ.",
    "output": "theorem convex_uIcc (r s : Î²) : Convex ğ•œ (uIcc r s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two sets 's' and 't', and any other two sets 's'' and 't'', if 's' is almost everywhere less than or equal to 't' with respect to measure 'Î¼', and 's'' is almost everywhere less than or equal to 't'' with respect to the same measure 'Î¼', then the intersection of 's' and 's'' is almost everywhere less than or equal to the intersection of 't' and 't'' with respect to measure 'Î¼'.",
    "output": "theorem ae_le_set_inter {s' t' : Set Î±} (h : s â‰¤áµ[Î¼] t) (h' : s' â‰¤áµ[Î¼] t') :\n    (s âˆ© s' : Set Î±) â‰¤áµ[Î¼] (t âˆ© t' : Set Î±) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a functor H from category J to the functor category Kâ¥¤C, given that H has a colimit and given a cocone c over H, for any objects j in J and k in K, the composition of the application of the colimit cocone's morphism at j and the application of the morphism of the cocone c at j, both applied at k, is equal to the application at k of the application at j of the morphism of the cocone c.",
    "output": "theorem colimit.Î¹_desc_app (H : J â¥¤ K â¥¤ C) [HasColimit H] (c : Cocone H) (j : J) (k : K) :\n    (colimit.Î¹ H j).app k â‰« (colimit.desc H c).app k = (c.Î¹.app j).app k :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two disjoint closed sets 's' and 't' in a topological space 'X', there exists a continuous function 'f' from 'X' to the real numbers such that 'f' equals 0 on 's', 'f' equals 1 on 't', and for all 'x' in 'X', the value of 'f(x)' lies in the closed interval from 0 to 1.",
    "output": "theorem exists_continuous_zero_one_of_closed {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)\n    (hd : Disjoint s t) : âˆƒ f : C(X, â„), EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± and any two sets S and T of this type, the cardinality (or size) of the union of S and T is less than or equal to the sum of the cardinalities of S and T.",
    "output": "theorem mk_union_le {Î± : Type u} (S T : Set Î±) : (#(S âˆª T : Set Î±)) â‰¤ (#S) + (#T) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a ring homomorphism 'f' from ring 'R' to ring 'S' and an element 'r' from ring 'R', the kernel lift of 'f' applied to the quotient of the kernel of 'f' and 'r' is equal to the application of 'f' to 'r'.",
    "output": "theorem kerLift_mk (f : R â†’+* S) (r : R) : kerLift f (Ideal.Quotient.mk (ker f) r) = f r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' from the opposite of a set 'Î±' that has a negation operation, the unary operation on the negation of 'x' is equal to the negation of the unary operation on 'x'.",
    "output": "theorem unop_neg [Neg Î±] (x : Î±áµáµ’áµ–) : unop (-x) = -unop x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three integers a, b, and c, if c is greater than 0 and the product of a and c is less than or equal to b, then a is less than or equal to the quotient of b and c.",
    "output": "theorem le_ediv_of_mul_le {a b c : â„¤} (H1 : 0 < c) (H2 : a * c â‰¤ b) : a â‰¤ b / c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of elements of type Î² and an element 'b' of type Î², the vector subtraction of set 's' and singleton set containing 'b' is equal to the image of set 's' under the function of vector subtraction by 'b'.",
    "output": "theorem vsub_singleton (s : Set Î²) (b : Î²) : s -áµ¥ {b} = (Â· -áµ¥ b) '' s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given non-negative real number q that is greater than or equal to 1, and a function f from Î± to Î², if the measure Î¼ is finite and the function f belongs to the space of measurable functions for which the p-th power of the absolute value is integrable (Memâ„’p), then the function f is integrable with respect to the measure Î¼.",
    "output": "theorem Memâ„’p.integrable {q : â„â‰¥0âˆ} (hq1 : 1 â‰¤ q) {f : Î± â†’ Î²} [IsFiniteMeasure Î¼]\n    (hfq : Memâ„’p f q Î¼) : Integrable f Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Theorem step 5: Given a Sylow subgroup P of N, where N is a finite group and its order is the smallest prime factor of the order of N, P is not the trivial group.",
    "output": "theorem step5 {P : Sylow (Fintype.card N).minFac N} : P.1 â‰  âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any matrix A and any natural number n, the negative nth power of A is equal to the inverse of the nth power of A.",
    "output": "theorem zpow_neg_coe_nat (A : M) (n : â„•) : A ^ (-n : â„¤) = (A ^ n)â»Â¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "An element 'x' belongs to the Lie Span of a set 's' if and only if for every Lie Submodule 'N', if 's' is a subset of 'N', then 'x' belongs to 'N'.",
    "output": "theorem mem_lieSpan {x : M} : x âˆˆ lieSpan R L s â†” âˆ€ N : LieSubmodule R L M, s âŠ† N â†’ x âˆˆ N :="
  },
  {
    "instruction": "",
    "input": "For any natural numbers a, k, x, and y, there exists a natural number a1 greater than 1 such that the nth Pell number with parameter a1 equals x and the nth companion Pell number with parameter a1 equals y if and only if a is greater than 1, k is less than or equal to y, and either x equals 1 and y equals 0, or there exist natural numbers u, v, s, t, and b such that the following conditions are met:",
    "output": "theorem matiyasevic {a k x y} :\n    (âˆƒ a1 : 1 < a, xn a1 k = x âˆ§ yn a1 k = y) â†”\n      1 < a âˆ§ k â‰¤ y âˆ§ (x = 1 âˆ§ y = 0 âˆ¨\n        âˆƒ u v s t b : â„•,\n          x * x - (a * a - 1) * y * y = 1 âˆ§ u * u - (a * a - 1) * v * v = 1 âˆ§\n          s * s - (b * b - 1) * t * t = 1 âˆ§ 1 < b âˆ§ b â‰¡ 1 [MOD 4 * y] âˆ§\n          b â‰¡ a [MOD u] âˆ§ 0 < v âˆ§ y * y âˆ£ v âˆ§ s â‰¡ x [MOD u] âˆ§ t â‰¡ k [MOD 4 * y]) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a maximal theory T and a sentence Ï† in the language L, Ï† is a member of T if and only if T logically entails Ï†.",
    "output": "theorem IsMaximal.mem_iff_models (h : T.IsMaximal) (Ï† : L.Sentence) : Ï† âˆˆ T â†” T âŠ¨áµ‡ Ï† :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The lower limit inferior of a function u with respect to a filter f for values x that satisfy either property p or property q, is less than or equal to the lower limit inferior of the same function with respect to the same filter for values x that satisfy property q.",
    "output": "theorem bliminf_or_le_inf_aux_right : (bliminf u f fun x => p x âˆ¨ q x) â‰¤ bliminf u f q :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "\"a and b or (if a then c)\" is equivalent to \"if a then b or c\".",
    "output": "theorem and_or_imp : a âˆ§ b âˆ¨ (a â†’ c) â†” a â†’ b âˆ¨ c :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a supremum-preserving function 'f' from a complete lattice Î³ to a complete lattice Î´, a supremum-preserving function 'g' from a complete lattice Î² to Î³, and a supremum-preserving function 'h' from a complete lattice Î± to Î², the composition of 'f' and 'g', when further composed with 'h', is equal to the composition of 'f' with the composition of 'g' and 'h'. This is the associative property of function composition in the context of supremum-preserving functions.",
    "output": "theorem comp_assoc (f : sSupHom Î³ Î´) (g : sSupHom Î² Î³) (h : sSupHom Î± Î²) :\n    (f.comp g).comp h = f.comp (g.comp h) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given finite set 's' of elements of type 'Î±' (where 'Î±' is a type with a decidable equality), the image under the quotient map of the filtered set of pairs from 's' that are diagonal is equal to the image under the quotient map of the diagonal of 's'.",
    "output": "theorem filter_image_quotient_mk''_isDiag [DecidableEq Î±] (s : Finset Î±) :\n    ((s Ã—Ë¢ s).image Quotient.mk'').filter IsDiag = s.diag.image Quotient.mk'' :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any real number 'r', the algebraic mapping from 'R' to the quaternion number system 'â„[R,câ‚,câ‚‚]' of 'r' is equal to the quaternion 'âŸ¨r, 0, 0, 0âŸ©'.",
    "output": "theorem algebraMap_eq (r : R) : algebraMap R â„[R,câ‚,câ‚‚] r = âŸ¨r, 0, 0, 0âŸ© :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a polynomial 'p' over a domain 'R', if the number of roots of 'p' is equal to the degree of 'p', then the coefficient of 'p' at a natural number 'k' (where 'k' is less than or equal to the degree of 'p') is equal to the leading coefficient of 'p' times negative one raised to the power of the difference between the degree of 'p' and 'k', times the symmetric function of the roots of 'p' at the difference between the degree of 'p' and 'k'.",
    "output": "theorem _root_.Polynomial.coeff_eq_esymm_roots_of_card [IsDomain R] {p : R[X]}\n    (hroots : Multiset.card p.roots = p.natDegree) {k : â„•} (h : k â‰¤ p.natDegree) :\n    p.coeff k = p.leadingCoeff * (-1) ^ (p.natDegree - k) * p.roots.esymm (p.natDegree - k) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Applying a function f to x for (n + minimalPeriod f x) iterations is equal to applying the function f to x for n iterations. This implies that the minimal period of the function f at x is a cycle that repeats itself.",
    "output": "theorem iterate_add_minimalPeriod_eq : (f^[n + minimalPeriod f x]) x = (f^[n]) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The application of the cospan extension, given objects iX, iY, iZ and morphisms wf and wg, to the right walking cospan equals iY.",
    "output": "theorem cospanExt_app_right : (cospanExt iX iY iZ wf wg).app WalkingCospan.right = iY :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The cosine of an angle (Î¸) plus pi divided by two is equal to the negative sine of the angle (Î¸).",
    "output": "theorem cos_add_pi_div_two (Î¸ : Angle) : cos (Î¸ + â†‘(Ï€ / 2)) = -sin Î¸ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ordinal number 'a', the lift of the successor of 'a' is equal to the successor of the lift of 'a'.",
    "output": "theorem lift_succ (a : Ordinal.{v}) : lift.{u} (succ a) = succ (lift.{u} a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If there is a left isomorphism, then there is a pushout of functions f and g.",
    "output": "theorem hasPushout_of_left_iso : HasPushout f g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The constant coefficient of the inverse of a power series Ï† is the inverse of the constant coefficient of Ï†.",
    "output": "theorem constantCoeff_inv (Ï† : PowerSeries k) : constantCoeff k Ï†â»Â¹ = (constantCoeff k Ï†)â»Â¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The base change of 'f' with respect to 'A' is equal to the left tensor of 'f' with respect to 'A'.",
    "output": "theorem baseChange_eq_ltensor : (f.baseChange A : A âŠ— M â†’ A âŠ— N) = f.lTensor A :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The function obtained by composing the function f with the vector field v is interval integrable over the volume from tâ‚ to tâ‚‚.",
    "output": "theorem intervalIntegrable_vComp (tâ‚ tâ‚‚ : â„) : IntervalIntegrable f.vComp volume tâ‚ tâ‚‚ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f is differentiable at a point x in the field ğ•œ, then the function that maps y to the negation of f(y) is also differentiable at the point x.",
    "output": "theorem DifferentiableAt.neg (h : DifferentiableAt ğ•œ f x) : DifferentiableAt ğ•œ (fun y => -f y) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any prime number p and any natural number x, there exist two natural numbers a and b, both less than or equal to half of p, such that the sum of their squares is congruent to x modulo p.",
    "output": "theorem Nat.sq_add_sq_modEq (p : â„•) [Fact p.Prime] (x : â„•) :\n    âˆƒ a b : â„•, a â‰¤ p / 2 âˆ§ b â‰¤ p / 2 âˆ§ a ^ 2 + b ^ 2 â‰¡ x [MOD p] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any types Î±, Î², Î³ and a property p of type Î±, given a function f that maps any element of type Î± satisfying property p to type Î², an optional value x of type Î±, and a function g that maps type Î² to an optional value of type Î³, the bind operation of the partial map of f on x with respect to property p and function g is equal to the partial bind of x with the function that takes an element a and a proof h of property p for a, and maps them to the application of function g on the result of applying function f on a and the proof of property p for a.",
    "output": "theorem bind_pmap {Î± Î² Î³} {p : Î± â†’ Prop} (f : âˆ€ a, p a â†’ Î²) (x : Option Î±) (g : Î² â†’ Option Î³) (H) :\n    pmap f x H >>= g = x.pbind fun a h â†¦ g (f a (H _ h)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function 'f' is differentiable on a subset 's' of the field 'ğ•œ', and the derivative of 'f' within 's' is continuously differentiable 'n' times on 's', then 'f' is continuously differentiable 'n + 1' times on 's'.",
    "output": "theorem contDiffOn_succ_of_fderivWithin {n : â„•} (hf : DifferentiableOn ğ•œ f s)\n    (h : ContDiffOn ğ•œ n (fun y => fderivWithin ğ•œ f s y) s) : ContDiffOn ğ•œ (n + 1 : â„•) f s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements x and y from a module Mâ‚, the bilinear form of the negation of x and y is equal to the negation of the bilinear form of x and y.",
    "output": "theorem neg_left (x y : Mâ‚) : Bâ‚ (-x) y = -Bâ‚ x y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two order-preserving functions 'g' from 'Î²' to 'Î³' and 'f' from 'Î±' to 'Î²', the dual of the composition of 'g' and 'f' is equal to the composition of the duals of 'g' and 'f'.",
    "output": "theorem dual_comp (g : Î² â†’o Î³) (f : Î± â†’o Î²) :\n    OrderHom.dual (g.comp f) = (OrderHom.dual g).comp (OrderHom.dual f) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The coefficient of zero in the Teichmuller expansion of a ring element r is equal to r itself.",
    "output": "theorem teichmuller_coeff_zero (r : R) : (teichmuller p r).coeff 0 = r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' of subsets of 'Î±' and a subset 't' of 'Î±', if 't' is an element of 's', then 't' is a measurable set in the sigma-algebra generated by 's'.",
    "output": "theorem measurableSet_generateFrom {s : Set (Set Î±)} {t : Set Î±} (ht : t âˆˆ s) :\n    MeasurableSet[generateFrom s] t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three elements a, b, and x of a set Î±, the swapping of a and b in x is not equal to x if and only if a is not equal to b and x is either equal to a or b.",
    "output": "theorem swap_apply_ne_self_iff {a b x : Î±} : swap a b x â‰  x â†” a â‰  b âˆ§ (x = a âˆ¨ x = b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If an element 'x' is of finite order and another element 'y' belongs to the subgroup generated by 'x', then 'y' is also of finite order.",
    "output": "theorem IsOfFinOrder.of_mem_zpowers (h : IsOfFinOrder x) (h' : y âˆˆ Subgroup.zpowers x) :\n    IsOfFinOrder y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The orbit of the element 1 under the action of the subgroup s is equal to the subgroup s itself.",
    "output": "theorem orbit_subgroup_one_eq_self : MulAction.orbit s (1 : Î±) = s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The sum of the product of a function f, which maps from a pair of types Î± and Î² to non-negative real numbers, over all pairs (p.1, p.2) where p is a pair from Î± and Î², is equal to the double sum over all elements a from Î± and b from Î² of the function f applied to a and b.",
    "output": "theorem tsum_prod {f : Î± â†’ Î² â†’ â„â‰¥0âˆ} : (âˆ‘' p : Î± Ã— Î², f p.1 p.2) = âˆ‘' (a) (b), f a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The length of an empty path, from a vertex 'a' to itself in a graph, is equal to zero.",
    "output": "theorem length_nil {a : V} : (nil : Path a a).length = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The Cartesian product of sets s and t is equal to the union of the image of set t under the function that pairs each element of t with a fixed element of s, for each element in s.",
    "output": "theorem prod_eq_biUnion_left : s Ã—Ë¢ t = â‹ƒ a âˆˆ s, (fun b => (a, b)) '' t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two submodules 'p' and 'p'' of a module 'M' over a ring 'R', if 'p' is less than or equal to 'p'', then the kernel of the function 'ofLe' (which represents the inclusion of 'p' in 'p'') is the zero submodule.",
    "output": "theorem ker_ofLe (p p' : Submodule R M) (h : p â‰¤ p') : ker (ofLe h) = âŠ¥ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f is differentiable within a set s at a point x, then the function obtained by subtracting a constant c from f is also differentiable within the set s at the same point x.",
    "output": "theorem DifferentiableWithinAt.sub_const (hf : DifferentiableWithinAt ğ•œ f s x) (c : F) :\n    DifferentiableWithinAt ğ•œ (fun y => f y - c) s x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a countable index set Î¹ and a directed family of sets s indexed by Î¹, the measure of the union of all sets in the family is equal to the supremum of the measures of the individual sets in the family.",
    "output": "theorem measure_iUnion_eq_iSup [Countable Î¹] {s : Î¹ â†’ Set Î±} (hd : Directed (Â· âŠ† Â·) s) :\n    Î¼ (â‹ƒ i, s i) = â¨† i, Î¼ (s i) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'z' from the field 'K', the real part of 'z' is less than or equal to the norm of 'z'.",
    "output": "theorem re_le_norm (z : K) : re z â‰¤ â€–zâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If function 'f' is Big O of function 'g' (denoted as f =O[l] g) under a filter 'l', then the norm of the ratio of 'f' and 'g' (â€–f x / g xâ€–) is bounded under the filter 'l'. This is a statement in the field of asymptotic analysis.",
    "output": "theorem div_isBoundedUnder_of_isBigO {Î± : Type _} {l : Filter Î±} {f g : Î± â†’ ğ•œ} (h : f =O[l] g) :\n    IsBoundedUnder (Â· â‰¤ Â·) l fun x => â€–f x / g xâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For all elements x and y, the equivalence of the sum of x and y is equal to the sum of the equivalence of x and the equivalence of y.",
    "output": "theorem map_add : âˆ€ x y, e (x + y) = e x + e y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any type Î± and two type families Î²â‚ and Î²â‚‚ over Î±, given a function F that for each element of Î± provides an equivalence between Î²â‚ and Î²â‚‚, the symmetry of the right congruence of the dependent pair (psigma) under F is equal to the right congruence of the dependent pair under the symmetry of F.",
    "output": "theorem psigmaCongrRight_symm {Î±} {Î²â‚ Î²â‚‚ : Î± â†’ Sort _} (F : âˆ€ a, Î²â‚ a â‰ƒ Î²â‚‚ a) :\n    (psigmaCongrRight F).symm = psigmaCongrRight fun a => (F a).symm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a functor 'F' from category 'D' to category 'E', the object of the functor 'whiskeringLeftFunctor' applied to 'L', 'W', and 'E' and then applied to 'F' is equal to the composition of functors 'L' and 'F'.",
    "output": "theorem whiskeringLeftFunctor'_obj (F : D â¥¤ E) : (whiskeringLeftFunctor' L W E).obj F = L â‹™ F :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a semidirect product of two groups N and G (denoted as N â‹Š[Ï†] G), with a given element 'a' from this semidirect product, the left component of the inverse of 'a' is equal to the result of applying the homomorphism Ï† to the inverse of the right component of 'a', and then applying the inverse operation to the left component of 'a'.",
    "output": "theorem inv_left (a : N â‹Š[Ï†] G) : aâ»Â¹.left = Ï† a.rightâ»Â¹ a.leftâ»Â¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given property 'p' of an element 'x' in the lowest possible value (atBot), if 'p' eventually holds for 'x', then there exists an element 'a' such that for all elements 'b' less than or equal to 'a', the property 'p' holds. This is under the conditions that 'Î±' is a semilattice with an infimum operation and 'Î±' is nonempty.",
    "output": "theorem Eventually.exists_forall_of_atBot [SemilatticeInf Î±] [Nonempty Î±] {p : Î± â†’ Prop}\n    (h : âˆ€á¶  x in atBot, p x) : âˆƒ a, âˆ€ b â‰¤ a, p b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'s' is a lower set if and only if for all 'a' in 's', the set of all elements less than 'a' is a subset of 's'.",
    "output": "theorem isLowerSet_iff_Iio_subset : IsLowerSet s â†” âˆ€ â¦ƒaâ¦„, a âˆˆ s â†’ Iio a âŠ† s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two types Î± and Î², where Î± has a multiplication operation and Î² is a commutative group, if there is a function f from Î± to Î² that preserves multiplication (i.e., is a multiplicative homomorphism), then the function that maps each element of Î± to the inverse of its image under f is also a multiplicative homomorphism.",
    "output": "theorem inv {Î± Î²} [Mul Î±] [CommGroup Î²] {f : Î± â†’ Î²} (hf : IsMulHom f) : IsMulHom fun a => (f a)â»Â¹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î±' to 'Î²' (where 'Î²' is a topological space) and given two elements 'a' and 'b' from 'Î±' such that 'a' is less than 'b', the function 'f' is continuous at 'b' within the interval open at 'a' and closed at 'b' if and only if the function 'f' is continuous at 'b' within the interval closed at 'b' and extending to negative infinity.",
    "output": "theorem continuousWithinAt_Ioc_iff_Iic [TopologicalSpace Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :\n    ContinuousWithinAt f (Ioc a b) b â†” ContinuousWithinAt f (Iic b) b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Given a prime number 'p' and a natural number 'n', and given that 'p' divides the cardinality of a finite type 'Î±', there exists a permutation 'Ïƒ' of 'Î±' such that 'Ïƒ' raised to the power of 'p' to the power of 'n' equals 1. Furthermore, given an element 'a' of 'Î±' such that 'Ïƒ' of 'a' equals 'a', there exists an element 'b' of 'Î±' such that 'Ïƒ' of 'b' equals 'b' and 'b' is not equal to 'a'.",
    "output": "theorem exists_fixed_point_of_prime' {p n : â„•} [hp : Fact p.Prime] (hÎ± : p âˆ£ Fintype.card Î±)\n    {Ïƒ : Perm Î±} (hÏƒ : Ïƒ ^ p ^ n = 1) {a : Î±} (ha : Ïƒ a = a) : âˆƒ b : Î±, Ïƒ b = b âˆ§ b â‰  a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The commutator of the identity element (1) and any element (g) in a group (G) is equal to the identity element.",
    "output": "theorem commutatorElement_one_left : â…(1 : G), gâ† = 1 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any objects m, n, m', n' in M and morphisms f from m to m' and g from n to n' and any object X in C, the composition of the application of the functor F's map on g to the object obtained by applying the functor F's object on m to X, the map of the functor F's object on n' applied to the application of the functor F's map on f to X, and the application of the functor F's Î¼ on m' and n' to X, is equal to the composition of the application of the functor F's Î¼ on m and n to X and the application of the functor F's map on the tensor product of f and g to X.",
    "output": "theorem Î¼_naturalityâ‚‚ {m n m' n' : M} (f : m âŸ¶ m') (g : n âŸ¶ n') (X : C) :\n    (F.map g).app ((F.obj m).obj X) â‰« (F.obj n').map ((F.map f).app X) â‰« (F.Î¼ m' n').app X =\n      (F.Î¼ m n).app X â‰« (F.map (f âŠ— g)).app X :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The application of the function 'mapPair' with parameters 'f' and 'g' to 'left' is equal to 'f'.",
    "output": "theorem mapPair_left : (mapPair f g).app âŸ¨leftâŸ© = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two points x and y in an affine space P, it is not the case that x and y are on the same weak side of the bottom (denoted by âŠ¥) affine subspace in P.",
    "output": "theorem not_wSameSide_bot (x y : P) : Â¬(âŠ¥ : AffineSubspace R P).WSameSide x y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a function f is integrable over a measurable set s with respect to measure Î¼, and if function f equals function g on set s, then function g is also integrable over set s with respect to measure Î¼.",
    "output": "theorem IntegrableOn.congr_fun (h : IntegrableOn f s Î¼) (hst : EqOn f g s) (hs : MeasurableSet s) :\n    IntegrableOn g s Î¼ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given semiring S, a scalar multiplication operation between R and S, a module S over M, and a scalar tower between R, S, and M, the span of S over the span of R over a set s (in the module M) is equal to the span of S over the set s.",
    "output": "theorem span_span_of_tower [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    span S (span R s : Set M) = span S s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ordinal number 'a' and any ordinal number 'b' greater than zero, 'a' is less than or equal to the product of 'b' and 'a'.",
    "output": "theorem le_mul_right (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a â‰¤ b * a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "There exists a unique integer 'm' such that the sum of 'b' and 'm' times 'a' is in the half-open interval from 'c' to 'c + a'. This is under the condition that 'a' is greater than 0.",
    "output": "theorem existsUnique_add_zsmul_mem_Ico {a : Î±} (ha : 0 < a) (b c : Î±) :\n    âˆƒ! m : â„¤, b + m â€¢ a âˆˆ Set.Ico c (c + a) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any semiring R and any natural numbers n and m, the cast of n to the power of m in R is equal to the cast of n in R to the power of m.",
    "output": "theorem Nat.cast_pow [Semiring R] (n m : â„•) : (â†‘(n ^ m) : R) = (â†‘n : R) ^ m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any index set Î¹ and any two functions f and g from Î¹ to the set of cardinals, if for every element in the index set, the value of function f at that element is less than or equal to the value of function g at that element, then the product of the values of function f over the index set is less than or equal to the product of the values of function g over the index set.",
    "output": "theorem prod_le_prod {Î¹} (f g : Î¹ â†’ Cardinal) (H : âˆ€ i, f i â‰¤ g i) : prod f â‰¤ prod g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a chain (a set where any two elements are related) under a relation 'r' on a set 's' and the relation 'r' is transitive on a set 'Î±', then for any three elements 'a', 'b', and 'c' in 's', there exists an element 'z' in 's' such that 'a', 'b', and 'c' are all related to 'z' under the relation 'r'.",
    "output": "theorem IsChain.exists3 (hchain : IsChain r s) [IsTrans Î± r] {a b c} (mem1 : a âˆˆ s) (mem2 : b âˆˆ s)\n    (mem3 : c âˆˆ s) : âˆƒ (z : _) (_ : z âˆˆ s), r a z âˆ§ r b z âˆ§ r c z :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The ordered connected component of a set 's' at a point 'x' is equal to the empty set if and only if 'x' is not an element of 's'.",
    "output": "theorem ordConnectedComponent_eq_empty : ordConnectedComponent s x = âˆ… â†” x âˆ‰ s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any order-preserving bijection Ï† from a set Î± to a set Î², a set s is an antichain under the order relation \"less than or equal to\" if and only if the image of s under Ï† is also an antichain under the same order relation.",
    "output": "theorem image_iso_iff [LE Î±] [LE Î²] {Ï† : Î± â‰ƒo Î²} :\n    IsAntichain (Â· â‰¤ Â·) (Ï† '' s) â†” IsAntichain (Â· â‰¤ Â·) s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "'a' is equal to the product of 'gcdA' of 'a' and 'b' and the greatest common divisor of 'a' and 'b'.",
    "output": "theorem gcd_a_eq : a = gcdA' a b * gcd a b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two real numbers 'a' and 'b' that are both nonnegative, and any complex number 'r', the complex power of the product of 'a' and 'b' is equal to the product of the complex powers of 'a' and 'b'.",
    "output": "theorem mul_cpow_ofReal_nonneg {a b : â„} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (r : â„‚) :\n    ((a : â„‚) * (b : â„‚)) ^ r = (a : â„‚) ^ r * (b : â„‚) ^ r :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If a category C has limits of a shape defined by a wide pullback shape J, then for any object B in C, the category of arrows over B has limits of a shape defined by the discrete category J.",
    "output": "theorem over_product_of_widePullback [HasLimitsOfShape (WidePullbackShape J) C] {B : C} :\n    HasLimitsOfShape (Discrete J) (Over B) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'k' in field 'K', the floor function of 'k' in the basis singleton of 'K' is equal to the floor of 'k'.",
    "output": "theorem coe_floor_self (k : K) : (floor (Basis.singleton Î¹ K) k : K) = âŒŠkâŒ‹ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If the scalar multiplication of 'c' and 'a' is less than the scalar multiplication of 'c' and 'b', and 'c' is nonnegative, then 'a' is less than 'b'.",
    "output": "theorem lt_of_smul_lt_smul_of_nonneg (h : c â€¢ a < c â€¢ b) (hc : 0 â‰¤ c) : a < b :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a finite type Î¹, the application of the dual basis to the basis h is equal to Îµ.",
    "output": "theorem coe_dualBasis [Fintype Î¹] : â‡‘h.basis.dualBasis = Îµ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The vector measure with density zero is equal to zero.",
    "output": "theorem withDensityáµ¥_zero : Î¼.withDensityáµ¥ (0 : Î± â†’ E) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If we have a function 'f' from a finite set of size 0 to any set 'Î±', then the list obtained by applying 'f' to each element of the finite set is an empty list.",
    "output": "theorem ofFn_zero (f : Fin 0 â†’ Î±) : ofFn f = [] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a function 'f' from 'Î¹' to 'Î±', the infimum (greatest lower bound) of 'f' is less than or equal to 'f' at any given index 'i'.",
    "output": "theorem iInf_le (f : Î¹ â†’ Î±) (i : Î¹) : iInf f â‰¤ f i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any four type vectors Î±, Î², Î³, Î´ of the same length n, the composition of the functions h, g, and f is associative. That is, composing h and g first and then f is the same as composing h with the composition of g and f.",
    "output": "theorem comp_assoc {Î± Î² Î³ Î´ : TypeVec n} (h : Î³ âŸ¹ Î´) (g : Î² âŸ¹ Î³) (f : Î± âŸ¹ Î²) :\n    (h âŠš g) âŠš f = h âŠš g âŠš f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a continuous linear map 'l', the set 'l.toExposed A' is an exposed set in the field 'ğ•œ' and the set 'A'.",
    "output": "theorem ContinuousLinearMap.toExposed.isExposed : IsExposed ğ•œ A (l.toExposed A) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any object 'i' in the diagram 'D.J', the composition of the functor 'F' mapped over the morphism 'D.Î¹ i' and the homomorphism of the glued isomorphism of 'D' with respect to 'F' is equal to the 'i'-th component of the morphism associated with the glued data of 'D' with respect to 'F'.",
    "output": "theorem Î¹_gluedIso_hom (i : D.J) : F.map (D.Î¹ i) â‰« (D.gluedIso F).hom = (D.mapGlueData F).Î¹ i :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a number 'a' greater than 1, 'a' raised to the power of 'n' is less than or equal to 'a' raised to the power of 'm' if and only if 'n' is less than or equal to 'm'.",
    "output": "theorem pow_le_pow_iff (h : 1 < a) : a ^ n â‰¤ a ^ m â†” n â‰¤ m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'x' from group 'G', the application of the function 'mk' with 'N' on 'x' equals 'x'.",
    "output": "theorem mk'_apply (x : G) : mk' N x = x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 's' is an open set in a topological space and 'c' is a non-zero element of a group with zero, then the set resulting from scaling 's' by 'c' is also an open set.",
    "output": "theorem IsOpen.smulâ‚€ {c : Gâ‚€} {s : Set Î±} (hs : IsOpen s) (hc : c â‰  0) : IsOpen (c â€¢ s) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given metric space 'm' over a set 'Î³' with a topological space 'U', if the topological space 'U' is equivalent to the topological space derived from the metric space 'm', then replacing the topology of the metric space 'm' with 'U' does not change the metric space 'm'.",
    "output": "theorem MetricSpace.replaceTopology_eq {Î³} [U : TopologicalSpace Î³] (m : MetricSpace Î³)\n    (H : U = m.toPseudoMetricSpace.toUniformSpace.toTopologicalSpace) :\n    m.replaceTopology H = m :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given object G in category C, if G is a coseparator, then for all objects X and Y in C, and for all morphisms f and g from X to Y, if for all morphisms h from Y to G, the composition of f and h equals the composition of g and h, then f equals g.",
    "output": "theorem IsCoseparator.def {G : C} :\n    IsCoseparator G â†’ âˆ€ â¦ƒX Y : Câ¦„ (f g : X âŸ¶ Y), (âˆ€ h : Y âŸ¶ G, f â‰« h = g â‰« h) â†’ f = g :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two real numbers x and y, if the inner product of x and y is zero, then the square of the norm of the difference between x and y is equal to the sum of the square of the norm of x and the square of the norm of y.",
    "output": "theorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : âŸªx, yâŸ«_â„ = 0) :\n    â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given function 'g' mapping from Î´ to Î², the preimage of the set 's' cross 't' under the function that maps 'b' to the pair '(a, g b)' is equal to the preimage of 't' under 'g' if 'a' is in 's', otherwise it is the empty set. This is under the condition that whether an element is in 's' is decidable.",
    "output": "theorem mk_preimage_prod_right_fn_eq_if [DecidablePred (Â· âˆˆ s)] (g : Î´ â†’ Î²) :\n    (fun b => (a, g b)) â»Â¹' s Ã—Ë¢ t = if a âˆˆ s then g â»Â¹' t else âˆ… :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If x is less than y for any partial natural numbers x and y, then x is not equal to infinity.",
    "output": "theorem ne_top_of_lt {x y : PartENat} (h : x < y) : x â‰  âŠ¤ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two elements 'a' and 'b', there exists an element 'm' such that for any element 'c', if 'c' is related to 'a' or 'c' is related to 'b', then 'c' is related to 'm'. Given an element 'a', the set 's' is unbounded by the relation 'r' intersected with the set of all elements 'b' that are not related to 'a', if and only if the set 's' is unbounded by the relation 'r'.",
    "output": "theorem unbounded_inter_not (H : âˆ€ a b, âˆƒ m, âˆ€ c, r c a âˆ¨ r c b â†’ r c m) (a : Î±) :\n    Unbounded r (s âˆ© { b | Â¬r b a }) â†” Unbounded r s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "Multiplication is commutative, meaning the order in which two numbers are multiplied does not change the result. In other words, multiplying M by N is the same as multiplying N by M.",
    "output": "theorem mul_comm : M * N = N * M :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The Cartesian product of the image of set 's' under function 'mâ‚' and the image of set 't' under function 'mâ‚‚' is equal to the image of the Cartesian product of sets 's' and 't' under the function that maps each pair '(p.1, p.2)' to '(mâ‚ p.1, mâ‚‚ p.2)'.",
    "output": "theorem prod_image_image_eq {mâ‚ : Î± â†’ Î³} {mâ‚‚ : Î² â†’ Î´} :\n    (mâ‚ '' s) Ã—Ë¢ (mâ‚‚ '' t) = (fun p : Î± Ã— Î² => (mâ‚ p.1, mâ‚‚ p.2)) '' s Ã—Ë¢ t :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given property 'p' that applies to elements of type 'Î²' and a given measure 'Î¼' of type 'Î±', the property 'p' holds almost everywhere for the measure 'Î¼' mapped by a function 'f' if and only if the property 'p' applied to 'f x' holds almost everywhere for the measure 'Î¼'.",
    "output": "theorem ae_map_iff {p : Î² â†’ Prop} {Î¼ : Measure Î±} : (âˆ€áµ x âˆ‚Î¼.map f, p x) â†” âˆ€áµ x âˆ‚Î¼, p (f x) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "In a preordered set of elements of type Î±, the interval (a, b] is bounded above by the greater-than relation.",
    "output": "theorem bounded_gt_Ioc [Preorder Î±] (a b : Î±) : Bounded (Â· > Â·) (Ioc a b) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'y' in the set 'S', the application of the function 'toAlgHom' to 'y' is equal to the application of the function 'algebraMap' from 'S' to 'A' to 'y'.",
    "output": "theorem toAlgHom_apply (y : S) : toAlgHom R S A y = algebraMap S A y :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a set 's' of type Î±, if 's' is not a subset of 0, then the scalar multiplication of 's' with the universal set of type Î² equals the universal set.",
    "output": "theorem smul_univâ‚€ {s : Set Î±} (hs : Â¬s âŠ† 0) : s â€¢ (univ : Set Î²) = univ :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any element 'z' from the field 'K', the norm of the imaginary part of 'z' is less than or equal to the norm of 'z' itself.",
    "output": "theorem norm_im_le_norm (z : K) : â€–im zâ€– â‰¤ â€–zâ€– :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given element 'a' of a set 'Î±', which has a covariant class structure with respect to addition and a less-than relation, the sign of the negation of 'a' is equal to the negation of the sign of 'a'.",
    "output": "theorem Right.sign_neg [CovariantClass Î± Î± (Function.swap (Â· + Â·)) (Â· < Â·)] (a : Î±) :\n    sign (-a) = -sign a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given set 's' and a function 'f' from 'Î±' to 'M', the product of the multiplication indicator of the complement of 's' and the multiplication indicator of 's' itself is equal to the function 'f'.",
    "output": "theorem mulIndicator_compl_mul_self (s : Set Î±) (f : Î± â†’ M) :\n    mulIndicator (sá¶œ) f * mulIndicator s f = f :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two complex numbers z and w, the imaginary part of the difference between z and w is equal to the difference between the imaginary parts of z and w.",
    "output": "theorem sub_im (z w : â„‚) : (z - w).im = z.im - w.im :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any ideal P of the polynomial ring R[X], the quotient map of the ideal, which is mapped by the polynomial map ring homomorphism of the quotient of the comap of P and the ring homomorphism from R to R[X], is injective. This is under the condition that the polynomial map ring homomorphism of the quotient of the comap of P and the ring homomorphism from R to R[X] is less than or equal to the comap map.",
    "output": "theorem injective_quotient_le_comap_map (P : Ideal R[X]) :\n    Function.Injective <|\n      Ideal.quotientMap\n        (Ideal.map (Polynomial.mapRingHom (Quotient.mk (P.comap (C : R â†’+* R[X])))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (P.comap (C : R â†’+* R[X]))))\n        le_comap_map :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any two morphisms Î± and Î² from presheafed space X to Y, if Î± equals Î², then the application of Î±'s structure morphism at U equals the composition of the application of Î²'s structure morphism at U and the map of X's presheaf induced by the equality of Î± and Î².",
    "output": "theorem congr_app {X Y : PresheafedSpace C} {Î± Î² : X âŸ¶ Y} (h : Î± = Î²) (U) :\n    Î±.c.app U = Î².c.app U â‰« X.presheaf.map (eqToHom (by subst h ; rfl)) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any three finite sets s, tâ‚, and tâ‚‚, the difference of s and the union of tâ‚ and tâ‚‚ is equal to the intersection of the difference of s and tâ‚ and the difference of s and tâ‚‚.",
    "output": "theorem sdiff_union_distrib (s tâ‚ tâ‚‚ : Finset Î±) : s \\ (tâ‚ âˆª tâ‚‚) = s \\ tâ‚ âˆ© (s \\ tâ‚‚) :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a positive multiplication-monotone type Î±, if a is greater than or equal to 0 and b is less than or equal to 1, then the product of a and b is less than or equal to a.",
    "output": "theorem mul_le_of_le_one_right [PosMulMono Î±] (ha : 0 â‰¤ a) (h : b â‰¤ 1) : a * b â‰¤ a :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The logarithm function is continuous at any point 'x' that is not equal to zero.",
    "output": "theorem continuousAt_log (hx : x â‰  0) : ContinuousAt log x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If you insert an element at the position equal to the length of the list, it is the same as appending the element to the end of the list.",
    "output": "theorem insertNth_length_self (l : List Î±) (x : Î±) : insertNth l.length x l = l ++ [x] :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If 'a' is not equal to 'a' (denoted as 'a â‰  a'), then the function 'single a b' applied to 'a' (denoted as '(single a b : Î± â†’â‚€ M) a') equals zero.",
    "output": "theorem single_eq_of_ne (h : a â‰  a') : (single a b : Î± â†’â‚€ M) a' = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The subtype function of a submonoid S' is equal to the value of the subtype.",
    "output": "theorem coe_subtype : (SubmonoidClass.Subtype S' : S' â†’ M) = Subtype.val :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If you bind a measure 'm' from the set 'Î±' to a zero measure on the set 'Î± â†’ Measure Î²', the result will be zero.",
    "output": "theorem bind_zero_right (m : Measure Î±) : bind m (0 : Î± â†’ Measure Î²) = 0 :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "The inverse of the algebraic equivalence reindexing given by a certain equivalence 'e' between 'm' and 'n', is the same as the algebraic equivalence reindexing given by the inverse of 'e'.",
    "output": "theorem reindexAlgEquiv_symm (e : m â‰ƒ n) : (reindexAlgEquiv R e).symm = reindexAlgEquiv R e.symm :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a projection of an interval from 'a' to 'b' where 'a' is less than 'b', the projection at point 'x' equals 'b' if and only if 'b' is less than or equal to 'x'.",
    "output": "theorem projIcc_eq_right (h : a < b) :\n    projIcc a b h.le x = âŸ¨b, right_mem_Icc.mpr h.leâŸ© â†” b â‰¤ x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a measurable set 's', the measure of 's' according to the probability mass function 'p' is equal to the sum over all 'x' of the indicator function of 's' applied to 'p' and 'x'.",
    "output": "theorem toMeasure_apply (hs : MeasurableSet s) : p.toMeasure s = âˆ‘' x, s.indicator p x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For a given order isomorphism 'e' between two sets Î± and Î², and a given set 's' of Î±, the preimage of the preimage of 's' under the inverse of 'e' is equal to 's'.",
    "output": "theorem preimage_symm_preimage (e : Î± â‰ƒo Î²) (s : Set Î±) : e â»Â¹' (e.symm â»Â¹' s) = s :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If two functions f and g commute and for a given natural number n and an element x, if f of x equals g of x, then the nth iteration of f on x equals the nth iteration of g on x.",
    "output": "theorem iterate_eq_of_map_eq (h : Commute f g) (n : â„•) {x} (hx : f x = g x) :\n    (f^[n]) x = (g^[n]) x :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any isomorphism 'i' between 'X' and 'Y', the function from 'X' to 'Y' derived from the equivalence corresponding to 'i' is equal to the morphism 'hom' of 'i'.",
    "output": "theorem toEquiv_fun (i : X â‰… Y) : (i.toEquiv : X â†’ Y) = i.hom :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "If you map a substructure S of a model M using the identity homomorphism of a language L and M, you will get the same substructure S.",
    "output": "theorem map_id (S : L.Substructure M) : S.map (Hom.id L M) = S :="
  },
  {
    "instruction": "Translate the statement in natural language to Lean",
    "input": "For any list 'l', the count of elements in 'l' that satisfy a predicate 'p' is equal to the length of the list obtained by filtering 'l' with the same predicate 'p'.",
    "output": "theorem countp_eq_length_filter (l) : countp p l = length (filter p l) :="
  }
]